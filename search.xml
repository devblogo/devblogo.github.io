<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你真的了解Python中的类class？</title>
    <url>/6958375754505650213.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>在Python的类中，有着类属性、实例属性，静态方法、类方法、实例方法的区别。到底有什么不一样呢？接下来我们就一探究竟。</p>
</blockquote>
<h2 id="类属性、实例属性"><a href="#类属性、实例属性" class="headerlink" title="类属性、实例属性"></a>类属性、实例属性</h2><p>来看下简单的 <code>Student</code> 类的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    # 类属性</span><br><span class="line">    school = &apos;井冈山大学&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line"></span><br><span class="line">        # 实例属性</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>

<p>其中 <code>school</code> 是 <code>Student</code> 类的类属性，<code>name</code> 则是实例属性。</p>
<p>在 <code>ipython</code> 中测试一下如何访问其属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [5]: stu1 = Student(&apos;hui&apos;)</span><br><span class="line"></span><br><span class="line">In [6]: stu2 = Student(&apos;wang&apos;)</span><br><span class="line"></span><br><span class="line">In [7]: stu3 = Student(&apos;zack&apos;)</span><br><span class="line"></span><br><span class="line">In [8]: stu1.name, Student.school</span><br><span class="line">Out[8]: (&apos;hui&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [9]: stu2.name, Student.school</span><br><span class="line">Out[9]: (&apos;wang&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [10]: stu3.name, Student.school</span><br><span class="line">Out[10]: (&apos;zack&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line"># 看看实例对象能不能访问类属性，类对象能不能访问实例属性</span><br><span class="line">In [11]: stu1.name, stu1.school</span><br><span class="line">Out[11]: (&apos;hui&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [12]: Student.name, stu1.school</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-12-b897e001b174&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 Student.name, stu1.school</span><br><span class="line"></span><br><span class="line">AttributeError: type object &apos;Student&apos; has no attribute &apos;name&apos;</span><br></pre></td></tr></table></figure>

<p>经过测试可以发现 <strong>实例属性需要通过实例对象来访问，类属性通过类来访问</strong>，但在测验中 <code>stu1.school</code> 实例对象也能访问类属性，为什么呢？</p>
<p>其实，实例对象也是间接的通过类对象进行访问的，在每一个实例对象中都有一个 <code>__class__</code> 的属性，其指向的就是创建实例对象的类对象。<code>stu1.__class__</code> 的指向就是 <code>Student</code>类对象。然后实例对象访问属性的规则是先访问实例属性，然后再根据实例对象的 <code>__class__</code> 来访问类属性。如果都没有找到则报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [15]: dir(stu1)</span><br><span class="line">Out[15]:</span><br><span class="line">[&apos;__class__&apos;,</span><br><span class="line"> &apos;__delattr__&apos;,</span><br><span class="line"> &apos;__dict__&apos;,</span><br><span class="line"> &apos;__dir__&apos;,</span><br><span class="line"> </span><br><span class="line"> ....</span><br><span class="line"> </span><br><span class="line"> &apos;name&apos;,</span><br><span class="line"> &apos;school&apos;]</span><br><span class="line"></span><br><span class="line">In [16]: stu1.__class__</span><br><span class="line">Out[16]: __main__.Student</span><br><span class="line"></span><br><span class="line">In [17]: stu1.__class__.school</span><br><span class="line">Out[17]: &apos;井冈山大学&apos;</span><br><span class="line"></span><br><span class="line">In [18]: id(Student)</span><br><span class="line">Out[18]: 2011692023944</span><br><span class="line"></span><br><span class="line">In [19]: id(stu1.__class__)</span><br><span class="line">Out[19]: 2011692023944</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>Student</code>，<code>stu1.__class__</code> 的 <code>id()</code> 都一样，说明其内存地址都一样。因此实例属性可以通过 <code>__class__</code> 访问类属性。</p>
<p>存储方式如下图</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1a80c4aadeb83f0cb3d9b4dcf496641f851f8687cc0f6efabe9e66d35ee38dda" alt="类对象派生实例对象"></p>
<p>由上图可以看出：</p>
<ul>
<li>类属性在内存中只保存一份</li>
<li>实例属性在每个对象中都要保存一份</li>
</ul>
<p>还是以上面的例子在 <code>ipython</code> 中对类属性的修改进行测验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [24]: class Student(object):</span><br><span class="line">    ...:</span><br><span class="line">    ...:     # 类属性</span><br><span class="line">    ...:     school = &apos;井冈山大学&apos;</span><br><span class="line">    ...:</span><br><span class="line">    ...:     def __init__(self, name):</span><br><span class="line">    ...:</span><br><span class="line">    ...:         # 实例属性</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [25]: stu1 = Student(&apos;hui&apos;)</span><br><span class="line"></span><br><span class="line">In [26]: stu2 = Student(&apos;jack&apos;)</span><br><span class="line"></span><br><span class="line">In [27]: stu1.name, stu1.school</span><br><span class="line">Out[27]: (&apos;hui&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [28]: stu2.name, stu2.school</span><br><span class="line">Out[28]: (&apos;jack&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line"># 通过类对象进行修改</span><br><span class="line">In [29]: Student.school = &apos;清华大学&apos;</span><br><span class="line"></span><br><span class="line">In [30]: stu2.name, stu2.school</span><br><span class="line">Out[30]: (&apos;jack&apos;, &apos;清华大学&apos;)</span><br><span class="line"></span><br><span class="line">In [31]: stu1.name, stu1.school</span><br><span class="line">Out[31]: (&apos;hui&apos;, &apos;清华大学&apos;)</span><br><span class="line"></span><br><span class="line"># 通过实例对象进行修改</span><br><span class="line">IIn [33]: stu1.school = &apos;北京大学&apos;</span><br><span class="line"></span><br><span class="line">In [34]: stu1.name, stu1.school</span><br><span class="line">Out[34]: (&apos;hui&apos;, &apos;北京大学&apos;)</span><br><span class="line"></span><br><span class="line">In [35]: stu2.name, stu2.school</span><br><span class="line">Out[35]: (&apos;jack&apos;, &apos;清华大学&apos;)</span><br><span class="line"></span><br><span class="line">In [36]: Student.school</span><br><span class="line">Out[36]: &apos;清华大学&apos;</span><br><span class="line"></span><br><span class="line">In [37]: stu1.__class__.school</span><br><span class="line">Out[37]: &apos;清华大学&apos;</span><br><span class="line">    </span><br><span class="line">In [39]: id(stu2.school)</span><br><span class="line">Out[39]: 2011720409808</span><br><span class="line"></span><br><span class="line">In [40]: id(Student.school)</span><br><span class="line">Out[40]: 2011720409808</span><br><span class="line"></span><br><span class="line">In [41]: id(stu1.school)</span><br><span class="line">Out[41]: 2011720494992</span><br><span class="line"></span><br><span class="line"># 通过实例对象的__class__属性修改</span><br><span class="line">IIn [42]: stu2.__class__.school = &apos;井冈山大学&apos;</span><br><span class="line"></span><br><span class="line">In [43]: stu1.name, stu1.school</span><br><span class="line">Out[43]: (&apos;hui&apos;, &apos;北京大学&apos;)</span><br><span class="line"></span><br><span class="line">In [44]: stu2.name, stu2.school</span><br><span class="line">Out[44]: (&apos;jack&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [45]: Student.school</span><br><span class="line">Out[45]: &apos;井冈山大学&apos;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong> <strong>实例对象.类属性 = xxx</strong> 并没有修改到其类属性，而是在实例对象中创建了一个与类属性同名的实例属性。因此修改类属性，应该使用类对象进行修改。再外界最好不要使用 <strong>实例对象.新属性 = xxx</strong>，动态创建实例属性。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>到底是用类属性，还是实例属性？</p>
<blockquote>
<p>如果每个实例对象需要具有相同值的属性，那么就使用类属性，用一份既可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">class Province(object):</span><br><span class="line">    # 类属性</span><br><span class="line">    country = &apos;中国&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 实例属性</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">p1 = Province(&apos;江西省&apos;)</span><br><span class="line">p2 = Province(&apos;四川省&apos;)</span><br></pre></td></tr></table></figure>



<h2 id="实例方法、静态方法和类方法"><a href="#实例方法、静态方法和类方法" class="headerlink" title="实例方法、静态方法和类方法"></a>实例方法、静态方法和类方法</h2><p>类中方法包括：<strong>实例方法、静态方法和类方法</strong>，三种方法在内存中都归属于类，区别在于<strong>调用方式不同</strong>。</p>
<ul>
<li><strong>实例方法</strong>：由对象调用，至少一个 <code>self</code> 参数；执行实例方法时，自动将调用该方法的对象赋值给 <code>self</code>。</li>
<li><strong>类方法</strong>：由类调用，至少一个 <code>cls</code> 参数；执行类方法时，自动将调用该方法的类赋值给 <code>cls</code>。</li>
<li><strong>静态方法</strong>：由类调用，无默认参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    foo = &apos;Foo&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def instance_func(self):</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.foo)</span><br><span class="line">        print(&apos;实例方法&apos;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_func1(cls):</span><br><span class="line">        print(cls.foo)</span><br><span class="line">        print(&apos;类方法1&apos;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_func2(cls):</span><br><span class="line">        print(cls.name)</span><br><span class="line">        print(&apos;类方法二&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_func():</span><br><span class="line">        print(&apos;静态方法&apos;)</span><br></pre></td></tr></table></figure>



<p>其中 <code>@classmethod</code> 是装饰器，说明这是类方法，<code>@staticmethod</code> 则说明是静态方法。关于装饰器的内容这里就不在赘述了。</p>
<p>在 <code>ipython</code> 中测验一下各方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# 实例对象调用</span><br><span class="line">In [71]: f = Foo(&apos;hui&apos;)</span><br><span class="line"></span><br><span class="line">In [72]: f.instance_func()</span><br><span class="line">hui</span><br><span class="line">Foo</span><br><span class="line">实例方法</span><br><span class="line"></span><br><span class="line">In [73]: f.class_func1()</span><br><span class="line">Foo</span><br><span class="line">类方法1</span><br><span class="line"></span><br><span class="line">In [74]: f.class_func2()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-74-7d161e9e60ec&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 f.class_func2()</span><br><span class="line"></span><br><span class="line">&lt;ipython-input-60-7fc48649a96a&gt; in class_func2(cls)</span><br><span class="line">     18     @classmethod</span><br><span class="line">     19     def class_func2(cls):</span><br><span class="line">---&gt; 20         print(cls.name)</span><br><span class="line">     21         print(&apos;类方法二&apos;)</span><br><span class="line">     22</span><br><span class="line"></span><br><span class="line">AttributeError: type object &apos;Foo&apos; has no attribute &apos;name&apos;</span><br><span class="line"></span><br><span class="line">In [75]: f.static_func()</span><br><span class="line">静态方法</span><br><span class="line"></span><br><span class="line"># 类对象自身调用</span><br><span class="line">In [76]: Foo.instance_func()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-76-883efcb56130&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 Foo.instance_func()</span><br><span class="line"></span><br><span class="line">TypeError: instance_func() missing 1 required positional argument: &apos;self&apos;</span><br><span class="line"></span><br><span class="line">In [77]: Foo.class_func1()</span><br><span class="line">Foo</span><br><span class="line">类方法1</span><br><span class="line"></span><br><span class="line">In [78]: Foo.static_func()</span><br><span class="line">静态方法</span><br></pre></td></tr></table></figure>

<p>可以发现实例对象三种方法都可以调用，但 <code>cls</code> 类对象不能访问实例属性。类对象不能直接调用实例方法，类、静态方法可以。</p>
<h3 id="self与cls的区别"><a href="#self与cls的区别" class="headerlink" title="self与cls的区别"></a>self与cls的区别</h3><ul>
<li><code>self</code> 指的是类实例对象本身(注意：不是类本身)。</li>
<li><code>cls</code> 指的是类对象本身</li>
<li><code>self</code> 可以访问到类属性、实例属性，<code>cls</code> 只能访问类属性。</li>
</ul>
<p>其中 <code>self, cls</code> 只是代指实例对象和类对象，因此换成其他变量也可以，<strong>但是约定成俗</strong>（为了和其他编程语言统一，减少理解难度），不要搞另类，大家会不明白的。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要操作类属性的定义成类方法。</p>
<p>需要操作实例属性的定义成实例方法。</p>
<p>既不需要操作类属性，也不需要操作实例属性就定义成静态方法。</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p> <strong>新建文件夹X</strong></p>
<blockquote>
<p>大自然用数百亿年创造出我们现实世界，而程序员用几百年创造出一个完全不同的虚拟世界。我们用键盘敲出一砖一瓦，用大脑构建一切。人们把1000视为权威，我们反其道行之，捍卫1024的地位。我们不是键盘侠，我们只是平凡世界中不凡的缔造者 。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6958375754505650213" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>追溯Python类的鼻祖——元类</title>
    <url>/6957631734343008269.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Python中万物皆对象"><a href="#Python中万物皆对象" class="headerlink" title="Python中万物皆对象"></a>Python中万物皆对象</h2><blockquote>
<p>Python是一门面向对象的语言，所以Python中数字、字符串、列表、集合、字典、函数、类等都是对象。</p>
</blockquote>
<p>利用 <code>type()</code> 来查看Python中的各对象类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [11]: # 数字</span><br><span class="line"></span><br><span class="line">In [12]: type(10)</span><br><span class="line">Out[12]: int</span><br><span class="line"></span><br><span class="line">In [13]: type(3.1415926)</span><br><span class="line">Out[13]: float</span><br><span class="line"></span><br><span class="line">In [14]: # 字符串</span><br><span class="line"></span><br><span class="line">In [15]: type(&apos;a&apos;)</span><br><span class="line">Out[15]: str</span><br><span class="line"></span><br><span class="line">In [16]: type(&quot;abc&quot;)</span><br><span class="line">Out[16]: str</span><br><span class="line"></span><br><span class="line">In [17]: # 列表</span><br><span class="line"></span><br><span class="line">In [18]: type(list)</span><br><span class="line">Out[18]: type</span><br><span class="line"></span><br><span class="line">In [19]: type([])</span><br><span class="line">Out[19]: list</span><br><span class="line"></span><br><span class="line">In [20]: # 集合</span><br><span class="line"></span><br><span class="line">In [21]: type(set)</span><br><span class="line">Out[21]: type</span><br><span class="line"></span><br><span class="line">In [22]: my_set = &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">In [23]: type(my_set)</span><br><span class="line">Out[23]: set</span><br><span class="line"></span><br><span class="line">In [24]: # 字典</span><br><span class="line"></span><br><span class="line">In [25]: type(dict)</span><br><span class="line">Out[25]: type</span><br><span class="line"></span><br><span class="line">In [26]: my_dict = &#123;&apos;name&apos;: &apos;hui&apos;&#125;</span><br><span class="line"></span><br><span class="line">In [27]: type(my_dict)</span><br><span class="line">Out[27]: dict</span><br><span class="line"></span><br><span class="line">In [28]: # 函数</span><br><span class="line"></span><br><span class="line">In [29]: def func():</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [30]: type(func)</span><br><span class="line">Out[30]: function</span><br><span class="line"></span><br><span class="line">In [31]: # 类</span><br><span class="line"></span><br><span class="line">In [32]: class Foo(object):</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [33]: type(Foo)</span><br><span class="line">Out[33]: type</span><br><span class="line"></span><br><span class="line">In [34]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [35]: type(f)</span><br><span class="line">Out[35]: __main__.Foo</span><br><span class="line"></span><br><span class="line">In [36]: # type</span><br><span class="line"></span><br><span class="line">In [37]: type(type)</span><br><span class="line">Out[37]: type</span><br></pre></td></tr></table></figure>

<p>可以看出</p>
<ul>
<li>数字 <code>1</code> 是 <strong>int类型</strong> 的对象</li>
<li>字符串 <code>abc</code> 是 <strong>str类型</strong> 的对象</li>
<li>列表、集合、字典是 <strong>type类型</strong> 的对象，其创建出来的对象才分别属于 <code>list、set、dict</code> 类型</li>
<li>函数 <code>func</code> 是 <strong>function类型</strong> 的对象</li>
<li>自定义类 <code>Foo</code> 创建出来的对象 <code>f</code> 是 <code>Foo</code> 类型，其类本身 <code>Foo</code> 则是 <strong>type类型</strong> 的对象。</li>
<li><strong>连 <code>type</code> 本身都是type类型的对象</strong></li>
</ul>
<ol>
<li>类也是对象</li>
</ol>
<hr>
<blockquote>
<p>类就是拥有相等功能和相同的属性的对象的集合</p>
</blockquote>
<p>在大多数编程语言中，<strong>类就是一组用来描述如何生成一个对象的代码段</strong>。在 Python 中这一点仍然成立：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [1]: class ObjectCreator(object):</span><br><span class="line">   ...:     pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: my_object = ObjectCreator()</span><br><span class="line"></span><br><span class="line">In [3]: print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator object at 0x0000021257B5A248&gt;</span><br></pre></td></tr></table></figure>

<p>但是，Python中的类还远不止如此。<strong>类同样也是一种对象</strong>。是的，没错，就是对象。只要你 <strong>使用关键字 <code>class</code>，Python解释器在执行的时候就会创建一个对象</strong>。</p>
<p>下面的代码段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码&gt;&gt;&gt; class ObjectCreator(object):</span><br><span class="line">…       pass</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>将在内存中创建一个对象，名字就是 <code>ObjectCreator</code>。这个 <strong>对象（类对象ObjectCreator）拥有创建对象（实例对象）的能力</strong>。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：</p>
<ol>
<li>你可以将它赋值给一个变量</li>
<li>你可以拷贝它</li>
<li>你可以为它增加属性</li>
<li>你可以将它作为函数参数进行传递</li>
</ol>
<p>如下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [39]: class ObjectCreator(object):</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [40]: print(ObjectCreator)</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [41]:# 当作参数传递</span><br><span class="line"></span><br><span class="line">In [41]: def out(obj):</span><br><span class="line">    ...:     print(obj)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [42]: out(ObjectCreator)</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [43]: # hasattr 判断一个类是否有某种属性</span><br><span class="line"></span><br><span class="line">In [44]: hasattr(ObjectCreator, &apos;name&apos;)</span><br><span class="line">Out[44]: False</span><br><span class="line"></span><br><span class="line">In [45]: # 新增类属性</span><br><span class="line"></span><br><span class="line">In [46]: ObjectCreator.name = &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [47]: hasattr(ObjectCreator, &apos;name&apos;)</span><br><span class="line">Out[47]: True</span><br><span class="line"></span><br><span class="line">In [48]: ObjectCreator.name</span><br><span class="line">Out[48]: &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [49]: # 将类赋值给变量</span><br><span class="line"></span><br><span class="line">In [50]: obj = ObjectCreator</span><br><span class="line"></span><br><span class="line">In [51]: obj()</span><br><span class="line">Out[51]: &lt;__main__.ObjectCreator at 0x212596a7248&gt;</span><br><span class="line"></span><br><span class="line">In [52]:</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>动态地创建类</li>
</ol>
<hr>
<p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用 <code>class</code> 关键字即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码def cls_factory(cls_name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建类工厂</span><br><span class="line">    :param: cls_name 创建类的名称</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if cls_name == &apos;Foo&apos;:</span><br><span class="line">        class Foo():</span><br><span class="line">            pass</span><br><span class="line">        return Foo  # 返回的是类，不是类的实例</span><br><span class="line"></span><br><span class="line">    elif cls_name == &apos;Bar&apos;:</span><br><span class="line">        class Bar():</span><br><span class="line">            pass</span><br><span class="line">        return Bar</span><br></pre></td></tr></table></figure>



<p><strong>IPython 测验</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码MyClass = cls_factory(&apos;Foo&apos;)</span><br><span class="line"></span><br><span class="line">In [60]: MyClass</span><br><span class="line">Out[60]: __main__.cls_factory.&lt;locals&gt;.Foo # 函数返回的是类，不是类的实例</span><br><span class="line"></span><br><span class="line">In [61]: MyClass()</span><br><span class="line">Out[61]: &lt;__main__.cls_factory.&lt;locals&gt;.Foo at 0x21258b1a9c8&gt;</span><br></pre></td></tr></table></figure>

<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。</p>
<p>当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。</p>
<ol start="3">
<li>使用 type 创建类</li>
</ol>
<hr>
<p>type 还有一种完全不同的功能，动态的创建类。</p>
<p>type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p>
<p>type 可以像这样工作：</p>
<p>type(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p>
<p>比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [63]: class Test:</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [64]: Test()</span><br><span class="line">Out[64]: &lt;__main__.Test at 0x21258b34048&gt;</span><br><span class="line"></span><br><span class="line">In [65]:</span><br></pre></td></tr></table></figure>

<p>可以手动像这样创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [69]:# 使用type定义类</span><br><span class="line"></span><br><span class="line">In [69]: Test2 = type(&apos;Test2&apos;, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [70]: Test2()</span><br><span class="line">Out[70]: &lt;__main__.Test2 at 0x21259665808&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>Test2</code> 作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。即 type函数 中第1个实参，也可以叫做其他的名字，这个名字表示类的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [71]: UserCls = type(&apos;User&apos;, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [72]: print(UserCls)</span><br><span class="line">&lt;class &apos;__main__.User&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [73]:</span><br></pre></td></tr></table></figure>



<p>使用 <code>help</code> 来测试这2个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [74]: # 用 help 查看 Test类</span><br><span class="line"></span><br><span class="line">In [75]: help(Test)</span><br><span class="line">Help on class Test in module __main__:</span><br><span class="line"></span><br><span class="line">class Test(builtins.object)</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [76]: # 用 help 查看 Test2类</span><br><span class="line"></span><br><span class="line">In [77]: help(Test2)</span><br><span class="line">Help on class Test2 in module __main__:</span><br><span class="line"></span><br><span class="line">class Test2(builtins.object)</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [78]:</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>使用type创建带有属性的类</li>
</ol>
<hr>
<p>type 接受一个字典来为类定义属性，因此</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br></pre></td></tr></table></figure>

<p>可以翻译为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Parent(object):</span><br><span class="line">	name = &apos;hui&apos;</span><br></pre></td></tr></table></figure>

<p>并且可以将 <code>Parent</code> 当成一个普通的类一样使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [79]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [80]: print(Parent)</span><br><span class="line">&lt;class &apos;__main__.Parent&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [81]: Parent.name</span><br><span class="line">Out[81]: &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [82]: p = Parent()</span><br><span class="line"></span><br><span class="line">In [83]: p.name</span><br><span class="line">Out[83]: &apos;hui&apos;</span><br></pre></td></tr></table></figure>

<p>当然，你可以继承这个类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Child1(Parent):</span><br><span class="line">    name = &apos;jack&apos;</span><br><span class="line">    sex =  &apos;男&apos;</span><br><span class="line">    </span><br><span class="line">class Child2(Parent):</span><br><span class="line">    name = &apos;mary&apos;</span><br><span class="line">    sex = &apos;女&apos;</span><br></pre></td></tr></table></figure>

<p>就可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码 Child1 = type(&apos;Child1&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;jack&apos;, &apos;sex&apos;: &apos;男&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [85]: Child2 = type(&apos;Child2&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;mary&apos;, &apos;sex&apos;: &apos;女&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [87]: Child1.name, Child1.sex</span><br><span class="line">Out[87]: (&apos;jack&apos;, &apos;男&apos;)</span><br><span class="line"></span><br><span class="line">In [88]: Child2.name, Child2.sex</span><br><span class="line">Out[88]: (&apos;mary&apos;, &apos;女&apos;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>type 的第2个参数，<strong>元组中是父类的名字，而不是字符串</strong></li>
<li>添加的属性是 <strong>类属性</strong>，并不是实例属性</li>
</ul>
<ol start="5">
<li>使用type创建带有方法的类</li>
</ol>
<hr>
<p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p>
<h3 id="添加实例方法"><a href="#添加实例方法" class="headerlink" title="添加实例方法"></a>添加实例方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [89]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [90]: # 定义函数</span><br><span class="line"></span><br><span class="line">In [91]: def get_name(self):</span><br><span class="line">    ...:     return self.name</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [92]: Child3 = type(&apos;Child3&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;blob&apos;, &apos;get_name&apos;: get_name&#125;)</span><br><span class="line"></span><br><span class="line">In [93]: c3 = Child3()</span><br><span class="line"></span><br><span class="line">In [94]: c3.name</span><br><span class="line">Out[94]: &apos;blob&apos;</span><br><span class="line"></span><br><span class="line">In [95]: c3.get_name()</span><br><span class="line">Out[95]: &apos;blob&apos;</span><br></pre></td></tr></table></figure>



<h3 id="添加静态方法"><a href="#添加静态方法" class="headerlink" title="添加静态方法"></a>添加静态方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [96]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [97]: # 定义静态方法</span><br><span class="line">    </span><br><span class="line">In [98]: @staticmethod</span><br><span class="line">    ...: def test_static():</span><br><span class="line">    ...:     print(&apos;static method called...&apos;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [100]: Child4 = type(&apos;Child4&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;zhangsan&apos;, &apos;test_static&apos;: test_static&#125;)</span><br><span class="line"></span><br><span class="line">In [101]: c4 = Child4()</span><br><span class="line"></span><br><span class="line">In [102]: c4.test_static()</span><br><span class="line">static method called...</span><br><span class="line"></span><br><span class="line">In [103]: Child4.test_static()</span><br><span class="line">static method called...</span><br></pre></td></tr></table></figure>



<h3 id="添加类方法"><a href="#添加类方法" class="headerlink" title="添加类方法"></a>添加类方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [105]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [106]: # 定义类方法</span><br><span class="line"></span><br><span class="line">In [107]: @classmethod</span><br><span class="line">     ...: def test_class(cls):</span><br><span class="line">     ...:     print(cls.name)</span><br><span class="line">     ...:</span><br><span class="line"></span><br><span class="line">In [108]: Child5 = type(&apos;Child5&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;lisi&apos;, &apos;test_class&apos;: test_class&#125;)</span><br><span class="line"></span><br><span class="line">In [109]: c5 = Child5()</span><br><span class="line"></span><br><span class="line">In [110]: c5.test_class()</span><br><span class="line">lisi</span><br><span class="line"></span><br><span class="line">In [111]: Child5.test_class()</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure>

<p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是<strong>当你使用关键字 <code>class</code> 时 <code>Python</code> 在幕后做的事情，就是通过元类来实现的</strong>。</p>
<p>较为完整的使用 type 创建类的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Animal(object):</span><br><span class="line">    </span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;吃东西&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dog_eat(self):</span><br><span class="line">    print(&apos;喜欢吃骨头&apos;)</span><br><span class="line"></span><br><span class="line">def cat_eat(self):</span><br><span class="line">    print(&apos;喜欢吃鱼&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog = type(&apos;Dog&apos;, (Animal, ), &#123;&apos;tyep&apos;: &apos;哺乳类&apos;, &apos;eat&apos;: dog_eat&#125;)</span><br><span class="line"></span><br><span class="line">Cat = type(&apos;Cat&apos;, (Animal, ), &#123;&apos;tyep&apos;: &apos;哺乳类&apos;, &apos;eat&apos;: cat_eat&#125;)</span><br><span class="line"></span><br><span class="line"># ipython 测验</span><br><span class="line">In [125]: animal = Animal()</span><br><span class="line"></span><br><span class="line">In [126]: dog = Dog()</span><br><span class="line"></span><br><span class="line">In [127]: cat = Cat()</span><br><span class="line"></span><br><span class="line">In [128]: animal.eat()</span><br><span class="line">吃东西</span><br><span class="line"></span><br><span class="line">In [129]: dog.eat()</span><br><span class="line">喜欢吃骨头</span><br><span class="line"></span><br><span class="line">In [130]: cat.eat()</span><br><span class="line">喜欢吃鱼</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>到底什么是元类（终于到主题了）</li>
</ol>
<hr>
<p><strong>元类就是用来创建类的【东西】</strong>。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。</p>
<p>元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码MyClass = MetaClass() # 使用元类创建出一个对象，这个对象称为“类”</span><br><span class="line">my_object = MyClass() # 使用“类”来创建出实例对象</span><br></pre></td></tr></table></figure>

<p>你已经看到了type可以让你像这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码MyClass = type(&apos;MyClass&apos;, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>这是因为函数 <code>type</code> 实际上是一个元类。<strong><code>type</code> 就是 Python在背后用来创建所有类的元类</strong>。现在你想知道那为什么 type 会全部采用小写形式而不是 Type 呢？好吧，我猜这是为了和 str 保持一致性，str是用来创建字符串对象的类，而 int 是用来创建整数对象的类。type 就是创建类对象的类。你可以通过检查 <code>__class__</code> 属性来看到这一点。因此 <strong>Python中万物皆对象</strong></p>
<p>现在，对于任何一个 <code>__class__</code> 的 <code>__class__</code> 属性又是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [136]: a = 10</span><br><span class="line"></span><br><span class="line">In [137]: b = &apos;acb&apos;</span><br><span class="line"></span><br><span class="line">In [138]: li = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [139]: a.__class__.__class__</span><br><span class="line">Out[139]: type</span><br><span class="line"></span><br><span class="line">In [140]: b.__class__.__class__</span><br><span class="line">Out[140]: type</span><br><span class="line"></span><br><span class="line">In [141]: li.__class__.__class__</span><br><span class="line">Out[141]: type</span><br><span class="line"></span><br><span class="line">In [142]: li.__class__.__class__.__class__</span><br><span class="line">Out[142]: type</span><br></pre></td></tr></table></figure>

<p>因此，元类就是创建类这种对象的东西。type 就是 Python的内建元类，当然了，你也可以创建自己的元类。</p>
<ol start="7">
<li><code>__metaclass__</code> 属性</li>
</ol>
<hr>
<p>你可以在定义一个类的时候为其添加 <code>__metaclass__</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(object):</span><br><span class="line">    __metaclass__ = something…</span><br><span class="line">    ...省略...</span><br></pre></td></tr></table></figure>

<p>如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下 <code>class Foo(object)</code>，但是类Foo还没有在内存中创建。Python会在类的定义中寻找 <code>__metaclass__</code> 属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的 <code>type</code> 来创建这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(Bar):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>Python做了如下的操作：</p>
<ol>
<li>Foo中有 <code>__metaclass__</code> 这个属性吗？如果有，Python会通过 <code>__metaclass__</code> 创建一个名字为Foo的类(对象)</li>
<li>如果Python没有找到 <code>__metaclass__</code>，它会继续在 <strong>Bar（父类）</strong> 中寻找 <code>__metaclass__</code> 属性，并尝试做和前面同样的操作。</li>
<li>如果Python在任何父类中都找不到 <code>__metaclass__</code>，它就会在模块层次中去寻找 <code>__metaclass__</code>，并尝试做同样的操作。</li>
<li>如果还是找不到 <code>__metaclass__</code> ，Python就会用内置的 <code>type</code> 来创建这个类对象。</li>
</ol>
<p>现在的问题就是，你可以在 <code>__metaclass__</code> 中放置些什么代码呢？</p>
<p>答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化的type都可以。</p>
<ol start="8">
<li>自定义元类</li>
</ol>
<hr>
<blockquote>
<p>元类的主要目的就是为了当创建类时能够自动地改变类。</p>
</blockquote>
<p>假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定 <code>__metaclass__</code>。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</p>
<p>幸运的是，<code>__metaclass__</code> 实际上可以被任意调用，它并不需要是一个正式的类。所以，我们这里就先以一个简单的函数作为例子开始。</p>
<h3 id="python2中"><a href="#python2中" class="headerlink" title="python2中"></a>python2中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# -*- coding:utf-8 -*-</span><br><span class="line">def upper_attr(class_name, class_parents, class_attr):</span><br><span class="line"></span><br><span class="line">    # class_name 会保存类的名字 Foo</span><br><span class="line">    # class_parents 会保存类的父类 object</span><br><span class="line">    # class_attr 会以字典的方式保存所有的类属性</span><br><span class="line"></span><br><span class="line">    # 遍历属性字典，把不是__开头的属性名字变为大写</span><br><span class="line">    new_attr = &#123;&#125;</span><br><span class="line">    for name, value in class_attr.items():</span><br><span class="line">        if not name.startswith(&quot;__&quot;):</span><br><span class="line">            new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    # 调用type来创建一个类</span><br><span class="line">    return type(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    __metaclass__ = upper_attr # 设置Foo类的元类为upper_attr</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line"># Flase</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br><span class="line"># True</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br></pre></td></tr></table></figure>



<h3 id="python3中"><a href="#python3中" class="headerlink" title="python3中"></a>python3中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# -*- coding:utf-8 -*-</span><br><span class="line">def upper_attr(class_name, class_parents, class_attr):</span><br><span class="line"></span><br><span class="line">    #遍历属性字典，把不是__开头的属性名字变为大写</span><br><span class="line">    new_attr = &#123;&#125;</span><br><span class="line">    for name,value in class_attr.items():</span><br><span class="line">        if not name.startswith(&quot;__&quot;):</span><br><span class="line">            new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    #调用type来创建一个类</span><br><span class="line">    return type(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line"># 再类的继承()中使用metaclass</span><br><span class="line">class Foo(object, metaclass=upper_attr):</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line"># Flase</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br><span class="line"># True</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br></pre></td></tr></table></figure>



<p>再做一次，这一次用一个真正的 <code>class</code> 来当做元类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class UpperAttrMetaClass(type):</span><br><span class="line">    </span><br><span class="line">    def __new__(cls, class_name, class_parents, class_attr):</span><br><span class="line">        # 遍历属性字典，把不是__开头的属性名字变为大写</span><br><span class="line">        new_attr = &#123;&#125;</span><br><span class="line">        for name, value in class_attr.items():</span><br><span class="line">            if not name.startswith(&quot;__&quot;):</span><br><span class="line">                new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">        # 方法1：通过&apos;type&apos;来做类对象的创建</span><br><span class="line">        return type(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">        # 方法2：复用type.__new__方法</span><br><span class="line">        # 这就是基本的OOP编程，没什么魔法</span><br><span class="line">        # return type.__new__(cls, class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"># python3的用法</span><br><span class="line">class Foo(object, metaclass=UpperAttrMetaClass):</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line"># python2的用法</span><br><span class="line">class Foo(object):</span><br><span class="line">	__metaclass__ = UpperAttrMetaClass</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line"># 输出: False</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br><span class="line"># 输出: True</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"># 输出: &apos;bip&apos;</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__new__ 是在__init__之前被调用的特殊方法</span><br><span class="line">__new__是用来创建对象并返回之的方法</span><br><span class="line">而__init__只是用来将传入的参数初始化给对象</span><br><span class="line">这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span><br></pre></td></tr></table></figure>

<p>就是这样，除此之外，关于元类真的没有别的可说的了。但就元类本身而言，它们其实是很简单的：</p>
<ol>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改之后的类</li>
</ol>
<h3 id="究竟为什么要使用元类？"><a href="#究竟为什么要使用元类？" class="headerlink" title="究竟为什么要使用元类？"></a>究竟为什么要使用元类？</h3><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？</p>
<p>好吧，一般来说，你根本就用不上它：</p>
<blockquote>
<p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters</p>
</blockquote>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码已上传到 <code>Gitee</code> <a href="https://gitee.com/huiDBK/PythonKnowledge" target="_blank" rel="noopener">PythonKnowledge: Python知识宝库</a>，欢迎大家来访。</p>
<p><strong>✍ 码字不易，还望各位大侠多多支持❤️。</strong></p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p> <strong>新建文件夹X</strong></p>
<blockquote>
<p>大自然用数百亿年创造出我们现实世界，而程序员用几百年创造出一个完全不同的虚拟世界。我们用键盘敲出一砖一瓦，用大脑构建一切。人们把1000视为权威，我们反其道行之，捍卫1024的地位。我们不是键盘侠，我们只是平凡世界中不凡的缔造者 。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6957631734343008269" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的魔法属性</title>
    <url>/6959490821934710797.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="魔法属性"><a href="#魔法属性" class="headerlink" title="魔法属性"></a>魔法属性</h2><blockquote>
<p>在Python中，所有以 <code>__</code> 双下划线包起来的方法，都统称为 <code>Magic Method</code>，例如类的初始化方法 <code>__init__()</code> ，实例对象创造方法 <code>__new__()</code>等。</p>
<p>魔法属性和方法是Python内置的一些属性和方法，有着特殊的含义。命名时前后加上两个下划线，在执行系统特定操作时，会自动调用。</p>
</blockquote>
<h2 id="常见的魔法属性"><a href="#常见的魔法属性" class="headerlink" title="常见的魔法属性"></a>常见的魔法属性</h2><h3 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a>__doc__</h3><blockquote>
<p>表示类的描述信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line"># __doc__</span><br><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，这是用于测试的类 &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># ipython 测验</span><br><span class="line">In [2]: Foo.__doc__</span><br><span class="line">Out[2]: &apos; 描述类信息，这是用于测试的类 &apos;</span><br></pre></td></tr></table></figure>



<h3 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__ 和 __class__"></a>__module__ 和 __class__</h3><ul>
<li><code>__module__</code> 表示当前操作的对象在那个模块</li>
<li><code>__class__</code> 表示当前操作的对象的类是什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line"># __module__、__class__</span><br><span class="line"># oop.py</span><br><span class="line">class Student(object):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"># main.py</span><br><span class="line">from oop import Student</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">print(s.__module__)  # 输出 oop 即：输出模块</span><br><span class="line">print(s.__class__)   # 输出 &lt;class &apos;oop.Student&apos;&gt; 即：输出类</span><br></pre></td></tr></table></figure>



<h3 id="init-、-new"><a href="#init-、-new" class="headerlink" title="__init__ 、__new__"></a>__init__ 、__new__</h3><blockquote>
<p><code>__init__()</code> 初始化方法 和 <code>__new__()</code>，通过类创建对象时，自动触发执行。<code>__new__</code> 是用来创建类并返回这个类的实例，而 <code>__init__</code> 只是将传入的参数来初始化该实例。</p>
</blockquote>
<ul>
<li><code>__new__()</code> 创建对象时调用，会返回当前对象的一个实例</li>
<li><code>__init__()</code> 创建完对象后调用，对当前对象的一些实例初始化，无返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line"># __init__ 、 __new__</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        print(&apos;__init__() called&apos;)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&apos;__new__() called&apos;)</span><br><span class="line">        print(cls, args, kwargs)</span><br><span class="line">        return super().__new__(cls)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># ipython 测验</span><br><span class="line">In [26]: s1 = Student(&apos;hui&apos;, age=21)</span><br><span class="line">__new__() called</span><br><span class="line">&lt;class &apos;__main__.Student&apos;&gt; (&apos;hui&apos;,) &#123;&apos;age&apos;: 21&#125;</span><br><span class="line">__init__() called</span><br><span class="line"></span><br><span class="line">In [27]: s2 = Student(&apos;jack&apos;, age=20)</span><br><span class="line">__new__() called</span><br><span class="line">&lt;class &apos;__main__.Student&apos;&gt; (&apos;jack&apos;,) &#123;&apos;age&apos;: 20&#125;</span><br><span class="line">__init__() called</span><br></pre></td></tr></table></figure>



<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h3><blockquote>
<p>当对象在内存中被释放时，自动触发执行。</p>
</blockquote>
<p>注：此方法一般无须定义，因为Python是一门高级语言，有 <strong>内存管理、垃圾回收机制</strong>，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，<code>__del__</code> 的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __del__</span><br><span class="line">class Foo:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&apos;__del__() called&apos;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"># ipython 测验</span><br><span class="line">In [29]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [30]: del f</span><br><span class="line">__del__() called</span><br></pre></td></tr></table></figure>



<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><blockquote>
<p>让类的实例的行为表现的像函数一样，你可以调用它们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性，其让Python编程更加舒适甜美。<strong>对象后面加括号，触发执行</strong>。</p>
</blockquote>
<p>注：<code>__init__</code> 方法的执行是由创建对象触发的，即：<code>对象 = 类名()</code> ；而对于 <code>__call__</code> 方法的执行是由对象后加括号触发的，即：<code>对象()</code> 或者 <code>类()()</code></p>
<p><code>__call__</code> 在那些 <strong>类的实例经常改变状态的时候会非常有效</strong>。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __call__</span><br><span class="line">class Rect(object)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    调用实例对象来改变矩形的位置</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        # x, y代表矩形坐标</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    def __call__(self, x, y):        </span><br><span class="line">        # 改变实体的位置</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ipython 测验</span><br><span class="line">In [33]: r = Rect(10, 10)</span><br><span class="line"></span><br><span class="line">In [34]: r.x, r.y</span><br><span class="line">Out[34]: (10, 10)</span><br><span class="line"></span><br><span class="line">In [35]: r(0, 0)</span><br><span class="line"></span><br><span class="line">In [36]: r.x, r.y</span><br><span class="line">Out[36]: (0, 0)</span><br><span class="line"></span><br><span class="line">In [37]: r(100, 100)</span><br><span class="line"></span><br><span class="line">In [38]: r.x, r.y</span><br><span class="line">Out[38]: (100, 100)</span><br></pre></td></tr></table></figure>



<h3 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a>__dict__</h3><blockquote>
<p>类或对象中的所有属性</p>
</blockquote>
<p>类的实例属性属于对象；类中的类属性和方法等属于类，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __dict__</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self._age</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># ipython 测验</span><br><span class="line">In [47]: # 获取类属性</span><br><span class="line"></span><br><span class="line">In [48]: Student.__dict__</span><br><span class="line">Out[48]:</span><br><span class="line">mappingproxy(&#123;&apos;__module__&apos;: &apos;__main__&apos;,</span><br><span class="line">              &apos;__init__&apos;: &lt;function __main__.Student.__init__(self, name, age)&gt;,</span><br><span class="line">              &apos;age&apos;: &lt;property at 0x210e2a005e8&gt;,</span><br><span class="line">              &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Student&apos; objects&gt;,</span><br><span class="line">              &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Student&apos; objects&gt;,</span><br><span class="line">              &apos;__doc__&apos;: None&#125;)</span><br><span class="line"></span><br><span class="line">In [49]: # 获取实例对象的属性</span><br><span class="line"></span><br><span class="line">In [50]: s = Student(&apos;hui&apos;, 21)</span><br><span class="line"></span><br><span class="line">In [51]: s.__dict__</span><br><span class="line">Out[51]: &#123;&apos;name&apos;: &apos;hui&apos;, &apos;_age&apos;: 21&#125;</span><br><span class="line"></span><br><span class="line">In [52]: s2 = Student(&apos;jack&apos;, 20)</span><br><span class="line"></span><br><span class="line">In [53]: s2.__dict__</span><br><span class="line">Out[53]: &#123;&apos;name&apos;: &apos;jack&apos;, &apos;_age&apos;: 20&#125;</span><br></pre></td></tr></table></figure>



<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><blockquote>
<p>如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [65]: # __str__</span><br><span class="line">    ...: class Foo(object):</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [66]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [67]: print(f)</span><br><span class="line">&lt;__main__.Foo object at 0x00000210E2715608&gt;</span><br><span class="line"></span><br><span class="line">In [68]: class Foo(object):</span><br><span class="line">    ...:</span><br><span class="line">    ...:     def __str__(self):</span><br><span class="line">    ...:         return &apos;&lt; Custom Foo object str &gt;&apos;</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [69]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [70]: print(f)</span><br><span class="line">&lt; Custom Foo object str &gt;</span><br></pre></td></tr></table></figure>



<h3 id="getitem-、-setitem-、-delitem"><a href="#getitem-、-setitem-、-delitem" class="headerlink" title="__getitem__、__setitem__、__delitem__"></a>__getitem__、__setitem__、__delitem__</h3><blockquote>
<p>用于索引操作，如字典。以上分别表示获取、设置、删除数据。</p>
<p>用于切片操作，如列表。</p>
</blockquote>
<h4 id="字典示例"><a href="#字典示例" class="headerlink" title="字典示例"></a>字典示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __getitem__、__setitem__、__delitem__</span><br><span class="line">class MyDict(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.my_dict = dict()</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        print(&apos;__getitem__() &apos;, key)</span><br><span class="line">        return self.my_dict.get(key, None)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&apos;__setitem__() &apos;, key, value)</span><br><span class="line">        self.my_dict.update(key=value)</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&apos;__delitem__() &apos;, key)</span><br><span class="line">        del self.my_dict[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ipython 测验        </span><br><span class="line">In [33]: mdict = MyDict()</span><br><span class="line"></span><br><span class="line">In [34]: print(mdict[&apos;name&apos;])</span><br><span class="line">__getitem__()  name</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">In [35]: # 新增</span><br><span class="line"></span><br><span class="line">In [36]: mdict[&apos;name&apos;] = &apos;hui&apos;</span><br><span class="line">__setitem__()  name hui</span><br><span class="line"></span><br><span class="line">In [37]: mdict[&apos;age&apos;] = 21</span><br><span class="line">__setitem__()  age 21</span><br><span class="line"></span><br><span class="line">In [38]: mdict[&apos;name&apos;]</span><br><span class="line">__getitem__()  name</span><br><span class="line">Out[38]: &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [39]: mdict[&apos;age&apos;]</span><br><span class="line">__getitem__()  age</span><br><span class="line">Out[39]: 21</span><br><span class="line"></span><br><span class="line">In [40]: # 更新</span><br><span class="line"></span><br><span class="line">In [41]: mdict[&apos;name&apos;] = &apos;jack&apos;</span><br><span class="line">__setitem__()  name jack</span><br><span class="line"></span><br><span class="line">In [42]: mdict[&apos;name&apos;]</span><br><span class="line">__getitem__()  name</span><br><span class="line">Out[42]: &apos;jack&apos;</span><br><span class="line"></span><br><span class="line">In [43]: # 删除</span><br><span class="line"></span><br><span class="line">In [44]: del mdict[&apos;age&apos;]</span><br><span class="line">__delitem__()  age</span><br><span class="line"></span><br><span class="line">In [45]: print(mdict[&apos;age&apos;])</span><br><span class="line">__getitem__()  age</span><br><span class="line">None</span><br></pre></td></tr></table></figure>



<h4 id="列表示例"><a href="#列表示例" class="headerlink" title="列表示例"></a><strong>列表示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# 切片操作</span><br><span class="line">class MyList(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.mlist = list()</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        print(&apos;__getitem__() called&apos;)</span><br><span class="line">        print(index)</span><br><span class="line">        if isinstance(index, slice):</span><br><span class="line">            return self.mlist[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, value):</span><br><span class="line">        print(&apos;__getitem__() called&apos;)</span><br><span class="line">        print(index, value)</span><br><span class="line">        if isinstance(index, slice):</span><br><span class="line">            self.mlist[index] = value</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, index):</span><br><span class="line">        print(&apos;__delitem__() called&apos;)</span><br><span class="line">        if isinstance(index, slice):</span><br><span class="line">            del self.mlist[index]</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line"># ipython 测验</span><br><span class="line">In [70]: mlist = MyList()</span><br><span class="line"></span><br><span class="line">In [71]: mlist[0]</span><br><span class="line">__getitem__() called</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">In [72]: mlist[0:-1]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(0, -1, None)</span><br><span class="line">Out[72]: []</span><br><span class="line"></span><br><span class="line">In [73]: mlist[:] = [1,2,3]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, None) [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [74]: mlist[:]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, None)</span><br><span class="line">Out[74]: [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [75]: mlist[0:2]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(0, 2, None)</span><br><span class="line">Out[75]: [1, 2]</span><br><span class="line"></span><br><span class="line">In [76]: mlist[::-1]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, -1)</span><br><span class="line">Out[76]: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">In [77]: mlist[0]</span><br><span class="line">__getitem__() called</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">In [78]: mlist[0:1]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(0, 1, None)</span><br><span class="line">Out[78]: [1]</span><br><span class="line"></span><br><span class="line">In [79]: del mlist[0:1]</span><br><span class="line">__delitem__() called</span><br><span class="line"></span><br><span class="line">In [80]: mlist[:]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, None)</span><br><span class="line">Out[80]: [2, 3]</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong> 当进行 <code>mlist[0]</code> 操作的时候传递并不是一个 <code>slice</code> 对象，不是一个 <code>int</code> 类型的数字，所以不能把索引为 <code>0</code> 的值取出来，改成 <code>mlist[0, 1]</code> 或者在 <code>__getitem__()</code> 的方法中新增数字判断，大家可以尝试一下。</p>
<h3 id="enter-、-exit"><a href="#enter-、-exit" class="headerlink" title="__enter__、__exit__"></a>__enter__、__exit__</h3><p><code>with</code> 声明是从 <code>Python2.5</code> 开始引进的关键词。你应该遇过这样子的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码with open(&apos;foo.txt&apos;) as bar:</span><br><span class="line">    # do something with bar</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>在 <code>with</code> 声明的代码段中，我们可以做一些对象的开始操作和退出操作,还能对异常进行处理。这需要实现两个魔术方法: __enter__ 和 __exit__。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__enter__(self):</span><br></pre></td></tr></table></figure>

<p>定义了当使用 <code>with</code> 语句的时候，会话管理器在块被初始创建时要产生的行为。请注意，<code>__enter__</code> 的返回值与 <code>with</code> 语句的目标或者 <code>as</code> 后的名字绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__exit__(self, exception_type, exception_value, traceback):</span><br></pre></td></tr></table></figure>

<p>定义了当一个代码块被执行或者终止后，会话管理器应该做什么。它可以被用来处理异常、执行清理工作或做一些代码块执行完毕之后的日常工作。如果代码块执行成功，<code>exception_type，exception_value，和traceback</code> 将会为 <code>None</code> 。否则，你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，请确保<code>__exit__</code> 在所有语句结束之后返回 <code>True</code>。如果你想让异常被会话管理器处理的话，那么就让其产生该异常。</p>
<h3 id="copy-、-deepcopy"><a href="#copy-、-deepcopy" class="headerlink" title="__copy__、__deepcopy__"></a>__copy__、__deepcopy__</h3><p>　　有时候，尤其是当你在处理可变对象时，你可能想要复制一个对象，然后对其做出一些改变而不希望影响原来的对象。这就是Python的copy所发挥作用的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__copy__(self):</span><br></pre></td></tr></table></figure>

<p>　　定义了当对你的类的实例调用 <code>copy.copy()</code> 时所产生的行为。<code>copy.copy()</code> 返回了你的对象的一个浅拷贝——这意味着，当实例本身是一个新实例时，它的所有数据都被引用了——例如，当一个对象本身被复制了，它的数据仍然是被引用的（因此，对于浅拷贝中数据的更改仍然可能导致数据在原始对象的中的改变）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__deepcopy__(self, memodict=&#123;&#125;):</span><br></pre></td></tr></table></figure>

<p>　　定义了当对你的类的实例调用 <code>copy.deepcopy()</code>时所产生的行为。<code>copy.deepcopy()</code> 返回了你的对象的一个深拷贝——对象和其数据都被拷贝了。<code>memodict</code> 是对之前被拷贝的对象的一个缓存——这优化了拷贝过程并且阻止了对递归数据结构拷贝时的无限递归。当你想要进行对一个单独的属性进行深拷贝时，调用<code>copy.deepcopy()</code>，并以 <code>memodict</code> 为第一个参数。</p>
<p>　　<strong>这些魔术方法的用例看起来很小，并且确实非常实用. 它们反应了关于面向对象程序上一些重要的东西在<code>Python</code> 上，并且总的来说 <code>Python</code> 总是一个简单的方法去找某些事情，即使是没有必要的。这些魔法方法可能看起来不是很有用，但是一旦你需要它们，你会感到庆幸它们的存在。</strong></p>
<h2 id="其他魔法方法"><a href="#其他魔法方法" class="headerlink" title="其他魔法方法"></a>其他魔法方法</h2><p>由于魔法属性、方法太多了在这就不一一描述和展示了，其他的就以表格形式呈现吧。</p>
<h3 id="用于比较的魔术方法"><a href="#用于比较的魔术方法" class="headerlink" title="用于比较的魔术方法"></a>用于比较的魔术方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__cmp__(self, other)</code></td>
<td>比较方法里面最基本的的魔法方法</td>
</tr>
<tr>
<td><code>__eq__(self, other)</code></td>
<td>定义相等符号的行为，<strong>==</strong></td>
</tr>
<tr>
<td><code>__ne__(self,other)</code></td>
<td>定义不等符号的行为，<strong>!=</strong></td>
</tr>
<tr>
<td><code>__lt__(self,other)</code></td>
<td>定义小于符号的行为，<strong>&lt;</strong></td>
</tr>
<tr>
<td><code>__gt__(self,other)</code></td>
<td>定义大于符号的行为，<strong>&gt;</strong></td>
</tr>
<tr>
<td><code>__le__(self,other)</code></td>
<td>定义小于等于符号的行为，<strong>&lt;=</strong></td>
</tr>
<tr>
<td><code>__ge__(self,other)</code></td>
<td>定义大于等于符号的行为，<strong>&gt;=</strong></td>
</tr>
</tbody></table>
<h3 id="数值计算的魔术方法"><a href="#数值计算的魔术方法" class="headerlink" title="数值计算的魔术方法"></a>数值计算的魔术方法</h3><h4 id="单目运算符和函数"><a href="#单目运算符和函数" class="headerlink" title="单目运算符和函数"></a>单目运算符和函数</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__pos__(self)</code></td>
<td>实现一个取正数的操作</td>
</tr>
<tr>
<td><code>__neg__(self)</code></td>
<td>实现一个取负数的操作</td>
</tr>
<tr>
<td><code>__abs__(self)</code></td>
<td>实现一个内建的 <code>abs()</code> 函数的行为</td>
</tr>
<tr>
<td><code>__invert__(self)</code></td>
<td>实现一个取反操作符（～操作符）的行为</td>
</tr>
<tr>
<td><code>__round__(self, n)</code></td>
<td>实现一个内建的 <code>round()</code> 函数的行为</td>
</tr>
<tr>
<td><code>__floor__(self)</code></td>
<td>实现 <code>math.floor()</code> 的函数行为</td>
</tr>
<tr>
<td><code>__ceil__(self)</code></td>
<td>实现 <code>math.ceil()</code> 的函数行为</td>
</tr>
<tr>
<td><code>__trunc__(self)</code></td>
<td>实现 <code>math.trunc()</code> 的函数行为</td>
</tr>
</tbody></table>
<h4 id="双目运算符或函数"><a href="#双目运算符或函数" class="headerlink" title="双目运算符或函数"></a>双目运算符或函数</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__add__(self, other)</code></td>
<td>实现一个加法</td>
</tr>
<tr>
<td><code>__sub__(self, other)</code></td>
<td>实现一个减法</td>
</tr>
<tr>
<td><code>__mul__(self, other)</code></td>
<td>实现一个乘法</td>
</tr>
<tr>
<td><code>__floordiv__(self, other)</code></td>
<td>实现一个 <strong>//</strong> 操作符产生的整除操作</td>
</tr>
<tr>
<td><code>__div__(self, other)</code></td>
<td>实现一个 <strong>/</strong> 操作符代表的除法操作</td>
</tr>
<tr>
<td><code>__truediv__(self, other)</code></td>
<td>实现真实除法</td>
</tr>
<tr>
<td><code>__mod__(self, other)</code></td>
<td>实现一个 <strong>%</strong> 操作符代表的取模操作</td>
</tr>
<tr>
<td><code>__divmod__(self, other)</code></td>
<td>实现一个内建函数 <code>divmod()</code></td>
</tr>
<tr>
<td><code>__pow__(self, other)</code></td>
<td>实现一个指数操作( ****** 操作符）的行为</td>
</tr>
<tr>
<td><code>__lshift__(self, other)</code></td>
<td>实现一个位左移操作**（&lt;&lt;）**的功能</td>
</tr>
<tr>
<td><code>__rshift__(self, other)</code></td>
<td>实现一个位右移操作**（&gt;&gt;）**的功能</td>
</tr>
<tr>
<td><code>__and__(self, other)</code></td>
<td>实现一个按位进行与操作**（&amp;）**的行为</td>
</tr>
<tr>
<td><code>__or__(self, other)</code></td>
<td>实现一个按位进行或操作的行为</td>
</tr>
<tr>
<td><code>__xor__(self, other)</code></td>
<td>异或运算符相当于 <strong>^</strong></td>
</tr>
</tbody></table>
<h4 id="增量运算"><a href="#增量运算" class="headerlink" title="增量运算"></a>增量运算</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__iadd__(self, other)</code></td>
<td>加法赋值</td>
</tr>
<tr>
<td><code>__isub__(self, other)</code></td>
<td>减法赋值</td>
</tr>
<tr>
<td><code>__imul__(self, other)</code></td>
<td>乘法赋值</td>
</tr>
<tr>
<td><code>__ifloordiv__(self, other)</code></td>
<td>整除赋值，地板除，相当于 <strong>//=</strong> 运算符</td>
</tr>
<tr>
<td><code>__idiv__(self, other)</code></td>
<td>除法赋值，相当于 <strong>/=</strong> 运算符</td>
</tr>
<tr>
<td><code>__itruediv__(self, other)</code></td>
<td>真除赋值</td>
</tr>
<tr>
<td><code>__imod_(self, other)</code></td>
<td>模赋值，相当于 <strong>%=</strong> 运算符</td>
</tr>
<tr>
<td><code>__ipow__(self, other)</code></td>
<td>乘方赋值，相当于 <code>**=</code> 运算符</td>
</tr>
<tr>
<td><code>__ilshift__(self, other)</code></td>
<td>左移赋值，相当于 <strong>&lt;&lt;=</strong> 运算符</td>
</tr>
<tr>
<td><code>__irshift__(self, other)</code></td>
<td>左移赋值，相当于 <strong>&gt;&gt;=</strong> 运算符</td>
</tr>
<tr>
<td><code>__iand__(self, other)</code></td>
<td>与赋值，相当于 <strong>&amp;=</strong> 运算符</td>
</tr>
<tr>
<td><code>__ior__(self, other)</code></td>
<td>或赋值</td>
</tr>
<tr>
<td><code>__ixor__(self, other)</code></td>
<td>异或运算符，相当于 <strong>^=</strong> 运算符</td>
</tr>
</tbody></table>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__int__(self)</code></td>
<td>转换成整型</td>
</tr>
<tr>
<td><code>__long__(self)</code></td>
<td>转换成长整型</td>
</tr>
<tr>
<td><code>__float__(self)</code></td>
<td>转换成浮点型</td>
</tr>
<tr>
<td><code>__complex__(self)</code></td>
<td>转换成 复数型</td>
</tr>
<tr>
<td><code>__oct__(self)</code></td>
<td>转换成八进制</td>
</tr>
<tr>
<td><code>__hex__(self)</code></td>
<td>转换成十六进制</td>
</tr>
<tr>
<td><code>__index__(self)</code></td>
<td>如果你定义了一个可能被用来做切片操作的数值型，你就应该定义<code>__index__</code></td>
</tr>
<tr>
<td><code>__trunc__(self)</code></td>
<td>当 <code>math.trunc(self)</code> 使用时被调用 <code>__trunc__</code> 返回自身类型的整型截取</td>
</tr>
<tr>
<td><code>__coerce__(self, other)</code></td>
<td>执行混合类型的运算</td>
</tr>
</tbody></table>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码已上传到 <code>Gitee</code> <a href="https://gitee.com/huiDBK/PythonKnowledge" target="_blank" rel="noopener">PythonKnowledge: Python知识宝库</a>，欢迎大家来访。</p>
<p><strong>✍ 码字不易，还望各位大侠多多支持❤️。</strong></p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p> <strong>新建文件夹X</strong></p>
<blockquote>
<p>大自然用数百亿年创造出我们现实世界，而程序员用几百年创造出一个完全不同的虚拟世界。我们用键盘敲出一砖一瓦，用大脑构建一切。人们把1000视为权威，我们反其道行之，捍卫1024的地位。我们不是键盘侠，我们只是平凡世界中不凡的缔造者 。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6959490821934710797" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析Python的单例模式实现一、引言二、单例的应用</title>
    <url>/7272006755265380367.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><blockquote>
<p>单例模式是一种常见的设计模式，它限制一个类只能生成一个实例。在Python开发中，我们该如何实现单例模式呢？本文将通过一个简单的例子，使用Python的元类来实现一个线程安全的单例类，并比较说明使用装饰器实现单例的优劣。</p>
<p>单例模式看起来简单，但是想要做到完全线程安全并支持子类继承，还有一定的难度。本文将从单例模式的概念和应用场景开始，一步步分析线程安全的单例类该如何设计，加锁来保证线程安全等。</p>
</blockquote>
<h1 id="二、单例的应用场景"><a href="#二、单例的应用场景" class="headerlink" title="二、单例的应用场景"></a>二、单例的应用场景</h1><ol>
<li>系统只需要一个实例对象，比如配置类、日志、工具类等。使用单例可以直接保证全局只存在一个实例。</li>
<li>控制资源访问，比如一个硬件资源只允许一个进程访问，或者打印机只允许一个任务执行打印操作。</li>
<li>频繁创建和销毁实例会带来较高的系统开销，使用单例可以减少内存占用和性能消耗。比如任务池、连接池等。</li>
<li>想确保一个类只有一个可见的实例，并提供一个全局访问点，如线程池、缓存、会话对象等。</li>
<li>当类状态需要频繁保存和恢复时，可以让类成为单例，避免每次获取实例后都要恢复状态的操作。</li>
<li>在面向对象中，如果有状态共享的需求，可以将共享状态和逻辑封装在一个单例类中。</li>
<li>单例可以简化代码，从而降低维护成本。在不需要多个实例的情况下，单例可以消除判断逻辑。</li>
</ol>
<p>如下是一些伪代码的单例DEMO</p>
<p><strong>配置类</strong></p>
<p>配置类信息在程序运行期间仅需要一个实例，使用单例模式可以保证全局唯一:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Config(metaclass=SingletonMetaCls):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.config = &#123;&apos;timeout&apos;:100， &apos;port&apos;:8000&#125;</span><br><span class="line"></span><br><span class="line"># 访问配置    </span><br><span class="line">print(Config().config)</span><br></pre></td></tr></table></figure>

<p><strong>2. 日志类</strong></p>
<p>日志类也只需要一个实例输出日志信息即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Logger(metaclass=SingletonMetaCls):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;初始化logger&quot;)</span><br><span class="line">        </span><br><span class="line">    def log(self， msg):</span><br><span class="line">        print(f&quot;log: &#123;msg&#125;&quot;)</span><br><span class="line">        </span><br><span class="line"># 使用        </span><br><span class="line">Logger().log(&quot;测试日志&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>任务池</strong></p>
<p>控制任务池的资源个数，只初始化指定数量的连接:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class TaskPool(metaclass=SingletonMetaCls):</span><br><span class="line">    def __init__(self， size=10):</span><br><span class="line">        print(f&quot;初始化&#123;size&#125;个任务到池中&quot;)</span><br><span class="line">        </span><br><span class="line"># 初始化一个10大小的任务池        </span><br><span class="line">pool = TaskPool()</span><br></pre></td></tr></table></figure>

<p>总之，任何只需要一个实例、不保存状态的工具/帮助类，你需要限制实例个数的场景，都可以考虑使用单例模式实现。</p>
<h1 id="三、单例的实现"><a href="#三、单例的实现" class="headerlink" title="三、单例的实现"></a>三、单例的实现</h1><h2 id="重写-new-方法"><a href="#重写-new-方法" class="headerlink" title="重写 __new__ 方法"></a>重写 __new__ 方法</h2><p>Python 的 new 对象不像java等其他语言一样，一些初学者可能会误认为 __init__ 方法是构造对象，实则不是，__init__方法是初始化对象属性，而__new__ 方法才是真正构造类实例对象。因此我们可以通过 <strong>重写__new__方法</strong> 并在方法内部添加判断逻辑，来限制一个类只创建一个实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Singleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        # 重写 __new__ 实现单例</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化实例属性</span><br><span class="line">        self.demo_name = &quot;Singleton Demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line"></span><br><span class="line">print(&quot;s1 demo_name&quot;, s1.demo_name)</span><br><span class="line">print(&quot;s2 demo_name&quot;, s2.demo_name)</span><br><span class="line">print(&quot;s1&quot;, s1)</span><br><span class="line">print(&quot;s2&quot;, s2)</span><br><span class="line">print(&quot;s1 is s2&quot;, s1 is s2)</span><br><span class="line">print(&quot;s1 == s2&quot;, s1 == s2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">s1 demo_name Singleton Demo</span><br><span class="line">s2 demo_name Singleton Demo</span><br><span class="line">s1 &lt;__main__.Singleton object at 0x1051dcb80&gt;</span><br><span class="line">s2 &lt;__main__.Singleton object at 0x1051dcb80&gt;</span><br><span class="line">s1 is s2 True</span><br><span class="line">s1 == s2 True</span><br></pre></td></tr></table></figure>

<p>通过重写 <code>__new__</code> 实现单例，就可以实现最简单的单例模式。可以发现创建的对象的内存地址都是一样的。</p>
<p>上面的实现模式属于懒汉模式，还有一种叫做饿汉模式。先简单介绍下这两种模式概念。</p>
<p><strong>懒汉模式</strong></p>
<p>懒汉模式是等到<strong>需要才创建实例</strong>，比如:</p>
<p>一个游戏需要读取玩家存档数据的类，如果玩家没有存档,就不需要创建该类的实例，等玩家第一次存档时再实例化该类，读取并保存游戏状态。这种情况下使用懒汉模式更合适，不会提前占用内存资源。</p>
<p><strong>饿汉模式</strong></p>
<p>饿汉模式是<strong>提前创建实例</strong>，比如:</p>
<p>一个数据库连接池类，系统启动时就需要初始化一个指定大小的连接池，以备后续使用。这里需要饿汉模式提前创建并准备好数据库连接池，否则后面需要数据库连接时会出现延迟。</p>
<ul>
<li>懒汉是按需创建，节省资源</li>
<li>饿汉是准备实例，避免后续延迟</li>
</ul>
<p><strong>饿汉代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码#!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author: Hui</span><br><span class="line"># @Desc: &#123; 单例DEMO &#125;</span><br><span class="line"># @Date: 2023/08/22 09:27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseSingleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls):</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            cls._instance = cls()</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(BaseSingleton):</span><br><span class="line">    # _instance = Singleton() 这是错误的语法</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            BaseSingleton.instance()</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化实例属性</span><br><span class="line">        self.demo_name = &quot;Singleton Demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Singleton.instance()</span><br><span class="line">s2 = Singleton.instance()</span><br><span class="line">s3 = Singleton()</span><br><span class="line">s4 = Singleton()</span><br><span class="line"></span><br><span class="line">print(&quot;s1&quot;, s1)</span><br><span class="line">print(&quot;s2&quot;, s2)</span><br><span class="line">print(&quot;s3&quot;, s3)</span><br><span class="line">print(&quot;s4&quot;, s4)</span><br><span class="line">print(&quot;s1 is s2&quot;, s1 is s2)</span><br><span class="line">print(&quot;s2 is s3&quot;, s2 is s3)</span><br><span class="line">print(&quot;s3 is s4&quot;, s3 is s4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">s1 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s2 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s3 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s4 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s1 is s2 True</span><br><span class="line">s2 is s3 True</span><br><span class="line">s3 is s4 True</span><br></pre></td></tr></table></figure>

<p>python的饿汉模式，不能直接在类中构造自身对象，如下是错误的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Singleton(BaseSingleton):</span><br><span class="line">    _instance = Singleton() # 这是错误的语法</span><br></pre></td></tr></table></figure>

<p>因此这里通过添加一个静态方法 instance() 来实现饿汉单例模式，但感觉有点不太像，就是要在new 对象前先通过 instance() 方法初始化下对象实例，到后面在其他模块使用已经存在的实例即可。但有时候就是想，instance() 是单例，Singleton() 这种new 对象不是，那就不要重写 <code>__new__</code> 方法即可。因为有时候new对象想重新初始化属性。</p>
<blockquote>
<p>虽然通过重写 <code>__new__</code> 方法，实现了单例模式，但不够完善，在并发的情况下还是会创建多个实例，属于线程不安全，因此还是需要改造下，这里先展示并发问题，具体改造看下面装饰器的写法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Singleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        # 重写 __new__ 实现单例</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            print(&quot;new instance&quot;)</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化实例属性</span><br><span class="line">        self.demo_name = &quot;Singleton Demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_obj(num):</span><br><span class="line">    s = Singleton()</span><br><span class="line">    print(f&quot;s&#123;num&#125;&quot;, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多线程测试并发</span><br><span class="line">with ThreadPoolExecutor() as pool:</span><br><span class="line">    for i in range(3, 10):</span><br><span class="line">        pool.submit(create_obj, i)</span><br></pre></td></tr></table></figure>

<p>测试效果，这个要多运行几遍才有概率复现</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4bf364d376781e1cc0a6b1040a1965d3c9d61c15f845f41abc8edcd33ee989d0" alt></p>
<p>可以发现，多线程的打印是凌乱的，但已经可以证明有2个线程创建了两实例对象 new instance，对象的内存地址也不一样。这是由于 <strong>if not cls._instance:</strong> 操作是非原子性操作的导致的并发问题。</p>
<h2 id="装饰器写法"><a href="#装饰器写法" class="headerlink" title="装饰器写法"></a>装饰器写法</h2><p>重写 <code>__new__</code> 方法还是比较容易懂，但不太方便使用，每个类都要重写这个方法就很麻烦，逻辑都是一样的，因此我上面抽了一个 <strong>BaseSingleton</strong> 类来做，通过继承来复用代码。还有一种方式就是通过装饰器来实现单例，把共用的逻辑放到装饰器中做，然后再处理下并发问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码def singleton(cls_obj):</span><br><span class="line">    &quot;&quot;&quot;单例装饰器&quot;&quot;&quot;</span><br><span class="line">    _instance_dic = &#123;&#125;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    @functools.wraps(cls_obj)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        if cls_obj in _instance_dic:</span><br><span class="line">            # 实例字典中存在则直接返回</span><br><span class="line">            return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">        with _instance_lock:  # 互斥锁，防止多线程竞争，导致创建多实例</span><br><span class="line">            if cls_obj not in _instance_dic:</span><br><span class="line">                # 实例字典中没有，则创建对象实例，存入字典中</span><br><span class="line">                _instance_dic[cls_obj] = cls_obj(*args, **kwargs)</span><br><span class="line">        return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>

<p>由于 <strong>if cls_obj not in _instance_dic</strong> 判断是非原子性操作故而会引发多线程并发问题。</p>
<p>它大致会转换成以下字节码指令执行:</p>
<ol>
<li>加载<code>_instance_dic</code>到栈顶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">LOAD_GLOBAL   0 (_instance_dic)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>加载<code>cls_obj</code>到栈顶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">LOAD_FAST    0 (cls_obj)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用<code>__contains__</code>方法检查是否在字典中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">CONTAINS_OP</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>根据返回值进行跳转</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">POP_JUMP_IF_FALSE  &lt;target&gt;</span><br></pre></td></tr></table></figure>

<p>如果<code>cls_obj</code>不在<code>_instance_dic</code>中,就会跳转到<code>target</code>位置,也就是if块内的代码。</p>
<p>可以看到校验是否在字典中是在多个指令中完成，不是一个原子操作。</p>
<p>在多线程环境下，如果多个线程同时执行到这里，都可能会通过校验,然后创建实例添加到字典中，从而导致线程不安全。</p>
<p>故而在装饰器中通过线程的互斥锁来解决并发问题，然后通过字典来判断是否存在类的实例对象，存在直接返回，不存在创建对象实例存入字典中来达到单例的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@singleton</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Demo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.demo_name = &quot;singleton_demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = Foo()</span><br><span class="line">f2 = Foo()</span><br><span class="line">print(f1)</span><br><span class="line">print(f2)</span><br><span class="line">print(&quot;f1 is f2&quot;, f1 is f2)</span><br><span class="line"></span><br><span class="line">d1 = Demo()</span><br><span class="line">d2 = Demo()</span><br><span class="line">print(d1)</span><br><span class="line">print(d2)</span><br><span class="line">print(&quot;d1 is d2&quot;, d1 is d2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">&lt;__main__.Foo object at 0x102f56c70&gt;</span><br><span class="line">&lt;__main__.Foo object at 0x102f56c70&gt;</span><br><span class="line">f1 is f2 True</span><br><span class="line">&lt;__main__.Demo object at 0x102f56d60&gt;</span><br><span class="line">&lt;__main__.Demo object at 0x102f56d60&gt;</span><br><span class="line">d1 is d2 True</span><br></pre></td></tr></table></figure>

<p>并发安全验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">@singleton</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def two_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_obj(num):</span><br><span class="line">    foo = Foo()</span><br><span class="line">    print(f&quot;foo&#123;num&#125;&quot;, foo)</span><br><span class="line">    return foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with ThreadPoolExecutor() as pool:</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.submit(create_obj, i)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fe09da082dc62e4fe844e7e00da0fce61861d767ee844567ef4d7a47c0d9208d" alt></p>
<p>ok，对象实例都是 <strong>&lt;</strong>main<strong>.Foo object at 0x1016ed700&gt;，</strong> 大家可以多运行几次，加了锁不会出现多个实例对象了。</p>
<p>这里发现被装饰的类都实现了单例模式，接下来我们一探究竟，在装饰器内部打印些东西，看看其工作原理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">def singleton(cls_obj):</span><br><span class="line">    &quot;&quot;&quot;单例装饰器&quot;&quot;&quot;</span><br><span class="line">    print(&quot;cls_obj&quot;, cls_obj)</span><br><span class="line"></span><br><span class="line">    _instance_dic = &#123;&#125;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    @functools.wraps(cls_obj)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        if cls_obj in _instance_dic:</span><br><span class="line">            # 实例字典中存在则直接返回</span><br><span class="line">            return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">        with _instance_lock:  # 互斥锁，防止多线程竞争，导致创建多实例</span><br><span class="line">            if cls_obj not in _instance_dic:</span><br><span class="line">                # 实例字典中没有，则创建对象实例，存入字典中</span><br><span class="line">                _instance_dic[cls_obj] = cls_obj(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        print(&quot;_instance_dic&quot;, _instance_dic, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">        return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Demo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.demo_name = &quot;singleton_demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = Foo()</span><br><span class="line">f2 = Foo()</span><br><span class="line">print(f1)</span><br><span class="line">print(f2)</span><br><span class="line">print(&quot;f1 is f2&quot;, f1 is f2)</span><br><span class="line"></span><br><span class="line">d1 = Demo()</span><br><span class="line">d2 = Demo()</span><br><span class="line">print(d1)</span><br><span class="line">print(d2)</span><br><span class="line">print(&quot;d1 is d2&quot;, d1 is d2)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/60a067e3c913629f84a361e7ad342e2b0e7c4a3b4687af4c5047169db045a21b" alt></p>
<p>模块在初始化的时候，其实就会把类初始化形成<strong>类对象，注意不是类的实例对象。</strong></p>
<ul>
<li>装饰器的原理就是python解释器识别到 <strong>@singleton</strong> 的语法糖时自动把类对象的引用传递给 singleton 装饰器函数</li>
<li>此时装饰器会返回一个新的函数对象（wrapper）出去，把类对象重新赋值了</li>
</ul>
<pre><code>+ **Foo = singleton(Foo) = wrapper**
+ **Demo = singleton(Demo) = wrapper**</code></pre><ul>
<li>到创建对象实例时，Foo() 实则变成了是调用函数 wrapper() 来创建对象</li>
<li>然后每个类都维护了一份 _instance = {} 实例字典，来确保这个类创建的对象只有一份</li>
</ul>
<pre><code>+ Key 是类对象，eg：Foo、Demo
+ Value 是类的实例对象，eg：Foo()，Demo()</code></pre><p>可能大家会不了解类对象的概念，可以先看看我这篇文章 <a href="https://dev.newban.cn/6958375754505650213">你真的了解Python中的类class? - 掘金</a> 然后再回来看就更容易看懂了。</p>
<p>但装饰器实现的单例模式装饰方便、代码简洁，但是破坏了类的类型，把类变成了函数，导致编写代码的时候没有提示，也不知道有什么属性与方法，所以实际使用起来及其不方便。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a91c46fd372b859ee89bcf2e4a43721fd37b0c76702d8565d463dbe3996ff71a" alt></p>
<p>接下来就是引出另一种写法，元类实现单例。</p>
<h2 id="元类写法"><a href="#元类写法" class="headerlink" title="元类写法"></a>元类写法</h2><blockquote>
<p>元类是一种非常晦涩的知识点，一般场景都用不上，但知道元类的原理，后面需要用到时，可以帮助你更好的抽象与封装。</p>
<p>元类就是创建 <strong>类对象的类，type 就是元类</strong></p>
<p>可以先了解下元类的知识点：<a href="https://dev.newban.cn/6957631734343008269">追溯Python类的鼻祖——元类 - 掘金</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码#!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author: Hui</span><br><span class="line"># @Desc: &#123; 元类模块 &#125;</span><br><span class="line"># @Date: 2022/11/26 16:43</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonMetaCls(type):</span><br><span class="line">    &quot;&quot;&quot; 单例元类 &quot;&quot;&quot;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(cls， *args， **kwargs):</span><br><span class="line">        cls._instance = None</span><br><span class="line">        super().__init__(*args， **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(cls， *args， **kwargs):</span><br><span class="line">        if cls._instance:</span><br><span class="line">            # 存在实例对象直接返回，减少锁竞争，提高性能</span><br><span class="line">            return cls._instance</span><br><span class="line"></span><br><span class="line">        with cls._instance_lock:</span><br><span class="line">            if not cls._instance:</span><br><span class="line">                cls._instance = super().__call__(*args， **kwargs)</span><br><span class="line">        return cls._instance</span><br></pre></td></tr></table></figure>

<p>使用单例元类进行单例的封装会比装饰器的更好一些，装饰器封装的单例，再实际使用的过程中不太方便，IDE一些开发工具不知道这个类有什么属性，元类就不会，继承也可以实现单例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">foo1 is foo2 True</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/36dd0fd8008c3666db7e7f6d71e151f4ca0ee9865bbb4f6ade53f574b2ffea7a" alt></p>
<p>继承案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Demo(Foo):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;demo_bar&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo1 = Demo()</span><br><span class="line">demo2 = Demo()</span><br><span class="line">print(&quot;demo1 is demo2&quot;, demo1 is demo2)</span><br><span class="line">print(&quot;demo2 two_bar&quot;, demo2.tow_bar())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">foo1 is foo2 True</span><br><span class="line">foo2 two_bar barbar</span><br><span class="line">demo1 is demo2 True</span><br><span class="line">demo2 two_bar demo_bardemo_bar</span><br></pre></td></tr></table></figure>

<p><strong>元类实现原理</strong></p>
<ul>
<li>加载Foo、Demo等类时，发现指定了元类 <strong>metaclass=SingletonMetaCls，</strong> 则会让指定的元类来帮助创建类对象</li>
<li>此时 <strong>SingletonMetaCls 会调用__init__ 来创建类对象，然后通过super() 让 type 来创建类对象</strong></li>
</ul>
<pre><code>+ type(类名, 父类元组, 类属性字典)
+ 并动态加了个 cls.\_instance 属性</code></pre><ul>
<li>Foo()、Demo()，创建实例对象时，是Foo、Demo类对象触发了()，所以调用 <strong>call</strong>() 魔法属性来构造对象实例，存到cls._instance中</li>
<li>下次再创建实例对象，则是先判断是否有，有直接返回，没有则创建</li>
</ul>
<p>可以打印一些信息来验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonMetaCls(type):</span><br><span class="line">    &quot;&quot;&quot; 单例元类 &quot;&quot;&quot;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(cls, *args, **kwargs):</span><br><span class="line">        cls._instance = None</span><br><span class="line">        print(&quot;SingletonMetaCls __init__&quot;, cls)</span><br><span class="line">        print(&quot;args&quot;, args)</span><br><span class="line">        print(&quot;kwargs&quot;, kwargs)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def _init_instance(cls, *args, **kwargs):</span><br><span class="line">        if cls._instance:</span><br><span class="line">            # 存在实例对象直接返回，减少锁竞争，提高性能</span><br><span class="line">            print(&quot;cls._instance&quot;, cls._instance)</span><br><span class="line">            return cls._instance</span><br><span class="line"></span><br><span class="line">        with cls._instance_lock:</span><br><span class="line">            if cls._instance is None:</span><br><span class="line">                cls._instance = super().__call__(*args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;SingletonMetaCls __call__ cur cls&quot;, cls)</span><br><span class="line">        instance = cls._init_instance()</span><br><span class="line">        reinit = kwargs.get(&quot;reinit&quot;, True)</span><br><span class="line">        if reinit:</span><br><span class="line">            # 默认都重新初始化单例对象属性</span><br><span class="line">            instance.__init__(*args, **kwargs)</span><br><span class="line">        return instance</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from py_tools.meta_cls import SingletonMetaCls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Foo __init__&quot;)</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Foo __new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># foo1 = Foo()</span><br><span class="line"># foo2 = Foo()</span><br><span class="line"># print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line"># print(&quot;foo2 two_bar&quot;, foo2.tow_bar())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Demo(Foo):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;demo_bar&quot;</span><br></pre></td></tr></table></figure>

<p>模块加载时就会走元类的__init__</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码SingletonMetaCls __init__ &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">args (&apos;Foo&apos;, (), &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;Foo&apos;, &apos;__init__&apos;: &lt;function Foo.__init__ at 0x100eb0310&gt;, &apos;__new__&apos;: &lt;function Foo.__new__ at 0x100ed53a0&gt;, &apos;tow_bar&apos;: &lt;function Foo.tow_bar at 0x100ed5430&gt;, &apos;__classcell__&apos;: &lt;cell at 0x100eaafd0: SingletonMetaCls object at 0x1217193b0&gt;&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br><span class="line"></span><br><span class="line">SingletonMetaCls __init__ &lt;class &apos;__main__.Demo&apos;&gt;</span><br><span class="line">args (&apos;Demo&apos;, (&lt;class &apos;__main__.Foo&apos;&gt;,), &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;Demo&apos;, &apos;__init__&apos;: &lt;function Demo.__init__ at 0x100ed54c0&gt;&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看看new对象的时候的打印信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Foo __init__&quot;)</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Foo __new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br></pre></td></tr></table></figure>

<p>输出信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码SingletonMetaCls __init__ &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">args (&apos;Foo&apos;, (), &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;Foo&apos;, &apos;__init__&apos;: &lt;function Foo.__init__ at 0x104998550&gt;, &apos;__new__&apos;: &lt;function Foo.__new__ at 0x1049d5550&gt;, &apos;tow_bar&apos;: &lt;function Foo.tow_bar at 0x1049d55e0&gt;, &apos;__classcell__&apos;: &lt;cell at 0x104991fd0: SingletonMetaCls object at 0x12f626fb0&gt;&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br><span class="line"></span><br><span class="line">SingletonMetaCls __call__ cur cls &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">Foo __new__</span><br><span class="line">Foo __init__</span><br><span class="line">Foo __init__</span><br><span class="line"></span><br><span class="line">SingletonMetaCls __call__ cur cls &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">cls._instance &lt;__main__.Foo object at 0x1049b3f70&gt;</span><br><span class="line">Foo __init__</span><br><span class="line">foo1 is foo2 True</span><br></pre></td></tr></table></figure>

<p>可以发现跟我上面的说的一致，这里引出了好多魔法属性来验证，可以先看看 <a href="https://dev.newban.cn/6959490821934710797">Python中的魔法属性 - 掘金</a></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><ul>
<li>类重写 <strong>new</strong> 易懂，但每个类都要重写太冗余了</li>
</ul>
<pre><code>+ 故抽出 BaseSingleton 基类，复用逻辑通过 instance() 来实现单例（**推荐**）
+ 如果要构造实例属性会有点不太方便</code></pre><ul>
<li>装饰器写法也是复用了创建单例的逻辑，装饰起来方便、简洁</li>
</ul>
<pre><code>+ 但实际使用装饰过的类不方便，没有类属性提示</code></pre><ul>
<li>元类的写法会有点难与绕，实际使用起来方便，多继承也实现了单例（<strong>推荐</strong>）</li>
</ul>
<pre><code>+ 使用起来和平常使用类没有区别
+ 还可以通过**reinit**参数来控制是否重新初始化实例对象属性</code></pre><ul>
<li>通过线程的互斥锁来解决并发问题</li>
</ul>
<pre><code>+ 双重判断来减少锁竞争，提高性能</code></pre><ul>
<li>当然还有其他的方式实现单例，例如通过Python的模块导入，来保证只会创建一个实例</li>
</ul>
<h1 id="五、源代码"><a href="#五、源代码" class="headerlink" title="五、源代码"></a>五、源代码</h1><p>有些细节，我没有展开讲，大家可以下载源代码，亲自实践下。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7272006755265380367" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决swagger2默认地址失效前言修改</title>
    <url>/7221525689856688184.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>本文正在参加<a href="https://dev.newban.cn/7207698564641996856/">「金石计划」</a></em></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有段时间没用 Java 写过项目了，今天因为需求要搭建一个小项目，果然是略显生疏，一路磕磕碰碰的，不过总算都是让我解决了。</p>
<p>回归正题，本篇博文要讲的是，关于配置好 <code>swagger2</code> 之后，访问其页面却被告诉页面不存在，即默认地址失效的问题。</p>
<p>当然也顺带讲解一下 SpringBoot 和 Springfox 的版本兼容性问题。以下就先讲解如何简单地解决版本兼容性问题。</p>
<h1 id="修改路径匹配策略"><a href="#修改路径匹配策略" class="headerlink" title="修改路径匹配策略"></a>修改路径匹配策略</h1><p>先介绍一下相关的配置信息，<code>SpringBoot</code> 用的版本是 2.7.10，<code>maven</code> 是 3.6.1，用的是阿里云的镜像。</p>
<p><code>swagger2</code> 的安装配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;!--swagger2--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后新建一个 <code>SwaggerConfig.java</code> 类，用于配置一些与 <code>Swagger2</code> 相关的内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket examApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(&quot;xxx&quot;)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.sidiot.xxx.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder().title(&quot;xxx&quot;)</span><br><span class="line">                .description(&quot;xxx&quot;)</span><br><span class="line">                .contact(new Contact(&quot;sid10t.&quot;, &quot;https://www.sid10t.com&quot;, &quot;e-mail&quot;))</span><br><span class="line">                .version(&quot;1.0.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将程序启动，发现报错了：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/123a826a9092dc63887b1de5fabbc7e768568e37e435ec308753fe977a6ecb61" alt="image.png"></p>
<p>错误原因是 <code>org.springframework.context.ApplicationContextException: Failed to start bean &#39;documentationPluginsBootstrapper&#39;; nested exception is java.lang.NullPointerException</code>；</p>
<p>这个异常表示在启动 Spring 应用程序上下文时，<code>documentationPluginsBootstrapper</code> 这个 Bean 启动失败，并且嵌套异常是 <code>NullPointerException</code>。通常这种错误发生在调用一个空对象的方法或者访问一个空对象的属性时。</p>
<p>这是因为 SpringBoot 在 2.6.1 之后，SpringMVC 处理程序映射匹配请求路径的默认策略已从 <code>AntPathMatcher</code> 更改为 <code>PathPatternParser</code>。而 Springfox 使用的路径匹配还是 <code>AntPathMatcher</code>，因此导致了这个错误的发生。</p>
<p>那么这里只需要在配置文件 <code>application.properties</code> 中，重新修改策略即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">properties复制代码spring.mvc.pathmatch.matching-strategy=ant-path-matcher</span><br></pre></td></tr></table></figure>

<p>用 <code>.yml</code> 的小伙伴这样改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yml复制代码spring:</span><br><span class="line">  mvc:</span><br><span class="line">    pathmatch:</span><br><span class="line">      matching-strategy: ant_path_matcher</span><br></pre></td></tr></table></figure>

<p>修改完成之后就能正常访问到页面了！</p>
<p>关于 SpringBoot 在 2.6.1 之后的一些变化，可以参考这篇博文：<a href="https://xie.infoq.cn/article/514f30865d7dfffc0c23eb78b" target="_blank" rel="noopener">Springboot 升级到 2.6.1 的坑</a>；</p>
<p><strong>用这个方法解决兼容性问题的小伙伴，是不会碰到 <code>swagger2</code> 默认地址失效的问题的，用下面一种方法解决兼容性问题就会遇到！</strong></p>
<h1 id="使用-EnableWebMvc-注解"><a href="#使用-EnableWebMvc-注解" class="headerlink" title="使用 @EnableWebMvc 注解"></a>使用 @EnableWebMvc 注解</h1><p>是的，除了上述提到的修改匹配策略之外，还有一种方式也能解决兼容性问题，那就是使用注解 <code>@EnableWebMvc</code>；</p>
<p>我们只需要在启动类上加上 <code>@EnableWebMvc</code> 这个注解就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@EnableWebMvc</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class xxxApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(xxxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加上注解之后，启动我们的程序看一看，发现没有报错，是正常运行的，在打开 <code>swagger</code> 的页面瞅瞅，</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4512665197b7075b583eb25d8c4696ce4dd0e178c6ce6068eaaba3cb0fa99080" alt="image.png"></p>
<p>发现找不到页面，在看看控制台也是如此：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码2023-04-13 17:34:54.885  WARN 17948 --- [nio-8080-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /swagger-ui.html</span><br></pre></td></tr></table></figure>

<p>试了试其他相关的 url 路径也是找不到，这是为什么呢？</p>
<p>先简单介绍一下 <code>@EnableWebMvc</code> 这个注解：</p>
<p><code>@EnableWebMvc</code> 是 SpringMVC 框架中的一个注解，它的作用是开启对 SpringMVC 的支持。</p>
<p>具体来说，使用 <code>@EnableWebMvc</code> 注解会导入一系列与 SpringMVC 相关的配置类，并且会自动注册多个关键组件，如 HandlerMapping、HandlerAdapter、ViewResolver 等。这些组件可以让开发者方便地处理 HTTP 请求和响应、实现 MVC 模式以及生成视图。</p>
<p>但需要注意的是，如果使用了 <code>@EnableWebMvc</code> 注解，则默认情况下会禁用 SpringBoot 中的自动配置，因为 <code>@EnableWebMvc</code> 已经提供了类似的功能。如果想要同时使用 SpringBoot 的自动配置和<code>@EnableWebMvc</code>，可以通过在配置类上添加 <code>@Import({WebMvcAutoConfiguration.class})</code> 注解来实现。</p>
<p>而 <code>Swagger</code> 通常是使用 springfox-swagger2 和 springfox-swagger-ui 这两个库来实现的。在使用 <code>@EnableWebMvc</code> 注解时，会覆盖掉 SpringBoot 自动配置中的 WebMvcAutoConfiguration，可能导致 <code>Swagger</code> 的默认地址 <code>/swagger-ui.html</code> 失效。因为在 WebMvcAutoConfiguration 类中有一个关于 <code>Swagger</code> 的默认配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@ConditionalOnClass(&#123; UiConfiguration.class &#125;)</span><br><span class="line">@EnableConfigurationProperties(SwaggerUiProperties.class)</span><br><span class="line">public class SwaggerUiWebMvcConfiguration &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在提供了许多 <code>Swagger</code> 相关的默认配置，包括默认的 UI 界面路径 <code>/swagger-ui.html</code>。但是，当添加 <code>@EnableWebMvc</code> 注解后，SpringMVC 将覆盖掉这个类的配置，进而导致 <code>Swagger</code> 的默认 UI 界面无法使用。</p>
<p>解决这个问题的方法是手动配置 <code>Swagger</code> 相关的 Bean，并指定 Swagger UI 的访问路径和资源文件位置。比如可以在配置类中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123; </span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2).select()</span><br><span class="line">          .apis(RequestHandlerSelectors.any())</span><br><span class="line">          .paths(PathSelectors.any())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurerAdapter webMvcConfigurerAdapter() &#123;</span><br><span class="line">        return new WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">                registry.addResourceHandler(&quot;/swagger-ui.html**&quot;)</span><br><span class="line">                        .addResourceLocations(&quot;classpath:/META-INF/resources/swagger-ui.html&quot;);</span><br><span class="line">                registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以手动配置 Swagger 相关的 Bean，并指定 Swagger UI 的访问路径和资源文件位置，从而解决 <code>@EnableWebMvc</code> 导致 <code>Swagger</code> 默认地址失效的问题。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>解决 swagger2 默认地址失效</em></strong> 的全部内容了，希望对大家有所帮助！</p>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7176830504996454455">【问题解决】解决如何在 CPU 上加载多 GPU 训练的模型</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注；</p>
<p>👍 创作不易，请多多支持；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a> <a href="https://juejin.cn/column/7143109530753171486" target="_blank" rel="noopener">JAVA</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7221525689856688184" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>掘金·金石计划,后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决如何在CPU上加载多GPU训练的模型</title>
    <url>/7176830504996454455.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>本文正在参加<a href="https://dev.newban.cn/7162096952883019783">「金石计划 . 瓜分6万现金大奖」</a></em></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一期的恶意文件检测模型训练好了，因此需要进行测试，关于恶意文件检测的内容，可以回看博主之前写的博文：</p>
<ul>
<li><a href="https://dev.newban.cn/7165831526137987108">【AI】浅析恶意文件静态检测及部分问题解决思路</a></li>
<li><a href="https://dev.newban.cn/7176224054884433957">【AI】恶意文件静态检测模型检验及小结</a></li>
</ul>
<p>因为样本在某台机子上，又恰逢有其他模型在训练，因此 GPU 资源被占满了，不过测试这个模型的话，CPU 也绰绰有余了，当我准备使用 CPU 训练时，却遇到了问题；</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><strong><em>1、<code>model.to(device)</code> 不会影响 <code>torch.load()</code>；</em></strong></p>
<p>我一开始以为只要使用 <code>model.to</code> 就算是使用上 CPU 了；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py复制代码device = torch.device(&quot;cpu&quot;)</span><br><span class="line">model = ...</span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line">model_savedir_ = &apos;&apos;</span><br><span class="line">if os.path.exists(model_savedir_):</span><br><span class="line">    print(&quot;model load.&quot;)</span><br><span class="line">    state_dict = torch.load(model_savedir_)</span><br><span class="line">    model.load_state_dict(state_dict)</span><br></pre></td></tr></table></figure>

<p>事实证明，我想的太简单了…</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a49df6ca30f6ad11f5e3db1758a52da5860bc103dfc0fbfa84a40ca3be4aca93" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码RuntimeError: CUDA error: out of memory</span><br><span class="line">CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.</span><br><span class="line">For debugging consider passing CUDA_LAUNCH_BLOCKING=1.</span><br></pre></td></tr></table></figure>

<p>这个问题很显而易见，就是 GPU 的内存溢出了，但是按我的思路，用的应该是 CPU 啊，所以我怀疑是 <code>torch.load()</code> 这个函数出了问题，查询了一番资料后，发现是要这样使用的 <code>state_dict = torch.load(model_savedir_, map_location=device)</code>；</p>
<hr>
<p><strong><em>2、GPU 与 CPU 训练时参数名不一致</em></strong></p>
<p>当我以为大功告成，点击运行之时，不料，又报错了：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d4dbefed7c59f9fc9bbc5733d229b612a2dd8cec581f0b4b67e6246ba2796b30" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码RuntimeError: Error(s) in loading state_dict for ..model..:</span><br><span class="line">	Missing key(s) in state_dict: &quot;fc.weight&quot;, &quot;fc.bias&quot;, &quot;features.0.0.weight&quot;, &quot;features.0.1.weight&quot;, &quot;features.0.1.bias&quot;, &quot;features.0.1.running_mean&quot;, &quot;features.0.1.running_var&quot;, &quot;features.1.conv.0.weight&quot;, &quot;features.1.conv.1.weight&quot;, &quot;features.1.conv.1.bias&quot;, &quot;features.1.conv.1.running_mean&quot;, &quot;features.1.conv.1.running_var&quot;, &quot;features.1.conv.3.weight&quot;, &quot;features.1.conv.4.weight&quot;, &quot;features.1.conv.4.bias&quot;, &quot;features.1.conv.4.running_mean&quot;, &quot;features.1.conv.4.running_var&quot;, &quot;features.1.conv.5.fc.0.weight&quot;, ...</span><br></pre></td></tr></table></figure>

<p>根据理解，就是说找不到参数，因此，我将字典部分内容打印了一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py复制代码for k, v in state_dict.items():</span><br><span class="line">    print(k, v)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b1bb57abc8c5e210319f18281f76dfc3de45076d22c22d7a2f9e7f884ee911e0" alt="image.png"></p>
<p>发现问题了，在多 GPU 上训练的模型，保存时会在参数名前多加了一个 <code>module.</code> 前缀，因此在用 CPU 进行加载时，需要把这个前缀去掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py复制代码if os.path.exists(model_savedir_):</span><br><span class="line">    print(&quot;model load.&quot;)</span><br><span class="line">    state_dict = torch.load(model_savedir_, map_location=device)</span><br><span class="line">    from collections import OrderedDict</span><br><span class="line">    state_dict_new = OrderedDict()</span><br><span class="line">    for k, v in state_dict.items():</span><br><span class="line">        name = k[7:]  # 去掉 `module.`</span><br><span class="line">        state_dict_new[name] = v</span><br><span class="line">    model.load_state_dict(state_dict_new)</span><br></pre></td></tr></table></figure>

<p>这样就能够在 CPU 上加载多 GPU 训练的模型了！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>【问题解决】解决如何在 CPU 上加载多 GPU 训练的模型</em></strong> 的全部内容了，希望对大家有所帮助！</p>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7173960546998288391">【问题解决】解决 Docker 二次重启 MySQL 8 遇到的一些问题</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注；</p>
<p>👍 创作不易，请多多支持；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a> <a href="https://juejin.cn/column/7160294356350402590" target="_blank" rel="noopener">AI</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7176830504996454455" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>掘金·金石计划,人工智能,PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程fork()系统调用详解</title>
    <url>/7250283546367557692.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>前言：</strong>  本文介绍了进程控制相关的命令与函数，并深入讨论了fork函数的实现机制以及fork函数的一次调用两次返回，最后通过实例演示了如何使用fork函数控制进程的创建。</p>
<hr>
<blockquote>
<h3 id="🏆文章目录"><a href="#🏆文章目录" class="headerlink" title="🏆文章目录"></a>🏆文章目录</h3><ul>
<li><ul>
<li><a href="http://www.cnblogs.com/#1_forkgetpidgetppid_10" target="_blank" rel="noopener">🥇1. fork()、getpid()、getppid()函数介绍</a><ul>
<li><ul>
<li><a href="http://www.cnblogs.com/#11_fork_12" target="_blank" rel="noopener">🥈1.1 fork()函数介绍</a><ul>
<li><a href="http://www.cnblogs.com/#12_getpidgetppid_44" target="_blank" rel="noopener">🥈1.2 getpid()函数与getppid()函数介绍</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/#2_fork_74" target="_blank" rel="noopener">🥇2. fork()工作机制</a></li>
<li><ul>
<li><a href="http://www.cnblogs.com/#21_fork_76" target="_blank" rel="noopener">🥈2.1 fork()的实现机制——一次调用两次返回与进程复制</a><ul>
<li><a href="http://www.cnblogs.com/#22_shell_147" target="_blank" rel="noopener">🥈2.2 shell进程控制命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/#3__200" target="_blank" rel="noopener">🥇3. 进程创建的控制</a></li>
<li><ul>
<li><a href="http://www.cnblogs.com/#31__202" target="_blank" rel="noopener">🥈3.1 控制进程创建个数</a><ul>
<li><a href="http://www.cnblogs.com/#32__265" target="_blank" rel="noopener">🥈3.2 进程顺序控制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bac32d431949da0d952521763f96cd08d685c4dda30861e1e844bcbbda4c97d0" alt="在这里插入图片描述"></p>
<hr>
<h2 id="🥇1-fork-、getpid-、getppid-函数介绍"><a href="#🥇1-fork-、getpid-、getppid-函数介绍" class="headerlink" title="🥇1. fork()、getpid()、getppid()函数介绍"></a>🥇1. fork()、getpid()、getppid()函数介绍</h2><h3 id="🥈1-1-fork-函数介绍"><a href="#🥈1-1-fork-函数介绍" class="headerlink" title="🥈1.1 fork()函数介绍"></a>🥈1.1 fork()函数介绍</h3><p>fork()用于创建一个子进程，我们在shell下执行一个命令其实也是通过fork()实现的，fork()是Linux下最基本的一个系统调用。fork()最大的特点就是一次调用，两次返回，两次返回主要是区分父子进程，因为fork()之后将出现两个进程，所以有两个返回值，父进程返回子进程ID，子进程返回0。</p>
<ul>
<li>包含头文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码pid_t fork(void);</span><br></pre></td></tr></table></figure>

<ul>
<li>函数功能</li>
</ul>
<p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, the calling process, referred to as the parent. 通过复制的方式创建一个进程，被创建的进程称为子进程，调用进程称为父进程，复制的子进程是从父进程fork()调用后面的语句开始执行的。</p>
<ul>
<li>函数参数</li>
</ul>
<pre><code>+ void</code></pre><ul>
<li>函数返回值</li>
</ul>
<pre><code>+ On success, the PID of the child process is returned in the parent, and 0 is returned in the child.


    - 父进程返回子进程ID
    - 子进程返回0
+ On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately. 失败返回-1并设置errno。</code></pre><h3 id="🥈1-2-getpid-函数与getppid-函数介绍"><a href="#🥈1-2-getpid-函数与getppid-函数介绍" class="headerlink" title="🥈1.2 getpid()函数与getppid()函数介绍"></a>🥈1.2 getpid()函数与getppid()函数介绍</h3><ul>
<li>包含头文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码pid_t getpid(void);</span><br><span class="line">pid_t getppid(void);</span><br></pre></td></tr></table></figure>

<ul>
<li>函数功能</li>
</ul>
<pre><code>+ getpid() returns the process ID of the calling process. 获得当前进程的ID。
+ getppid() returns the process ID of the parent of the calling process. 获得当前进程的父进程的ID。</code></pre><ul>
<li>函数参数</li>
</ul>
<p>void</p>
<ul>
<li>函数返回值</li>
</ul>
<pre><code>+ getpid()返回当前进程ID
+ getppid()返回当前进程的父进程ID</code></pre><h2 id="🥇2-fork-工作机制"><a href="#🥇2-fork-工作机制" class="headerlink" title="🥇2. fork()工作机制"></a>🥇2. fork()工作机制</h2><h3 id="🥈2-1-fork-的实现机制——一次调用两次返回与进程复制"><a href="#🥈2-1-fork-的实现机制——一次调用两次返回与进程复制" class="headerlink" title="🥈2.1 fork()的实现机制——一次调用两次返回与进程复制"></a>🥈2.1 fork()的实现机制——一次调用两次返回与进程复制</h3><p>下面通过一个案例来分析fork()是如何创建进程，又是如何返回的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码/************************************************************</span><br><span class="line">  &gt;File Name  : fork_test.c</span><br><span class="line">  &gt;Author     : Mindtechnist</span><br><span class="line">  &gt;Company    : Mindtechnist</span><br><span class="line">  &gt;Create Time: 2022年05月18日 星期三 15时59分29秒</span><br><span class="line">************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;=== process begin ===\n&quot;);</span><br><span class="line">	pid_t pid = fork();</span><br><span class="line">	if(pid == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;fork err&quot;);</span><br><span class="line">		return -1;	</span><br><span class="line">	&#125;</span><br><span class="line">	if(pid == 0) /*子进程*/</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i am child: %d, may parent: %d\n&quot;, getpid(), getppid());	</span><br><span class="line">        /*	test2</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;fork process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">	&#125;</span><br><span class="line">	if(pid &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i am call: %d, child: %d, parent: %d\n&quot;, getpid(), pid, getppid());	</span><br><span class="line">        /*	test1</span><br><span class="line">        sleep(1);</span><br><span class="line">        */</span><br><span class="line">        /*	test2</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        	sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;=== process end ===\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行该程序，我们会发现一个很有意思的现象  </p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fafd376bc74eb2c8ec739f00f878ce077fe5b5ccc50fec7f534874c24edeabdf" alt="在这里插入图片描述"></p>
<p>首先反常的第一点，我们在程序中的打印顺序是先进入子进程(pid == 0)分支，再进入父进程(pid &gt; 0)分支，但实际的打印顺序是先执行了父进程分支的printf()函数，后执行的子进程分支到的printf()函数；第二点是，在执行子进程的printf()函数时，竟然已经回到了shell下，可以看图中高亮标出的位置。下面对着两点详细分析；第三点，子进程打印的父进程ID和父进程自己打印的ID不同。</p>
<p>我们已经知道，fork()系统调用的特点是一次调用两次返回，并且子进程的创建是对父进程的复制，那么是从哪复制开始复制的呢，我们根据程序运行结果分析，程序只打印了一次begin语句，说明不是从头开始复制的，实际上它是从fork()的下一句开始复制的，从fork()开始，后面就成了两个分支。  </p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdb191b64b5c41c162683c5e85f7cac326af6ff4fcfab3cb03711714337712f8" alt="在这里插入图片描述">  </p>
<p>我们看到的运行结果中红色标记的①，实际上是由父进程打印的，②是由子进程打印的，既然不是一个进程打印的，那也就没有先后顺序的问题了。而子进程打印的父进程ID是1，父进程打印的自己的ID是5270，这是因为在子进程结束前，父进程就已经结束了，新建的子进程变成了孤儿进程，所以它会被1号进程收养，所以新建子进程的父进程ID是1，这也是为什么第二个printf()语句是在shell下执行的原因，因为原来的父进程结束了，所以回到了shell进程下，此时子进程还没有结束，它被1号进程接管，继续执行后面的语句，直到结束。</p>
<p>（实际上，这里的3397进程就是我们的shell进程，shell进程是我们自己启动的进程的父进程；而1号进程则是init进程，init进程是Linux下最原始的进程，是所有进程最终的父进程。）</p>
<p>我们可以在父进程中加一个sleep()函数（放开上面代码中test1注释掉的代码即可），让父进程等一下子进程，并看一下效果，这次就好了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e1974e32e5e32093cbe56c5cee535e7e18133e9eaf726f3ce08c632112591074" alt="在这里插入图片描述"></p>
<h3 id="🥈2-2-shell进程控制命令"><a href="#🥈2-2-shell进程控制命令" class="headerlink" title="🥈2.2 shell进程控制命令"></a>🥈2.2 shell进程控制命令</h3><p>下面我们通过shell下的进程控制命令进一步分析上面所讲的fork()实现机制，首先介绍几个命令：</p>
<ul>
<li>ps 查看进程信息，主要用到下面两个参数</li>
</ul>
<pre><code>+ ps aux


![在这里插入图片描述](https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4a0ccdcd9f14231b758652246dec2928e1cf99c20c3ca733ba0bd9909e7c14c7)
+ ps ajx：可以查看父进程ID，追溯进程之间的关系  

![在这里插入图片描述](https://gitee.com/songjianzaina/juejin_p1/raw/master/img/381dc2bb7ef3969a8bf919917a4cfb9a960aeca6b2601e25bf0027c030ef5f63)</code></pre><ul>
<li>kill 给进程发送信号，通过这个命令可以杀死进程，常用的两个参数</li>
</ul>
<pre><code>+ kill -l：查看所有信号；![在这里插入图片描述](https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eba311e7cb46140e255a7918de72da4f03d83a0c846896ffa68cd0c89157bf8f)


+ kill -9 pid：给进程号为pid的进程发送9号信号，杀死进程，实际上相当于 kill -SIGKILL pid，也可以直接通过 kill pid 来杀死pid进程；</code></pre><p>我们再做一个测试，将上面代码中的test2处的注释放开，编译并运行程序，让两个进程一直在while中执行</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ef400deb517f0567299702d88dc27c2a2f38d42a57dc1177e3df4f77094ef5cb" alt="在这里插入图片描述"></p>
<p>开始循环后，我们另起一个shell来查看进程信息，可以通过管道和grep过滤我们需要的进程信息</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dd63f2ea606412c02510b9cd4a5f17b23dae237b81596e58d0464e0912dd4d6b" alt="在这里插入图片描述"></p>
<p>通过ajx追溯进程血缘关系</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e8365205ce3d3a95496c1d3e365fd1d0e31018eb97b2fc81e0607045d665f529" alt="在这里插入图片描述"></p>
<p>可以看到fork()的调用进程5721，它的父进程是3397也就是 bash shell 进程</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d4565da90a72f764700766d53fcd61a996666697b21cfcfebf2528b70bff788b" alt="在这里插入图片描述"></p>
<p>通过kill杀死父进程，可以看到子进程被1号进程接管</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/394cbf0da62afcc2c1924b41ae653584597895a135acdb68951e8f08e78f75e4" alt="在这里插入图片描述"></p>
<p>1号进程就是init进程</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d1eb7c7f2f34ed484084e35796da3b824f3a20bdf00d86aa26ac6362cd8ab859" alt="在这里插入图片描述"></p>
<h2 id="🥇3-进程创建的控制"><a href="#🥇3-进程创建的控制" class="headerlink" title="🥇3. 进程创建的控制"></a>🥇3. 进程创建的控制</h2><h3 id="🥈3-1-控制进程创建个数"><a href="#🥈3-1-控制进程创建个数" class="headerlink" title="🥈3.1 控制进程创建个数"></a>🥈3.1 控制进程创建个数</h3><p>我们通过一个for循环来创建进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markdown复制代码/************************************************************</span><br><span class="line">  &gt;File Name  : mutifork.c</span><br><span class="line">  &gt;Author     : Mindtechnist</span><br><span class="line">  &gt;Company    : Mindtechnist</span><br><span class="line">  &gt;Create Time: 2022年05月18日 星期三 19时33分50秒</span><br><span class="line">************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	pid_t pid = 0;</span><br><span class="line">	for(i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		if(pid == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;i am chiled: %d, ppid: %d\n&quot;, getpid(), getppid());</span><br><span class="line">			/*</span><br><span class="line">			break;</span><br><span class="line">			*/</span><br><span class="line">		&#125;	</span><br><span class="line">		if(pid &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;i am call: %d, child:%d, ppid: %d\n&quot;, getpid(), pid, getppid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，在程序我们期望的是创建5个进程，但是实际运行后出现了一大堆进程，我们可以用wc命令统计一下  </p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1d4055de8e0d5caafb7d0d3932870a825d836b1a82f302fc64500650b01f8828" alt="在这里插入图片描述"></p>
<p>shell命令统计创建的进程个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl复制代码ps aux | grep mutifork | grep -v grep | wc -l</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdb5a95315e28967ece27638438ecbbb7f233728299929413d01f37b2f78cdd6" alt="在这里插入图片描述"></p>
<p>总共有32个进程，我们在程序中只循环了5次，为什么有32个进程呢，下面看一张图</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ce5c96632ec4bc09058c4f2c5254016a1bea60672ed50f508a97a3153f9b16dd" alt="在这里插入图片描述"></p>
<p>每次fork的时候，进程都会一分为二，所以5次循环相当于创建了2的5次方，也就是32个进程。要想避免这种情况，只需要根据返回值判断当前为子进程的时候就退出循环即可，也就是把上面代码中注释掉的break放开即可。</p>
<h3 id="🥈3-2-进程顺序控制"><a href="#🥈3-2-进程顺序控制" class="headerlink" title="🥈3.2 进程顺序控制"></a>🥈3.2 进程顺序控制</h3><p>使用fork()创建的进程都是一样的，在操作系统看来没有区别，先后顺序也是不确定的，我们要想控制进程的退出顺序，需要自己去实现这个逻辑。比如说我们可以依据for循环中i的值来判断哪个进程先创建的，哪个进程后创建的，按照逻辑i小的应该是先创建的，因为C语言就是顺序执行的。因为子进程创建出来就break退出for循环了，所以五个子进程对应的i是0-4，而只有最开始的父进程可以执行到i=5。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码sleep(i); /*不同进程睡眠时间不同，第一个创建的进程</span><br><span class="line">			i的值为0，睡眠最短，最先退出，后面的进</span><br><span class="line">			程对应的i逐渐增大，睡眠时间增加，退出越晚*/</span><br><span class="line">if(i &lt; 5)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;child: %d, parent: %d\n&quot;, getpid(), getppid());</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;parent: %d\n&quot;, getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7250283546367557692?searchId=202404171908050B578BFE9B0EAC21E7B5" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>在kubernetes环境下如何采集日志节点采集Si</title>
    <url>/7347000319983419411.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为稀土掘金技术社区首发签约文章，30天内禁止转载，30天后未获授权禁止转载，侵权必究！</p>
<p>当我们没有使用云原生方案部署应用时采用的日志方案往往是 ELK 技术栈。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/170bd36c33d917fb4370dce4e5092a45c2e7aeacfa50573fe2d0cb0a2bdff112" alt></p>
<p>这套技术方案比较成熟，稳定性也很高，所以几乎成为了当时的标配。</p>
<p>可是随着我们使用 kubernetes 步入云原生的时代后， kubernetes 把以往的操作系统上的许多底层都屏蔽，再由他提供了一些标准接口。</p>
<p>同时在 kubernetes 中的日志来源也比传统虚拟机多，比如可能有容器、kubernetes 自身的事件、日志等。</p>
<p>我们的日志采集方案也得与时俱进，kubernetes 的官方博客有介绍提供一下几种方案：</p>
<h1 id="节点采集"><a href="#节点采集" class="headerlink" title="节点采集"></a>节点采集</h1><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c3fe1c50d49d2f01167a4155107c9b1b27ec81af64dfed100d7d1cdfda1ed2eb" alt></p>
<p>第一种方案是在节点中采集日志，我们知道 kubernetes 是分为 master 调度节点以及 worker 工作节点；我们的应用都是运行在 worker 节点中的。</p>
<blockquote>
<p>在 kubernetes 环境中更推荐使用标准的 stdout/stderr 作为日志输出，这样 kubernetes 更方便做统一处理。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5b2db5eb99963a5b04c2027a27a9562d19202fc0a304e6d9e188875f650d91c1" alt></p>
<p>以我们的 docker 运行时为例，默认情况下我们的标准输入文件会写入到 <code>/var/log</code> 目录中。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0d7896af3481e728995a8704ed2d25a718d66a953c624547347bd955156143b5" alt></p>
<p>如上图所示：我们可以在 kubernetes 的每一个 worker 节点中部署一个 <code>DaemonSet</code> 类型的采集器（filebeat 等），再由他去采集该节点下 <code>/var/log</code> 的日志，最终由他将日志采集后发往日志处理的后端，比如 elasticsearch 等组件中。</p>
<p>这种方案的好处是资源占用较低，往往是有多少个 worker 节点就可以部署多少个采集器。</p>
<p>而且和业务的耦合度低，业务和采集器不管谁进行重启或升级互相都不会产生影响。</p>
<p>但缺点也比较明显，整个节点的日志采集瓶颈都在这个采集器这里了，如果某些 worker 节点的 Pod 数量不均衡，或者是本身日志产生也不平均时就会出现明显的负债不平衡。</p>
<p>而且也无法针对某些日志高峰场景进行调优（毕竟所有的 Pod 都是使用的一个日志采集器）。</p>
<p>所以节点级的日志采集更适用与该 worker 节点负债较低的时候使用，也更容易维护。</p>
<h1 id="Sidecar-代理模式"><a href="#Sidecar-代理模式" class="headerlink" title="Sidecar 代理模式"></a>Sidecar 代理模式</h1><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/20a005a35d418c6fca6357f638ffe03fe16ee36c8c75e5bee2df77634ab51978" alt><br>第二种相对于第一种可以理解为由集中式的日志采集分散到各个应用 Pod 中自行采集。</p>
<p>需要为每一个业务 Pod 挂载一个边车（sidecar）进行日志采集，由于边车和业务 Pod 共享的是一个存储，所以可以很方便的读取到日志。</p>
<p>由于它是和应用挂载在一起的，所以资源占用自然会比节点采集更多，同理耦合度也增加了，采集组件的升级可能还会影响的业务 Pod。</p>
<p>但同样的带来好处就是可以针对单个 Pod 更精细的控制采集方案。</p>
<p>比如对于一些日志写入频繁的应用，可以将 filebeat 的配置提高，甚至还可以将这种高负载的日志单独写入一个 elasticsearch 中，这样可以与普通负载的日志进行资源隔离。</p>
<p>这个方案更适用与集群规模较大的场景，需要做一些精细化配置。</p>
<hr>
<p>我们其实也是采用的也是这个方案，不过具体细节稍有不同。</p>
<p>我们没有直接使用标准输入和输出，原因如下：</p>
<p>日志格式没法统一，导致最终查询的时候无法做一些标准化的限制（比如我们要求每个日志都需要带业务 id、traceId 等，查询时候有这些业务指标就很容易沉淀一些标准的查询语句。）</p>
<p>最终我们还是采用了 Java 的老朋友，logback 配置了自己的日志格式，所有的应用都会根据这个模版进行日志输出。</p>
<p>同时利用日志框架的批量写入、缓冲等特性还更容易进行日志的性能调优。（只使用标准输出时对应用来说是黑盒。）</p>
<p>最终我们的技术方案是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a6e843a03caa2ea6813b09e0e63a83d1cc6ccf26f4f12c58c116e37be3d832c9" alt></p>
<h1 id="直接写入"><a href="#直接写入" class="headerlink" title="直接写入"></a>直接写入</h1><p>还有一种方案是直接写入，这个其实和 kubernetes 本身就没有太多关系了。</p>
<p>由业务自己调用 elasticsearch 或者其他的存储组件的 API 进行写入，这种通常适用于对性能要求较高的场景，略过了中间的采集步骤，直接写入存储端。</p>
<p>这个我在 <a href="https://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/" target="_blank" rel="noopener">VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</a>中介绍过，我需要在 broker 的拦截器中埋点消息信息，从而可以生成一个消息🆔的链路信息。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/17ebd2c95765a002b09f1802053874402b7d19e9f4d22e06440fb0120ca0a92d" alt></p>
<p>因为需要拦截消息的发送、消费的各个阶段，加上并发压力较高，所以对日志的写入性能要求还是蛮高的。</p>
<p>因此就需要在拦截器中直接对写入到日志存储。</p>
<blockquote>
<p>这里考虑到我这里的但一场景，以及对资源的消耗，最终选取了 <code>victoriaLog</code> 这个日志存储。</p>
</blockquote>
<p>而在发送日志的时候也得用了高性能的日志发生框架，这里选取了<a href="https://github.com/aliyun/aliyun-log-java-producer" target="_blank" rel="noopener">aliyun-log-java-producer</a>然后做了一些定制。</p>
<p>这个库支持以下一些功能：</p>
<ul>
<li>高性能：批量发送、多线程等</li>
<li>自动重试</li>
<li>异步非阻塞</li>
<li>资源控制（可以对内存、数量进行控制）</li>
</ul>
<p>因为这是为阿里云日志服务的一个组件，代码里硬编码了只能写入阿里的日志服务。</p>
<p>所以拿来稍加改造后，现在可以支持自定义发送到任意后端，只需要在初始化时自定义实现发送回调接口即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码ProducerConfig producerConfig = new ProducerConfig();</span><br><span class="line">producerConfig.setSenderArgs(new Object[]&#123;vlogUrl, client&#125;);</span><br><span class="line">producerConfig.setSender((batch, args) -&gt; &#123;</span><br><span class="line">    StringBuilder body = new StringBuilder();</span><br><span class="line">    for (String s : batch.getLogItemsString()) &#123;</span><br><span class="line">        body.append(&quot;&#123;\&quot;create\&quot;:&#123;&#125;&#125;&quot;);</span><br><span class="line">        body.append(&quot;\n&quot;);</span><br><span class="line">        body.append(s);</span><br><span class="line">        body.append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    RequestBody requestBody =</span><br><span class="line">            RequestBody.create(MediaType.parse(&quot;application/json&quot;), body.toString());</span><br><span class="line">    Request request =</span><br><span class="line">            new Request.Builder()</span><br><span class="line">                    .url(String.format(&quot;%s/insert/elasticsearch/_bulk&quot;, args[0]))</span><br><span class="line">                    .post(requestBody)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">    OkHttpClient okHttpClient = (OkHttpClient) args[1];</span><br><span class="line">    try (Response response = okHttpClient.newCall(request).execute()) &#123;</span><br><span class="line">        if (response.isSuccessful()) &#123;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.error(&quot;Request failed with error code: &quot; + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(&quot;Send vlogs failed&quot;, e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">logProducer = new LogProducer(producerConfig);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到这个库只是对阿里云日志服务的一个组件，加上代码已经很久没维护了，所以就没有将这部分代码提交到社区，感兴趣的评论区留言。</p>
</blockquote>
<h1 id="日志安全"><a href="#日志安全" class="headerlink" title="日志安全"></a>日志安全</h1><p>日志是一个非常基础但又很敏感的功能，首先是编码规范上要避免打印一些敏感信息；比如身份证、密码等；同时对日志的访问也要最好权限控制。</p>
<p>在我们内部的研效平台中，对于日志、监控等功能都是和应用权限挂钩的。</p>
<p>简单来说就是关闭了统一查询 ES 的入口，只在应用层级提供查询，类似于：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/32003c66f9651627979b962e8e40659d8d9fda1d59e4cfd3aa69f659e6f6afaf" alt></p>
<blockquote>
<p>图来自于 orbit 产品。</p>
</blockquote>
<h1 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h1><p>当然讲到日志目前自然也逃不过 OpenTelemetry，作为当前云原生可观测性的标准也提供了对应的日志组件。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e3096a5dc352ae8f637e347f8ad07e1c429c3c58626f283213ba9ee54bdc7b0b" alt><br>OpenTelemetry 也定义了结构化的日志格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;&quot;resourceLogs&quot;:[&#123;&quot;resource&quot;:&#123;&quot;attributes&quot;:[&#123;&quot;key&quot;:&quot;resource-attr&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;resource-attr-val-1&quot;&#125;&#125;]&#125;,&quot;scopeLogs&quot;:[&#123;&quot;scope&quot;:&#123;&#125;,&quot;logRecords&quot;:[&#123;&quot;timeUnixNano&quot;:&quot;1581452773000000789&quot;,&quot;severityNumber&quot;:9,&quot;severityText&quot;:&quot;Info&quot;&quot;body&quot;:&#123;&quot;stringValue&quot;:&quot;This is a log message&quot;&#125;,&quot;attributes&quot;:[&#123;&quot;key&quot;:&quot;app&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;server&quot;&#125;&#125;,&#123;&quot;key&quot;:&quot;instance_num&quot;,&quot;value&quot;:&#123;&quot;intValue&quot;:&quot;1&quot;&#125;&#125;],&quot;droppedAttributesCount&quot;:1,&quot;traceId&quot;:&quot;08040201000000000000000000000000&quot;,&quot;spanId&quot;:&quot;0102040800000000&quot;&#125;,&#123;&quot;timeUnixNano&quot;:&quot;1581452773000000789&quot;,&quot;severityNumber&quot;:9,&quot;severityText&quot;:&quot;Info&quot;,&quot;body&quot;:&#123;&quot;stringValue&quot;:&quot;something happened&quot;&#125;,&quot;attributes&quot;:[&#123;&quot;key&quot;:&quot;customer&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;acme&quot;&#125;&#125;,&#123;&quot;key&quot;:&quot;env&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;dev&quot;&#125;&#125;],&quot;droppedAttributesCount&quot;:1,&quot;traceId&quot;:&quot;&quot;,&quot;spanId&quot;:&quot;&quot;&#125;]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以配置 <code>otel.logs.exporter=otlp (default)</code> 可以将日志输出到 <code>oetl-collector</code> 中，再由他输出到后端存储中。</p>
<p>虽然这样 <code>otel-collectoer</code> 就成为瓶颈了，但我们也可以部署多个副本来降低压力。</p>
<p>同时也可以在应用中指定不同的 <code>endpoint(otel.exporter.otlp.endpoint=http://127.0.0.1:4317)</code> 来区分日志的 collector，与其他类型的 collector 做到资源隔离。</p>
<p>不过目前社区关于日志的实践还比较少，而且由于版本 1.0 版本 release 的时间也不算长，稳定性和之前的 filebeat 相比还得需要时间检验。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理想情况下，我们需要将可观测性的三个重要组件都关联起来才能更好的排查定位问题。</p>
<p>比如当收到监控系统通过指标变化发出的报警时，可以通过链路追踪定位具体是哪个系统触发的问题。</p>
<p>之后通过 traceID 定位到具体的日志，再通过日志的上下文列出更多日志信息，这样整个链条就可以串联起来，可以极大的提高效率。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/aliyun/aliyun-log-java-producer" target="_blank" rel="noopener">github.com/aliyun/aliy…</a></li>
<li><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">kubernetes.io/docs/concep…</a></li>
<li><a href="https://coding.net/help/docs/orbit/env/logs-event/intro.html" target="_blank" rel="noopener">coding.net/help/docs/o…</a></li>
<li><a href="https://opentelemetry.io/docs/concepts/signals/logs/" target="_blank" rel="noopener">opentelemetry.io/docs/concep…</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7347000319983419411" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,监控</tag>
      </tags>
  </entry>
  <entry>
    <title>不可思议！亿级数据竟然如此轻松同步至ES！</title>
    <url>/7354922285094207540.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-这是一个背景"><a href="#1-这是一个背景" class="headerlink" title="1 这是一个背景"></a>1 这是一个背景</h2><p>最近接了一个需求，要提供一个随意组合多个条件来查询订单数据的功能，看着数据库里过亿的订单量，头发不争气的又脱落了两根代表这个需求不简单</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/86b971f3f5a8659f134c1258e62d4795c78ae38e6dc1f8840500687fcc197a77" alt></p>
<p>脱落的两根头发，不是技术实现上很难，其实技术实现上清晰明了，就是通过数据异构，将数据同步到ES，利用ES的倒排索引、缓存等能力，提供多条件复杂查询的能力，而ES集群我们已经有了</p>
<p>但有些数据，在目前的ES索引中是不存在的，也就是说，我需要将过亿的订单数据从订单数据库重新刷一遍到ES中，而这一顿操作下来得需要一周的时间!</p>
<p>什么？你不信，那咱们来捋一捋</p>
<h2 id="2-捋一捋订单数据同步到ES中的复杂度"><a href="#2-捋一捋订单数据同步到ES中的复杂度" class="headerlink" title="2 捋一捋订单数据同步到ES中的复杂度"></a>2 捋一捋订单数据同步到ES中的复杂度</h2><h3 id="2-1-数据同步ES索引流程"><a href="#2-1-数据同步ES索引流程" class="headerlink" title="2.1 数据同步ES索引流程"></a>2.1 数据同步ES索引流程</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee1aa85681d3382c0239eed86a037459e2531f3358e587991d924ff04eab1960" alt></p>
<p>如上图所示，就是将数据同步到ES索引的过程。</p>
<p>首先需要从订单数据库查询所有的订单数据，然后根据订单数据上保存的用户ID，商品ID等信息从用户服务，商品服务查询相关信息，经过处理与组装后落到ES集群中。</p>
<p>之所以要查询用户信息和商品信息，是因为异构在ES索引中的订单数据，并不会与mysql中的数据一一对应，有很多根据商品类目，用户信息等查询订单信息的诉求存在，因此在这里就需要查询很多的上游服务来组装信息</p>
<h3 id="2-2-来梳理下是否有难点"><a href="#2-2-来梳理下是否有难点" class="headerlink" title="2.2 来梳理下是否有难点?"></a>2.2 来梳理下是否有难点?</h3><ol>
<li>从数据库把上亿的订单数据出来。这个操作不能影响到线上业务，因此查询的订单数据库一般是从库，OK，配置多数据源来读取数据吧，而且上亿的订单一般采用的都是分库分表来存储的，我们是分了16个库，每个库16个表，总共256张表，嘿嘿</li>
<li>上亿的订单数据不能一次性全部读取到内存吧，不然内存冒烟都存不下啊。所以得考虑分页，分页直接limit也不好，随着数据量越大，速度越慢，所以得考虑一个游标，嗯，选一个字段当游标吧，游标最好唯一且递增</li>
<li>从多个服务获取数据，这些数据所在的服务一般都属于公司的其它部门，读取数据的时候也不能影响到人家的服务吧，你这里查询的是嘎嘎猛，一看人家的服务都崩了，这个黑锅就飞来了。所以这里得考虑限流吧，得考虑隔离吧？不说全链路隔离，成本太高，起码关键服务得隔离一下</li>
<li>数据同步一段时间，产品来问，同步多久了啊，大概还有多久能完成啊，数据量大概是多少啊，一脸懵，不知道啊。</li>
<li>如果中途同步失败了，咋处理啊，是不是得重试，咋重试，重试策略是啥？失败有没有报警，能不能及时感知并处理啊？如果同步一段时间中断了咋整啊？有没有记录从哪中断的？能否从中断处继续同步啊，不然从头开始又得N天，哭了</li>
<li>同步了一部分，发现有问题需要暂停一会，咋整？</li>
<li>如果只想同步部分数据不一致的订单数据，可能就2,3个订单，咋整，是不是还得提供按照手动输入订单ID同步ES数据的能力？</li>
<li>同步过程是咋样的？开始时间？结束时间？共耗时多久？操作人是谁？这些统计数据从哪来？</li>
<li>想夜深人静的时候同步数据，这有时候对业务的影响小，定个闹钟晚上起？</li>
<li>现在不单需要同步订单的数据了，还需要同步商品ES集群的数据，这些逻辑还得重新写一遍？</li>
</ol>
<p>啊啊啊啊，想想都头疼啊</p>
<p>所以，一些事情看着简单，其实并没有那么简单</p>
<h2 id="3-神奇的服务"><a href="#3-神奇的服务" class="headerlink" title="3 神奇的服务"></a>3 神奇的服务</h2><p>为了让头发更有归属感，针对上述的难点开发了一款神奇的服务，那就是ECP。<br>它可以将整个流程自动化、可视化的处理，降低数据异构到ES的成本<br>任务界面如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8e31491a488e4e298ba8942ee48a1b1ef2951de35e73c02275047f4dcc12a72e" alt></p>
<h3 id="3-1-ECP的简单运行流程"><a href="#3-1-ECP的简单运行流程" class="headerlink" title="3.1 ECP的简单运行流程"></a>3.1 ECP的简单运行流程</h3><p>简单来说，ECP的作用就是将数据从数据源读取出来，然后推送给ES写服务。<br>因为数据处理的逻辑因不同的业务而异，ES写服务由各个对接方来实现，因此一个简单的流程如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/21d44b864cea1b9d9d2960a9765975d7075e376ab5fcc07f300476186155c2eb" alt></p>
<p>这里面涉及到一些技术细节，比如如何进行多数据源数据读取，数据源配置，sql校验，动态限流、SPI机制、重试策略与故障感知、探活与故障恢复，环境隔离等等。</p>
<p>下面一一介绍下</p>
<h3 id="3-2-多数据源数据读取"><a href="#3-2-多数据源数据读取" class="headerlink" title="3.2 多数据源数据读取"></a>3.2 多数据源数据读取</h3><p>ECP支持目前支持三个数据源数据的读取，分别为ID源，文本源、以及脚本源</p>
<h4 id="3-2-1-ID源"><a href="#3-2-1-ID源" class="headerlink" title="3.2.1 ID源"></a>3.2.1 ID源</h4><p>有个文本框用来输入ID。这种场景适用于小数据的数据同步，比如发现一些数据库和ES的数据不一致了，就简单的刷一下数据</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ae1394f5d0a8321b3178dad68ce14a51833142623d2baca9e50311723ff33360" alt></p>
<h4 id="3-2-2-文件源"><a href="#3-2-2-文件源" class="headerlink" title="3.2.2 文件源"></a>3.2.2 文件源</h4><p>文件源指的是数据源来源于文本文件，适合中等数据的同步。<br>ECP和对象存储进行了对接，用户可以上传文件至对象存储，在任务执行时，ECP会读取对象存储中的文本数据。</p>
<p>这种情况需要注意的是，用户上传的文件有可能会比较大，直接都读取到内存再处理不现实，因此这里采用的是流的方式进行读取，读取一批处理一批，再释放一批，不会造成OOM</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6e4dae85ee864d91185849746c5a44e57aebe134c64672b721542665934de642" alt></p>
<p>简化的处理方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbscript复制代码</span><br><span class="line"></span><br><span class="line">try (Response response = OK_HTTP_CLIENT.newCall(request).execute()) &#123;</span><br><span class="line">            if (!response.isSuccessful()) &#123;</span><br><span class="line">                throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">		// 以流的方式读取文件数据</span><br><span class="line">		InputStream inputStream = response.body().byteStream();</span><br><span class="line">		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-脚本源"><a href="#3-2-3-脚本源" class="headerlink" title="3.2.3 脚本源"></a>3.2.3 脚本源</h4><p>脚本源适用于大数据量的数据同步。</p>
<p>脚本本质上就是SQL和数据源的结合。</p>
<p>用户在ECP中配置数据库的连接信息，然后配置SQL。ECP会执行该SQL，将数据从配置的数据库中读取出来，推送到ES写服务中。</p>
<p>脚本源可以支持上亿数据的读取与推送，如下图为订单库（分库分表）配置的脚本信息：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fb2cf25c1e3f9f5572f7c49017c86d5dea287a53b09e0e09da2d41c87a575700" alt></p>
<h4 id="3-2-4-脚本源大数据读取的实现"><a href="#3-2-4-脚本源大数据读取的实现" class="headerlink" title="3.2.4 脚本源大数据读取的实现"></a>3.2.4 脚本源大数据读取的实现</h4><p>将几亿数据读取到内存中来处理显然不可能，因此采用局部数据的读取与处理才是正道。</p>
<p>在业务中，经常使用的是分页，但分页如果仅是使用limit offset,size，待offset的值比较大时，性能会急剧下降，形成慢SQL，甚至拖累整个数据库的性能。</p>
<p>因此在分页数量比较大时，需要指定一个有索引的字段作为游标，该游标可以提高分页的性能，如在订单表中，若在订单ID是递增的且有设置了索引，SQL就可以这么写：<code>select * from t_order where order_id &gt; xxx order by order_id desc limit 10</code>; 利用order_id值的变化就可以起到分页的效果</p>
<p>这种方式虽好，但让用户选定游标索引无疑增加了使用的门槛，因此ECP没有采用上述分页的形式来读取大数据，而是采用JDBC游标查询的方式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码				// 建立连接</span><br><span class="line">       conn = DriverManager.getConnection(url, param.getDsUsername(), param.getDsPassword());</span><br><span class="line">       // 创建查询</span><br><span class="line">       stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">       stmt.setFetchSize(param.getFetchSize());</span><br></pre></td></tr></table></figure>

<p>游标查询每次读取fetchSize大小的数据量，可以很好的避免读取大数据量导致的OOM问题</p>
<h3 id="3-3-SQL的解析与校验"><a href="#3-3-SQL的解析与校验" class="headerlink" title="3.3 SQL的解析与校验"></a>3.3 SQL的解析与校验</h3><p>用户配置SQL脚本，ECP需要对该SQL脚本进行校验与修改，传统的字符串处理（比如正则）虽然在一定情况下可以满足需求，但是容易出错。<br>因此ECP采用的是Druid的SQL解析工具包，可以将SQL解析成AST语法树，以便对SQL进行各种处理。如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eae4f4ba1b37a3311960391d75a04ab20de0364ae178503f1c62b221f258744b" alt></p>
<p>ECP提供的数据样例查询，会对SQL自动拼接上limit 1<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0b17bb0150afbade03f148f0de2cec6a3613bbacd88131cd8e950d64bfb1dd4f" alt><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a4e278631494707c32b7d87403db443d4bf740e44de5979b64942aa89980c892" alt></p>
<h3 id="3-4-动态限流的实现"><a href="#3-4-动态限流的实现" class="headerlink" title="3.4 动态限流的实现"></a>3.4 动态限流的实现</h3><p>限流分集群限流和单机限流，经过评估，在能简单就简单的原则下，我们采用的是单机限流，限流组件使用的是guava的RateLimiter</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/033425061a740892f1fc0d9f95251f80a3175cb9bc25f713a486939e20f16412" alt></p>
<p>当在页面上修改QPS的值时，会将该值同步到数据库中，有个调度任务会不断地扫描该值的变动，将变动的值同步到RateLimiter组件中</p>
<p>当然，也可以采用数据监听的策略(比如广播MQ)，让变动值同步到RateLimiter更及时，但这种方式还需引入其它组件，复杂度嗷嗷上升，不符合我们简单实现的策略</p>
<p>动态限流的实现流程如下；<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/41baf2c7abf9b96c768884b350762390d0d47650b1197b451610b52e34eb2839" alt></p>
<p>如下图是在不同的时间点修改了限流值后的QPS变化图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3883885a2f61250a1de649889a3012ee73aa3de40799c1c6fd3e4105762bb343" alt></p>
<h3 id="3-5-重试策略与故障感知"><a href="#3-5-重试策略与故障感知" class="headerlink" title="3.5 重试策略与故障感知"></a>3.5 重试策略与故障感知</h3><p>ES中和DB中的数据要尽可能的保证实时一致性，但最终一致性是必须要保证的，所以数据推送、处理失败的时候要进行重试，如何重试？</p>
<p>首先需要了解下失败的类型，制定合适的重试策略，知彼知己，百战不殆嘛</p>
<p>一、网络抖动导致的接口调用超时。<br>在调用微服务RPC接口的时候，由于网络抖动等情况，会导致接口调用超时，但很快就会恢复，通常情况下也就偶尔一次，下一次调用就会正常</p>
<p>二、数据处理逻辑异常。这种情况下，异常没办法自恢复，只能人工介入</p>
<p>三、上游服务异常。如上游服务压力过大导致接口调用失败，这时候就需要我们缓一缓再继续处理，不能一个劲的调用导致上游服务崩溃掉</p>
<p>结合上面的失败类型的特点，斐波那契数列的重试策略就非常适合<br>斐波那契数列的特点是：1，1，2，3，5，8，13，21，34，55，89…</p>
<p>当第一次失败的时候，延时1秒后就重试，如果此时是网络抖动导致的超时，重试就成功了，不影响数据处理的速度<br>若失败的次数越多，重试的间隔时间就会越长，这也会兼顾到上述二、三的失败类型</p>
<p>重试组件使用的是Guava Retry，简单的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码</span><br><span class="line">// 重试组件配置</span><br><span class="line">private final Retryer&lt;Boolean&gt; RETRYER = RetryerBuilder.&lt;Boolean&gt;newBuilder()</span><br><span class="line">            // 对中断类的异常不重试</span><br><span class="line">            .retryIfException(input -&gt; !isPauseException(input))</span><br><span class="line">            // 1,1,2,3,5,8,13,21,33...</span><br><span class="line">            .withWaitStrategy(WaitStrategies.fibonacciWait(1000, 30, TimeUnit.SECONDS))</span><br><span class="line">	          // 重试次数达到一定的次数后，不再重试</span><br><span class="line">            .withStopStrategy(StopStrategies.stopAfterAttempt(MAX_RETRY_TIMES))</span><br><span class="line">            .withRetryListener(new RetryListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public &lt;V&gt; void onRetry(Attempt&lt;V&gt; attempt) &#123;</span><br><span class="line">                    if (attempt.hasException()) &#123;</span><br><span class="line">                        log.error(&quot;act=【DataFlushRpcCallRetry】desc=【重试】重试次数=【&#123;&#125;】重试异常=【&#123;&#125;】&quot;, attempt.getAttemptNumber(), attempt.getExceptionCause());</span><br><span class="line">                        // 重试超过阈值进行报警提醒</span><br><span class="line">                        alarmIfExceedThreshold(attempt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">// 将执行逻辑抽象为Runnable，对外暴露该方法</span><br><span class="line">public void execute(Runnable runnable) &#123;</span><br><span class="line">    innerExecute(runnable,RETRYER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void innerExecute(Runnable runnable, Retryer&lt;Boolean&gt; retryer) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">				retryer.call(() -&gt; &#123;</span><br><span class="line">	       runnable.run();</span><br><span class="line">	       return true;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       log.error(&quot;act=【DataFlushRpcCallRetry】desc=【重试异常】error=【&#123;&#125;】&quot;, e);</span><br><span class="line">       throw new IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若重试到一定次数之后依然是失败的话，则会将错误信息发送到报警群。<br>根据推送的信息，可以明确知道错误的类型，重试的次数，以及任务的创建人等等信息，无需查看日志，即可定位大部分的问题。如下图：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0f3337a9b2b4c43a46459884d6805cf3725c557c353910ee6a21888180d903b1" alt></p>
<h3 id="3-6-将数据推送给哪个服务来处理？-SPI机制"><a href="#3-6-将数据推送给哪个服务来处理？-SPI机制" class="headerlink" title="3.6 将数据推送给哪个服务来处理？-SPI机制"></a>3.6 将数据推送给哪个服务来处理？-SPI机制</h3><p>ECP是个通用的服务，因此需要将共性功能收拢在一起做成成品，将非共性的功能抽象一下，交给各个对接方去实现。</p>
<p>从简单实现的角度来看，若有某个服务想要对接ECP，我们在ECP上开发一下，调用该服务的接口，将数据推送给该服务，思路虽清晰明了，但对接及维护成本极高，且没有一个统一的规范，因此不可取，其流程如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/58881c8e0c47dd6615354e65de5f5cf47dc402c68d33d158e1a79a1157707a9b" alt></p>
<p>Java上有个很好的思想可以解决这个问题，那就是SPI。因此由ECP提供一个接口，制定一个规范，具体的ES索引数据的组装逻辑由各个对接方去实现</p>
<p>这样，若有一个新的对接方接入，只要实现接口即可，ECP无需做任何改动<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d2f24dddbbab3953c1b35055dd7aa3af9fd834ca135a35ae378a41f71d728e25" alt></p>
<p>至于服务发现，ECP采用的配置的方式，也就是在新建任务的时候，选择数据推送的消费方服务，如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1410fe2305598099d11f678f41d1db6f2642137fa849ad7ff6a1303ccfc9f853" alt></p>
<p>对于实现方式，得益于公司内部自研的RPC框架，提供了动态指定调用服务的方式，伪代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码Reference&lt;IEsIndexFlushAPI&gt; reference = new Reference&lt;&gt;();</span><br><span class="line">// 设置调用的服务名</span><br><span class="line">reference.setServiceName(serviceName);</span><br><span class="line">// 设置接口名</span><br><span class="line">reference.setInterfaceClass(IEsIndexFlushAPI.class);</span><br><span class="line">// 设置上下文</span><br><span class="line">reference.setApplicationConfig(applicationConfig);</span><br><span class="line">// 获取接口实例</span><br><span class="line">IEsIndexFlushAPI iEsIndexFlushAPI = ES_INDEX_FLUSH_API_MAP.computeIfAbsent(serviceName, s -&gt; reference.refer());</span><br><span class="line">// 接口调用</span><br><span class="line">log.info(&quot;act=【EsIndexFlushApiInvoker】desc=【请求值】serviceName=【&#123;&#125;】dataListSize=【&#123;&#125;】indexNameList=【&#123;&#125;】tag=【&#123;&#125;】&quot;, serviceName,request.getDataList().size(),request.getIndexNameList(),request.getTag() );</span><br><span class="line">EMApiResult&lt;FlushResponse&gt; result = iEsIndexFlushAPI.flush(request);</span><br></pre></td></tr></table></figure>

<h3 id="3-7-环境隔离"><a href="#3-7-环境隔离" class="headerlink" title="3.7 环境隔离"></a>3.7 环境隔离</h3><p>同步数据是个比较重的操作，这个操作不应该影响到线上业务<br>因此，同步数据的服务应当与线上服务隔离开<br>ECP整合了架构组提供的标签路由功能，可以在整个请求链路中调用指定标签的服务，实现环境隔离</p>
<p>ECP标签路由配置图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6e945cf15358568bc07e38c12e0187683e73de327e4b84cec011576ef54c5a3a" alt></p>
<p>如下图，若在ECP上配置任务的标签路由为FLUSH，则在同步任务执行过程中，会自动调用链路中绑定了FLUSH标签的服务分组。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4902dedbc47e92b9b6dfc4ba4291e0589fe621957488e2137fce1f533364e32f" alt></p>
<p>若某些服务没有配置为FLUSH标签的分组，这时就会自动请求该服务的线上正常环境。<br>这样，就可以做到一定程度上的环境隔离<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77cb28ae6ea97f861efd8f0dbb05a3ee550c20e11455ad5466e6ad32308ff68d" alt></p>
<h3 id="3-8-探活与任务故障恢复机制"><a href="#3-8-探活与任务故障恢复机制" class="headerlink" title="3.8 探活与任务故障恢复机制"></a>3.8 探活与任务故障恢复机制</h3><p>在推送数据的过程中，若发生了不可描述的事情导致任务中断，咋整？</p>
<p>到了需求DeadLine，发现任务在某年某月某日进度为1%的时候停了，哭了。</p>
<p>而且工作时间紧，任务重，总不能一定盯着任务，看有没有中断吧？这不适合，也不礼貌。</p>
<p>当然，这种情况在ECP是不会发生的，因为ECP是有“自救包”的。下面聊下ECP的任务探活和中断恢复机制</p>
<p>如下图，在ECP中有探活和任务故障恢复两大组件<br>探活组件负责监控当前任务线程的执行状态，若任务线程正在执行，则对该任务的存活时间进行续期<br>任务故障恢复组件负责扫描当前未完成的任务，若任务上次存活时间大于指定的阈值时，则拉取该任务恢复执行<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c3c18b42e4490426bc8fb41a7934692d7c4a28f79185d6816f552d0d953e5d72" alt></p>
<p>续期的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码    @Scheduled(fixedDelay = ScheduleTimeConstants.KEEP_ALIVE_MILLS)</span><br><span class="line">    public void renewal()&#123;</span><br><span class="line">        futureMap.forEach((taskId,future)-&gt;&#123;</span><br><span class="line">            if (!future.isDone())&#123;</span><br><span class="line">                log.info(&quot;act=【renewal】desc=【任务续期】taskId=【&#123;&#125;】续期时间=【&#123;&#125;】&quot;,taskId, DateUtils.dateToString(new Date(),DateUtils.PATTERN));</span><br><span class="line">                contextService.renewal(taskId);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                log.info(&quot;act=【renewal】desc=【任务结束】taskId=【&#123;&#125;】&quot;,taskId);</span><br><span class="line">                futureMap.remove(taskId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>任务故障恢复的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码    @Scheduled(fixedDelay = ScheduleTimeConstants.RESTART_TASK_MILLS)</span><br><span class="line">    public void restartTask()&#123;</span><br><span class="line"></span><br><span class="line">				 // 1.查询当前未完成的任务</span><br><span class="line">        List&lt;TaskFlushExecuteContextPO&gt; contextPOS = contextService.queryRunningTask();</span><br><span class="line"></span><br><span class="line">        for (TaskFlushExecuteContextPO contextPO : contextPOS) &#123;</span><br><span class="line">            // 2.计算上次存活到当前的时间</span><br><span class="line">            Integer durationMin = calculateTimeSinceLastAlive();</span><br><span class="line"></span><br><span class="line">						// 3.若时间大于指定阈值 则对任务重新拉起</span><br><span class="line">            if (durationMin &gt;= MAX_DURATION_MIN)&#123;</span><br><span class="line">                log.info(&quot;act=【restartTask】desc=【任务重新拉起】taskId=【&#123;&#125;】&quot;,contextPO.getTaskId());</span><br><span class="line">                // 4.更新alive_time进行锁定 防止并发执行</span><br><span class="line">                int i = contextExtMapper.casUpdateAliveTime();</span><br><span class="line">                if (i &gt;0)&#123;</span><br><span class="line">                    // 5.重新拉起任务</span><br><span class="line">                    restart0(contextPO, aliveTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-平滑迁移的实现"><a href="#3-9-平滑迁移的实现" class="headerlink" title="3.9 平滑迁移的实现"></a>3.9 平滑迁移的实现</h3><p>将数据同步到ES，通常有两种方式：</p>
<ol>
<li>直接把数据同步到原索引上</li>
<li>新建一个索引，利用双写以及切换别名的方式实现流量的平滑迁移。</li>
</ol>
<p>对于新建一个索引的场景，往往是索引Mapping的改变，或者是为了不影响原索引，保证操作可回滚</p>
<p>针对这种场景，ECP分析了历来大家手动操作刷ES索引的步骤，将流程进行抽象，归纳了以下几个步骤，如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f29f695b3d7b2bad18a00541f00e46ab3acf135064823a7b8ec150abd02789f2" alt></p>
<p>ECP提供了平滑迁移组件，其内部整合了Apollo配置中心实现推送能力，其简要的实现流程如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b0c6943f2bbba3421c19651996a32fcc703c9e08adcc94adc8f31b402761151a" alt></p>
<h3 id="3-10-优雅的日志记录"><a href="#3-10-优雅的日志记录" class="headerlink" title="3.10 优雅的日志记录"></a>3.10 优雅的日志记录</h3><p>如下图所示展示了该任务操作的日志，原则上日志记录为非核心业务，需要与核心业务代码进行剥离，因此使用注解式流水记录是个很好的选择</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/33d58df5811ea744ea32365bebfd23557c8a9b1d743d95252dbe7a7468dfc862" alt></p>
<p>但注解式流水记录有个问题，就是在很多的场景下，流水里面的值需要动态获取，利用注解可以实现吗?<br>答案是可以的，在上图所示中，任务ID、数据来源都是动态数据，那如何实现的呢？看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码@Flow(subjectIdEp = &quot;#taskPO.id&quot;,subjectType = SubjectTypeEnum.TASK,operateFlowType = OperateFlowTypeEnum.CREATE_TASK,content = &quot;&apos;创建任务，任务ID：&apos; + #taskPO.id &quot;)</span><br><span class="line">    public void saveTaskWithUser(TaskPO taskPO) &#123;</span><br><span class="line">        String name = LoginUserContext.get().getName();</span><br><span class="line">        taskPO.setCreator(name);</span><br><span class="line">        taskPO.setModifier(name);</span><br><span class="line">        taskMapper.insertSelective(taskPO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>subjectIdEp为流水主题ID，#taskPo.id为一个表达式，可用动态获取参数taskPo中的id值，这里利用了springEl表达式的能力</p>
<p>content = “‘创建任务，任务ID：’ + #taskPO.id “ 为流水信息，同样利用了springEL表达式，动态获取请求参数taskPo中的id信息</p>
<p>但有些信息需要一系列的计算才可以获取到，而不是单纯的从对象中取值，这也是可以实现的。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码@Flow(subjectIdEp = &quot;#contextPO.taskId&quot;,</span><br><span class="line">            subjectType = SubjectTypeEnum.TASK,</span><br><span class="line">            operateFlowType = OperateFlowTypeEnum.DATA_FLUSH,</span><br><span class="line">            content = &quot;&apos;【数据同步】异常中断任务恢复执行，中断时间：&apos; + T(com.zhuanzhuan.esmanage.utils.DateUtils).dateToStringSimple(#aliveTime)&quot;)</span><br><span class="line">    @Transactional(rollbackFor = Exception.class,isolation = Isolation.REPEATABLE_READ)</span><br><span class="line">    public void restart0(TaskFlushExecuteContextPO contextPO, Date aliveTime) &#123;</span><br><span class="line">        log.info(&quot;act=【restartTask】desc=【任务重新拉起】taskId=【&#123;&#125;】原aliveTime=【&#123;&#125;】&quot;, contextPO.getTaskId(), aliveTime);</span><br><span class="line">        dsProcessorExecutor.executeAndKeepAliveMonitor(contextPO.getTaskId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>T(com.zhuanzhuan.esmanage.utils.DateUtils).dateToStringSimple(#aliveTime)</code> 代表执行的是<code>DateUtils.dateToStringSimple</code> 方法，也就是说注解的表达式是可以调用方法的，包括从spring容器中获取对象，调用对象的方法均可。</p>
<p>这种注解式流水的实现原理，就是利用SPEL表达式和Spring Aop的特性，写一个切面，拦截自定义的flow注解即可，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码</span><br><span class="line"></span><br><span class="line">// 定义切面，拦截FLOW注解</span><br><span class="line">@Around(&quot;@annotation(com.zhuanzhuan.esmanage.entity.annotation.Flow)&quot;)</span><br><span class="line">public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">    // 调用目标方法</span><br><span class="line">    Object result = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = point.proceed();</span><br><span class="line">        recordFlow(point,result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        recordException(point,e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 流水记录的实现</span><br><span class="line">private void recordFlow(ProceedingJoinPoint point, Object result) &#123;</span><br><span class="line">    // try catch 防止影响主逻辑</span><br><span class="line">    //TODO 看是否需要写在一个事务中，主要评估流水的重要性</span><br><span class="line">    try &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Flow flowAnnotation = getFlowAnnotation(signature);</span><br><span class="line"></span><br><span class="line">        // 组装参数上下文</span><br><span class="line">        EvaluationContext evaluationContext = buildContext(point, signature);</span><br><span class="line"></span><br><span class="line">        evaluationContext.setVariable(&quot;result&quot;,result);</span><br><span class="line"></span><br><span class="line">        // ID表达式</span><br><span class="line">        String subjectIdEp = flowAnnotation.subjectIdEp();</span><br><span class="line"></span><br><span class="line">        // content表达式</span><br><span class="line">        String content = getContent(flowAnnotation, evaluationContext);</span><br><span class="line"></span><br><span class="line">				// SPEL解析表达式</span><br><span class="line">        Expression expression = PARSER.parseExpression(subjectIdEp);</span><br><span class="line">        Integer subjectId = (Integer)expression.getValue(evaluationContext);</span><br><span class="line">        record(flowAnnotation, subjectId, content);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(&quot;记录操作流水失败&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>总得来说，ECP的实现中有很多的技术细节需要考虑，技术难度一般。<br>实际上，在我们大部分的项目中，考验的就是对细节的把控~</p>
<p>ps：感谢ChatGPT对本文名称的大力支持</p>
<hr>
<blockquote>
<p>关于作者</p>
</blockquote>
<p>闫展，转转交易中台研发工程师</p>
<p><code>&gt; 转转研发中心及业界小伙伴们的技术学习交流平台，定期分享一线的实战经验及业界前沿的技术话题。</code></p>
<p><code>&gt; 关注公众号「转转技术」（综合性）、「大转转FE」（专注于FE）、「转转QA」（专注于QA），更多干货实践，欢迎交流分享~</code></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7354922285094207540" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Elasticsearch,后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从一个JDK21+OpenTelemetry不兼容的问题</title>
    <url>/7356138322367266854.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为稀土掘金技术社区首发签约文章，30天内禁止转载，30天后未获授权禁止转载，侵权必究！</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间公司领导让我排查一个关于在 jdk21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(<code>java.net.spi.InetAddressResolverProvider</code>) 不生效的问题。</p>
<p>但这个不生效的前置条件有点多：</p>
<ul>
<li>JDK 的版本得在 18+</li>
<li>SpringBoot3.x</li>
<li>还在额外再配合使用 <code>-javaagent:opentelemetry-javaagent.jar</code> 使用，也就是 OpenTelemetry 提供的 agent。</li>
</ul>
<p>才会导致自定义的 <code>InetAddressResolverProvider</code> 无法正常工作。</p>
<hr>
<p>在复现这个问题之前先简单介绍下 <code>java.net.spi.InetAddressResolverProvider</code> 这个 SPI；它是在 JDK18 之后才提供的，在这之前我们使用 <code>InetAddress</code> 的内置解析器来解析主机名和 IP 地址，但这个解析器之前是不可以自定义的。</p>
<p>在某些场景下会不太方便，比如我们需要请求 <code>order.service</code> 这个域名时希望可以请求到某一个具体 IP 地址上，我们可以自己配置 host ，或者使用服务发现机制来实现。</p>
<p>但现在通过 <code>InetAddressResolverProvider</code> 就可以定义在请求这个域名的时候返回一个我们预期的 IP 地址。</p>
<p>同时由于它是一个 SPI，所以我们只需要编写一个第三方包，任何项目依赖它之后在发起网络请求时都会按照我们预期的 IP 进行请求。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>要使用它也很简单，主要是两个类：</p>
<ul>
<li><code>InetAddressResolverProvider</code>：这是一个抽象类，我们可以继承它之后重写它的 get 函数返回一个 <code>InetAddressResolver</code> 对象</li>
<li><code>InetAddressResolver</code>：一个接口，主要提供了两个函数；一个用于传入域名返回 IP 地址，另一个反之：传入 IP 地址返回域名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码</span><br><span class="line">public class MyAddressResolverProvider extends InetAddressResolverProvider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public InetAddressResolver get(Configuration configuration) &#123;</span><br><span class="line">        return new MyAddressResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;MyAddressResolverProvider Internet Address Resolver Provider&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyAddressResolver implements InetAddressResolver &#123;</span><br><span class="line"></span><br><span class="line">    public MyAddressResolver() &#123;</span><br><span class="line">        System.out.println(&quot;=====MyAddressResolver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Stream&lt;InetAddress&gt; lookupByName(String host, LookupPolicy lookupPolicy)</span><br><span class="line">            throws UnknownHostException &#123;</span><br><span class="line">        if (host.equals(&quot;fedora&quot;)) &#123;</span><br><span class="line">            return Stream.of(InetAddress.getByAddress(new byte[] &#123;127, 127, 10, 1&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        return Stream.of(InetAddress.getByAddress(new byte[] &#123;127, 0, 0, 1&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String lookupByAddress(byte[] addr) &#123;</span><br><span class="line">        System.out.println(&quot;++++++&quot; + addr[0] + &quot; &quot; + addr[1] + &quot; &quot; + addr[2] + &quot; &quot; + addr[3]);</span><br><span class="line">        return  &quot;fedora&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">addresses = InetAddress.getAllByName(&quot;fedora&quot;);</span><br><span class="line">// output: 127 127 10 1</span><br></pre></td></tr></table></figure>

<p>这里我简单实现了一个对域名 fedora 的解析，会直接返回 <code>127.127.10.1</code>。</p>
<p>如果使用 IP 地址进行查询时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码InetAddress byAddress = InetAddress.getByAddress(new byte[]&#123;127, 127, 10, 1&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;+++++&quot; + byAddress.getHostName());</span><br><span class="line">// output: fedora</span><br></pre></td></tr></table></figure>

<p>当然要要使得这个 SPI 生效的前提条件是我们需要新建一个文件：<br><code>META-INF/services/java.net.spi.InetAddressResolverProvider</code><br>里面的内容是我们自定义类的全限定名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码com.example.demo.MyAddressResolverProvider</span><br></pre></td></tr></table></figure>

<p>这样一个完整的 SPI 就实现完成了。</p>
<hr>
<p>正常情况下我们将应用打包为一个 jar 之后运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>是可以看到输出结果是符合预期的。</p>
<p>一旦我们使用配合上 spring boot 打包之后，也就是加上以下的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;parent&gt;  </span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  </span><br><span class="line">  &lt;version&gt;3.2.3&lt;/version&gt;  </span><br><span class="line">  &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;  </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;  </span><br><span class="line">  &lt;plugins&gt;  </span><br><span class="line">   &lt;plugin&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  </span><br><span class="line">   &lt;/plugin&gt;  </span><br><span class="line">  &lt;/plugins&gt;  </span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>再次执行其实也没啥问题，也能按照预期输出结果。</p>
<p>但我们加上 OpenTelemetry 的 agent 时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java  -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>就会发现在执行解析的时候抛出了 <code>java.net.UnknownHostException</code>异常。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/40663931448c0d22892951556772c37f48f811189d1e95210ec96369bbf19b3c" alt><br>从结果来看就是没有进入我们自定义的解析器。</p>
<h1 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h1><p>在讲排查过程之前还是要先预习下关于 Java SPI 的原理以及应用场景。</p>
<p>以前写过一个 http 框架 <a href="https://github.com/TogetherOS/cicada" target="_blank" rel="noopener">cicada</a>，其中有一个可拔插 IOC 容器的功能：</p>
<blockquote>
<p>就是可以自定义实现自己的 IOC 容器，将自己实现的 IOC 容器打包为一个第三方包加入到依赖中，cicada 框架就会自动使用自定义的 IOC 实现。</p>
</blockquote>
<p>要实现这个功能本质上就是要定义一个接口，然后根据依赖的不同实现创建接口的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public interface CicadaBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Register into bean Factory</span><br><span class="line">     * @param object</span><br><span class="line">     */</span><br><span class="line">    void register(Object object);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get bean from bean Factory</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    Object getBean(String name) throws Exception;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get bean by class type</span><br><span class="line">     * @param clazz</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return bean</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; clazz) throws Exception;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * release all beans</span><br><span class="line">     */</span><br><span class="line">    void releaseBean() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取具体的示例代码时就只需要使用 JDK 内置的 <code>ServiceLoader</code> 进行加载即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public static CicadaBeanFactory getCicadaBeanFactory() &#123;  </span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);  </span><br><span class="line">    if (cicadaBeanFactories.iterator().hasNext())&#123;  </span><br><span class="line">        return cicadaBeanFactories.iterator().next() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return new CicadaDefaultBean();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也非常的简洁，和刚才提到的 <code>InetAddressResolverProvider</code> 一样我们需要新增一个 <code>META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory</code> 文件来配置我们的类名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码private boolean hasNextService() &#123;</span><br><span class="line">    if (nextName != null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configs == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	// PREFIX = META-INF/services/</span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            if (loader == null)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            else</span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; catch (IOException x) &#123;</span><br><span class="line">            fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((pending == null) || !pending.hasNext()) &#123;</span><br><span class="line">        if (!configs.hasMoreElements()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ServiceLoader 类中会会去查找 <code>META-INF/services</code> 的文件，然后解析其中的内容从而反射生成对应的接口对象。</p>
<p>这里还有一个关键是通常我们的代码都会打包为一个 JAR 包，类加载器需要加载这个 JAR 包，同时需要在这个 JAR 包里找到我们之前定义的那个 spi 文件，如果这里查不到文件那就认为没有定义 SPI。</p>
<p>这个是本次问题的重点，会在后文分析原因的时候用到。</p>
<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>因为问题就出现在是否使用 opentelemetry-javaagent.jar 上，所以我需要知道在使用了 agent 之后有什么区别。</p>
<p>从刚才的对 SPI 的原理分析，加上 agent 出现异常，说明理论上就是没有读取到我们配置的文件: <code>java.net.spi.InetAddressResolverProvider</code>。</p>
<p>于是我便开始 debug，在 ServiceLoader 加载 jar 包的时候是可以看到具体使用的是什么 <code>classLoader</code> 。</p>
<p>这是不配置 agent 的时候使用的 classLoader：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37e7eb96c48654de344f8b9df2eab1f9d265dc8f34f2649f0a9ec773aadd049f" alt><br>使用这个 loader 是可以通过文件路径在 jar 包中查找到我们配置的文件。</p>
<p>而配置上 agent 之后使用的 classLoader:<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c192d0901edf4795609628fc8e8c34a41ca93b0800f3857488f93609d64c1f9d" alt><br>却是一个 JarLoader，这样是无法加载到在 springboot 格式下的配置文件的，至于为什么加载不到，那就要提一下 maven 打包后的文件目录和 spring boot 打包后的文件目录的区别了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ced2dbf766da7bebb6afc5e2f8f3d87919bc7defcd7e6282da6b023546c732df" alt><br>这里我截图了同样的一份代码不同的打包方式：<br>上面的是传统 maven，下图是 spring boot；其实主要的区别就是在 pom 中使用了一个构建插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;  </span><br><span class="line">  &lt;plugins&gt;  </span><br><span class="line">   &lt;plugin&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  </span><br><span class="line">   &lt;/plugin&gt;  </span><br><span class="line">  &lt;/plugins&gt;  </span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者使用 <code>spring-boot</code> 命令再次打包的效果也是一样的。</p>
</blockquote>
<p>会发现 spring boot 打包后会多出一层 <code>BOOT-INF</code> 的文件夹，然后会在 <code>MANIFIST.MF</code> 文件中定义 <code>Main-Class</code> 和 <code>Start-Class</code>.</p>
<hr>
<p>通过上面的 debug 其实会发现 JarLoader 只能在加载 maven 打包后的文件，也就是说无法识别 BOOT-INF 这个目录。</p>
<p>正常情况下 spring boot 中会有一个额外的 <code>java.nio.file.spi.FileSystemProvider</code> 实现:<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/00d3e86262088af3b4aac38ce56ddb04a911e57be510de6c53ea0ed0ffc60f85" alt><br>通过这个类的实现可以直接从 JAR 包中加载资源，比如我们自定义的 SPI 资源等。</p>
<p>初步判断使用 <code>opentelemetry-javaagent.jar</code>的 agent 之后，它的类加载器优先于了 spring boot ，从而导致后续的加载失败。</p>
<h2 id="远程-debug"><a href="#远程-debug" class="headerlink" title="远程 debug"></a>远程 debug</h2><p>这里穿插几个 debug 小技巧，其中一个是远程 debug，因为这里我是需要调试 javaagent，正常情况下是无法直接 debug 的。</p>
<p>所以我们可以使用以下命令启动应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java -agentlib:jdwp=&quot;transport=dt_socket,server=y,suspend=y,address=5000&quot; -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/71100a0db50f579639883c90c7076c7a86d9e5ec9b99b2481f8d332353728f58" alt></p>
<p>然后在 idea 中配置一个 remote 启动。</p>
<blockquote>
<p>注意这里的端口得和命令行中的保持一致。</p>
</blockquote>
<p>当应用启动之后便可以在 idea 中启动这个 remote 了，这样便可以正常 debug 了。</p>
<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>第二个是条件断点也非常有用，有时候我们需要调试一个公共函数，调用的地方非常多。</p>
<p>而我们只需要关心某一类行为的调用，此时就可以对这个函数中的变量进行判断，当他们满足某些条件时再进入断点，这样可以极大的提高我们的调试效率：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6a98ef517979d3fbb5531ff7058902e9da58060b87f0cc0cd5e2ef4625076569" alt></p>
<p>配置也很简单，只需要在断点上右键就可以编辑条件了。</p>
<h1 id="社区咨询"><a href="#社区咨询" class="headerlink" title="社区咨询"></a>社区咨询</h1><p>虽然我根据现象初步可以猜测下原因，但依然不确定如何调整才能解决这个问题，于是便去社区提了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921" target="_blank" rel="noopener">issue</a>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a9c5c62da4e6fff0b04dc44cd70129bc775f3694e48cd672d1b8b5f0912faf03" alt><br>最后在社区大佬的帮助下发现我们需要禁用掉 OpenTelemetry agent 中的一个 resource 就可以了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7b3c09a33dc8f93d256702c1a170b514ebc1d4696cf2eee492fca340436b0b5c" alt><br>这个 resource 是由 agent 触发的，它优先于 spring boot 之前进行 SPI 的加载。<br>目的是为了给 metric 和 trace 新增两个属性：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fbb18e1a3fbe3886101b4cdb01df9c54b8701b34a1ae7d7432e4ff8d2f501a95" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e38390c177f68b8d5512ee4e68a3cb05378edab113721ad12613947e5689c441" alt><br>加载的核心代码在这里，只要禁用掉之后就不会再加载了。</p>
<p>禁用前：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e539943a4351c677f694e36879b0525bb5ad571e67e3cbb2d230b22ed8110047" alt></p>
<p>禁用后：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ab7e1911dd115a331020ebb3b61ac663b5063f7c16a1b054382947a9dc086dfc" alt></p>
<p>当我们禁用掉之后就不会存在这两个属性了，不过我们目前并没有使用这两个属性，所以为了使得 SPI 生效就只有先禁用掉了，后续再看看社区还有没有其他的方案。</p>
<p>想要复现 debug 的可以在这里尝试：<br><a href="https://github.com/crossoverJie/demo" target="_blank" rel="noopener">github.com/crossoverJi…</a></p>
<p>参考连接：</p>
<ul>
<li><a href="https://github.com/TogetherOS/cicada" target="_blank" rel="noopener">github.com/TogetherOS/…</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal" target="_blank" rel="noopener">docs.spring.io/spring-boot…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7356138322367266854" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决ECharts图表窗口自适应与数据不渲染</title>
    <url>/7354960709010800677.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中使用 <strong>ECharts</strong> 遇到了一些问题，包括图表不会随着窗口大小变化而变化，以及父组件向子组件传值时，ECharts 中的值不会被同步渲染等，因此写本博文进行记录；</p>
<p>博文中的所有代码全部收集在<a href="https://github.com/sid10t/vue-learn_and_upgrade" target="_blank" rel="noopener">博主的 GitHub 仓库</a>中，相关技术栈专栏如下：</p>
<ul>
<li><a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a>;</li>
<li><a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>;</li>
</ul>
<h1 id="快速上手-ECharts"><a href="#快速上手-ECharts" class="headerlink" title="快速上手 ECharts"></a>快速上手 ECharts</h1><p>在分析解决问题前，我们先复现一下情景。根据 <a href="https://echarts.apache.org/handbook/zh/get-started/" target="_blank" rel="noopener">ECharts 的官方文档</a>，我们快速的在 Vue 中构建 ECharts 图表。</p>
<p>首先，根据<a href="https://echarts.apache.org/handbook/zh/get-started/" target="_blank" rel="noopener">官方文档</a>的提示，在下载好的 ECharts 压缩包中提取 <code>dist/echarts.js</code> 放置在自己项目的目录下，并在项目中进行引用，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts 入门示例&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;../../vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;../../echarts.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>接着，为 ECharts 准备一个 DOM 容器，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;div id=&quot;main&quot; style=&quot;width: 100%; height:400px;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>最后，通过 <a href="https://echarts.apache.org//api.html#echarts.init" target="_blank" rel="noopener"><code>echarts.init</code></a> 方法初始化一个 ECharts 实例并通过 <a href="https://echarts.apache.org//api.html#echartsInstance.setOption" target="_blank" rel="noopener"><code>setOption</code></a> 方法生成一个简单的柱状图，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            option: &#123;</span><br><span class="line">                title: &#123;</span><br><span class="line">                    text: &apos;ECharts 入门示例&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                tooltip: &#123;&#125;,</span><br><span class="line">                legend: &#123;</span><br><span class="line">                    data: [&apos;销量&apos;]</span><br><span class="line">                &#125;,</span><br><span class="line">                xAxis: &#123;</span><br><span class="line">                    data: [&apos;衬衫&apos;, &apos;羊毛衫&apos;, &apos;雪纺衫&apos;, &apos;裤子&apos;, &apos;高跟鞋&apos;, &apos;袜子&apos;]</span><br><span class="line">                &#125;,</span><br><span class="line">                yAxis: &#123;&#125;,</span><br><span class="line">                series: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: &apos;销量&apos;,</span><br><span class="line">                        type: &apos;bar&apos;,</span><br><span class="line">                        data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            this.initChart()</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            initChart() &#123;</span><br><span class="line">                let myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line">                myChart.setOption(this.option);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c1aa8ce0005d8236e800a7c1d1a127de48730c65915b6d4d164729b87be1ceb" alt="n1.png"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html" target="_blank" rel="noopener">【ECharts 入门示例】代码点击此处跳转</a>。</p>
<h1 id="图表自适应"><a href="#图表自适应" class="headerlink" title="图表自适应"></a>图表自适应</h1><p>在上述构建的场景中，图表并不会随着窗口大小的变化而变化，如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c89b66623f04e2e2cf19cde2188f97d489d78a8183b81d1c4a2c2c6094524e71" alt="n2.png"></p>
<p>为了实现图表的窗口自适应功能，我们需要监听窗口的大小变化，并且同时调整图表的大小，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码mounted() &#123;</span><br><span class="line">    this.initChart()</span><br><span class="line">    if (this.autoResize) &#123;</span><br><span class="line">        window.addEventListener(&apos;resize&apos;, this.resizeChart)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    resizeChart() &#123;</span><br><span class="line">        console.log(&apos;chart resize!&apos;)</span><br><span class="line">        this.chart.resize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>autoResize</code> 表示是否启动自适应功能，<code>window.addEventListener(&#39;resize&#39;, this.resizeChart)</code> 监听窗口的大小变化，如果窗口大小发生改变，则调用 <code>resizeChart()</code> 方法，<code>resizeChart()</code> 方法中使用了 ECharts 自带的调整图表大小的方法 <code>resize()</code>；</p>
<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/817de377d65437d28675219ec4ff46dcc51932a6f6af922a48725c1695c94771" alt="n3.png"></p>
<p>不过眼尖的读者已经发现了，只是缩小了一点窗口的大小，该方法就被调用了85次，这对我们来说是没有必要的，因为我们不需要实时的去调整窗口大小，只需要在一定时间内完成调整即可，因此引入 <a href="https://www.jsdelivr.com/package/npm/lodash" target="_blank" rel="noopener"><code>loadsh</code></a> 的防抖功能，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    resizeChart: _.debounce(function () &#123;</span><br><span class="line">        console.log(&apos;chart resize!&apos;)</span><br><span class="line">        this.chart.resize()</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6d5d22ad358f6d394fd6f7927e376e57a082f28a1bb22f13dcf139f0b1f530a8" alt="n4.png"></p>
<p>除了使用 <code>loadsh</code> 的防抖功能来节约资源，提高性能之外，还可以在 Vue 实例被销毁之前，取消监控并销毁 ECharts 实例，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码beforeDestroy() &#123;</span><br><span class="line">    if (!this.chart) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.autoResize) &#123;</span><br><span class="line">        window.removeEventListener(&apos;resize&apos;, this.resizeChart)</span><br><span class="line">    &#125;</span><br><span class="line">    this.chart.dispose()</span><br><span class="line">    this.chart = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94.html" target="_blank" rel="noopener">【ECharts 图表自适应】代码点击此处跳转</a>。</p>
<h1 id="数据不渲染"><a href="#数据不渲染" class="headerlink" title="数据不渲染"></a>数据不渲染</h1><p>在前面的内容中，我们成功地开发了一个适用于特定场景的 Echarts 图表组件。为了让这个组件更具普适性和扩展性，我们计划对其进行一些改进和优化。</p>
<p>首先，我们将 <code>div</code> 元素的属性改进成动态绑定的方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;div :class=&quot;className&quot; :style=&quot;&#123; height: height, width: width &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>然后，设置组件的 <code>props</code> 配置，这些 <code>props</code> 允许在父组件中给子组件传递数据，同时也为这些属性提供了默认值以防止属性未被传递时出现错误，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码props: &#123;</span><br><span class="line">  className: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;DataChild&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  width: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;100%&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  height: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;500px&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  autoResize: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  series: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default: null,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在上述代码中，父组件传入不同的 <code>series</code> 数值，可以动态的改变 ECharts 图表。</p>
<p>接着，我们开始构建父组件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;template&gt;</span><br><span class="line">  &lt;data-child :series=&quot;this.series&quot;&gt;&lt;/data-child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import DataChild from &quot;./DataChild.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;DataParent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    DataChild,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      series: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;..&quot;,</span><br><span class="line">          type: &quot;..&quot;,</span><br><span class="line">          data: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.fetchData();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData() &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，通过 <code>fetchData()</code> 方法来获取需要渲染数据，这里的话使用 POSTMAN 来模拟后端服务器发送数据。</p>
<p>创建一个模拟服务器，设置 API 接口与响应数据：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/141feab875a64d25f2accb87f9de2886adfe4e08532a36464c553256e5ccd349" alt="p1.png"></p>
<p>对模拟服务器进行相关配置：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7717db9f5cb5af1cc83424ca71455ad453f566d0ef2adaa76c6a32d803c69fae" alt="p2.png"></p>
<p>通过访问 API 接口来获取数据：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37d520443657f4c81dc6a9368002fe2f4086db04dccd7378f3bdecc837304244" alt="p3.png"></p>
<p>同时也能查看到请求日志：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8c0934c21c19a39f4ab3928623f2baad5ee8d79b8e71d42a455591cfe9972c80" alt="p4.png"></p>
<p>在 Vue 中，我们通过 axios 来请求接口，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码fetchData() &#123;</span><br><span class="line">  const url = &quot;&quot;;</span><br><span class="line">  axios</span><br><span class="line">    .get(url + &quot;/test/data&quot;)</span><br><span class="line">    .then((resp) =&gt; &#123;</span><br><span class="line">      this.series[0].data = resp.data.data;</span><br><span class="line">      console.log(this.series);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然而出现了点问题，数据是请求到了，但是 ECharts 图表并没有渲染上：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdfad029876feb145a313c394f7fda86a68558acaa4197e878d84400757fca16" alt="s1.png"></p>
<p>我们在子组件中也打印一下相关数据，确认父组件的数据是否传递到子组件中，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码console.log(&apos;Child Data Before:&apos;, this.series)</span><br><span class="line">this.initChart();</span><br><span class="line">console.log(&apos;Child Data After:&apos;, this.series)</span><br><span class="line"></span><br><span class="line">initChart() &#123;</span><br><span class="line">  ...</span><br><span class="line">  console.log(&apos;Child Data:&apos;, this.series)</span><br><span class="line">  this.chart.setOption(this.option);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>子组件也确实获取到了数据，那为什么图表不渲染数据呢？</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a2d73d82b9d1e84106d6cec98d3e4f78c0c84da6932c0b3977c2fa149fe4bd6f" alt="s2.png"></p>
<p>这是因为，当父组件需要通过异步 AJAX 请求获取数据来设置子组件的 <code>props</code> 属性时，可能会遇到子组件渲染速度快于 AJAX 请求返回的情况。这种情况下，父组件在 <code>created</code> 或 <code>mounted</code> 生命周期钩子函数执行时，子组件可能已经开始渲染，但是尚未接收到通过 AJAX 请求获得的数据，因此只有默认的 <code>props</code> 值会被子组件使用。</p>
<p>可以通过在父子组件中打点来得知程序的运行情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// parent</span><br><span class="line">created() &#123;</span><br><span class="line">  console.log(&quot;Parent Created Before&quot;);</span><br><span class="line">  this.fetchData();</span><br><span class="line">  console.log(&quot;Parent Created After&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">fetchData() &#123;</span><br><span class="line">  axios</span><br><span class="line">    ...</span><br><span class="line">    .then((resp) =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      console.log(&quot;Parent Fetch Data&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// child</span><br><span class="line">created() &#123;</span><br><span class="line">  console.log(&quot;Child Created&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  console.log(&quot;Child Mounted Before&quot;);</span><br><span class="line">  this.initChart();</span><br><span class="line">  console.log(&quot;Child Mounted After&quot;);</span><br><span class="line">  ...</span><br><span class="line">&#125;,</span><br><span class="line">initChart() &#123;</span><br><span class="line">  ...</span><br><span class="line">  console.log(&apos;Child Init Data&apos;)</span><br><span class="line">  ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b5eea0f3332fb46eb08c85aeed988f2ced228921992014a129adb8f205320493" alt="s3.png"></p>
<p>通过上述的运行结果可知，正如我们所预料的那样，由于父组件的 <code>fetchData()</code> 方法使用了异步请求，因此程序会一直执行下去，并不会因为没有获取到数据而阻塞，当子组件完成图表渲染 <code>initChart()</code> 后，父组件才请求到数据，<strong>因此才造成了子组件图表中的数据不渲染问题</strong>，子组件图表渲染时使用的数据是 <code>props</code> 中的默认值，即空数组。</p>
<p>那如何解决这个问题呢？其实很简单，我们只要监听对应的属性即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码watch: &#123;</span><br><span class="line">  option: &#123;</span><br><span class="line">    handler(newVal, oldVal) &#123;</span><br><span class="line">      if (this.chart) &#123;</span><br><span class="line">        if (newVal) &#123;</span><br><span class="line">          this.chart.setOption(newVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.chart.setOption(oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.initChart();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>上述代码之所以监听的是 <code>option</code> 而不是 <code>series</code>，是因为在初始化图表时已经进行了赋值 <code>this.option.series = this.series;</code>，<code>series</code> 本身是 <code>option</code> 的属性，通过 <code>deep: true</code> 也可以监听到 <code>series</code> 发生变化，同时监听 <code>option</code> 还能监听到其他属性。</p>
<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d9f850ffa6e58fad52aa3e001b1e6179bd9e8a03b6b4dfc0fff93ef092c0b1fc" alt="s4.png"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/data-rendered/src/components" target="_blank" rel="noopener">【ECharts 数据不渲染】代码点击此处跳转</a>。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>解决 ECharts 图表窗口自适应与数据不渲染问题</em></strong> 的所有内容了，希望本篇博文对大家有所帮助！欢迎大家持续关注我的博客，一起分享学习和成长的乐趣！✨</p>
<p>代码：</p>
<ul>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html" target="_blank" rel="noopener">ECharts 入门示例</a>；</li>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94.html" target="_blank" rel="noopener">ECharts 图表自适应</a>；</li>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/data-rendered/src/components" target="_blank" rel="noopener">ECharts 数据不渲染</a>；</li>
</ul>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7221525689856688184">解决 swagger2 默认地址失效</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注，创作不易，请多多支持；</p>
<p>👍 公众号：<strong>sidiot的技术驿站</strong>；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a>；<a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>；<a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7354960709010800677" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>前端,Vue.js,架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisstream用做消息队列完美吗?1基础知</title>
    <url>/7357301805569687563.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis Stream 是 Redis 5.0 版本中引入的一种新的数据结构，它用于实现简单但功能强大的消息传递模式。</p>
<p>这篇文章，我们聊聊 Redis Stream 基本用法 ，以及如何在 SpringBoot 项目中应用 Redis Stream 。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2455fe8b4155656ae7cc88bc6b1289ee10d09cf39b53065640e2ee8e0c7e62d5" alt></p>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p>Redis Stream 的结构如下图所示，它是一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4776bf4b53f713c0c722d4c852bf6c05864235aecba83fd841cb8a24ca2b5225" alt></p>
<p>每个 Redis Stream 都有唯一的名称 ，对应唯一的 Redis Key 。</p>
<p>同一个 Stream 可以挂载多个<strong>消费组 ConsumerGroup</strong> , 消费组不能自动创建，需要<strong>使用 XGROUP CREATE 命令创建</strong>。</p>
<p>每个消费组会有个<strong>游标 last_delivered_id</strong>，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动 ，标识当前消费组消费到哪条消息了。</p>
<p>消费组 ConsumerGroup 同样可以挂载多个消费者 Consumer , 每个 Consumer 并行的读取消息，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</p>
<p>消费者内部有一个属性 <strong>pending_ids</strong> ， 记录了当前消费者读取但没有回复 ACK 的消息 ID 列表 。</p>
<h1 id="2-核心命令"><a href="#2-核心命令" class="headerlink" title="2 核心命令"></a>2 核心命令</h1><h2 id="01-XADD-向-Stream-末尾添加消息"><a href="#01-XADD-向-Stream-末尾添加消息" class="headerlink" title="01 XADD 向 Stream 末尾添加消息"></a>01 XADD 向 Stream 末尾添加消息</h2><p>使用 XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列。基础语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码XADD key ID field value [field value ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key</strong> ：队列名称，如果不存在就创建</li>
<li><strong>ID</strong> ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。</li>
<li><strong>field value</strong> ： 记录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XADD mystream * name1 value1 name2 value2</span><br><span class="line">&quot;1712473185388-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XLEN mystream</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name2 value2 name3 value3</span><br><span class="line">&quot;1712473231761-0&quot;</span><br></pre></td></tr></table></figure>

<p>消息 ID 使用 * 表示由 redis 生成，同时也可以自定义，但是自定义时要保证递增性。</p>
<blockquote>
<p>消息 ID 的格式： 毫秒级时间戳 + 序号 , 例如：1712473185388-5 , 它表示当前消息在毫秒时间戳 1712473185388 产生 ，并且该毫秒内产生到了第5条消息。</p>
</blockquote>
<p>在添加队列消息时，也<strong>可以指定队列的长度</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XADD mystream MAXLEN 100 * name value1 age 30</span><br><span class="line">&quot;1713082205042-0&quot;</span><br></pre></td></tr></table></figure>

<p>使用 XADD 命令向 <code>mystream</code> 的 stream 中添加了一条消息，并且指定了最大长度为 100。消息的 ID 由 Redis 自动生成，消息包含两个字段 <code>name</code> 和 <code>age</code>，分别对应的值是 <code>value1</code> 和 <code>30</code>。</p>
<h2 id="02-XRANGE-获取消息列表"><a href="#02-XRANGE-获取消息列表" class="headerlink" title="02 XRANGE 获取消息列表"></a>02 XRANGE 获取消息列表</h2><p>使用 XRANGE 获取消息列表，会自动过滤已经删除的消息。语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码XRANGE key start end [COUNT count]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key</strong> ：队列名</li>
<li><strong>start</strong> ：开始值， <strong>-</strong> 表示最小值</li>
<li><strong>end</strong> ：结束值， <strong>+</strong> 表示最大值</li>
<li><strong>count</strong> ：数量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XRANGE mystream - + COUNT 2</span><br><span class="line">1) 1) &quot;1712473185388-0&quot;</span><br><span class="line">   2) 1) &quot;name1&quot;</span><br><span class="line">      2) &quot;value1&quot;</span><br><span class="line">      3) &quot;name2&quot;</span><br><span class="line">      4) &quot;value2&quot;</span><br><span class="line">2) 1) &quot;1712473231761-0&quot;</span><br><span class="line">   2) 1) &quot;name2&quot;</span><br><span class="line">      2) &quot;value2&quot;</span><br><span class="line">      3) &quot;name3&quot;</span><br><span class="line">      4) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>我们得到两条消息，第一层是消息 ID ，第二层是消息内容 ，消息内容是 Hash 数据结构 。</p>
<h2 id="03-XREAD-以阻塞-非阻塞方式获取消息列表"><a href="#03-XREAD-以阻塞-非阻塞方式获取消息列表" class="headerlink" title="03 XREAD 以阻塞/非阻塞方式获取消息列表"></a>03 XREAD 以阻塞/非阻塞方式获取消息列表</h2><p>使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>count</strong> ：数量</li>
<li><strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式</li>
<li><strong>key</strong> ：队列名</li>
<li><strong>id</strong> ：消息 ID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XREAD streams mystream 0-0</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1712473185388-0&quot;</span><br><span class="line">         2) 1) &quot;name1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">            3) &quot;name2&quot;</span><br><span class="line">            4) &quot;value2&quot;</span><br><span class="line">      2) 1) &quot;1712473231761-0&quot;</span><br><span class="line">         2) 1) &quot;name2&quot;</span><br><span class="line">            2) &quot;value2&quot;</span><br><span class="line">            3) &quot;name3&quot;</span><br><span class="line">            4) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>XRED 读消息时分为<strong>阻塞</strong>和<strong>非阻塞</strong>模式，使用 <strong>BLOCK</strong> 选项可以表示阻塞模式，需要设置阻塞时长。非阻塞模式下，读取完毕（即使没有任何消息）立即返回，而在阻塞模式下，若读取不到内容，则阻塞等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XREAD block 1000 streams mystream $</span><br><span class="line">(nil)</span><br><span class="line">(1.07s)</span><br></pre></td></tr></table></figure>

<p>使用 Block 模式，配合 $ 作为 ID ，表示读取最新的消息，若没有消息，命令阻塞！等待过程中，其他客户端向队列追加消息，则会立即读取到。</p>
<p>因此，典型的队列就是 XADD 配合 XREAD Block 完成。XADD 负责生成消息，XREAD 负责消费消息。</p>
<h2 id="04-XGROUP-CREATE-创建消费者组"><a href="#04-XGROUP-CREATE-创建消费者组" class="headerlink" title="04 XGROUP CREATE 创建消费者组"></a>04 XGROUP CREATE 创建消费者组</h2><p>使用 XGROUP CREATE 创建消费者组，分两种情况：</p>
<ul>
<li>从头开始消费:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码XGROUP CREATE mystream consumer-group-name 0-0</span><br></pre></td></tr></table></figure>

<ul>
<li>从尾部开始消费:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码XGROUP CREATE mystream consumer-group-name $</span><br></pre></td></tr></table></figure>

<p>执行效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XGROUP CREATE mystream mygroup 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="05-XREADGROUP-GROUP-读取消费组中的消息"><a href="#05-XREADGROUP-GROUP-读取消费组中的消息" class="headerlink" title="05 XREADGROUP GROUP 读取消费组中的消息"></a>05 XREADGROUP GROUP 读取消费组中的消息</h2><p>使用 XREADGROUP GROUP 读取消费组中的消息，语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>group</strong> ：消费组名</li>
<li><strong>consumer</strong> ：消费者名。</li>
<li><strong>count</strong> ： 读取数量。</li>
<li><strong>milliseconds</strong> ： 阻塞毫秒数。</li>
<li><strong>key</strong> ： 队列名。</li>
<li><strong>ID</strong> ： 消息 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt;  XREADGROUP group mygroup consumerA count 1 streams mystream &gt;</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1712473185388-0&quot;</span><br><span class="line">         2) 1) &quot;name1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">            3) &quot;name2&quot;</span><br><span class="line">            4) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<p>消费者组 <code>mygroup</code> 中的消费者 <code>consumerA</code> ，从 名为 <code>mystream</code> 的 Stream 中读取消息。</p>
<ul>
<li><code>COUNT 1</code> 表示一次最多读取一条消息</li>
<li><code>&gt;</code> 表示消息的起始位置是当前可用消息的 ID，即从当前未读取的最早消息开始读取。</li>
</ul>
<h2 id="06-XACK-消息消费确认"><a href="#06-XACK-消息消费确认" class="headerlink" title="06 XACK 消息消费确认"></a>06 XACK 消息消费确认</h2><p>接收到消息之后，我们要手动确认一下（ack），语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码xack key group-key ID [ID ...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XACK mystream mygroup 1713089061658-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 ack 确认消息已经被消费完成，整个流程的执行如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/07ee8b4f0ad2f007285ed2a2b0fe62b803809e6f8c2eca35fb5690a53b3e0a28" alt></p>
<p>我们可以使用 xpending 命令查看<strong>消费者未确认的消息ID</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; xpending mystream mygroup</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) &quot;1713091227595-0&quot;</span><br><span class="line">3) &quot;1713091227595-0&quot;</span><br><span class="line">4) 1) 1) &quot;consumerA&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="07-XTRIM-限制-Stream-长度"><a href="#07-XTRIM-限制-Stream-长度" class="headerlink" title="07 XTRIM 限制 Stream 长度"></a>07 XTRIM 限制 Stream 长度</h2><p>我们使用 XTRIM 对流进行修剪，限制长度， 语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XADD mystream * field1 A field2 B field3 C field4 D</span><br><span class="line">&quot;1712535017402-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream MAXLEN 2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1712498239430-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;zhangyogn&quot;</span><br><span class="line">2) 1) &quot;1712535017402-0&quot;</span><br><span class="line">   2) 1) &quot;field1&quot;</span><br><span class="line">      2) &quot;A&quot;</span><br><span class="line">      3) &quot;field2&quot;</span><br><span class="line">      4) &quot;B&quot;</span><br><span class="line">      5) &quot;field3&quot;</span><br><span class="line">      6) &quot;C&quot;</span><br><span class="line">      7) &quot;field4&quot;</span><br><span class="line">      8) &quot;D&quot;</span><br></pre></td></tr></table></figure>

<h1 id="3-SpringBoot-Redis-Stream-实战"><a href="#3-SpringBoot-Redis-Stream-实战" class="headerlink" title="3 SpringBoot Redis Stream 实战"></a>3 SpringBoot Redis Stream 实战</h1><p><strong>1、添加 SpringBoot Redis 依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2、yaml 文件配置</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/301bf51f03671472c93d10ab46791914ee1757087a47579ce850ca3471b4c8ac" alt></p>
<p><strong>3、RedisTemplate 配置</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3bba11fd415f2adc5f770f9c6ff51279646c748b564af5b6e38eb9485d77a48b" alt></p>
<p><strong>4、定义stream监听器</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/34b2912b1b7f8ae95f8c04366864c5b15b7afc9b88c227542cbb18e1ef60ff5b" alt></p>
<p><strong>5、定义streamcontainer 并启动</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8e15539a8d63714a1977ae33c56bde339ef0a2692e24b6b207e43615e3340ac2" alt></p>
<p><strong>6、发送消息</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/32edf7403232acc07aa0e5ce32a101ac5b8a93a00b2e6094887187b23bd2e454" alt></p>
<p>执行完成之后，消费者就可以打印如下日志：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/174bca8cfe61c29ab45cd7cf40787e02fd4793f4b30e0d9223185d3c5b3da68f" alt></p>
<p>演示代码地址：</p>
<blockquote>
<p><a href="https://github.com/makemyownlife/courage-cache-demo" target="_blank" rel="noopener">github.com/makemyownli…</a></p>
</blockquote>
<h1 id="4-Redis-stream-用做消息队列完美吗"><a href="#4-Redis-stream-用做消息队列完美吗" class="headerlink" title="4 Redis stream 用做消息队列完美吗"></a>4 Redis stream 用做消息队列完美吗</h1><p>笔者认为 Redis stream 用于消息队列最大的进步在于：<strong>实现了发布订阅模型</strong>。</p>
<p>发布订阅模型具有如下特点：</p>
<ul>
<li><strong>消费独立</strong></li>
</ul>
<p>相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。</p>
<ul>
<li><strong>一对多通信</strong></li>
</ul>
<p>基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。</p>
<p>细品 Redis stream 的设计，我们发现它和 Kafka 非常相似，比如说消费者组，消费进度偏移量等。</p>
<p>我们曾经诟病 Redis List 数据结构用做队列时，因为消费时没有 Ack 机制，应用异常挂掉导致消息偶发丢失的情况，Redis Stream 已经完美的解决了。</p>
<p>因为消费者内部有一个属性 <strong>pending_ids</strong> ， 记录了当前消费者读取但没有回复 ACK 的消息 ID 列表 。当消费者重新上线，这些消息可以重新被消费。</p>
<p>但 Redis stream 用做消息队列完美吗 ？</p>
<p><strong>这个真没有！</strong> 。</p>
<p>1、Redis 本身定位是<strong>内存数据库</strong>，它的设计之初都是为缓存准备的，<strong>并不具备消息堆积的能力</strong>。而专业消息队列一个非常重要的功能是<strong>数据中转枢纽</strong>，Redis 的定位很难满足，所以使用起来要非常小心。</p>
<p>2、Redis 的高可用方案可能丢失消息（AOF 持久化 和 主从复制都是异步 ），而专业消息队列可以针对不同的场景选择不同的高可用策略。</p>
<p>所以，笔者认为 Redis 非常适合轻量级消息队列解决方案，轻量级意味着：数据量可控 + 业务模型简单 。</p>
<hr>
<p>参考文章：</p>
<blockquote>
<p><a href="https://redis.io/docs/data-types/streams/" target="_blank" rel="noopener">redis.io/docs/data-t…</a></p>
<p><a href="https://www.runoob.com/redis/redis-stream.html" target="_blank" rel="noopener">www.runoob.com/redis/redis…</a></p>
<p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html" target="_blank" rel="noopener">pdai.tech/md/db/nosql…</a></p>
</blockquote>
<hr>
<p>如果我的文章对你有所帮助，还请帮忙<strong>点赞、在看、转发</strong>一下，你的支持会激励我输出更高质量的文章，非常感谢！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357301805569687563" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁实战</title>
    <url>/7354929072957702144.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>柯苏远写于2024年4月7日 20点10分</p>
<p>公司的主要业务线是国外电商，之前是在客户下订单，以及厂商对客户订单进行打包发货等关键节点都会给客户发送对应邮件。</p>
<p>可是由于邮件没有短信那么及时，方便，为了提高客户的体验和下单率准备在整个系统接入短信。</p>
<p>所以这里就涉及到要和国外通讯商对接短信发送的接口。</p>
<p>这里主要是两个接口：一个是获取token接口，一个是发送短信接口。<strong>获取token的接口一个小时之内只能获取5次，一次获取到的token有效期是一个小时。</strong></p>
<h2 id="简单-token-缓存设计"><a href="#简单-token-缓存设计" class="headerlink" title="简单 token 缓存设计"></a>简单 token 缓存设计</h2><p>根据背景描述，显而易见的是，token必须要缓存起来，因为一个小时就只能获取5次，所以必须尽量重复使用，以下是我的设想的接口调用情况：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/931970573cab39f90b6378091c2a504b9396ff33cbc309f4a2d36b2a1b66994f" alt="获取token-进阶.jpg"></p>
<p>从直观感受上来讲，确实是可以了，我们通常的设计一般情况下都不会考虑多线程并发的情况。</p>
<p><strong>但是！！！ 我们的业务项目是电商欸，肯定会存在并发的可能。</strong></p>
<p><strong>所以我将方案给我老大看了之后，我老大一眼就看出我没有考虑并发问题，要我重新去设计。</strong></p>
<h2 id="并发-token-缓存设计"><a href="#并发-token-缓存设计" class="headerlink" title="并发 token 缓存设计"></a>并发 token 缓存设计</h2><p>由于上一版的核心就是没考虑并发，如果此时100个线程同时去缓存获取并且同时没获取到，再然后同时去调用了短信的api，那么这个api一分钟5次的限制一下子就到了峰值。</p>
<p>考虑到并发点，我引入了分布式锁，对之前方案做了更新，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b62bd491d872553145744ace1b24f3ae4e0fbba03a13b09f8eb84056c448616d" alt="获取token流程-私人版.jpg"></p>
<p>整个流程图看起来复杂了很多，其实和上面方案比较起来主要就两点：</p>
<ol>
<li>在调用api之前加了分布式锁，在取得token之后，释放分布式锁。</li>
<li>如果在一个线程持有分布式锁的情况，其它线程进来没获取锁，就让它们冷处理，类似一个while循环操作，然后睡眠200毫秒，循环15次去缓存里取。如果15次都没有从缓存里取到token对象，那么就要进行去抢夺分布式锁，如果抢夺成功那么执行调用api流程，如果失败，那么再去缓存看看，有的话直接返回token对象，没有的话再去抢夺分布式锁。</li>
</ol>
<h2 id="具体实现-amp-当前问题"><a href="#具体实现-amp-当前问题" class="headerlink" title="具体实现 &amp; 当前问题"></a>具体实现 &amp; 当前问题</h2><p>具体实现分布式锁：</p>
<ul>
<li>在项目里用的是redisTemplate，有一个setIfAbsent，然后再结合expire(<strong>项目里是10s</strong>)，用这两个命令来获取分布式锁。</li>
<li>释放的时候直接就是delete。</li>
</ul>
<p>其实这种实现方式是不严谨的，有如下缺点：</p>
<ul>
<li>setIfAbsent和expire：这两个不是原子命令，如果setIfAbsent成功，由于某种原因expire没有成功，那么就会造成死锁，这个分布式锁会得不到释放。</li>
<li>expire 这里设置的过期时间是10s，但是如果我业务执行时间大于10s呢？分布式锁就失效了，那还搞个毛线？其它线程也进我的临界区了，线程不安全了。</li>
<li>delete是直接删除的，没有考虑某种未知错误造成删除失败的原因。这个其实是小问题，即使删除失败也有超时的保证。</li>
</ul>
<p><strong>这三个目前存在的问题和老大聊了，老大说确实是有这问题，然后后面研究一下redisson，然后完善一下这个分布式锁，后面等手头活少点去研究一下。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>api token 缓存设计</li>
<li>多线程下 api token 缓存设计</li>
<li>分布式锁的实现 &amp; 目前存在的问题</li>
<li>后续目标：研究redisson实现分布式锁。</li>
</ol>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7354929072957702144#comment" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>详解MySQL自定义函数</title>
    <url>/7357390581302493195.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>在实际开发过程中。业务是复杂多变的；在大多数情况下我们都会将这些复杂多变的东西放到代码里面去处理，但是你知道吗，MySQL本身也是支持我们去自定义函数处理这些内容的。</p>
<p>在本文中，我们将一起学习一下自定义函数。</p>
</blockquote>
<h2 id="一-自定义函数的概念"><a href="#一-自定义函数的概念" class="headerlink" title="一. 自定义函数的概念"></a>一. 自定义函数的概念</h2><h3 id="1-1-什么是MySQL自定义函数"><a href="#1-1-什么是MySQL自定义函数" class="headerlink" title="1.1 什么是MySQL自定义函数"></a>1.1 什么是MySQL自定义函数</h3><p>MySQL自定义函数是用户根据自己的需求和逻辑编写的特定功能的函数。它们是在MySQL数据库中创建的，可以根据用户定义的输入参数执行特定的操作，并返回一个结果。</p>
<h3 id="1-2-存储过程和自定义函数的区别"><a href="#1-2-存储过程和自定义函数的区别" class="headerlink" title="1.2 存储过程和自定义函数的区别"></a>1.2 存储过程和自定义函数的区别</h3><ul>
<li>存储过程（Stored Procedure）是一组预编译的SQL语句，它们一起执行一系列操作。存储过程通常用于执行一些复杂的业务逻辑或批处理操作。它们可以接受输入参数，并且可以返回多个结果集。存储过程通常用于执行数据操作，如插入、更新和删除数据。</li>
<li>自定义函数（Function）是一个具有特定功能的代码块，接受输入参数并返回一个值。函数可以在SQL查询中使用，作为表达式的一部分。它们通常用于计算和转换数据，而不像存储过程那样执行复杂的操作。函数可以返回一个标量值（如整数、字符串等），也可以返回一个表。</li>
</ul>
<h3 id="1-3-自定义函数与内置函数的关系"><a href="#1-3-自定义函数与内置函数的关系" class="headerlink" title="1.3 自定义函数与内置函数的关系"></a>1.3 自定义函数与内置函数的关系</h3><ul>
<li>自定义函数是由用户编写的，用于满足特定需求的函数。</li>
<li>内置函数是MySQL提供的已经实现的函数，用于执行常见的操作，如数学计算、字符串处理等。内置函数是MySQL自身提供的一组功能强大的函数库，可以直接在查询中使用。</li>
<li>用户可以在自定义函数中调用内置函数，以扩展其功能或组合使用。因此，自定义函数可以使用内置函数来完成更复杂的任务。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1437ba600563d31873006268b9fed1be50b5a0dbd582400043b5154c7e442df8" alt="image.png"></p>
<h2 id="二-自定义函数的类型"><a href="#二-自定义函数的类型" class="headerlink" title="二. 自定义函数的类型"></a>二. 自定义函数的类型</h2><p>自定义函数的类型根据使用场景和函数返回的结果类型和形式来进行分类，大概可以分为以下三类：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/731eabb01ed2d8e6968a856717ca8750096674257ecd6a2b74cb2b1f6db785cd" alt="518B7944-C304-4343-9F5F-C138D5D0E35C.png"></p>
<ol>
<li><strong>标量函数（Scalar Function）</strong> ：这种函数接收一组输入参数，并返回一个单一的标量值，如整数、字符串、日期等。标量函数经常用于计算和转换数据，例如计算年龄、字符串拼接、日期格式化等。</li>
<li><strong>聚合函数（Aggregate Function）</strong> ：聚合函数接收一组输入值，并对它们进行聚合计算，返回一个单一的结果。常见的聚合函数包括<code>SUM</code>（求和）、<code>AVG</code>（平均值）、<code>COUNT</code>（计数）、<code>MAX</code>（最大值）<code>和MIN</code>（最小值）。聚合函数通常与<code>GROUP BY</code>子句一起使用。</li>
<li><strong>表值函数（Table-Valued Function）</strong> ：表值函数返回一个结果集，可以像表一样进行查询和操作。它可以作为查询的数据源，与普通的表一起使用。表值函数可以返回单个结果集或多个结果集。常见的表值函数包括行生成函数（<code>ROW GENERATO</code>R）和表返回函数（<code>TABLE-RETURNING</code>）。这三种类型是从什么维度划分的</li>
</ol>
<blockquote>
<p>注意：千万不要把存储过程和自定义函数混为一谈，虽然都是写一堆sql代码，但是无论是语法和使用姿势，他们都不是一个东西。</p>
</blockquote>
<h2 id="三-创建自定义函数的步骤"><a href="#三-创建自定义函数的步骤" class="headerlink" title="三. 创建自定义函数的步骤"></a>三. 创建自定义函数的步骤</h2><h3 id="3-1-创建自定义函数步骤"><a href="#3-1-创建自定义函数步骤" class="headerlink" title="3.1 创建自定义函数步骤"></a>3.1 创建自定义函数步骤</h3><p>创建自定义函数的步骤可以分为以下步骤：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/36625bf89003dea3391cf5f6f8b40f27eec9752bb72c8cb8bf9b87686689370e" alt="image.png"></p>
<ol>
<li><strong>确定函数需求</strong>：明确函数的功能、输入参数和返回值类型。</li>
<li><strong>编写函数代码</strong>：使用MySQL支持的编程语言（如SQL）编写函数的逻辑代码。可以使用控制结构、变量、内置函数等来实现所需的功能。</li>
<li><strong>创建函数</strong>：使用CREATE FUNCTION语句创建函数并将函数代码添加到数据库中。</li>
<li><strong>设置参数和返回值</strong>：根据函数需求，设置函数的输入参数和返回值类型。</li>
<li><strong>测试函数</strong>：使用适当的测试数据和参数调用函数，确保函数能够正确运行并返回预期的结果。</li>
</ol>
<h3 id="3-2-创建自定义函数的语法"><a href="#3-2-创建自定义函数的语法" class="headerlink" title="3.2 创建自定义函数的语法"></a>3.2 创建自定义函数的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码CREATE FUNCTION function_name ([parameter_list])</span><br><span class="line">    RETURNS return_type</span><br><span class="line">    [characteristics]</span><br><span class="line">    BEGIN</span><br><span class="line">        -- 函数逻辑代码</span><br><span class="line">        RETURN expression;</span><br><span class="line">    END;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面大写的内容都是语法固定值</li>
<li><code>function_name</code>是函数的名称，可以根据实际需求进行命名</li>
<li><code>parameter_list</code>是函数的输入参数列表，可以包含零个或多个参数。每个参数由名称、数据类型和其他属性组成</li>
<li><code>characteristics</code>是可选项，用于定义函数的属性，如语言、安全性、SQL数据访问等</li>
<li><code>BEGIN</code>和<code>END</code>之间是函数的逻辑代码，用于实现所需的功能</li>
<li><code>return_type</code>是函数的返回值类型，表示函数返回的结果的数据类型</li>
<li><code>RETURN</code>语句用于指定函数的返回值，可以使用表达式来计算返回值</li>
</ul>
<h3 id="3-3-自定义函数示例"><a href="#3-3-自定义函数示例" class="headerlink" title="3.3 自定义函数示例"></a>3.3 自定义函数示例</h3><p><strong>用户故事</strong>：作为一个电商平台，我有自己的会员体系，现在我希望根据我的会员体系来计算不同的积分</p>
<p><strong>需求</strong>：根据用户的购买行为给予积分奖励，不同等级的用户可能会有不同的积分回报率。普通用户，按5%计算积分；银牌用户，按10%计算积分；金牌用户，按15%计算积分</p>
<ul>
<li>自定义函数实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码CREATE FUNCTION CalculateRewardPoints(price DECIMAL(10,2), user_level INT)</span><br><span class="line">RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE points INT;</span><br><span class="line">    IF user_level = 1 THEN</span><br><span class="line">        SET points = FLOOR(price * 0.05); -- 普通用户，按5%计算积分</span><br><span class="line">    ELSEIF user_level = 2 THEN</span><br><span class="line">        SET points = FLOOR(price * 0.1); -- 银牌用户，按10%计算积分</span><br><span class="line">    ELSEIF user_level = 3 THEN</span><br><span class="line">        SET points = FLOOR(price * 0.15); -- 金牌用户，按15%计算积分</span><br><span class="line">    END IF;</span><br><span class="line">    RETURN points;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<ul>
<li>使用方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码select CalculateRewardPoints(109, 1) as score;</span><br><span class="line">-- 运行结果：5</span><br><span class="line">select CalculateRewardPoints(109, 2) as score;</span><br><span class="line">-- 运行结果：10</span><br><span class="line">select CalculateRewardPoints(109, 3) as score;</span><br><span class="line">-- 运行结果：16</span><br></pre></td></tr></table></figure>

<h2 id="四-自定义函数的使用场景"><a href="#四-自定义函数的使用场景" class="headerlink" title="四. 自定义函数的使用场景"></a>四. 自定义函数的使用场景</h2><p>MySQL自定义函数具有广泛的使用场景，以下是几个常见的使用场景</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/73d646eb27261a4c2ed8c91957d8e864b146f905fb9fc047fe37072c8eb4f3fe" alt="image.png"></p>
<p>通过自定义函数，可以提高数据库的灵活性、可读性和可维护性，使数据库应用更加强大和高效。</p>
<h2 id="五-自定义函数的性能考虑"><a href="#五-自定义函数的性能考虑" class="headerlink" title="五. 自定义函数的性能考虑"></a>五. 自定义函数的性能考虑</h2><h3 id="5-1-自定义函数对数据库性能的潜在影响"><a href="#5-1-自定义函数对数据库性能的潜在影响" class="headerlink" title="5.1 自定义函数对数据库性能的潜在影响"></a>5.1 自定义函数对数据库性能的潜在影响</h3><p>自定义函数对数据库性能可能产生潜在影响，主要体现在以下几个方面：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3ac61e14d9b9e00be99f4fe3cf029af67501e3e7ebbca48f9396591fd1629fe2" alt="image.png"></p>
<ol>
<li><strong>函数调用开销</strong>：每次调用函数都需要进行函数的解析、编译和执行，这会增加一定的开销。如果函数在大量的查询中频繁调用，可能会导致性能下降。</li>
<li><strong>函数执行时间</strong>：函数内部的逻辑代码执行时间可能会对性能产生影响。如果函数的逻辑复杂或处理大量数据的计算，可能会导致函数执行时间较长，从而影响查询的整体性能。</li>
<li><strong>函数与查询优化器</strong>：自定义函数的使用可能会限制查询优化器的优化能力。查询优化器在选择执行计划时，可能无法准确估计函数的执行成本，从而导致选择不够优化的执行计划。</li>
</ol>
<h3 id="5-2-优化自定义函数性能的方向"><a href="#5-2-优化自定义函数性能的方向" class="headerlink" title="5.2 优化自定义函数性能的方向"></a>5.2 优化自定义函数性能的方向</h3><p>为了优化自定义函数的性能，可以从以下入手：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/70450c65a671aba13fad4e90a3c49789257c7160c040992cb0c6c99c82cbc7aa" alt="image.png"></p>
<ol>
<li><strong>减少函数调用次数</strong>：尽量减少函数的调用次数，特别是在大规模数据查询中。可以通过优化查询语句或重构函数逻辑，减少函数的使用频率。</li>
<li><strong>避免在WHERE子句中使用函数</strong>：在WHERE子句中使用函数可能会导致无法使用索引，影响查询性能。尽量避免将函数应用于WHERE子句中的列，以充分利用索引优化查询。</li>
<li><strong>使用内置函数替代自定义函数</strong>：MySQL提供了许多内置函数，这些函数经过优化和性能测试，通常比自定义函数具有更好的性能。如果有适用的内置函数可用，优先选择使用内置函数。</li>
<li><strong>考虑使用存储过程或触发器</strong>：对于复杂的业务逻辑，可以考虑使用存储过程或触发器来代替自定义函数。存储过程和触发器可以与数据库紧密集成，执行效率较高。</li>
<li><strong>使用函数结果缓存</strong>：如果函数的计算结果在短时间内保持不变，可以考虑使用缓存来存储函数的结果，避免重复计算。可以使用MySQL的缓存机制或自定义缓存表来实现。</li>
<li><strong>定期优化数据库结构和查询</strong>：通过定期的数据库结构优化和查询优化，可以提高整体性能。包括创建适当的索引、合理划分数据表、优化查询语句等。</li>
</ol>
<blockquote>
<p>这里要说一个特别特别重要的：</p>
<p>1、函数使用要综合考虑，不能滥用；</p>
<p>2、使用了函数一定要做性能测试，不要觉得自己写的就牛逼轰轰的</p>
</blockquote>
<h2 id="六-自定义函数的维护"><a href="#六-自定义函数的维护" class="headerlink" title="六. 自定义函数的维护"></a>六. 自定义函数的维护</h2><p>现在的大部分开发，都有一个习惯，开发任务上线就Over了，没有持续打磨自己的功能，也没有有效的维护自己的项目，在自定义函数的时候，实际也是需要维护的；管理和维护自定义函数是确保其正常运行和性能的重要方面。</p>
<p>以下是管理和维护自定义函数的方法和技巧：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a770b6712f5d1a897d058b4e7b8d84230a0266d806ed13c13f7bdc8d51d292ff" alt="image.png"></p>
<ol>
<li><strong>备份自定义函数</strong>：定期备份数据库，包括自定义函数的定义和相关数据。这样可以在需要时还原函数或迁移至其他环境。</li>
<li><strong>版本控制</strong>：使用版本控制系统（如Git）对自定义函数的代码进行管理。这样可以跟踪和管理函数的修改历史，并方便团队合作和回滚操作。</li>
<li><strong>文档和注释</strong>：为自定义函数编写清晰的文档和注释，描述函数的用途、参数、返回值以及实现逻辑。这样可以方便其他开发人员理解和使用函数，并在维护时提供参考。</li>
<li><strong>监控函数性能</strong>：使用MySQL的性能监控工具（如EXPLAIN和SHOW PROFILE）来监视自定义函数的性能表现。通过分析查询执行计划和性能统计信息，可以发现潜在的性能瓶颈和优化机会。</li>
<li><strong>定期优化和重构</strong>：根据实际需求和性能问题，定期对自定义函数进行优化和重构。优化包括改进函数逻辑、使用更高效的算法、减少函数调用次数等，以提高函数的性能和可维护性。</li>
<li><strong>测试和验证</strong>：在对自定义函数进行更改或更新之前，进行充分的测试和验证。使用适当的测试数据和参数调用函数，确保函数在各种情况下都能返回正确的结果。</li>
<li><strong>错误处理和日志记录</strong>：在自定义函数中实现适当的错误处理机制，并在需要时记录错误日志。这样可以帮助诊断和解决函数中的问题，并及时修复潜在的错误。</li>
</ol>
<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><p>自定义函数在MySQL数据库中提供了强大的扩展能力，使得开发者能够根据具体的业务需求来创建特定的功能。这些函数可以直接在数据库层面处理数据，减少了应用程序与数据库之间的数据传输，提高了数据处理的效率和性能。</p>
<p>自定义函数在电商平台、金融分析、数据报告等多个领域都有着广泛的应用。例如，在电商平台中，可以根据用户的购买行为和会员等级计算积分；在金融分析中，可以用于计算投资组合的风险指标；在数据报告中，可以用于生成动态的数据汇总和图表。</p>
<p>当然尽管自定义函数带来了许多优势，但不合理的使用也可能引发一些问题，如性能下降、代码可读性降低等。因此，合理使用自定义函数至关重要。</p>
<blockquote>
<p>希望本文对您有所帮助。如果有任何错误或建议，请随时指正和提出。</p>
<p>同时，如果您觉得这篇文章有价值，请考虑点赞和收藏。这将激励我进一步改进和创作更多有用的内容。</p>
<p>感谢您的支持和理解！</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357390581302493195" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,MySQL,SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAIchemy异步DBManager封装-01入门理</title>
    <url>/7357703852726911016.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>SQLAlchemy 是一个强大的 Python SQL 工具包和对象关系映射（ORM）系统，是业内比较流行的ORM，设计非常优雅。随着其2.0版本的发布，SQLAlchemy 引入了原生的异步支持，这极大地增强了其在处理高并发和异步I/O场景下的能力。通过结合像greenlet、gevent这样的协程库，SQLAlchemy 使得异步数据库操作成为可能，从而提高了应用程序的性能和响应速度。</p>
<p>这里我将基于SQLAlchemy的异步支持，封装一些常用的增删改查（CRUD）操作到 <a href="https://github.com/HuiDBK/py-tools" target="_blank" rel="noopener">github.com/HuiDBK/py-t…</a> 中，以便在项目开发中更加便捷地使用。</p>
<p>Github: <a href="https://github.com/sqlalchemy/sqlalchemy" target="_blank" rel="noopener">github.com/sqlalchemy/…</a></p>
<p>2.0文档：<a href="https://docs.sqlalchemy.org/en/20/index.html" target="_blank" rel="noopener">docs.sqlalchemy.org/en/20/index…</a></p>
</blockquote>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>封装前，先简单介绍下如何使用 SQLAIchemy。</p>
<p>具体细节可以参考官网文档：<a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.html" target="_blank" rel="noopener">docs.sqlalchemy.org/en/20/orm/q…</a></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy[asyncio]==2.0.20</span><br><span class="line">pip install aiomysql==0.2.0</span><br></pre></td></tr></table></figure>

<p>这里安装了 sqlalchemy 2.0版本，以及 aiomysql 异步数据库驱动，进行演示。</p>
<h2 id="创建异步数据库引擎"><a href="#创建异步数据库引擎" class="headerlink" title="创建异步数据库引擎"></a><strong>创建异步数据库引擎</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy.ext.asyncio import create_async_engine  </span><br><span class="line"></span><br><span class="line"># db_uri = &quot;&#123;protocol&#125;://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;&quot;</span><br><span class="line"></span><br><span class="line">db_engine = create_async_engine(&quot;mysql+aiomysql://root:123456@127.0.0.1:3306/demo&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="声明数据库表映射模型"><a href="#声明数据库表映射模型" class="headerlink" title="声明数据库表映射模型"></a>声明数据库表映射模型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy import String</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseOrmTable(DeclarativeBase):</span><br><span class="line">    &quot;&quot;&quot;SQLAlchemy Base ORM Model&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __abstract__ = True</span><br><span class="line"></span><br><span class="line">    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, comment=&quot;主键ID&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserTable(BaseOrmTable):</span><br><span class="line">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    username: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户昵称&quot;)</span><br><span class="line">    password: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户密码&quot;)</span><br><span class="line">    phone: Mapped[str] = mapped_column(String(11), default=&quot;&quot;, comment=&quot;手机号&quot;)</span><br><span class="line">    email: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;邮箱&quot;)</span><br><span class="line">    avatar: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;头像&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="简单db操作"><a href="#简单db操作" class="headerlink" title="简单db操作"></a>简单db操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"># db_uri = &quot;&#123;protocol&#125;://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;&quot;</span><br><span class="line"></span><br><span class="line">db_engine = create_async_engine(&quot;mysql+aiomysql://root:123456@127.0.0.1:3306/hui-demo&quot;)</span><br><span class="line"></span><br><span class="line">Session = async_sessionmaker(db_engine)</span><br><span class="line"></span><br><span class="line">async def create_tables():</span><br><span class="line">    # 根据映射创建库表</span><br><span class="line">    async with db_engine.begin() as conn:</span><br><span class="line">        await conn.run_sync(BaseOrmTable.metadata.create_all)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    await create_tables()</span><br><span class="line"></span><br><span class="line">    async with Session.begin() as session:</span><br><span class="line">        # 添加用户</span><br><span class="line">        new_user = UserTable(username=&apos;hui&apos;, email=&apos;huidbk@163.com&apos;)</span><br><span class="line">        session.add(new_user)</span><br><span class="line">        await session.flush()   # 刷新table 对象属性，获取新增的id</span><br><span class="line">        print(new_user.id)</span><br><span class="line">        print(&quot;add user&quot;, new_user.__dict__)</span><br><span class="line"></span><br><span class="line">        # 获取用户</span><br><span class="line">        user = await session.get(UserTable, new_user.id)</span><br><span class="line">        print(&quot;get user&quot;, user.__dict__)</span><br><span class="line"></span><br><span class="line">        # 更新用户</span><br><span class="line">        user.email = &apos;hui@163.com&apos;</span><br><span class="line">        await session.merge(user)</span><br><span class="line">        print(&quot;updated user&quot;, user.__dict__)</span><br><span class="line"></span><br><span class="line">        # 删除用户</span><br><span class="line">        await session.delete(user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 运行主函数</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<h1 id="常用DB操作封装"><a href="#常用DB操作封装" class="headerlink" title="常用DB操作封装"></a>常用DB操作封装</h1><h2 id="SQLAlchemyManager"><a href="#SQLAlchemyManager" class="headerlink" title="SQLAlchemyManager"></a>SQLAlchemyManager</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SQLAlchemyManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_URL_TEMPLATE = &quot;&#123;protocol&#125;://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(</span><br><span class="line">            self,</span><br><span class="line">            host: str = &quot;localhost&quot;,</span><br><span class="line">            port: int = 3306,</span><br><span class="line">            user: str = &quot;&quot;,</span><br><span class="line">            password: str = &quot;&quot;,</span><br><span class="line">            db_name: str = &quot;&quot;,</span><br><span class="line">            pool_size: int = 30,</span><br><span class="line">            pool_pre_ping: bool = True,</span><br><span class="line">            pool_recycle: int = 600,</span><br><span class="line">            log: Union[logging.Logger] = None,</span><br><span class="line">    ):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.db_name = db_name</span><br><span class="line">        self.pool_size = pool_size</span><br><span class="line">        self.pool_pre_ping = pool_pre_ping</span><br><span class="line">        self.pool_recycle = pool_recycle</span><br><span class="line">        self.log = log or logger</span><br><span class="line"></span><br><span class="line">        self.db_engine: AsyncEngine = None</span><br><span class="line">        self.async_session_maker: async_sessionmaker = None</span><br><span class="line"></span><br><span class="line">    def get_db_url(self, protocol: str = &quot;mysql+aiomysql&quot;):</span><br><span class="line">        db_url = self.DB_URL_TEMPLATE.format(</span><br><span class="line">            protocol=protocol, user=self.user, password=self.password, host=self.host, port=self.port, db=self.db_name</span><br><span class="line">        )</span><br><span class="line">        return db_url</span><br><span class="line">     </span><br><span class="line">    def init_db_engine(self, protocol: str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化db引擎</span><br><span class="line">        Args:</span><br><span class="line">            protocol: 驱动协议类型</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            self.db_engine</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        db_url = self.get_db_url(protocol=protocol)</span><br><span class="line">        self.log.info(f&quot;init_db_engine =&gt; &#123;db_url&#125;&quot;)</span><br><span class="line">        self.db_engine = create_async_engine(</span><br><span class="line">            url=db_url, pool_size=self.pool_size, pool_pre_ping=self.pool_pre_ping, pool_recycle=self.pool_recycle</span><br><span class="line">        )</span><br><span class="line">        self.async_session_maker = async_sessionmaker(bind=self.db_engine, expire_on_commit=False)</span><br><span class="line">        return self.db_engine</span><br><span class="line">        </span><br><span class="line">    def init_mysql_engine(self, protocol: str = &quot;mysql+aiomysql&quot;):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化mysql引擎</span><br><span class="line">        Args:</span><br><span class="line">            protocol: 驱动协议类型</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            self.db_engine</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.init_db_engine(protocol=protocol)</span><br></pre></td></tr></table></figure>

<p>SQLAlchemyManager 主要封装一些数据库账户配置信息、连接池信息。</p>
<p><strong>pool_size（连接池大小）：</strong> 指定连接池中允许保持的最大连接数。当应用程序需要访问数据库时，连接池会维护一定数量的数据库连接，以便快速地响应请求。通常情况下，pool_size 的值应该根据应用程序的并发访问量和数据库的性能来进行调整。</p>
<p><strong>pool_pre_ping（预检查连接）：</strong> 指定是否在数据库连接被使用前对连接进行预检查。预检查可以确保连接处于活动状态，并且可以自动重新连接到数据库服务器，以防止连接由于长时间空闲而失效。启用预检查可以提高应用程序对数据库的可靠性和稳定性。</p>
<p><strong>pool_recycle（连接回收时间）：</strong> 指定数据库连接在被重新使用之前的最大空闲时间。当连接空闲时间超过 pool_recycle 设置的值时，连接将被关闭并重新创建，以防止连接长时间处于空闲状态而导致的连接问题。pool_recycle 的值通常设置为一个较小的时间间隔，以确保连接能够及时地得到回收和重建，从而提高连接的健壮性和性能。</p>
<p><code>init_db_engine</code> 方法则是初始化数据库引擎，内部根据数据库配置信息</p>
<ul>
<li>构造异步的数据库引擎 <strong>db_engine</strong></li>
<li>维护一个 <strong>async_session_maker</strong> 数据库会话工厂</li>
</ul>
<h2 id="BaseORMTable-映射库表封装"><a href="#BaseORMTable-映射库表封装" class="headerlink" title="BaseORMTable 映射库表封装"></a>BaseORMTable 映射库表封装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from sqlalchemy import func</span><br><span class="line">from sqlalchemy.ext.asyncio import AsyncAttrs</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseOrmTable(AsyncAttrs, DeclarativeBase):</span><br><span class="line">    &quot;&quot;&quot;SQLAlchemy Base ORM Model&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __abstract__ = True</span><br><span class="line"></span><br><span class="line">    id: Mapped[int] = mapped_column(primary_key=True, comment=&quot;主键ID&quot;)</span><br><span class="line">    </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return str(self.to_dict())</span><br><span class="line"></span><br><span class="line">    def to_dict(self, alias_dict: dict = None, exclude_none=True) -&gt; dict:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        数据库模型转成字典</span><br><span class="line">        Args:</span><br><span class="line">            alias_dict: 字段别名字典 eg: &#123;&quot;id&quot;: &quot;user_id&quot;&#125;, 把id名称替换成 user_id</span><br><span class="line">            exclude_none: 默认排查None值</span><br><span class="line">        Returns: dict</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        alias_dict = alias_dict or &#123;&#125;</span><br><span class="line">        if exclude_none:</span><br><span class="line">            return &#123;</span><br><span class="line">                alias_dict.get(c.name, c.name): getattr(self, c.name)</span><br><span class="line">                for c in self.__table__.columns if getattr(self, c.name) is not None</span><br><span class="line">            &#125;</span><br><span class="line">        else:</span><br><span class="line">            return &#123;</span><br><span class="line">                alias_dict.get(c.name, c.name): getattr(self, c.name, None)</span><br><span class="line">                for c in self.__table__.columns</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TimestampColumns(AsyncAttrs, DeclarativeBase):</span><br><span class="line">    &quot;&quot;&quot;时间戳相关列&quot;&quot;&quot;</span><br><span class="line">    __abstract__ = True</span><br><span class="line"></span><br><span class="line">    created_at: Mapped[datetime] = mapped_column(default=datetime.now, comment=&quot;创建时间&quot;)</span><br><span class="line"></span><br><span class="line">    updated_at: Mapped[datetime] = mapped_column(default=datetime.now, onupdate=datetime.now, comment=&quot;更新时间&quot;)</span><br><span class="line"></span><br><span class="line">    deleted_at: Mapped[datetime] = mapped_column(nullable=True, comment=&quot;删除时间&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseOrmTableWithTS(BaseOrmTable, TimestampColumns):</span><br><span class="line">    __abstract__ = True</span><br></pre></td></tr></table></figure>

<p>创建一些基础的 ORM 类，以便后续的映射类可以继承并且共享一些公有属性和方法。</p>
<ol>
<li><code>BaseOrmTable</code> 类:</li>
</ol>
<pre><code>1. 定义了一个基础的 ORM 模型类，继承了 `AsyncAttrs` 和 `DeclarativeBase`。这样做使得 `BaseOrmTable` 类具有了异步属性访问的能力，为异步编程提供便利，特别是在异步环境中访问具有延迟加载或者异步加载特性的属性。
2. 提供了一个 `to_dict` 方法，用于将数据库模型转换为字典。它支持通过参数 `alias_dict` 指定字段别名，并且可以选择是否排除值为 None 的属性。</code></pre><ol start="2">
<li><code>TimestampColumns</code> 类:</li>
</ol>
<pre><code>1. 定义了一个包含时间戳相关列的抽象基类。这些列通常在很多数据库表中都会有，用于记录数据的创建时间、更新时间和删除时间。
2. 这些列被设置为默认值，比如 `created_at` 和 `updated_at` 默认使用 `datetime.now` 函数来自动记录当前时间，`deleted_at` 则允许为空，用于标记数据的删除时间（可用作于逻辑删除）</code></pre><ol start="3">
<li><code>BaseOrmTableWithTS</code> 类:</li>
</ol>
<pre><code>1. 继承了 `BaseOrmTable` 和 `TimestampColumns`，实际上是一个组合类，集成了基础的 ORM 功能和时间戳相关的列。
2. 这个类进一步封装了 `BaseOrmTable` 和 `TimestampColumns`，使得后续的映射类只需要继承这个类，就能够拥有基础的 ORM 功能和时间戳相关的列。</code></pre><p>通过这种封装，你可以在后续的数据库映射类中更加专注于业务逻辑的实现，而不需要重复编写基础的 ORM 功能和时间戳相关的列，提高了代码的重用性和可维护性。</p>
<h2 id="DBManager-数据库通用操作封装"><a href="#DBManager-数据库通用操作封装" class="headerlink" title="DBManager 数据库通用操作封装"></a>DBManager 数据库通用操作封装</h2><h3 id="前置封装说明"><a href="#前置封装说明" class="headerlink" title="前置封装说明"></a>前置封装说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import Any, List, Type, TypeVar, Union</span><br><span class="line">from py_tools.connections.db.mysql import BaseOrmTable</span><br><span class="line">from py_tools.meta_cls import SingletonMetaCls</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># 泛指 BaseOrmTable 所有子类实例对象类型   </span><br><span class="line">T_BaseOrmTable = TypeVar(&quot;T_BaseOrmTable&quot;, bound=BaseOrmTable)</span><br><span class="line">T_Hints = TypeVar(&quot;T_Hints&quot;)  # 用于修复被装饰的函数参数提示，让IDE有类型提示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def with_session(method) -&gt; T_Hints:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    兼容事务会话</span><br><span class="line">    Args:</span><br><span class="line">        method: orm 的 crud</span><br><span class="line"></span><br><span class="line">    Notes:</span><br><span class="line">        方法中没有带事务连接则，则构造</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    @functools.wraps(method)</span><br><span class="line">    async def wrapper(db_manager, *args, **kwargs):</span><br><span class="line">        session = kwargs.get(&quot;session&quot;) or None</span><br><span class="line">        if session:</span><br><span class="line">            return await method(db_manager, *args, **kwargs)</span><br><span class="line">        else:</span><br><span class="line">            async with db_manager.transaction() as session:</span><br><span class="line">                kwargs[&quot;session&quot;] = session</span><br><span class="line">                return await method(db_manager, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>

<p>这里我提供了一个 <strong>with_session</strong> 装饰器，用于在需要数据库会话（事务）的数据库操作方法中自动开启事务，由于 sqlaichemy 官方推荐每个数据库操作都手动开启事务会话（自动提交），装饰器的设计没有时则构造，有则共享，这样不但可以减少冗余 <strong>async with db_manager.transaction() as session</strong> 的代码，也可以兼容多个操作共享同一个 session 有问题时进行事务回滚。</p>
<p>由于给方法加了通用的装饰器导致一些版本的IDE无法识别方法真实的签名，使用时会出现不知道方法的入参是什么，对于开发者来说是极其不方便的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a1896230aace0636723f3562595c0e657c60cb0d26038b648b334f435662a0e1" alt></p>
<p>使用 typing 的 TypeVar 自定义类型来构造一个通用的泛型来当作函数返回的类型，进而修复。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import TypeVar</span><br><span class="line">T_Hints = TypeVar(&quot;T_Hints&quot;)  # 用于修复被装饰的函数参数提示，让IDE有类型提示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def with_session(method) -&gt; T_Hints:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8514e25ac87eda48a1b8e34edad9ff6d6080ecf9aa13037ffbc3619ac05cf82a" alt></p>
<p>这里PyCharm 2023.2.4 版本升级到 2024.1 就有提示了，IDE修复了，可以不用 T_Hints 了。</p>
<p>一些旧版本构造 sqlaichemy 的库表对象时也会出现不知道类对象属性入参提示，升级到最新版本都解决了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from contextlib import asynccontextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DBManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_CLIENT: SQLAlchemyManager = None</span><br><span class="line">    orm_table: Type[BaseOrmTable] = None</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def init_db_client(cls, db_client: SQLAlchemyManager):</span><br><span class="line">        cls.DB_CLIENT = db_client</span><br><span class="line">        return cls.DB_CLIENT</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    @asynccontextmanager</span><br><span class="line">    async def transaction(cls):</span><br><span class="line">        &quot;&quot;&quot;事务上下文管理器&quot;&quot;&quot;</span><br><span class="line">        async with cls.DB_CLIENT.async_session_maker.begin() as session:</span><br><span class="line">            yield session</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    @asynccontextmanager</span><br><span class="line">    async def connection(cls) -&gt; AsyncIterator[AsyncConnection]:</span><br><span class="line">        &quot;&quot;&quot;数据库引擎连接上下文管理器&quot;&quot;&quot;</span><br><span class="line">        async with cls.DB_CLIENT.db_engine.begin() as conn:</span><br><span class="line">            yield conn</span><br></pre></td></tr></table></figure>

<ul>
<li>init_db_client 方法用于初始化数据库客户端（引擎）。</li>
<li>transaction 则是简单的通过 contextlib 中 asynccontextmanager 封装一个异步的上下文管理器方便简洁的开启一个数据库会话（事务）进行数据库相关操作。</li>
<li>connection 数据库引擎连接上下文管理器。</li>
<li>orm_table 是具体继承 DBManager 的子类进行指定的，用于操作具体的库表（orm_table）。</li>
<li>DBManager 通过 SingletonMetaCls 元类实现单例模式。具体单例模式可以了解 <a href="https://dev.newban.cn/7272006755265380367">juejin.cn/post/727200…</a> 这篇文章有详细的介绍。</li>
</ul>
<h3 id="DB添加操作封装"><a href="#DB添加操作封装" class="headerlink" title="DB添加操作封装"></a>DB添加操作封装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">class DBManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_CLIENT: SQLAlchemyManager = None</span><br><span class="line">    orm_table: Type[BaseOrmTable] = None</span><br><span class="line"></span><br><span class="line">    @with_session</span><br><span class="line">    async def bulk_add(</span><br><span class="line">            self,</span><br><span class="line">            table_objs: List[Union[T_BaseOrmTable, dict]],</span><br><span class="line">            *,</span><br><span class="line">            orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">            flush: bool = False,</span><br><span class="line">            session: AsyncSession = None</span><br><span class="line">    ) -&gt; List[T_BaseOrmTable]:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        批量插入</span><br><span class="line">        Args:</span><br><span class="line">            table_objs: orm映射类实例列表</span><br><span class="line">                eg.[UserTable(username=&quot;hui&quot;, age=18), ...] or [&#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;, ...]</span><br><span class="line">            orm_table: orm表映射类</span><br><span class="line">            flush: 刷新对象状态，默认不刷新</span><br><span class="line">            session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            成功插入的对象列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        orm_table = orm_table or self.orm_table</span><br><span class="line">        if all(isinstance(table_obj, dict) for table_obj in table_objs):</span><br><span class="line">            # 字典列表转成orm映射类实例列表处理</span><br><span class="line">            table_objs = [orm_table(**table_obj) for table_obj in table_objs]</span><br><span class="line">    </span><br><span class="line">        session.add_all(table_objs)</span><br><span class="line">        if flush:</span><br><span class="line">            await session.flush(table_objs)</span><br><span class="line">    </span><br><span class="line">        return table_objs</span><br><span class="line">    </span><br><span class="line">    @with_session</span><br><span class="line">    async def add(</span><br><span class="line">            self,</span><br><span class="line">            table_obj: [T_BaseOrmTable, dict],</span><br><span class="line">            *,</span><br><span class="line">            orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">            session: AsyncSession = None</span><br><span class="line">     ) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        插入一条数据</span><br><span class="line">        Args:</span><br><span class="line">            table_obj: orm映射类实例对象, eg. UserTable(username=&quot;hui&quot;, age=18) or &#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">            orm_table: orm表映射类</span><br><span class="line">            session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">        Returns: 新增的id</span><br><span class="line">            table_obj.id</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        orm_table = orm_table or self.orm_table</span><br><span class="line">        if isinstance(table_obj, dict):</span><br><span class="line">            table_obj = orm_table(**table_obj)</span><br><span class="line">            </span><br><span class="line">        session.add(table_obj)</span><br><span class="line">        await session.flush(objects=[table_obj])  # 刷新对象状态，获取新增的id</span><br><span class="line">        return table_obj.id</span><br></pre></td></tr></table></figure>

<p>这里就是用 session.add 与 add_all 方法封装了数据库添加、批量添加的操作，封装的点主要在于除了 orm_table 实例对象入参还支持字典入参，内部还是转换成库表映射类实例来操作，最后通过 session.flush 方法，单个添加返回新增的主键id，批量添加则是返回实例对象列表。</p>
<p>设计的方法中有一个 * 号是参数的分隔符，它的作用是将其前面的参数声明为位置参数，而将 * 后面的参数声明为关键字参数，* 号后面的参数入参只能使用关键字形式的入参，我在很多的开源库中都看到了这样的设计，可以把一些函数语义连贯、常用必传的参数设置为位置参数，其他的则是关键字参数。这样可以明确参数的作用、提高函数的可读性、防止参数错误等。</p>
<p>具体看下使用案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">from sqlalchemy import String</span><br><span class="line">from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line">from py_tools.connections.db.mysql import BaseOrmTableWithTS, BaseOrmTable, DBManager, SQLAlchemyManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserTable(BaseOrmTableWithTS):</span><br><span class="line">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    username: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户昵称&quot;)</span><br><span class="line">    password: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户密码&quot;)</span><br><span class="line">    phone: Mapped[str] = mapped_column(String(11), default=&quot;&quot;, comment=&quot;手机号&quot;)</span><br><span class="line">    email: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;邮箱&quot;)</span><br><span class="line">    avatar: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;头像&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def create_tables():</span><br><span class="line">    # 根据映射创建库表（异步）</span><br><span class="line">    # async with db_engine.begin() as conn:</span><br><span class="line">    #    await conn.run_sync(BaseOrmTable.metadata.create_all)</span><br><span class="line">    </span><br><span class="line">    async with DBManager.connection() as conn:</span><br><span class="line">        await conn.run_sync(BaseOrmTable.metadata.create_all)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def init_orm_manager():</span><br><span class="line">    db_client = SQLAlchemyManager(</span><br><span class="line">        host=&quot;127.0.0.1&quot;,</span><br><span class="line">        port=3306,</span><br><span class="line">        user=&quot;root&quot;,</span><br><span class="line">        password=&quot;123456&quot;,</span><br><span class="line">        db_name=&quot;hui-demo&quot;,</span><br><span class="line">    )</span><br><span class="line">    db_client.init_mysql_engine()</span><br><span class="line">    DBManager().init_db_client(db_client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def manager_crud():</span><br><span class="line">    user = &#123;&quot;username&quot;: &quot;hui&quot;, &quot;email&quot;: &quot;huidbk.163.com&quot;&#125;</span><br><span class="line">    user_id = await DBManager().add(table_obj=user, orm_table=UserTable)</span><br><span class="line">    print(&quot;user_id&quot;, user_id)</span><br><span class="line"></span><br><span class="line">    users = [</span><br><span class="line">        &#123;&quot;username&quot;: &quot;zack&quot;, &quot;email&quot;: &quot;zack.163.com&quot;&#125;,</span><br><span class="line">        &#123;&quot;username&quot;: &quot;wang&quot;, &quot;email&quot;: &quot;wang.163.com&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">    add_users = await DBManager().bulk_add(table_objs=users, orm_table=UserTable)</span><br><span class="line">    add_user_ids = [user.id for user in add_users]</span><br><span class="line">    print(&quot;add_user_ids&quot;, add_user_ids)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    await create_tables()</span><br><span class="line"></span><br><span class="line">    # await normal_crud()</span><br><span class="line"></span><br><span class="line">    await init_orm_manager()</span><br><span class="line"></span><br><span class="line">    await manager_crud()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 运行主函数</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a077f583e2a48a0e4e6db698dfd1d53fe7ec47de05dc69c24a37afaac6ea120c" alt></p>
<p>在程序启动时初始化好DBManager 的 DB_CLIENT 就可以直接使用封装的方法，主要就是 DB_CLIENT 作为类属性，后面DBManager 实例与子类实例对象都可以共享这个数据库引擎。但我这里还是不推荐上面的写法，DBManager 是一些通用的DB操作，而具体一些业务操作还是单独封装一些DB业务Manager类来进行会比较好，更利于扩展维护与复用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class UserManager(DBManager):</span><br><span class="line">    orm_table = UserTable</span><br><span class="line"></span><br><span class="line">    async def get_name_by_email(self, email):</span><br><span class="line">        username = await self.query_one(cols=[&quot;username&quot;], conds=[self.orm_table.email == email], flat=True)</span><br><span class="line">        return username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def manager_crud():</span><br><span class="line"></span><br><span class="line">    # demo 2 （推荐）</span><br><span class="line">    user = UserTable(username=&quot;hui-test01&quot;, email=&quot;hui-test01.163.com&quot;)</span><br><span class="line">    user_id = await UserManager().add(table_obj=user)</span><br><span class="line">    print(&quot;user_id&quot;, user_id)</span><br><span class="line"></span><br><span class="line">    users = [</span><br><span class="line">        UserTable(username=&quot;hui-test02&quot;, email=&quot;hui-test02.163.com&quot;),</span><br><span class="line">        UserTable(username=&quot;hui-test03&quot;, email=&quot;hui-test03.163.com&quot;),</span><br><span class="line">    ]</span><br><span class="line">    add_users = await UserManager().bulk_add(table_objs=users)</span><br><span class="line">    add_user_ids = [user.id for user in add_users]</span><br><span class="line">    print(&quot;add_user_ids&quot;, add_user_ids)</span><br><span class="line">    </span><br><span class="line">    username = await UserManager().get_name_by_email(email=&quot;huidbk.163.com&quot;)</span><br><span class="line">    print(&quot;username&quot;, username)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">user_id 4</span><br><span class="line">add_user_ids [5, 6]</span><br><span class="line">username hui</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee698e1969ca8f266b2fcb2bacdd01697f3d61738867b9d5f70d41e113721239" alt></p>
<p>这里 <strong>UserManager</strong> 单独封装的 <strong>get_name_by_email</strong> 的方法就是业务中常用查询操作通过邮件获取用户名称，这里就是举一个简单的例子，具体DB业务具体封装而不是全部写在逻辑层，这样别人要用的时候就不用重新组织条件参数、上下文，而是简单传递业务参数进行复用获取数据。</p>
<p>UserManager 调用 add、bulk_add 等方法时也不用像 DBManager 指定 orm_table 参数，使用起来更简洁。具体是因为 UserManager 类指定了 类属性 orm_table = UserTable，再封装时有一句 <strong>orm_table = orm_table or self.orm_table</strong> 意思就是优先选择入参的orm_table，没有则是 self.orm_table （具体实例对象的orm_table）。这样写也体现出 封装、继承的灵活性。</p>
<p>这里也引出了另一个封装方法 <strong>query_one</strong> 查询单条数据。由于介绍了一些Demo如果把所有的封装方法混合到一起篇幅就太长，故而我准备分成三篇进行分别介绍，这样也更好阅读。</p>
<ol>
<li><a href="https://dev.newban.cn/7357703852726911016">SQLAIchemy 异步DBManager封装-01入门理解</a></li>
<li><a href="https://dev.newban.cn/7357957809072619554">SQLAIchemy 异步DBManager封装-02熟悉掌握</a></li>
<li><a href="https://dev.newban.cn/7358352353295106088">SQLAIchemy 异步DBManager封装-03得心应手</a></li>
</ol>
<h1 id="Github源代码"><a href="#Github源代码" class="headerlink" title="Github源代码"></a>Github源代码</h1><p>源代码已上传到了Github，里面也有具体的使用Demo，欢迎大家一起体验、贡献。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357703852726911016" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring配置类解析与Bean扫描过程源码分析一、注册C</title>
    <url>/7357917500964012042.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[TOC]</p>
<h1 id="一、注册ConfigurationClassPostProcessor"><a href="#一、注册ConfigurationClassPostProcessor" class="headerlink" title="一、注册ConfigurationClassPostProcessor"></a>一、注册ConfigurationClassPostProcessor</h1><p>Spring启动之前，构造AnnotatedBeanDefinitionReader（主要作用添加一些基础的PostProcessor，同时可以通过reader进行BeanDefinition的注册），同时对BeanFactory进行设置和添加PostProcessor（后置处理器）。</p>
<p>此时，会向BeanFactory中添加<code>ConfigurationClassPostProcessor</code>对应的BeanDefinition。</p>
<p><code>ConfigurationClassPostProcessor</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>接口，并实现了<code>postProcessBeanDefinitionRegistry</code>和<code>postProcessBeanFactory</code>方法。</p>
<p>当Spring容器调用invokeBeanFactoryPostProcessors方法时，就会执行<code>ConfigurationClassPostProcessor</code>的<code>BeanDefinitionRegistryPostProcessor</code>方法与<code>postProcessBeanFactory</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,</span><br><span class="line">		PriorityOrdered, ResourceLoaderAware, ApplicationStartupAware, BeanClassLoaderAware, EnvironmentAware &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		int registryId = System.identityHashCode(registry);</span><br><span class="line">		if (this.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);</span><br><span class="line">		&#125;</span><br><span class="line">		this.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">		processConfigBeanDefinitions(registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		int factoryId = System.identityHashCode(beanFactory);</span><br><span class="line">		if (this.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		this.factoriesPostProcessed.add(factoryId);</span><br><span class="line">		if (!this.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">			// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span><br><span class="line">			// Simply call processConfigurationClasses lazily at this point then.</span><br><span class="line">			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		enhanceConfigurationClasses(beanFactory);</span><br><span class="line">		beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、postProcessBeanDefinitionRegistry方法"><a href="#二、postProcessBeanDefinitionRegistry方法" class="headerlink" title="二、postProcessBeanDefinitionRegistry方法"></a>二、postProcessBeanDefinitionRegistry方法</h1><h2 id="1、processConfigBeanDefinitions方法"><a href="#1、processConfigBeanDefinitions方法" class="headerlink" title="1、processConfigBeanDefinitions方法"></a>1、processConfigBeanDefinitions方法</h2><p>该方法调用了<code>ConfigurationClassUtils.checkConfigurationClassCandidate</code>方法，判断一个类是否是配置类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码// org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate</span><br><span class="line">public static boolean checkConfigurationClassCandidate(</span><br><span class="line">		BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) &#123;</span><br><span class="line"></span><br><span class="line">	String className = beanDef.getBeanClassName();</span><br><span class="line">	if (className == null || beanDef.getFactoryMethodName() != null) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AnnotationMetadata metadata;</span><br><span class="line">	if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">			className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">		// Can reuse the pre-parsed metadata from the given BeanDefinition...</span><br><span class="line">		metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">	&#125;</span><br><span class="line">	else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;</span><br><span class="line">		// Check already loaded Class if present...</span><br><span class="line">		// since we possibly can&apos;t even load the class file for this Class.</span><br><span class="line">		Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();</span><br><span class="line">		if (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				BeanPostProcessor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				AopInfrastructureBean.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				EventListenerFactory.class.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">			metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; +</span><br><span class="line">						className, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line">	if (config != null &amp;&amp; !Boolean.FALSE.equals(config.get(&quot;proxyBeanMethods&quot;))) &#123;</span><br><span class="line">		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (config != null || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// It&apos;s a full or lite configuration candidate... Let&apos;s determine the order value, if any.</span><br><span class="line">	Integer order = getOrder(metadata);</span><br><span class="line">	if (order != null) &#123;</span><br><span class="line">		beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring认为，包含@Component、@ComponentScan、@Import、@ImportResource、@Bean方法的类，属于轻配置类。<br>而加了@Configuration的类属于full配置类。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/989ad853210c248013854c33f0c9bf160b61166cabcdec19ddb8cacf03685e5f" alt="在这里插入图片描述"></p>
<h2 id="2、流程梳理"><a href="#2、流程梳理" class="headerlink" title="2、流程梳理"></a>2、流程梳理</h2><p>1、在启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装为一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。</p>
<p>2、ConfigurationClassPostProcessor中会把配置类BeanDefinition取出来</p>
<p>3、构造一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass</p>
<p>4、如果配置类上存在@Component注解，那么解析配置类中的内部类（这里有递归，如果内部类也是配置类的话）</p>
<p>5、如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去</p>
<p>6、如果配置类上存在@ComponentScan注解，那么则解析该注解，进行扫描，扫描得到一系列的BeanDefinition对象，然后判断这些BeanDefinition是不是也是配置类BeanDefinition（只要存在@Component注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，（也有递归），并且会生成对应的ConfigurationClass</p>
<p>7、如果配置类上存在@Import注解，那么则判断Import的类的类型：<br>如果是ImportSelector，那么调用执行selectImports方法得到类名，然后在把这个类当做配置类进行解析**（也是递归）**<br>如果是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的importBeanDefinitionRegistrars属性中。</p>
<p>8、如果配置类上存在@ImportResource注解，那么则把导入进来的资源路径存在配置类对象中的importedResources属性中。</p>
<p>9、如果配置类中存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的beanMethods属性中。</p>
<p>10、如果配置类实现了某些接口，则看这些接口内是否定义了@Bean的默认方法</p>
<p>11、如果配置类有父类，则把父类当做配置类进行解析</p>
<p>12、AppConfig这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass<br>如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition<br>如果ConfigurationClass中存在一些BeanMethod，也就是定义了一些@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册<br>如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition<br>如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e22f346d35a4a87f9ad9b3ec9d304c049fa7ffcb5d4ec8761411b7e3953bbffc" alt="在这里插入图片描述"><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c5205ac788d613cee53f69c6abb061da4b6a5bddb97cd036eb8223b7bfd35b3" alt="在这里插入图片描述"></p>
<h2 id="3、postProcessBeanFactory方法"><a href="#3、postProcessBeanFactory方法" class="headerlink" title="3、postProcessBeanFactory方法"></a>3、postProcessBeanFactory方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码// org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses</span><br><span class="line">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	StartupStep enhanceConfigClasses = this.applicationStartup.start(&quot;spring.context.config-classes.enhance&quot;);</span><br><span class="line">	Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();</span><br><span class="line">	for (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">		BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">		Object configClassAttr = beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE);</span><br><span class="line">		AnnotationMetadata annotationMetadata = null;</span><br><span class="line">		MethodMetadata methodMetadata = null;</span><br><span class="line">		if (beanDef instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">			AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDef;</span><br><span class="line">			annotationMetadata = annotatedBeanDefinition.getMetadata();</span><br><span class="line">			methodMetadata = annotatedBeanDefinition.getFactoryMethodMetadata();</span><br><span class="line">		&#125;</span><br><span class="line">		if ((configClassAttr != null || methodMetadata != null) &amp;&amp; beanDef instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">			// Configuration class (full or lite) or a configuration-derived @Bean method</span><br><span class="line">			// -&gt; eagerly resolve bean class at this point, unless it&apos;s a &apos;lite&apos; configuration</span><br><span class="line">			// or component class without @Bean methods.</span><br><span class="line">			AbstractBeanDefinition abd = (AbstractBeanDefinition) beanDef;</span><br><span class="line">			if (!abd.hasBeanClass()) &#123;</span><br><span class="line">				boolean liteConfigurationCandidateWithoutBeanMethods =</span><br><span class="line">						(ConfigurationClassUtils.CONFIGURATION_CLASS_LITE.equals(configClassAttr) &amp;&amp;</span><br><span class="line">							annotationMetadata != null &amp;&amp; !ConfigurationClassUtils.hasBeanMethods(annotationMetadata));</span><br><span class="line">				if (!liteConfigurationCandidateWithoutBeanMethods) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						abd.resolveBeanClass(this.beanClassLoader);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new IllegalStateException(</span><br><span class="line">								&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line">			if (!(beanDef instanceof AbstractBeanDefinition)) &#123;</span><br><span class="line">				throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition &apos;&quot; +</span><br><span class="line">						beanName + &quot;&apos; since it is not stored in an AbstractBeanDefinition subclass&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (logger.isInfoEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">				logger.info(&quot;Cannot enhance @Configuration bean definition &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; since its singleton instance has been created too early. The typical cause &quot; +</span><br><span class="line">						&quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +</span><br><span class="line">						&quot;return type: Consider declaring such methods as &apos;static&apos;.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (configBeanDefs.isEmpty() || NativeDetector.inNativeImage()) &#123;</span><br><span class="line">		// nothing to enhance -&gt; return immediately</span><br><span class="line">		enhanceConfigClasses.end();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 代理</span><br><span class="line">	ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();</span><br><span class="line">	for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">		AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">		// If a @Configuration class gets proxied, always proxy the target class</span><br><span class="line">		beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">		// Set enhanced subclass of the user-specified bean class</span><br><span class="line">		Class&lt;?&gt; configClass = beanDef.getBeanClass();</span><br><span class="line">		Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);</span><br><span class="line">		if (configClass != enhancedClass) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(String.format(&quot;Replacing bean definition &apos;%s&apos; existing class &apos;%s&apos; with &quot; +</span><br><span class="line">						&quot;enhanced class &apos;%s&apos;&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));</span><br><span class="line">			&#125;</span><br><span class="line">			beanDef.setBeanClass(enhancedClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enhanceConfigClasses.tag(&quot;classCount&quot;, () -&gt; String.valueOf(configBeanDefs.keySet().size())).end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类，如果是full的配置类，会生成一个代理类。</p>
<p>我们看<code>enhancer.enhance</code>生成的代理对象：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0ee5d5f5b43ff380d3df48b5ab9a42dc60edd4155d4636243afe9c0950b89fe6" alt="在这里插入图片描述"><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7034dcf7d77fed6fabd787aabf14a07ff35138708151a744e6798fdc9157beb2" alt="在这里插入图片描述"><br>我们看一下BeanMethodInterceptor的代理方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码// org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor#intercept</span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span><br><span class="line">			MethodProxy cglibMethodProxy) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">	ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">	String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line">	// Determine whether this bean is a scoped-proxy</span><br><span class="line">	if (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">		String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line">		if (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">			beanName = scopedBeanName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// To handle the case of an inter-bean method reference, we must explicitly check the</span><br><span class="line">	// container for already cached instances.</span><br><span class="line"></span><br><span class="line">	// First, check to see if the requested bean is a FactoryBean. If so, create a subclass</span><br><span class="line">	// proxy that intercepts calls to getObject() and returns any cached bean instance.</span><br><span class="line">	// This ensures that the semantics of calling a FactoryBean from within @Bean methods</span><br><span class="line">	// is the same as that of referring to a FactoryBean within XML. See SPR-6602.</span><br><span class="line">	if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">			factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">		Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">		if (factoryBean instanceof ScopedProxyFactoryBean) &#123;</span><br><span class="line">			// Scoped proxy factory beans are a special case and should not be further proxied</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// It is a candidate FactoryBean - go ahead with enhancement</span><br><span class="line">			return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 代理类执行某个方法的时候，会判断正在执行的方法是不是正在创建Bean的方法</span><br><span class="line">	if (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">		// The factory is calling the bean method in order to instantiate and register the bean</span><br><span class="line">		// (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually</span><br><span class="line">		// create the bean instance.</span><br><span class="line">		if (logger.isInfoEnabled() &amp;&amp;</span><br><span class="line">				BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">			logger.info(String.format(&quot;@Bean method %s.%s is non-static and returns an object &quot; +</span><br><span class="line">							&quot;assignable to Spring&apos;s BeanFactoryPostProcessor interface. This will &quot; +</span><br><span class="line">							&quot;result in a failure to process annotations such as @Autowired, &quot; +</span><br><span class="line">							&quot;@Resource and @PostConstruct within the method&apos;s declaring &quot; +</span><br><span class="line">							&quot;@Configuration class. Add the &apos;static&apos; modifier to this method to avoid &quot; +</span><br><span class="line">							&quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;,</span><br><span class="line">					beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">		&#125;</span><br><span class="line">		// 直接执行该方法</span><br><span class="line">		return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就意味着，同一个代理配置类中调用@Bean的方法，相当于获取了同一个Bean。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/27f2cfb42202cd0d5deea476fbc02702a79c148f76ee3f4dfdf0d3354309f5a8" alt="在这里插入图片描述"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>JFR：<br><a href="https://zhuanlan.zhihu.com/p/122247741" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/122247741</a></p>
<p>@LookUp注解</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357917500964012042" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入探索垃圾收集</title>
    <url>/7357917500963373066.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><em>垃圾收集是应对应用程序内存管理挑战的主要方式之一，本文介绍了业界主流的垃圾收集算法（以Java为主），比较了不同算法的优劣、适用场景，对于研发团队选择适合业务场景的垃圾收集算法提供了很好的参考。原文: <a href="https://itnext.io/in-depth-exploration-of-garbage-collector-gc-828fcef9fe5d" target="_blank" rel="noopener">In-depth Exploration of Garbage Collector (GC)</a></em></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4dd5cda7cb94438d96365d04c0ec82173adad4c1c0861bb5604321bf8bf9bf47" alt="垃圾收集周期概览"></p>
<h4 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h4><p>在 C 或 C++ 等传统编程语言中，由开发人员负责为对象或数据结构显式分配、释放内存。</p>
<p>但是手动管理内存容易出错，导致内存泄漏（分配的内存未释放）或野指针（指针引用已被释放的内存）等错误，而这些问题会造成软件不稳定或不安全。</p>
<p>垃圾回收通过自动化内存管理过程来应对这些挑战。垃圾回收器不需要开发人员手动分配和释放内存，而是自动识别和回收程序无法再访问或引用的内存。</p>
<p>垃圾回收算法的复杂程度和实现方式各不相同，不同编程语言和运行环境可能会使用不同的垃圾回收策略。</p>
<p>虽然垃圾回收有很多好处，如自动内存管理、防止与内存相关的错误，但也会给 CPU 和内存使用造成额外开销。</p>
<p>本文旨在探讨不同垃圾收集算法，研究其内部工作原理、优点和局限性。</p>
<p>从而有助于我们选择合适的算法和配置，使我们能够更高效的编写代码。</p>
<h4 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h4><h5 id="程序运行内存"><a href="#程序运行内存" class="headerlink" title="程序运行内存"></a>程序运行内存</h5><p>运行中程序的典型内存布局如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6865f871acca789bf2c30372e5318a8da4876e0183e4023de2f65d3d9b6db86c" alt="违反内存安全。如何避免内存问题？| 作者：Héla Ben Khalfallah | Better Programming"></p>
<p>在程序运行期间，<strong>静态内存（Static memory）</strong> 用于存储全局变量或使用static关键字声明的变量。</p>
<p><strong>栈（Stack）</strong> 是计算机程序临时存放数据的指定内存区域，是一个连续内存块，在函数调用期间存储数据，并在函数结束后清除。</p>
<p>栈内存遵循<strong>后进先出（LIFO，Last-In-First-Out）</strong> 原则，即最新放入栈的条目将被最先移除。</p>
<p>在函数调用时，程序会生成一个称为<strong>栈帧（Stack Frame）</strong> 的新元素，然后将其推入该特定函数调用的栈中。</p>
<p>栈帧包括：</p>
<ul>
<li>函数局部变量。</li>
<li>传递给函数的参数。</li>
<li>返回地址，指示程序在函数结束后继续执行的位置。</li>
<li>附加元素，如前一帧的基本指针。</li>
</ul>
<p>函数执行完毕后，其<strong>栈帧</strong>将被移除，控制权将转回到帧内指示的返回地址。</p>
<p>请记住，<strong>栈</strong>内存的容量是有限的，一旦用完，就会发生<strong>栈溢出（Stack Overflow）</strong>，导致程序失败。因此，<strong>栈</strong>并不适合存储大量数据。</p>
<p>此外，<strong>栈</strong>不允许内存块在分配后调整大小。例如，如果我们为<strong>栈</strong>上的数组分配的内存太少，就无法像动态分配内存那样调整其大小。</p>
<p>这些因素促成了堆内存的发明。</p>
<p><strong>堆（Heap）</strong> 是指定用于动态内存分配的计算机内存区域。与<strong>栈</strong>内存自动管理不同，<strong>堆</strong>内存需要手动管理，通过 <code>malloc</code> 等方法分配内存，用 <code>free</code> 等方法释放内存。</p>
<p><strong>堆</strong>上的对象是通过<strong>引用（references）</strong> 访问的，引用是指向这些对象的<strong>指针（pointers）</strong>。对象在<strong>堆</strong>空间中实例化，而<strong>栈</strong>内存则保存对象的引用：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f82fbbc00f9cf3d3738e7c2a6a192abf355437ec97d5afecbf6c5eda1db674cc" alt="准备深入学习 Java 内存管理：垃圾回收器 - CodersTea"></p>
<p><strong>堆</strong>常用于以下场景：</p>
<ul>
<li>数据结构（如数组或对象）所需的内存只有在运行时才能确定（动态分配）。</li>
<li>数据的保留时间必须超过单次函数调用的持续时间。</li>
<li>将来有可能需要调整所分配内存的大小。</li>
</ul>
<p>本文后续内容的重点将放在<strong>堆</strong>内存的管理上。</p>
<h5 id="垃圾收集器的出现"><a href="#垃圾收集器的出现" class="headerlink" title="垃圾收集器的出现"></a>垃圾收集器的出现</h5><p>堆对象占用的内存可以通过显式删除分配（使用 C 的 <code>free</code> 或 C++ 的 <code>delete</code> 等操作）进行<strong>手动</strong>回收，也可以由运行时系统通过<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener">引用计数</a>或<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">垃圾回收</a>实现<strong>自动</strong>回收。</p>
<p>手动内存管理可能会导致两种主要的编程错误：</p>
<p>🔴第一种情况是在内存引用仍然存在的情况下过早释放内存，造成所谓的<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="noopener">野指针</a>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/19351473bcde8554a9788f011c6d14f2382a81e0ce64db94eb06b5f46579eb0b" alt="什么是悬空指针，在 c 语言中如何使用？— Quora"></p>
<p>🔴 第二种情况是可能无法释放程序不再需要的对象，造成<a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank" rel="noopener">内存泄漏</a>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b741926caccf9dbd6e9dbfa2e158dc6698fa3c8ca82a7931a395d26b0d3f1374" alt="内存泄露 - 通过 Kotlin 掌握高性能(oreilly.com)"></p>
<p>在并发编程中，这些问题变得更加复杂，因为多个线程可能会同时引用同一个对象。</p>
<p>因此，有必要对各种方法进行评估和重组，从而打造自动内存管理。</p>
<p>简单来说，自动内存管理可以看作是对手动内存管理的重构：</p>
<p>☑️ 内存管理集中在垃圾回收器这一单一工具中，由<strong>运行时控制</strong>（通常由虚拟机控制）。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b143de45fba2a658f5ee25ec48f3b1b9b6cc9c74e4a52e0b8b61ada7546f6cc6" alt="Java 垃圾回收基础 (oracle.com)"></p>
<p>☑️ 垃圾收集器的内存管理方法简化了手动释放内存的过程，使代码更易于阅读和维护。</p>
<p>☑️ 内存调试和分析变得更加高效。</p>
<p>☑️ 垃圾收集器和自动内存管理算法的升级变得可扩展、通用和高效。</p>
<p>垃圾回收器里有什么秘密？接下来我们将进一步探讨！</p>
<h4 id="垃圾收集器概述"><a href="#垃圾收集器概述" class="headerlink" title="垃圾收集器概述"></a>垃圾收集器概述</h4><p>垃圾收集器（GC）是一个定期触发的后台程序，能自动释放不再使用的对象所占用的内存，从而使内存满足应用程序的未来需求。</p>
<p>GC 如何识别未使用的对象？</p>
<p>垃圾收集器（GC）通过定位那些不再被运行程序的任何部分引用的对象来识别未使用的对象。如果一个对象没有任何活跃引用，就会被认为是死对象，可以被收集，从而释放内存。</p>
<p>堆不仅可以被局部变量引用，也可以被全局变量和静态变量、线程栈（被线程的执行栈引用的对象）和常量池（存储程序使用的常量值）引用。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/983fad1e7fbede26b4a8d49be2bfcd25ba0a249085a0b5b514625937a4bfb43b" alt="Java 中的垃圾回收 (2) (javacodegeeks.com)"></p>
<p>任何持有<strong>堆</strong>对象但不在<strong>堆</strong>中的指针（引用）都可以称为<strong>根（root）</strong>，垃圾回收利用这些<strong>根</strong>来确定对象是否有效。如果某个对象可以被任意一个<strong>根</strong>直接访问或临时访问，那么就不会被视为垃圾对象。如果无法访问，则视为垃圾，需要进行收集。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5fbfc71221bf6f914ecd88ff67987e263f61348731c91d4e0d48f5e031121ff3" alt="垃圾收集方法 - Hyperskill"></p>
<p>托管内存系统由在堆中运行的突变器（mutator）和垃圾回收器组成：</p>
<ul>
<li><strong>突变器</strong>是修改堆对象的程序（应用程序）。</li>
<li><strong>突变器</strong>通过分配器<strong>申请</strong>堆内存，而<strong>收集器</strong>则负责<strong>回收</strong>堆内存。</li>
<li>内存<strong>分配器</strong>和垃圾回收器合作管理堆内存空间。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e4ce9687f3cf2db664492e859e24ac80835520dc2b4cdffa7b800cb96a7329f5" alt="编写内存分配器 - Dmitry Soshnikov"></p>
<p>垃圾回收器的基本特征包括：</p>
<ul>
<li>最短的整体执行时间（吞吐量）。</li>
<li>优化空间使用（内存开销）。</li>
<li>停顿时间最少（尤其是实时任务）。</li>
<li>改进突变器的定位。</li>
<li>可扩展性。</li>
</ul>
<p>垃圾收集器所使用的各种算法在方法、优化和利弊方面各不相同，因此上述特性也会受到影响。</p>
<p>在接下来的章节中，我们将研究不同的算法，以确定它们的优势、局限性和在现实世界中的潜在用途。</p>
<p>开始！</p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><h5 id="工作原理和算法"><a href="#工作原理和算法" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p>Mark-Sweep 原始算法是由<a href="https://groups.seas.harvard.edu/courses/cs252/2016fa/16.pdf" target="_blank" rel="noopener">约翰-麦卡锡（John McCarthy）于 1960 年为 Lisp 引入</a>，基于某种STW（stop-the-world）机制。当程序请求内存但没有可用内存时，程序会被停止，并执行一次完整的垃圾回收以释放空间。</p>
<p>Mark-Sweep GC 的运行可概括为以下几个阶段：</p>
<p>1️⃣第一步是提取并准备根列表。根可能是局部变量、全局变量、静态变量或线程栈中引用的变量。</p>
<p>2️⃣ 确定所有根节点后，就进入<strong>标记阶段（mark phase）</strong>。标记阶段需要对根节点进行<a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">深度优先搜索（DFS）</a>遍历，目的是将根节点可到达的所有节点标记为活跃节点。</p>
<blockquote>
<p>许多垃圾收集算法在收集程序的核心部分都采用了<strong>跟踪例程(tracing routine)</strong>，<strong>该例程会标记每一个可以从初始根集到达的对象</strong>。跟踪例程通常会执行<strong>图遍历</strong>，使用标记栈，其中包含一组已访问过但其子对象尚未扫描的对象。跟踪流程会反复从标记栈中取出对象，标记其子对象，并将之前未标记的每个子对象插入标记栈。从标记栈中插入和移除对象的顺序决定了跟踪顺序。<strong>最常见的跟踪顺序是后进先出标记栈的 DFS（深度优先搜索）和作为先进先出队列工作的标记栈的 BFS（广度优先搜索）</strong>。</p>
<p>– <a href="https://web.archive.org/web/20170809123435id_/http://www.cs.technion.ac.il/~erez/Papers/dsa-ismm-15.pdf" target="_blank" rel="noopener">数据结构感知垃圾回收器</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7dd82b6d39701cdff63eb8c1c552bdc7a66b1710663ed76680687e68f37c3ba5" alt="COSC 340：软件工程导论 (utk.edu)"></p>
<p>3️⃣ 未标记的节点是垃圾节点，因此在<strong>清扫阶段（sweep phase）</strong>，GC 会遍历所有对象并释放未标记的对象。此外还会重置已标记的对象，为下一循环做好准备。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d28de7414d40b2eaa31e3c1534e59b1bfd91e5b2e553dd9ef11410f17221de59" alt="COSC 340：软件工程导论 (utk.edu)"></p>
<p>基本 Mark-Sweep 算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码//Marking</span><br><span class="line">Add each object referenced by the root set to Unscanned and set its reached-bit to 1;</span><br><span class="line">while(Unscanned != empty set)&#123;</span><br><span class="line">     remove some object o from Unscanned;</span><br><span class="line">     for(each object o&apos; referenced in o)&#123;</span><br><span class="line">         if(o&apos; is unreached; i.e, reached-bit is 0)&#123;</span><br><span class="line">              set the reached-bit of o&apos; to 1;</span><br><span class="line">            place o&apos; in Unscanned;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Sweeping</span><br><span class="line">Free = empty set;</span><br><span class="line">for(each chunk of memory o in heap)&#123;</span><br><span class="line">    if(o is unreached, i.e, its reached-bit is 0) add o to Free;</span><br><span class="line">    else set reached-bit of o to 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mark-Sweep GC 有一个优点：由于对象在 GC 期间不会移动，因此无需更新其指针。不过，也有几个缺点：</p>
<ul>
<li>由于在不扫描整个堆的情况下很难找到无法到达的对象，因此其扫描阶段的成本很高。</li>
<li>垃圾回收过程中必须停止执行程序，从而导致严重的性能问题。</li>
<li>堆中未使用内存的累积会导致内存碎片，使其无法用于新对象。</li>
</ul>
<p>显然，Mark-Sweep GC 不适合实时系统。</p>
<p>我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例"><a href="#真实用例" class="headerlink" title="真实用例"></a>真实用例</h5><p>该算法的原始版本可以在这些应用中找到：</p>
<p>1️⃣ uLisp：</p>
<blockquote>
<p>uLisp 中使用的垃圾回收器类型称为标记和扫描。首先，<code>markobject()</code> 会标记所有仍可访问的对象。然后，<code>sweep()</code> 基于未标记的对象建立一个新的 freelist，并删除已标记对象的标记。</p>
<p>– <a href="http://www.ulisp.com/show?1BD3" target="_blank" rel="noopener">uLisp — Garbage collection</a></p>
</blockquote>
<p>2️⃣ Ruby 的早期版本：</p>
<blockquote>
<p>Ruby 的第一个版本已经有了基于标记扫描（M&amp;S，Mark and Sweep）算法的 GC。M&amp;S 是最简单的 GC 算法之一，包括两个阶段：(1) 标记：遍历所有存活对象并标记。(2) 清扫：对未标记的未使用对象执行垃圾收集。</p>
<p>虽然 M&amp;S 算法简单且运行良好，但也存在一些问题。最重要的问题是”吞吐量 “和”暂停时间”。由于 GC 的开销，Ruby 程序的 GC 速度会减慢。换句话说，低吞吐量会增加应用程序的总执行时间。每次 GC 都会停止 Ruby 应用程序的运行。停顿时间过长会影响交互式网络应用的用户体验。Ruby 2.1 引入了分代垃圾回收（generational garbage collection），以解决”吞吐量”问题。</p>
<p>– <a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">Ruby 2.2 中的增量式垃圾回收 | Heroku</a></p>
</blockquote>
<p>此外，还可以找到原始算法的改进版本：</p>
<p>1️⃣增量式标记扫描算法（Incremental Mark-Sweep algorithm）：</p>
<p>➖ Ruby 2.2：</p>
<blockquote>
<p>增量式垃圾回收算法将垃圾回收执行过程拆分为多个细粒度过程，并将垃圾回收过程和 Ruby 进程交错处理。增量式垃圾回收会在一段时间内发起许多次较短的暂停，而不是一次长时间的暂停。总暂停时间是一样的（或者由于使用增量 GC，开销甚至更长一些），但每个单独的暂停时间要短得多，从而使得性能更加稳定。</p>
<p>– <a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">Ruby 2.2 中的增量式垃圾回收 | Heroku</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37d2c0268040c26172ae2af24d2fc6c4788e50b65852df453f4f97d868d5dd4e" alt="STW：Stop the world与增量式标记"></p>
<p>➖ OCaml：</p>
<blockquote>
<p>大堆通常比小堆大很多，可以扩展到千兆字节大小。垃圾收集算法分几个阶段运行[…]<strong>标记和清扫阶段在堆的片段上增量运行，以避免长时间暂停应用程序</strong>，并在每个片段之前进行快速的小堆收集。只有压缩阶段会一次性触及所有内存，不过这是相对罕见的操作。</p>
<p>– <a href="https://dev.realworldocaml.org/garbage-collector.html" target="_blank" rel="noopener">了解垃圾回收器 - 真实的 OCaml 世界</a></p>
</blockquote>
<p>➖ Mozilla SpiderMonkey:</p>
<blockquote>
<p>SpiderMonkey 的垃圾回收（GC）采用增量标记模式、 分代回收和压缩。大部分 GC 工作在辅助线程上执行。</p>
<p>– <a href="https://udn.realityripple.com/docs/Mozilla/Projects/SpiderMonkey/Internals/Garbage_collection" target="_blank" rel="noopener">垃圾回收（realityripple.com）</a></p>
</blockquote>
<p>2️⃣ 并发标记扫描（CMS，Concurrent Mark-Sweep）算法：</p>
<blockquote>
<p>并发标记扫描（CMS）收集器是专为那些希望缩短垃圾收集暂停时间的应用程序而设计的，这些应用程序可以在应用程序运行时与垃圾收集器共享处理器资源。</p>
<p>– <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">并发标记扫描（CMS）收集器（oracle.com）</a></p>
</blockquote>
<blockquote>
<p>并发标记扫描收集器（或并发收集器、CMS）是 Oracle HotSpot Java 虚拟机（JVM）中的标记扫描垃圾收集器，自 1.4.1 版起可用，在第 9 版中被弃用，在第 14 版中被移除，因此从 Java 15 开始就不再可用了。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Concurrent_mark_sweep_collector" target="_blank" rel="noopener">并发标记清扫收集器 - 维基百科</a></p>
</blockquote>
<p>顺便提一下，Java 已用 <a href="https://bugs.openjdk.org/browse/JDK-8229049?page=com.atlassian.jira.plugin.system.issuetabpanels%3Achangehistory-tabpanel" target="_blank" rel="noopener">Z 垃圾收集器 (ZGC) 和 Shenandoah 收集器</a>取代了并发标记扫描(CMS)，我们将在接下来的章节中介绍。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><h5 id="工作原理和算法-1"><a href="#工作原理和算法-1" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://www.cs.cornell.edu/courses/cs312/2003fa/lectures/sec24.htm" target="_blank" rel="noopener">复制垃圾回收(Copying Garbage Collection)</a>的原理是将堆分成两个大小相等的半空间：<strong>源空间(from-space)</strong> 和<strong>目标空间(to-space)</strong> ：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/105f8079355448bc07ebabf0913379533e7457d82543c140537e348cdb0ce636" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>1️⃣ 内存在源空间中分配，而目标空间为空。</p>
<p>2️⃣ 当源空间已满时，源空间中所有可访问的对象都会被复制到目标空间，指向它们的指针也会相应更新。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ed0f1edd23384fa3eb9501d2e0d5ed33986e6a5065fc65ee3dd52efacc6ad125" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>⛔ 在复制对象之前，有必要验证该对象以前是否被复制过。如果已经复制，则不应再次复制该对象，而应使用现有副本。在复制完源空间对象后，可以通过在该对象中放置一个”转发指针”来进行验证。</p>
<p>3️⃣ 最后，两个空间的角色互换，程序继续运行。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/861a42a9754c26462bb5115978317f25ba00ab2c76a5d9267f098415fcc38730" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>✔️ 在复制垃圾回收器中，内存分配在源空间中线性进行，无需空闲列表或搜索空闲块。只需用一个指针标记源空间中已分配区域和空闲区域的边界即可。</p>
<p>✔️ 此外，复制垃圾回收器中的分配非常快，几乎与栈分配一样快。</p>
<p>原始复制垃圾回收算法执行的是可达图（reachable graph）的<a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">深度优先遍历</a>，在递归执行时可能会导致<a href="https://en.wikipedia.org/wiki/Stack_overflow" target="_blank" rel="noopener">栈溢出</a>。</p>
<p>相比之下，Cheney的复制垃圾回收算法是一种高效的技术，它对可达图进行<a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noopener">广度优先遍历</a>，只需要一个指针作为附加状态：</p>
<p>✳️ 在任何广度优先遍历中，都有必要跟踪已被访问但其子节点尚未被探索的节点集。</p>
<blockquote>
<p>需要额外内存（通常是<a href="https://en.wikipedia.org/wiki/Queue_(data_structure)" target="_blank" rel="noopener">队列</a>）来跟踪已访问但尚未探索的子节点。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noopener">广度优先搜索 - 维基百科</a></p>
</blockquote>
<p>✳️ Cheney算法从根本上使用目标空间来存储这组节点，并用一个名为 <code>scan</code> 的指针来表示。</p>
<p>✳️ 这个指针将目标空间分为两部分：一部分是已访问过的子节点，另一部分是尚未访问过的子节点。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7f460dc3be3e253bf7f9b475df9922ca8b5f389c7ff75044155bc453f653ba81" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>➕ 使用复制垃圾回收代替标记和扫描的优势在于消除外部碎片、快速分配和避免死对象遍历。</p>
<p>➕ 切尼算法的一个主要特点是，它从不接触任何需要释放的对象，只遵循从活跃对象到活跃对象的指针。</p>
<p>➖ 但缺点是需要消耗两倍的虚拟内存，必须准确识别指针，复制成本可能很高。</p>
<p>Github上有<a href="https://gist.github.com/DEADB17/3fc90d569fb6f7466441" target="_blank" rel="noopener">实现Cheney算法的伪代码</a>。</p>
<p>让我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例-1"><a href="#真实用例-1" class="headerlink" title="真实用例"></a>真实用例</h5><p>1️⃣ Ocaml：</p>
<blockquote>
<p>为了对小堆进行垃圾回收，OCaml 会使用复制收集（copying collection）将小堆中的所有活跃块移动到大堆中。这需要的工作量与小堆中的活跃块数量成正比，而根据世代假设，小堆中的活跃块数量通常较少。一般来说，垃圾回收器会在运行过程中STW（即停止程序运行），这就是为什么必须快速完成，以便让应用程序以最小的代价恢复运行。</p>
<p>– <a href="https://dev.realworldocaml.org/garbage-collector.html" target="_blank" rel="noopener">了解垃圾回收器 - 真实世界 OCaml</a></p>
</blockquote>
<p>2️⃣ LISP：</p>
<blockquote>
<p>Fenichel 和 Yochelson 描述了在使用虚拟内存的 LISP 系统中，性能是如何随着时间的推移而下降的。他们的解决方案–复制垃圾回收（经 Cheney 进一步修改）–在现代 LISP 系统中被广泛采用，但其性能受到了限制，因为需要扫描可能很大的根集，并在每次垃圾回收时将通过计算维护的所有结构从一个区域移动到另一个区域。</p>
<p>– <a href="https://apps.dtic.mil/sti/tr/pdf/ADA290169.pdf" target="_blank" rel="noopener">通用计算机上 LISP 系统的终身垃圾收集器。(dtic.mil)</a></p>
</blockquote>
<p>3️⃣ Chicken (Scheme实现):</p>
<blockquote>
<p>所使用的设计是一种复制垃圾收集器，最初由 C. J. Cheney 设计，它将所有活跃对象复制到堆中。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Chicken_(Scheme_implementation)" target="_blank" rel="noopener">Chicken (Scheme implementation) — Wikipedia</a></p>
</blockquote>
<p>我们对复制垃圾回收领域的探索到此结束，现在让我们进入一种新的算法！</p>
<h4 id="标记-压缩-Mark-Compact"><a href="#标记-压缩-Mark-Compact" class="headerlink" title="标记-压缩(Mark-Compact)"></a>标记-压缩(Mark-Compact)</h4><h5 id="工作原理和算法-2"><a href="#工作原理和算法-2" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><blockquote>
<p><strong>标记-压缩算法可以看作是标记-扫描算法和Cheney复制算法的结合</strong>。首先，对可达对象进行标记，然后通过压缩步骤将可达（标记）对象移至堆区域的起始位置。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Mark%E2%80%93compact_algorithm" target="_blank" rel="noopener">标记-压缩算法 - 维基百科</a></p>
</blockquote>
<p>Mark-Compact 算法在运行过程中会经历不同阶段：</p>
<p>1️⃣ 从<strong>标记阶段</strong>开始，在这一阶段识别实时数据。</p>
<p>2️⃣ 接下来，通过重新定位对象和更新所有已移动对象的实时引用的指针值来<strong>压缩</strong>实时数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ae9ddf236ede04170027f695ffb9b7422b4663e6286acf11fd5b74f92d54d039" alt="COSC 340：软件工程导论 (utk.edu)"></p>
<p>压缩的方法有很多种，既可以保留原来的顺序，也可以不考虑。以下是几种不同的方法：</p>
<p>1️⃣ <strong>任意（Arbitrary）</strong>：不保持逻辑或空间顺序。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5f177a57a06ecc97aaa9a1d8d8e47fef7b2daf0af61ac0db570645639cdba6d7" alt="02-压缩(technion.ac.il)"></p>
<p>2️⃣ <strong>线性化（Linearizing）</strong>：移动物体，然后根据逻辑关系排序，即把相互指向的物体移动到相邻位置。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fb6a82e227b6fbae57d250f120580beb1d10a113d44c5c05383f4967043509b7" alt="02-压缩(technion.ac.il)"></p>
<p>3️⃣ <strong>滑动（Sliding）</strong>：保持原来的分配顺序。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/202d75771763d2ca503961d9ed7d7e59922a74737fcd176918e80cc25818a818" alt="02-压缩(technion.ac.il)"></p>
<p>让我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例-2"><a href="#真实用例-2" class="headerlink" title="真实用例"></a>真实用例</h5><p>有五种著名的压缩算法：</p>
<ul>
<li>双指算法（Two-finger algorithm，桑德斯 - 1974 年）：由于性能问题，实际中并没有使用。</li>
<li><a href="https://www.softwarepreservation.org/projects/LISP/lisp2/TM-3417_500_00_LISP2_GC_Spec.pdf" target="_blank" rel="noopener">Lisp 2 算法</a>。</li>
<li><a href="https://tugawa.github.io/publication/ismm2021-preprint.pdf" target="_blank" rel="noopener">Jonkers 的线程算法</a>（1979 年）。</li>
<li>SUN 的并行算法（<a href="https://www.usenix.org/legacy/events/jvm01/full_papers/flood/flood.pdf" target="_blank" rel="noopener">Flood-Detlefs-Shavit-Zhang - 2001</a>）。</li>
<li>IBM 的并行算法（<a href="https://research.ibm.com/haifa/Workshops/compiler2004/papers/GCforcompiler.pdf" target="_blank" rel="noopener">Abuaiadh-Ossia-Petrank-Silbershtein - 2004</a>）。</li>
<li>The Compressor (<a href="https://csaws.cs.technion.ac.il/~erez/Papers/compressor-pldi.pdf" target="_blank" rel="noopener">Kermany-Petrank — 2006</a>)。</li>
</ul>
<p>算法可分为以下几类：</p>
<ul>
<li><strong>单处理器压缩（Uni-processor compaction）</strong> 包括双指、Lisp2 和 Jonkers线程。</li>
<li><strong>并行编译（Parallel compaction）</strong> 包括 Sun 的编译、IBM 的编译和 Compressor（并行、并发、延迟……）。</li>
</ul>
<p>下面的表格总结了单处理器压缩算法的特点：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fd553acb21d4c905bf53db56c8e266a60092dd695b7493bda38ce6f954c7cdf7" alt="02-压缩(technion.ac.il)"></p>
<p>该表比较了 Jonkers 的线程算法、仅限于单线程的 IBM 并行压缩算法和完全并行的 IBM 并行压缩算法的性能（时间单位为毫秒）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/60f52d63f369ed223636292054f746e79dff48717b15abeca32eea454d71e97a" alt="02-压缩(technion.ac.il)"></p>
<p>即使仅限于单线程，IBM 的并行编译算法仍能保持高效，提供显著的速度提升和高质量的编译。</p>
<p>让我们使用更先进的算法！</p>
<h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h4><h5 id="工作原理和算法-3"><a href="#工作原理和算法-3" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p>分代垃圾收集是指根据对象的年龄将其分成若干代，并优先收集年轻代，而不是较老的一代。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/70901426ecdb58e192e9d944b1e77f2e41f525ac297e741bae5580ac78c8725a" alt="垃圾收集 (grinnell.edu)"></p>
<p>1️⃣ <strong>年轻代（The Young Generation）</strong> 是分配和老化所有新对象的地方。</p>
<p>2️⃣ 当年轻代填满时，会引发一次小规模垃圾收集，被死对象填满的年轻代很快就会被收集起来。</p>
<p>🚩 所有小规模垃圾回收都是STW事件。</p>
<p>3️⃣ 根据<strong>晋升政策（Promotion Policy）</strong>，幸存对象被晋升为<strong>老年代（Old Generation）</strong>。</p>
<p>4️⃣ 老年代用于存储存活时间较长的对象。通常情况下，会为年轻代对象设置阈值，当达到该年龄时，该对象就会被转移到老年代。</p>
<p>5️⃣ 当老年代内存已满时，将进行一次<strong>大回收</strong>，回收该代和所有年轻代的内存。</p>
<p>6️⃣ 此外，还为年轻代对象设置了阈值，当达到该阈值（即对象被复制的次数）时，对象就会被移到老年代。</p>
<p>🚩 大型垃圾回收也是STW事件。</p>
<p>✔️ 大部分分代收集器<strong>通过复制来管理年轻代</strong>：原始复制收集器、并行复制收集器或并行清理收集器。</p>
<p>✔️ 可以通过 <strong>Mark-Sweep</strong> 算法、<strong>并发收集器</strong>或<strong>增量收集器</strong>来管理旧世代。</p>
<p>回顾一下优缺点：</p>
<p>➕ 分代 GC 往往能减少 GC 暂停时间，因为大部分时间只收集最年轻的一代，也是最小的一代。</p>
<p>➕ 在复制 GC 时，分代还能避免重复复制长寿命对象。</p>
<p>➖ 在此方案中，由于实时对象可以处于不同的代际空间，因此出现了代间指针（例如，从上一代指向下一代的指针）的问题。</p>
<p>➖ 由于老年代的回收不如年轻代频繁，所以老对象有可能会阻止回收死去的年轻对象。这个问题被称为<a href="https://www.memorymanagement.org/glossary/n.html" target="_blank" rel="noopener">裙带关系问题(Nepotism)</a>。</p>
<p>让我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例-3"><a href="#真实用例-3" class="headerlink" title="真实用例"></a>真实用例</h5><p>1️⃣ Python：</p>
<blockquote>
<p>标准 CPython 垃圾回收器有两个组成部分，即引用计数回收器和分代垃圾回收器（称为 gc 模块）。</p>
<p>– <a href="https://rushter.com/blog/python-garbage-collector/" target="_blank" rel="noopener">Python 中的垃圾回收：你需要知道的事情 | Artem Golubin (rushter.com)</a></p>
</blockquote>
<blockquote>
<p>为了限制每次垃圾回收所需时间，默认构建的 GC 实现使用了一种流行的优化方法：世代。这个概念背后的主要思想是假设大多数对象的生命周期都很短，因此可以在创建后很快被回收。事实证明，这与许多 Python 程序的实际情况非常接近，因为许多临时对象的创建和销毁都非常快。为了利用这一事实，所有容器对象都被划分为三个空间/世代。每个新对象都从第一代（第 0 代）开始。前一种算法只对某一代的对象执行，如果一个对象在其一代的回收中存活下来，就会被转移到下一代（第 1 代），那里回收频率会更低。如果同一对象在新一代（第 1 代）的另一轮 GC 中存活下来，将被转移到最后一代（第 2 代），在那里回收的次数最少。</p>
<p>– <a href="https://devguide.python.org/internals/garbage-collector/index.html#optimization-generations" target="_blank" rel="noopener">垃圾收集器设计（python.org）</a></p>
</blockquote>
<p>2️⃣ Ruby：</p>
<blockquote>
<p>回到问题的关键：从 Ruby 2.1 开始，Ruby 引入了利用弱代际假设的分代 GC，将更频繁的垃圾回收工作集中在年轻、较新的对象上。Ruby 的垃圾回收器实际上有两种不同类型的垃圾回收：大 GC 和小 GC。小 GC 的频率更高，主要针对年轻对象。(大 GC 发生的频率较低，主要处理所有对象。小 GC 比大 GC 更快，因为查看的对象更少。</p>
<p>– <a href="https://jemma.dev/blog/gc-generational" target="_blank" rel="noopener">Ruby 垃圾回收深度剖析：分代垃圾回收 | Jemma Issroff</a></p>
</blockquote>
<p>3️⃣ V8 的垃圾回收：</p>
<blockquote>
<p>V8 使用分代垃圾收集器，将 Javascript 堆分成小的年轻代和大的老年代，前者用于分配新对象，后者用于长期存活的对象。由于大多数对象生命周期较短，因此这种分代策略使垃圾收集器可以在较小的年轻代中执行定期、短暂的垃圾收集（称为清扫），而无需跟踪老年代中的对象。年轻代使用半空间（复制）分配策略，新对象最初分配到年轻代的活跃半空间中。一旦半空间满了，清扫操作就会把活跃对象移到另一个半空间。已经移动过一次的对象会被提升到老年代，并被视为长寿对象。一旦活跃对象被移动，就会激活新的半空间，旧半空间中剩余的死对象就会被丢弃。老年垃圾收集器使用标记-扫描收集器（分多个小步骤增量标记活跃对象），并进行了多项优化，以改善延迟和内存消耗。</p>
<p>– <a href="https://v8.dev/blog/free-garbage-collection" target="_blank" rel="noopener">免费获取垃圾回收 - V8</a></p>
</blockquote>
<p>4️⃣ Java 序列收集器：</p>
<blockquote>
<p>串行 GC 是最简单的 Java GC 算法，是单核 32 位机器上的默认收集器。[…]串行收集器是一种分代垃圾收集器，年轻代使用疏散收集器（也称为标记复制收集器），老年代使用标记-清扫-压缩（MSC）收集器。年轻代的收集器称为Serial，而老年代的收集器称为Serial（MSC）。不过，对于大多数现代服务端应用来说，串行收集器并不实用。[…]并行收集器是具有两个或两个以上 CPU 的 64 位机器上的默认垃圾收集器（最高到 Java 8）。与串行收集器类似，都是分代收集器，但使用多线程来执行垃圾收集。并行收集器使用多个线程同时收集年轻代和老年代。并行收集器使用名为 ParallelScavenge 的标记复制收集器收集年轻代，使用名为 ParallelOld 的标记-清扫-压缩收集器收集老年代，这与串行收集器类似，主要区别在于并行收集器中使用了多个线程。</p>
<p>– <a href="https://abiasforaction.net/understanding-jvm-garbage-collection-part-6-serial-and-parallel-collector/#:~:text=The%20serial%20collector%20is%20a,is%20called%20Serial%20(MSC)." target="_blank" rel="noopener">了解 JVM 垃圾收集 - 第 6 部分（串行和并行收集器）</a></p>
</blockquote>
<blockquote>
<p>年轻代由伊甸园（eden）和两个幸存者空间（survivor spaces）组成。大多数对象最初都分配在 eden 中。其中一个幸存者空间在任何时候都是空的，是 eden 中所有活跃对象的目的地，另一个幸存者空间则是下一次复制集合的目的地。对象以这种方式在活跃空间之间复制，直到年龄足够长（复制到老年代）。</p>
<p>– <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html" target="_blank" rel="noopener">世代（oracle.com）</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/97691f660b7ad6fd1a7a0112e52312f15c73a7a370ca017f023fd12e000610b7" alt="世代（oracle.com）"></p>
<p>各种各样的算法和思考让我着迷。让我们在接下来的章节中进一步了解更现代、更复杂的 GC！</p>
<h4 id="垃圾优先（G1-Garbage-first）"><a href="#垃圾优先（G1-Garbage-first）" class="headerlink" title="垃圾优先（G1,Garbage-first）"></a>垃圾优先（G1,Garbage-first）</h4><h5 id="工作原理和算法-4"><a href="#工作原理和算法-4" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-E9CB81BC-92E5-489E-8A2E-760691A41CDF" target="_blank" rel="noopener">垃圾优先（G1）</a>是 Sun Microsystems 推出的一种垃圾收集算法，用于 Java 虚拟机（JVM）。</p>
<p>是一个分代、分区、增量、并行、并发为主、stop-the-world 和疏散（压缩）的垃圾收集器。</p>
<p>🔵 分区垃圾收集器将堆划分为多个区域，每个区域大小相等：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/991f0415aa8622bd298547ccdb407a05bc08732697b9f2c59ad84d03368ae7de" alt="垃圾优先（G1）垃圾收集器（oracle.com）"></p>
<p>🔵 每个区域都由不同部分组成：</p>
<ul>
<li><strong>空间（Space）</strong>：根据堆的最大大小，为每个区分配的空间从 1MB 到 32MB 不等。</li>
<li><strong>活跃（Alive）</strong>：区域内仍然活跃的部分对象。</li>
<li><strong>垃圾（Garbage）</strong>：区域内某些不再需要的对象，可归类为垃圾。</li>
<li><strong>RSet（Remembered Set）</strong>：一种元数据，可帮助跟踪哪些对象是有效的，哪些不再需要。该数据有助于 JVM 在任何给定时间内计算区域内有效对象的百分比（Liveness % = Live Size / Region Size）。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2a9c7f64034b937333bcd68a30282d39e37016887491e7cf61ce2469b626f2b3" alt="G1 GC - 性能工程入门 | Dhaval Shah (dhaval-shah.com)"></p>
<p>🔵 <strong>伊甸园（Eden）</strong>、<strong>幸存者（Survivor）</strong> 和<strong>旧（Old）</strong> 区不需要像旧版垃圾收集器（逻辑区域集）那样连续：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dfdbf2c43b19278a2a0b17f2b1c8ae222a7d4b008ed416da995961400c68523a" alt="G1 GC - 性能工程学入门 | Dhaval Shah (dhaval-shah.com)"></p>
<p>🔵 伊甸园区（”E”）和幸存者区（”S”）属于年轻代。</p>
<p>🔵 应用程序总是专门在伊甸园区分配对象，但大对象（跨越多个区的对象）除外，这些对象直接分配给老年代。</p>
<p>🔵 G1收集器在两个阶段之间交替运行：年轻（young-only）阶段和空间回收（space-reclamation）阶段。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/32198b8f5e321d29a876bc9f061cebe7df673b511e907f752d9d7c2e3acb5b39" alt="垃圾优先（G1）垃圾收集器（oracle.com）"></p>
<p>1️⃣ Young-only GC 负责将对象从伊甸园提升到幸存者区，或将幸存者区提升到老年区。Young-only事件被视为STW事件。</p>
<p>2️⃣ G1 收集器执行以下阶段，作为Young-only GC 的一部分：</p>
<ul>
<li><strong>初始标记（Initial Mark）</strong>：启动标记过程，同时进行常规的只收集年轻对象的工作。并发标记会确定旧一代区域中的所有实时对象（不是STW事件）。</li>
<li><strong>标记（Remark）</strong>：通过执行全局引用处理和类卸载，最终完成标记。回收完全清空的区域并清理内部数据结构（这是STW事件）。</li>
<li><strong>清理（Cleanup）</strong>：确定是否需要进行空间回收混合收集（这是STW事件）。</li>
</ul>
<p>3️⃣ 空间回收阶段涉及多个混合收集，不仅针对年轻代区域，还从选定的老年代区域回收活跃对象。</p>
<p>4️⃣ 当 G1 得出结论，进一步回收老年代区域不会产生大量空闲空间来证明所做努力的合理性时，空间回收阶段结束。</p>
<p>5️⃣ 空间回收后，收集周期重新开始，进入另一个Young-only阶段。</p>
<p>6️⃣ 如果应用程序在收集有效性信息时内存耗尽，G1 将执行就地停止的全堆压缩（Full GC）作为预防措施，与其他收集器类似。</p>
<p>🔵 根据我们所看到的，以下是使用 G1 的一些优缺点：</p>
<p>➕ 优点：</p>
<ul>
<li>可预测的暂停时间</li>
<li>基于区域的收集</li>
<li>自适应大小</li>
<li>压缩</li>
<li>软实时性能</li>
</ul>
<p>➖ 缺点：</p>
<ul>
<li>初始标记暂停</li>
<li>增加了 CPU 开销</li>
<li>与其他收集器相比，成熟度较低</li>
<li>堆碎片</li>
<li>配置复杂</li>
</ul>
<p>总之，垃圾优先（G1）具有可预测的暂停时间和有效的内存管理等显著优势。不过，并不是每个应用程序的理想选择，通常需要进行细致调整才能获得最佳性能。</p>
<blockquote>
<p>垃圾优先（G1）收集器是一种服务器风格的垃圾收集器，适用于具有大内存的多处理器机器，能高概率的实现垃圾收集（GC）暂停时间目标，同时实现高吞吐量。</p>
<p>– <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#:~:text=The%20Garbage%2DFirst%20(G1),probability%2C%20while%20achieving%20high%20throughput." target="_blank" rel="noopener">G1 垃圾收集器入门 (oracle.com)</a></p>
</blockquote>
<h5 id="真实用例-4"><a href="#真实用例-4" class="headerlink" title="真实用例"></a>真实用例</h5><p>垃圾优先（G1）算法是为 Java 虚拟机（JVM）创建的，通常用于在 JVM 上运行的编程语言，主要是 Java。任何使用 JVM 垃圾收集功能的 Java 应用程序都有可能通过 G1 垃圾收集器得到改进。</p>
<p>值得注意的是，G1 并不局限于 Java 语言本身，而是 JVM 运行时环境。其他可在 JVM 上运行的语言，如 Kotlin、Scala、Groovy 和 Clojure，在 JVM 上运行时也可以使用 G1 垃圾收集器。</p>
<p>接下来，我们将深入探讨另一种现代垃圾回收器的工作原理：Z！</p>
<h4 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h4><h5 id="工作原理和算法-5"><a href="#工作原理和算法-5" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p>Z 垃圾收集器（ZGC）是一种高性能的垃圾收集器，专门用于处理大型内存堆，如太字节级的内存堆。</p>
<p>ZGC 分为两类：<a href="https://openjdk.org/jeps/333" target="_blank" rel="noopener">非分代 ZGC</a> 和<a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener">分代 ZGC</a>。非分代 ZGC 自 Java 15 开始在生产中使用，而分代 ZGC 是 Java 21 的一部分。</p>
<p>有一份关于<a href="https://openjdk.org/jeps/8326667" target="_blank" rel="noopener">在未来版本中废弃非分代 ZGC 的草案</a>：</p>
<blockquote>
<p>弃用非分代 ZGC，以便在未来版本中将其删除。将分代 ZGC 改为默认 ZGC 模式，并废弃 <code>ZGenerational</code> 标志。</p>
<p>– <a href="https://openjdk.org/jeps/8326667" target="_blank" rel="noopener">JEP 草案：废弃非世代 ZGC（openjdk.org）</a></p>
</blockquote>
<p>ZGC 可同时管理几乎所有垃圾回收进程：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cf27aeb867ad4dc7adbb639df53d211473b5ce6a6c34ee21a0d16a87040d5745" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p>ZGC 运行周期包括 3 个阶段。每个阶段都以一个”安全点(safe-point)”同步点开始，包括暂停所有应用线程，又称 STW。除这 3 个阶段外，所有操作都与应用程序的其他部分同步进行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4b59d80515604305f623223cf4329299c2163fe71540fd0cf84290065eab6b57" alt="Z 垃圾收集器 - 简介 (openjdk.org)"></p>
<p>停顿总是低于毫秒：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0bad6dd87bcfef3b990b51856e44de6cdd46eb49300df5ab27dfc2214cbccacc" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2a3a2220877c750600af01bff0989f577109fa847cb12c0123b9403f0d2e12ab" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p>1️⃣ 第一阶段：周期开始时有一个同步暂停 (STW1)，允许：</p>
<ul>
<li>线程确定要使用的正确”颜色”（<strong>彩色指针，colored pointers</strong>）。</li>
<li>创建内存页（<strong>ZPages</strong>）。</li>
<li>确保所有”GC 根”都有效（颜色正确），必要时进行更正（<strong>加载屏障，Load Barriers</strong>）</li>
</ul>
<p>Mark/Remap 的后续并发阶段包括遍历对象图，以确定候选收集对象。</p>
<p>2️⃣ 第二阶段：STW2 暂停标志着标记阶段的结束。并行处理可识别需要压缩的内存区域。</p>
<p>3️⃣ 第三阶段：在 STW3 中再次识别出正确的颜色后，同时移动对象以压缩内存，从而完成循环。</p>
<p>让我们深入了解一下各种关键词的细节：</p>
<p>✳️ <strong>ZPages</strong>：ZGC 将堆内存分割成称为 ZPage 的区域，分为小、中、大三种：</p>
<ul>
<li>小（2 MiB - 对象大小不超过 256 KiB）。</li>
<li>中（32 MiB - 对象大小不超过 4MiB）。</li>
<li>大（4 MiB 以上 - 对象大小 &gt; 4 MiB）。</li>
</ul>
<p>中小页可以容纳多个对象，而大页只能容纳一个对象。这种限制有助于防止大型对象的移动，因为移动大型对象需要复制大量内存，可能会导致严重的延迟。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a94c9e8e1d9c14bc9e2fe39066dac82343c886967353e66eeaa24bcbd36e6aa8" alt="深入了解 ZGC 的架构 - Dev.java"></p>
<p>✳️ <strong>压缩和重定位</strong>：堆对象会不断压缩，以解决内存逐步碎片化的问题，并保证新对象的快速分配。</p>
<p>在生命周期中，可压缩页在第二阶段被识别（标记）（通常是对象最少的页），然后驻留在这些页上的所有对象在第三阶段被重定位。一旦页上没有任何对象，就可以回收其内存。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4f721c5392fcde11927ae2fa1efa242bd49a1ec3b996747822952dfdea741c6f" alt="深入了解 ZGC 的架构 - Dev.java"></p>
<p>为了同时执行重定位操作，ZGC 维护<strong>路由表</strong>。这些表存储在堆外，并为快速读取进行了优化，但会增加内存成本。</p>
<p>✳️ <strong>彩色指针</strong>：我们的目标是在指针中存储对象生命周期的相关信息，这是允许同时执行多种操作的关键。</p>
<p>4 比特专门用于存储元数据：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7d65ac2f275673cd09b23ce62f1a9dcf055e74f9ca39a244348f41c5946363fb" alt="Z 垃圾收集器 - 简介 (openjdk.org)"></p>
<p>指针的”颜色”由标记 0 (<strong>M0</strong>)、标记 1 (<strong>M1</strong>) 和重映射 (<strong>R</strong>) 这三个元比特的状态决定：</p>
<ul>
<li>M0 和 M1 用于标记要收集的对象。</li>
<li>重映射表示引用已被重定位。</li>
</ul>
<p>🚩 这三个比特中只有一个比特的值为 1。因此，得到了三种颜色：M0 (100)、M1 (010) 和 R (001)。</p>
<p>一种颜色要么是”好”的，要么是”坏”的，这是由生命周期阶段决定的：</p>
<ul>
<li>新实例化的对象会被标上正确的颜色。</li>
<li>ZGC 周期以短暂的STW（STW 1）开始，在此期间，通过交替改变 M0 和 M1 位的值来确定正确的颜色。因此，如果在一个周期中 M0 是正确的颜色，那么在下一个周期中 M1 将是正确的颜色。</li>
<li>在下一个并发阶段，即并发标记/重映射（Concurrent Mark/Remap）阶段，如果垃圾回收器遇到着色不正确的指针，会将指针更新为正确的地址，并分配适当的颜色。</li>
<li>在周期的最后一个同步点（STW 3），R 为正确的颜色。</li>
</ul>
<p>✳️ <strong>堆多重映射（Heap Multi-Mapping）</strong>：多内存映射允许多个虚拟地址指向同一个物理地址。因此，虚拟地址仅因元数据不同而不同的两个指针会指向相同的物理地址。</p>
<p>ZGC 需要这种技术，因为 ZGC 可以在应用程序运行时移动对象在堆内存中的物理位置。通过多重映射，对象的物理位置会映射到虚拟内存中的三个视图，分别对应指针的每种潜在”颜色”：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/efced130d14f231729429acb2fd3300cab407c67479d0e1f050c0101f39515ff" alt="Z 垃圾收集器 - 简介 (openjdk.org)"></p>
<p>这样，加载屏障就能识别自上一个同步点以来被重定位的对象。</p>
<p>✳️ <strong>加载屏障（Load barriers）</strong>：是 JIT 编译器在策略点注入的小段代码，特别是在从堆中加载对象引用时。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/71ee531ed4fc96240f30c63ab5801ec458ff91c14c1de247ee27c40f532b4402" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p>因为有了加载屏障，对象才可以随时移动，而不会更新指向它的指针。加载屏障会拦截对指针的读取，并对其进行纠正。这就确保了在 GC 和应用程序线程同时运行时，指针在任何时候被加载时都能指向正确的对象。</p>
<blockquote>
<p>在计算机术语中，内存屏障（memory barrier）也称为内存围栏（membar）、内存栅栏（memory fence）或栅栏指令（fence instruction），是一种屏障指令，能使中央处理器（CPU）或编译器对在屏障指令前后发出的内存操作执行顺序约束。通常意味着，在屏障指令之前发起的操作，能够保证在屏障指令之后的操作之前完成。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障 - 维基百科</a></p>
</blockquote>
<h5 id="真实用例-5"><a href="#真实用例-5" class="headerlink" title="真实用例"></a>真实用例</h5><p>Z 垃圾收集器（ZGC）主要用于在 Java 虚拟机（JVM）上运行的 Java 应用程序。因此，任何编译成 Java 字节码并在 JVM 上运行的编程语言都有可能使用 ZGC，这类语言中最主要的就是 Java 本身。</p>
<p>不过值得注意的是，除了 Java 之外，其他语言也可以在 JVM 上运行，包括 Kotlin、Scala、Groovy、Clojure 和 JRuby 等。只要这些语言利用 JVM 执行，就能受益于 ZGC 提供的功能和优化（如果进行了配置）。</p>
<p>总之，虽然 ZGC 由于与 JVM 集成而主要与 Java 有关，但也可用于其他基于 JVM 的语言。</p>
<p>让我们保持节奏，进入下一个算法！</p>
<h4 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h4><h5 id="工作原理和算法-6"><a href="#工作原理和算法-6" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://wiki.openjdk.org/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah</a> 主要由 Red Hat 开发，从 Java 12 开始作为 OpenJDK 的实验功能提供，得到了社区的积极开发和支持。</p>
<p>✔️ 虽然 Shenandoah 和 ZGC 都优先考虑通过<strong>并发垃圾收集</strong>来尽量减少暂停时间，但 Shenandoah 的设计是完全并发的，旨在完全避免 STW 暂停。ZGC 虽然采用了高度并发的方法，但在垃圾收集的某些阶段仍会出现短暂的 STW 停顿。</p>
<p>✔️ 虽然 Shenandoah 和 ZGC 都使用分段方法来管理堆，但分段粒度不同。Shenandoah 使用较大的区域，而 ZGC 使用较小的 ZPage。</p>
<p>✔️ Shenandoah 分几个阶段运行，包括初始标识、同步标识、同步驱逐（同步复制实时对象）和同步清理：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e65924caf291c1a694d2e5be015c27bc8d68b93d83e780d52dafbe812337e5f4" alt></p>
<p>✔️ Shenandoah 主要采用了并发驱逐，而 ZGC 则综合利用了并发标记、驱逐（重定位活跃对象）和压缩（尽量减少碎片）等技术。</p>
<p>✔️ 虽然 Shenandoah 和 ZGC 都使用专门的指针技术来保持垃圾回收过程中的一致性，但采用了不同的机制–Shenandoah 使用 <strong>Brooks</strong> 指针，而 ZGC 使用 <strong>Colored</strong> 指针。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9a4e36088e8204345558874e14855e1bfbdb1d01b2522675265768a406bd5ebc" alt="JVM 中的实验性垃圾回收器 | Baeldung"></p>
<blockquote>
<p>Shenandoah 会<strong>在对象布局中增加一个字</strong>，这就是间接指针，允许 Shenandoah 在不更新所有引用的情况下移动对象，也被称为 Brooks 指针。</p>
<p>– <a href="https://www.baeldung.com/jvm-experimental-garbage-collectors" target="_blank" rel="noopener">JVM 中的实验性垃圾回收器 | Baeldung</a></p>
</blockquote>
<p>✔️ Shenandoah 和 ZGC 都依靠加载屏障来确保垃圾回收过程中的内存一致性和正确性。加载屏障会拦截应用程序线程对对象引用的读取，确保观察到堆的一致视图，即使在并发垃圾回收操作的情况下也是如此。</p>
<p>💡 对那些优先考虑超低延迟和完全并发操作的用户来说，Shenandoah 是最佳选择，尤其是对于大规模堆内存和动态工作负载。相反，ZGC 则是经过验证、低延迟、兼容性强且易于配置的垃圾回收器的理想选择。</p>
<h5 id="真实用例-6"><a href="#真实用例-6" class="headerlink" title="真实用例"></a>真实用例</h5><p>Shenandoah 垃圾收集器（GC）主要用于在 Java 虚拟机（JVM）上运行的 Java 应用程序。因此，任何编译成 Java 字节代码并在 JVM 上运行的编程语言都有可能使用 Shenandoah GC，其中最主要的就是 Java 本身。</p>
<p>不过，值得注意的是，除了 Java 之外，其他语言也可以在 JVM 上运行，包括 Kotlin、Scala、Groovy、Clojure 和 JRuby 等。只要这些语言利用 JVM 执行，就能受益于 Shenandoah GC 提供的功能和优化（如果配置了这样的功能和优化）。</p>
<p>总之，虽然 Shenandoah GC 由于与 JVM 集成而主要与 Java 有关，但也可用于其他基于 JVM 的语言。</p>
<p>我们已经接近尾声，只需要介绍最后一个 GC，就可以进行比较了。开始吧！</p>
<h4 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h4><h5 id="工作原理和算法-7"><a href="#工作原理和算法-7" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://blogs.oracle.com/javamagazine/post/epsilon-the-jdks-do-nothing-garbage-collector" target="_blank" rel="noopener">Epsilon GC</a> 是 Java 11 中引入的一种特殊垃圾收集器，是一项试验性功能。传统垃圾收集器通过识别和收集未使用的对象来回收内存，而 Epsilon GC 与之不同，它根本不执行任何垃圾收集。相反，它允许 Java 虚拟机（JVM）在不收集垃圾的情况下分配内存！</p>
<p>以下是有关 Epsilon GC 的一些要点：</p>
<p>✔️ 无垃圾回收：Epsilon GC 不执行任何垃圾回收。它根据需要分配内存，但从不回收。这使它适用于不需要考虑垃圾回收开销的情况，如短期应用程序或手动管理内存的应用程序。</p>
<p>✔️ 用于性能测试：Epsilon GC 主要用于性能测试和基准测试。通过消除垃圾回收的开销，开发人员可以完全专注于应用程序性能，而不受垃圾回收暂停的干扰。</p>
<p>✔️ 不适合生产环境：Epsilon GC 不适用于生产环境，在生产环境中，内存管理和垃圾回收对应用程序的稳定性和性能至关重要。它仅用于测试和实验目的。</p>
<p>⛔ Epsilon GC 通过完全消除垃圾回收开销，为性能测试和实验提供了独特的选择。不过，它并不打算用于生产，其适用性有限，具体取决于应用程序的具体要求。</p>
<h5 id="真实用例-7"><a href="#真实用例-7" class="headerlink" title="真实用例"></a>真实用例</h5><p>Epsilon GC 是专为 Java 虚拟机（JVM）设计的垃圾收集器，因此与 Java 之外的任何编程语言都没有直接关联。任何在支持 Epsilon GC 的 JVM 上运行的 Java 应用程序都有可能使用。</p>
<p>是时候总结一下了！</p>
<h4 id="垃圾收集器算法比较"><a href="#垃圾收集器算法比较" class="headerlink" title="垃圾收集器算法比较"></a>垃圾收集器算法比较</h4><p>比较垃圾回收算法需要评估各种因素，如暂停时间、吞吐量、可扩展性、内存开销以及对特定应用场景的适用性。</p>
<p>1️⃣ 串行或单线程垃圾收集器：</p>
<ul>
<li>暂停时间：通常暂停时间较长，因为它会在垃圾回收期间停止所有应用线程。</li>
<li>吞吐量：与并发垃圾收集器相比，吞吐量一般较低。</li>
<li>可扩展性：堆大小较大或多线程应用时可能无法很好扩展。</li>
<li>内存开销：与其他收集器相比，内存开销通常较低。</li>
<li>适用性：适用于中小型应用或对暂停时间要求不高的应用。</li>
</ul>
<p>2️⃣ 并行垃圾收集器：</p>
<ul>
<li>暂停时间：与串行收集器相比，暂停时间更短，因为使用多个线程进行垃圾收集。</li>
<li>吞吐量：由于并行性，吞吐量比串行收集器高。</li>
<li>可扩展性：使用多核处理器和更大的堆大小时，可扩展性更好。</li>
<li>内存开销：由于增加了线程，内存开销通常比串行收集器高。</li>
<li>适用性：适用于吞吐量重要但暂停时间不重要的中型应用。</li>
</ul>
<p>3️⃣ Concurrent Mark-Sweep (CMS) 垃圾收集器：</p>
<ul>
<li>暂停时间：旨在通过与应用程序线程同时执行大部分垃圾收集工作，最大限度减少暂停时间。</li>
<li>吞吐量：吞吐量适中，但可能存在碎片问题。</li>
<li>可扩展性：在堆规模非常大或高度多线程的应用中可能无法很好的扩展。</li>
<li>内存开销：内存开销适中</li>
<li>适用性：适合堆的规模中等，以及对延迟要求敏感的应用。</li>
</ul>
<p>4️⃣ 垃圾优先（G1）垃圾收集器：</p>
<ul>
<li>暂停时间：旨在通过将堆划分为多个区域，并以增量方式执行垃圾回收，从而提供低暂停时间行为。</li>
<li>吞吐量对于大多数应用，尤其是具有大型堆的应用，吞吐量良好。</li>
<li>可扩展性：可基于多核处理器和大型堆实现良好扩展。</li>
<li>内存开销：由于基于区域的管理，内存开销适中。</li>
<li>适用性：适用于暂停时间短、吞吐量大的大规模应用。</li>
</ul>
<p>5️⃣ Z 垃圾收集器（ZGC）：</p>
<ul>
<li>暂停时间：旨在提供超低延迟性能，暂停时间通常低于 10 毫秒，即使在大型堆上也是如此。</li>
<li>吞吐量：为大多数应用提供良好的吞吐量，同时优先考虑低暂停时间。</li>
<li>可扩展性：高度可扩展性，支持超大堆大小和多线程应用。</li>
<li>内存开销：使用 ZPages 和其他技术，内存开销适中。</li>
<li>适用性：适用于有严格延迟要求和大规模堆的应用。</li>
</ul>
<p>6️⃣ Shenandoah垃圾收集器：</p>
<ul>
<li>暂停时间：目标是通过并发垃圾收集实现超低延迟，即使在大型堆上也能最大限度减少暂停时间。</li>
<li>吞吐量：提供良好的吞吐量，同时优先考虑低暂停时间。</li>
<li>可扩展性：高度可扩展性，支持超大堆和多线程应用。</li>
<li>内存开销：使用基于区域的管理，内存开销适中。</li>
<li>适用性：适用于有严格延迟要求和大规模堆的应用程序，尤其是具有动态内存分配模式的应用程序。</li>
</ul>
<p>总之，垃圾收集算法的选择取决于应用需求、堆大小、延迟敏感性和可用硬件资源等因素。必须仔细评估这些因素，为特定用例选择最合适的垃圾收集器。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>了解垃圾回收算法对于理解编程语言和运行时环境中如何进行内存管理至关重要，因为编程语言和运行时环境会自动执行这项任务。</p>
<p>这些算法在方法、优化和利弊方面各不相同，影响到暂停时间、吞吐量、内存开销和可扩展性等因素。</p>
<p>虽然垃圾回收提供了自动内存管理功能，并简化了开发人员分配和释放内存的过程，但也带来了权衡和挑战，在设计和实施软件系统时必须深思熟虑。</p>
<p>最后，将垃圾收集归类为”绿色技术”取决于多个因素，如其对资源利用、能源消耗、系统效率和整体环境可持续性的影响。虽然垃圾收集技术可以提高资源利用效率，并可能减少电子垃圾，但必须根据具体的使用情况和系统设置来评估其对环境的影响。</p>
<p>相信这次垃圾收集之旅一定会给你带来启发。</p>
<hr>
<blockquote>
<p>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号”DeepNoMind”，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</p>
</blockquote>
<p>本文由<a href="https://mdnice.com/?platform=2" target="_blank" rel="noopener">mdnice</a>多平台发布</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357917500963373066" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastify+TS实现基础IM服务（四）@fastify/</title>
    <url>/7357909187953623081.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文主要内容均为@fastifywebsocket入门内容，这部分可以直接去看NPM上的<a href="https://www.npmjs.com/package/@fastify/websocket" target="_blank" rel="noopener">@fastify/websocket</a> #readme</p>
<p>不同的是本文的代码示例都是TS的，如果已经有了这部分基础可以直接跳到改造js+ws聊天室代码部分</p>
</blockquote>
<p>Fastify 的 WebSocket 支持，基于 ws@8 构建。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm i @fastify/websocket</span><br><span class="line"># 或者</span><br><span class="line">yarn add @fastify/websocket</span><br></pre></td></tr></table></figure>

<p>如果你是 TypeScript 用户，这个包内置了自己的 TypeScript 类型，但你还需要安装 ws 包的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm i @types/ws -D</span><br><span class="line"># 或者</span><br><span class="line">yarn add -D @types/ws</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>注册这个插件后，你可以选择 WS 服务器响应哪些路由。这可以通过在 fastify 的 <code>.get</code> 路由上添加 <code>websocket: true</code> 属性到 <code>routeOptions</code> 来实现。在这种情况下，两个参数将被传递给处理程序，socket 连接和 fastify 请求对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket);</span><br><span class="line"></span><br><span class="line">app.register(async function (fastify) &#123;</span><br><span class="line">  fastify.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      // message.toString() === &apos;hi from client&apos;</span><br><span class="line">      connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(&#123; port: 3000 &#125;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，它将在每个未注册的路由上响应一个 404 错误，关闭传入的升级连接请求。</p>
<p>然而，你仍然可以定义一个通配符路由，它将被用作默认处理程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket, &#123;</span><br><span class="line">  options: &#123; maxPayload: 1048576 &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.register(async function (fastify) &#123;</span><br><span class="line">  fastify.get(&apos;/*&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      // message.toString() === &apos;hi from client&apos;</span><br><span class="line">      connection.socket.send(&apos;hi from wildcard route&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fastify.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      // message.toString() === &apos;hi from client&apos;</span><br><span class="line">      connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(&#123; port: 3000 &#125;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="附加事件处理程序"><a href="#附加事件处理程序" class="headerlink" title="附加事件处理程序"></a>附加事件处理程序</h3><p>重要的是，WebSocket 路由处理程序在处理程序执行期间同步附加事件处理程序，以避免意外丢弃消息。如果你想在你的 WebSocket 处理程序中进行任何异步工作，比如认证用户或从数据存储加载数据，请确保在触发这个异步工作之前附加任何 on(‘message’) 处理程序。否则，消息可能会在这个异步工作进行时到达，如果没有处理程序监听这个数据，它将被默默丢弃。</p>
<p>下面是一个例子，展示了如何在仍然访问异步资源的同时同步附加消息处理程序。我们将一个异步事情的 promise 存储在一个局部变量中，同步附加消息处理程序，然后使消息处理程序本身异步，以获取异步数据并进行一些处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码app.get(&apos;/*&apos;, &#123; websocket: true &#125;, (connection, request) =&gt; &#123;</span><br><span class="line">  const sessionPromise = request.getSession(); // 示例异步会话获取器，同步调用以返回一个 promise</span><br><span class="line"></span><br><span class="line">  connection.socket.on(&apos;message&apos;, async (message) =&gt; &#123;</span><br><span class="line">    const session = await sessionPromise;</span><br><span class="line">    // 使用消息和会话做一些事情</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用钩子"><a href="#使用钩子" class="headerlink" title="使用钩子"></a>使用钩子</h3><p>使用 @fastify/websocket 注册的路由遵循 Fastify 插件封装上下文，因此将运行已注册的任何钩子。这意味着你可能用于认证或错误处理的普通 HTTP 处理程序的相同路由钩子也适用于 websocket 处理程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码app.addHook(&apos;preValidation&apos;, async (request, reply) =&gt; &#123;</span><br><span class="line">  // 检查请求是否已认证</span><br><span class="line">  if (!request.isAuthenticated()) &#123;</span><br><span class="line">    await reply.code(401).send(&quot;未认证&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">  // 仅为认证的传入请求打开连接</span><br><span class="line">  connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="自定义错误处理程序"><a href="#自定义错误处理程序" class="headerlink" title="自定义错误处理程序"></a>自定义错误处理程序</h3><p>你可以选择性地提供一个自定义 <code>errorHandler</code>，它将用于处理已建立的 websocket 连接的任何清理工作。如果在建立连接后你的 websocket 路由处理程序抛出任何错误，将调用 <code>errorHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket, &#123;</span><br><span class="line">  errorHandler: function (error, connection, req, reply) &#123;</span><br><span class="line">    // 做些事情</span><br><span class="line">    // 销毁/关闭连接</span><br><span class="line">    connection.socket.terminate();</span><br><span class="line">  &#125;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    maxPayload: 1048576, // 我们将允许的最大消息大小设置为 1 MiB（1024 字节 * 1024 字节）</span><br><span class="line">    verifyClient: function (info, next) &#123;</span><br><span class="line">      if (info.req.headers[&apos;x-fastify-header&apos;] !== &apos;fastify is awesome !&apos;) &#123;</span><br><span class="line">        return next(false); // 连接不被允许</span><br><span class="line">      &#125;</span><br><span class="line">      next(true); // 连接被允许</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">  connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">    // message.toString() === &apos;hi from client&apos;</span><br><span class="line">    connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(&#123; port: 3000 &#125;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="自定义-preClose-钩子"><a href="#自定义-preClose-钩子" class="headerlink" title="自定义 preClose 钩子"></a>自定义 preClose 钩子</h3><p>默认情况下，当服务器关闭时，所有 ws 连接都将关闭。如果你希望修改这种行为，你可以传递你自己的 preClose 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket, &#123;</span><br><span class="line">  preClose: (done) =&gt; &#123; // 注意：也可以使用 async 风格，不使用 done-callback</span><br><span class="line">    const server = this.websocketServer;</span><br><span class="line"></span><br><span class="line">    for (const socket of server.clients) &#123;</span><br><span class="line">      socket.close(1001, &apos;WS 服务器以自定义方式离线，发送代码 + 消息&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.close(done);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试 ws 处理程序可能相当棘手，幸运的是 fastify-websocket 为 fastify 实例装饰了 injectWS。它允许轻松测试 websocket 端点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import Fastify from &apos;fastify&apos;;</span><br><span class="line">import FastifyWebSocket from &apos;@fastify/websocket&apos;;</span><br><span class="line">import ws from &apos;ws&apos;;</span><br><span class="line"></span><br><span class="line">const app = Fastify();</span><br><span class="line">await app.register(FastifyWebSocket);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">  const stream = ws.createWebSocketStream(connection.socket, &#123; /* 选项 */ &#125;);</span><br><span class="line">  stream.setEncoding(&apos;utf8&apos;);</span><br><span class="line">  stream.write(&apos;hello client&apos;);</span><br><span class="line">  </span><br><span class="line">  stream.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">    // 确保设置了数据处理程序或以其他方式读取所有传入的数据，否则流背压将导致底层 WebSocket 对象被暂停。</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">await app.listen(&#123; port: 3000 &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a>App.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import Fastify from &apos;fastify&apos;;</span><br><span class="line">import FastifyWebSocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const App = Fastify();</span><br><span class="line"></span><br><span class="line">App.register(FastifyWebSocket);</span><br><span class="line"></span><br><span class="line">App.register(async function(fastify) &#123;</span><br><span class="line">  fastify.addHook(&apos;preValidation&apos;, async (request, reply) =&gt; &#123;</span><br><span class="line">    if (request.headers[&apos;api-key&apos;] !== &apos;some-random-key&apos;) &#123;</span><br><span class="line">      return reply.code(401).send();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fastify.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h3 id="App-test-js"><a href="#App-test-js" class="headerlink" title="App.test.js"></a>App.test.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import &#123; test &#125; from &apos;tap&apos;;</span><br><span class="line">import Fastify from &apos;fastify&apos;;</span><br><span class="line">import App from &apos;./app&apos;;</span><br><span class="line"></span><br><span class="line">test(&apos;connect to /&apos;, async (t) =&gt; &#123;</span><br><span class="line">  t.plan(1);</span><br><span class="line"></span><br><span class="line">  const fastify = Fastify();</span><br><span class="line">  fastify.register(App);</span><br><span class="line">  t.teardown(fastify.close.bind(fastify));</span><br><span class="line"></span><br><span class="line">  const ws = await fastify.injectWS(&apos;/&apos;, &#123;headers: &#123; &quot;api-key&quot; : &quot;some-random-key&quot; &#125;&#125;);</span><br><span class="line">  let resolve;</span><br><span class="line">  const promise = new Promise(r =&gt; &#123; resolve = r; &#125;);</span><br><span class="line"></span><br><span class="line">  ws.on(&apos;message&apos;, (data) =&gt; &#123;</span><br><span class="line">    resolve(data.toString());</span><br><span class="line">  &#125;);</span><br><span class="line">  ws.send(&apos;hi from client&apos;);</span><br><span class="line"></span><br><span class="line">  t.assert(await promise, &apos;hi from server&apos;);</span><br><span class="line">  // 记得最后关闭 ws</span><br><span class="line">  ws.terminate();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><ul>
<li>测试结束时需要手动关闭 Websocket。</li>
<li>需要等待 fastify.ready() 以确保 fastify 已被装饰。</li>
<li>如果你需要处理服务器响应，需要在发送消息之前注册事件监听器。</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>@fastify/websocket 接受以下 ws 的选项：</p>
<ul>
<li>host - 绑定服务器的主机名。</li>
<li>port - 绑定服务器的端口。</li>
<li>backlog - 等待连接的队列的最大长度。</li>
<li>server - 一个预创建的 Node.js HTTP/S 服务器。</li>
<li>verifyClient - 用于验证传入连接的函数。</li>
<li>handleProtocols - 用于处理 WebSocket 子协议的函数。</li>
<li>clientTracking - 指定是否跟踪客户端。</li>
<li>perMessageDeflate - 启用/禁用 permessage-deflate。</li>
<li>maxPayload - 允许的最大消息大小（以字节为单位）。</li>
</ul>
<p>有关更多信息，你可以查看 ws 选项文档。</p>
<p>注意：默认情况下，如果你不提供 server 选项，@fastify/websocket 将把你的 websocket 服务器实例绑定到作用域内的 fastify 实例。</p>
<p>注意：ws 的 path 选项不应提供，因为路由由 fastify 自身处理</p>
<p>注意：ws 的 noServer 选项不应提供，因为 @fastify/websocket 的目的是在 fastify 服务器上监听。如果你想要一个自定义服务器，你可以使用 server 选项，如果你想要更多控制，你可以直接使用 ws 库</p>
<p>ws 不允许你将 objectMode 或 writableObjectMode 设置为 true</p>
<h3 id="完整的-TypeScript-示例"><a href="#完整的-TypeScript-示例" class="headerlink" title="完整的 TypeScript 示例"></a>完整的 TypeScript 示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码/* eslint-disable @typescript-eslint/no-unused-vars */</span><br><span class="line">import Fastify from &apos;fastify&apos;</span><br><span class="line">import FastifyWebsocket, &#123; WebSocket &#125; from &apos;@fastify/websocket&apos;</span><br><span class="line">import &#123; FastifyRequest, FastifyReply &#125; from &apos;fastify&apos;</span><br><span class="line"></span><br><span class="line">// 创建 Fastify 实例</span><br><span class="line">const app = Fastify()</span><br><span class="line"></span><br><span class="line">// 注册 @fastify/websocket 插件</span><br><span class="line">app.register(FastifyWebsocket, &#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    maxPayload: 1048576, // 设置允许的最大消息大小为 1MB</span><br><span class="line">    verifyClient: (info, done) =&gt; &#123;</span><br><span class="line">      // 示例：客户端验证逻辑</span><br><span class="line">      if (info.req.headers[&apos;x-fastify-header&apos;] === &apos;fastifyrocks&apos;) &#123;</span><br><span class="line">        done(true) // 验证通过</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        done(false) // 验证失败，连接被拒绝</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    clientTracking: true, // 启用客户端跟踪</span><br><span class="line">    perMessageDeflate: true // 启用 permessage-deflate 压缩</span><br><span class="line">  &#125;,</span><br><span class="line">  errorHandler: (error, connection, _req, _reply) =&gt; &#123;</span><br><span class="line">    // 错误处理逻辑</span><br><span class="line">    console.error(&apos;WebSocket 错误:&apos;, error)</span><br><span class="line">    connection.terminate() // 终止连接</span><br><span class="line">  &#125;,</span><br><span class="line">  preClose: (done) =&gt; &#123;</span><br><span class="line">    // 服务器关闭前的清理逻辑</span><br><span class="line">    console.log(&apos;正在关闭 WebSocket 连接&apos;)</span><br><span class="line">    done() // 完成清理操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 添加认证钩子</span><br><span class="line">app.addHook(</span><br><span class="line">  &apos;preValidation&apos;,</span><br><span class="line">  async (request: FastifyRequest, _reply: FastifyReply) =&gt; &#123;</span><br><span class="line">    if (!request.headers[&apos;authorization&apos;]) &#123;</span><br><span class="line">      throw new Error(&apos;未授权&apos;) // 抛出未授权错误</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义 WebSocket 路由</span><br><span class="line">app.get(</span><br><span class="line">  &apos;/ws&apos;,</span><br><span class="line">  &#123; websocket: true &#125;,</span><br><span class="line">  (connection: WebSocket, _req: FastifyRequest) =&gt; &#123;</span><br><span class="line">    connection.on(&apos;message&apos;, (message) =&gt; &#123;</span><br><span class="line">      console.log(&apos;收到消息:&apos;, message.toString())</span><br><span class="line">      connection.send(&apos;消息已接收&apos;) // 向客户端发送响应</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    connection.on(&apos;close&apos;, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;WebSocket 已关闭&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 启动服务器</span><br><span class="line">app.listen(&#123; port: 3000 &#125;, (err, address) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err)</span><br><span class="line">    process.exit(1) // 遇到错误，退出程序</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`服务器正在监听地址 $&#123;address&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="关键点解释"><a href="#关键点解释" class="headerlink" title="关键点解释"></a>关键点解释</h3><ul>
<li><strong>注册插件</strong>：通过 <code>app.register(FastifyWebsocket, {...})</code> 注册 <code>@fastify/websocket</code> 插件，并传递配置选项。</li>
<li><strong>选项配置</strong>：<code>options</code> 对象中包含了 <code>ws</code> 库的配置选项，如 <code>maxPayload</code>, <code>verifyClient</code>, <code>clientTracking</code>, 和 <code>perMessageDeflate</code>。</li>
</ul>
<pre><code>+ **`maxPayload`**：定义了 WebSocket 消息的最大大小（以字节为单位）。这是一个重要的安全特性，用于防止恶意用户通过发送大量数据来尝试耗尽服务器资源。
+ **`verifyClient`**：这是一个函数，用于在 WebSocket 握手阶段验证连接客户端。它接收两个参数：`info` 和 `done`。`info` 对象包含了请求相关的信息，如请求头和请求源等，而 `done` 是一个回调函数，用于基于验证结果接受或拒绝请求。这个验证步骤是实现自定义认证逻辑的理想场所。
+ **`clientTracking`**：当设置为 `true` 时，WebSocket 服务器将会跟踪连接到服务器的客户端。这使得服务器能够保持对所有活动 WebSocket 连接的引用，便于管理这些连接，如广播消息。
+ **`perMessageDeflate`**：这个选项启用了 permessage-deflate 压缩，可以减少通过 WebSocket 发送的数据的大小。这对于减少带宽使用和提高传输效率非常有用，特别是在发送大量数据时。除了这些选项，`@fastify/websocket` 插件还提供了其他几个重要的配置点：


+ **`errorHandler`**：这是一个函数，用于处理 WebSocket 连接过程中的任何错误。这允许开发者自定义错误处理逻辑，例如记录错误或关闭出现问题的连接。
+ **`preClose`**：这是一个函数，在服务器即将关闭前调用，允许进行清理工作，如优雅地关闭 WebSocket 连接。</code></pre><ul>
<li><strong>错误处理</strong>：<code>errorHandler</code> 函数用于处理 WebSocket 连接过程中的错误。</li>
<li><strong>认证钩子</strong>：<code>preValidation</code> 钩子用于在建立 WebSocket 连接之前进行认证检查。</li>
<li><strong>WebSocket 路由</strong>：通过 <code>app.get(&#39;/ws&#39;, {websocket: true}, handler)</code> 定义 WebSocket 路由。在路由处理函数中，可以使用 <code>connection.socket</code> 来发送和接收消息。</li>
<li><strong>启动服务器</strong>：通过 <code>app.listen({ port: 3000 }, callback)</code> 启动服务器。</li>
</ul>
<p>这个示例展示了如何在 Fastify 应用中使用 TypeScript 来集成和配置 WebSocket 功能，包括如何处理客户端消息、执行认证和错误处理。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357909187953623081" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>WebSocket,Node.js,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SkyWalking为所有的API接口增加tag背景胡</title>
    <url>/7357917741909262351.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景胡扯"><a href="#背景胡扯" class="headerlink" title="背景胡扯"></a>背景胡扯</h1><p>线上接口报错，接着被 SkyWalking 抓到，然后 SkyWalking 触发告警，最后老板@你，让你辛苦一下，在明早上班前把这个bug 改了，并告诉你你是全公司的希望。谁说不是呢？为公司业务保驾护航，我辈责无旁贷。</p>
<p>既然告警都触发了，咱就来看看怎么个事。嘿嘿小样，这下还能让你跑了。（实际上还真的有可能跑了，说多了都是泪）</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/312fc5e5d205931dbafd80c4c17a30de078fea560c0c55eec1db0e9725ac1db1" alt="image.png"></p>
<p>我打开 SkyWalking UI 一看，报错服务说要和我试试，我说可以。我一说他啪的一下一个显眼的红色报错直冲我面门，我鼠标一点，当时就全部防住了。防出去以后自然是传统功夫以点到为止，鼠标放在了报错上，没点他。我笑一下，准备收拳。</p>
<p>因为这时间，按传统功夫的点到为止他已经输了，如果我点下去，就直接把他错误堆栈打印出来了，我就鼠标放在错误上没点他。</p>
<p>我收鼠标的时间不打了，他突然袭击抛出上下文，我大意了啊，没有闪。他的上下文给我眼晃了一下，我当时流眼泪了，捂着眼，我说婷婷。上下文怎么没有用户标识。然后两分钟以后就好了，完犊子日志里面也没有。</p>
<p>看来是有备而来，这个服务不讲武德，来骗来偷袭我这个老码农。这好吗？这不好。</p>
<p>总之，就是缺少一些上下文数据，例如用户ID，设备ID这类的数据，我们给补上就行了，给老码农一个闪避buff。</p>
<h1 id="上菜：附加上下文"><a href="#上菜：附加上下文" class="headerlink" title="上菜：附加上下文"></a>上菜：附加上下文</h1><p>看一下官网的文档，怎么样能够给接口添加上下文数据</p>
<p><a href="https://skywalking.apache.org/docs/skywalking-java/v9.2.0/en/setup/service-agent/java-agent/application-toolkit-dependency/" target="_blank" rel="noopener">the toolkit, such as using maven or gradle | Apache SkyWalking</a></p>
<p>别忘了第一步先引入依赖，依赖版本和你使用的 <code>java-agent</code> 版本保持一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;apm-toolkit-trace&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;skywalking.version&#125;&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后才是第二部附加上下文 <code>tag</code>，我总结了三种方式：</p>
<p>第一种是最直接的，直接调用 <code>ActiveSpan.tag(&quot;my_tag&quot;, &quot;my_value&quot;)</code> 操作接口。特点就是直接到不能再直接了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@GetMapping(&quot;/xxx&quot;)</span><br><span class="line">public Result&lt;User&gt; query() &#123;  </span><br><span class="line">    ActiveSpan.tag(&quot;my_key&quot;, &quot;my_value&quot;);  </span><br><span class="line">    // 其他代码。。。 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是简单的，在接口方法上打上注解 <code>@Trace</code> 和 <code>@Tag</code>。特点是简单到不能再简单了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Trace</span><br><span class="line">@Tag(key = &quot;tag1&quot;, value = &quot;arg[0]&quot;)</span><br><span class="line">@Tag(key = &quot;tag2&quot;, value = &quot;arg[1]&quot;)</span><br><span class="line">@Tag(key = &quot;username&quot;, value = &quot;returnedObj.username&quot;)</span><br><span class="line">@Tag(key = &quot;age&quot;, value = &quot;returnedObj.age&quot;)</span><br><span class="line">public User methodYouWantToTrace(String param1, String param2) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种是相对优雅的，在拦截器上使用API统一操作。特点是无侵入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码</span><br><span class="line"> public class SkyWalkingTraceContextInterceptor implements HandlerInterceptor &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;  </span><br><span class="line">		// 这里太简单粗暴了，别抄哈。只是提供一种思路</span><br><span class="line">        String token = request.getHeader(TokenParserConfig.HEADER_TOKEN_KEY);  </span><br><span class="line">        if (StringUtils.isNotBlank(token)) &#123;  </span><br><span class="line">            ActiveSpan.tag(&quot;biz.token&quot;, token);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要能够根据 <code>tag</code> 来进行搜索，不要漏掉最后这一步。在配置文件中增加我们的 <code>tag key</code>，或者直接修改环境变量 <code>SW_SEARCHABLE_TAG_KEYS</code> 也行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yml复制代码searchableTracesTags: $&#123;SW_SEARCHABLE_TAG_KEYS:http.method,http.status_code,rpc.status_code,db.type,db.instance,mq.queue,mq.topic,mq.broker,mq.payload,biz.token&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357917741909262351" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAIchemy异步DBManager封装-02熟悉掌</title>
    <url>/7357957809072619554.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><blockquote>
<p>在上一篇文章中 <a href="https://dev.newban.cn/7357703852726911016">SQLAIchemy 异步DBManager封装-01入门理解</a> 我们深入讨论了SQLAlchemy异步DBManager整体的封装结构与思路。详细地介绍了如何封装添加和批量添加的操作方法，并通过实际示例进行了演示。SQL 全称是结构化查询语言，无疑查询是最复杂的部分。因此，在这篇文章中，我将详细介绍如何封装通用的数据库查询方法，并通过具体的示例来讲解这一过程，使得这一复杂的任务变得更为简单。</p>
</blockquote>
<h1 id="二、通用查询封装"><a href="#二、通用查询封装" class="headerlink" title="二、通用查询封装"></a>二、通用查询封装</h1><h2 id="指定主键id查询"><a href="#指定主键id查询" class="headerlink" title="指定主键id查询"></a>指定主键id查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class DBManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_CLIENT: SQLAlchemyManager = None</span><br><span class="line">    orm_table: Type[BaseOrmTable] = None</span><br><span class="line">    </span><br><span class="line">    @with_session</span><br><span class="line">    async def query_by_id(</span><br><span class="line">            self,</span><br><span class="line">            pk_id: int,</span><br><span class="line">            *,</span><br><span class="line">            orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">            session: AsyncSession = None,</span><br><span class="line">    ) -&gt; Union[T_BaseOrmTable, None]:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        根据主键id查询</span><br><span class="line">        Args:</span><br><span class="line">            pk_id: 主键id</span><br><span class="line">            orm_table: orm表映射类</span><br><span class="line">            session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            orm映射类的实例对象</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        orm_table = orm_table or self.orm_table</span><br><span class="line">        ret = await session.get(orm_table, pk_id)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>

<p>这个封装很简单，直接看demo吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class UserTable(BaseOrmTableWithTS):</span><br><span class="line">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    username: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户昵称&quot;)</span><br><span class="line">    age: Mapped[int] = mapped_column(default=0, comment=&quot;年龄&quot;)</span><br><span class="line">    password: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户密码&quot;)</span><br><span class="line">    phone: Mapped[str] = mapped_column(String(11), default=&quot;&quot;, comment=&quot;手机号&quot;)</span><br><span class="line">    email: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;邮箱&quot;)</span><br><span class="line">    avatar: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;头像&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserManager(DBManager):</span><br><span class="line">    orm_table = UserTable</span><br><span class="line"></span><br><span class="line">    async def get_name_by_email(self, email):</span><br><span class="line">        username = await self.query_one(cols=[&quot;username&quot;], conds=[self.orm_table.email == email], flat=True)</span><br><span class="line">        return username</span><br><span class="line">        </span><br><span class="line">async def query_demo():</span><br><span class="line">    user = await UserManager().query_by_id(pk_id=1)</span><br><span class="line">    print(&quot;user&quot;, user)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">user &#123;&apos;id&apos;: 1, &apos;username&apos;: &apos;hui&apos;, &apos;age&apos;: 18, &apos;password&apos;: &apos;&apos;, &apos;phone&apos;: &apos;&apos;, &apos;email&apos;: &apos;huidbk.163.com&apos;, &apos;avatar&apos;: &apos;&apos;, &apos;created_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43), &apos;updated_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询单条"><a href="#查询单条" class="headerlink" title="查询单条"></a>查询单条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@with_session</span><br><span class="line">async def _query(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: BaseOrmTable = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        limit: int = None,</span><br><span class="line">        offset: int = 0,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">) -&gt; Result[Any]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    通用查询</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表, 默认id升序</span><br><span class="line">        limit: 限制数量大小</span><br><span class="line">        offset: 偏移量</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 查询结果集</span><br><span class="line">        cursor_result</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cols = cols or []</span><br><span class="line">    cols = [column(col_obj) if isinstance(col_obj, str) else col_obj for col_obj in cols]  # 兼容字符串列表</span><br><span class="line"></span><br><span class="line">    conditions = conds or []</span><br><span class="line">    orders = orders or [column(&quot;id&quot;)]</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line"></span><br><span class="line">    # 构造查询</span><br><span class="line">    if cols:</span><br><span class="line">        # 查询指定列</span><br><span class="line">        query_sql = select(*cols).select_from(orm_table).where(*conditions).order_by(*orders)</span><br><span class="line">    else:</span><br><span class="line">        # 查询全部字段</span><br><span class="line">        query_sql = select(orm_table).where(*conditions).order_by(*orders)</span><br><span class="line"></span><br><span class="line">    if limit:</span><br><span class="line">        query_sql = query_sql.limit(limit).offset(offset)</span><br><span class="line"></span><br><span class="line">    # 执行查询</span><br><span class="line">    cursor_result = await session.execute(query_sql)</span><br><span class="line">    return cursor_result</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def query_one(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        flat: bool = False,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">) -&gt; Union[dict, T_BaseOrmTable, Any]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    查询单行</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表</span><br><span class="line">        flat: 单字段时扁平化处理</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Examples:</span><br><span class="line">        # 指定列名</span><br><span class="line">        ret = await UserManager().query_one(cols=[&quot;username&quot;, &quot;age&quot;], conds=[UserTable.id == 1])</span><br><span class="line">        sql =&gt; select username, age from user where id=1</span><br><span class="line">        ret =&gt; &#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">        # 指定列名，单字段扁平化处理</span><br><span class="line">        ret = await UserManager().query_one(cols=[&quot;username&quot;], conds=[UserTable.id == 1])</span><br><span class="line">        sql =&gt; select username from user where id=1</span><br><span class="line">        ret =&gt; &#123;&quot;username&quot;: &quot;hui&quot;&#125; =&gt; &quot;hui&quot;</span><br><span class="line"></span><br><span class="line">        # 计算总数</span><br><span class="line">        ret = await UserManager().query_one(cols=[func.count()], flat=True)</span><br><span class="line">        sql =&gt; select count(*) as count from user</span><br><span class="line">        ret =&gt; &#123;&quot;count&quot;: 10&#125; =&gt; 10</span><br><span class="line"></span><br><span class="line">        # 不指定列名，查询全部字段, 返回表实例对象</span><br><span class="line">        ret = await UserManager().query_one(conds=[UserTable.id == 1])</span><br><span class="line">        sql =&gt; select id, username, age from user where id=1</span><br><span class="line">        ret =&gt; UserTable(id=1, username=&quot;hui&quot;, age=18)</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        Union[dict, BaseOrmTable(), Any(flat=True)]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cursor_result = await self._query(cols=cols, orm_table=orm_table, conds=conds, orders=orders, session=session)</span><br><span class="line">    if cols:</span><br><span class="line">        if flat and len(cols) == 1:</span><br><span class="line">            # 单行单字段查询: 直接返回字段结果</span><br><span class="line">            # eg: select count(*) as count from user 从 &#123;&quot;count&quot;: 100&#125; =&gt; 100</span><br><span class="line">            # eg: select username from user where id=1 从 &#123;&quot;username&quot;: &quot;hui&quot;&#125; =&gt; &quot;hui&quot;</span><br><span class="line">            return cursor_result.scalar_one()</span><br><span class="line"></span><br><span class="line">        # eg: select username, age from user where id=1 =&gt; &#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">        return cursor_result.mappings().one() or &#123;&#125;</span><br><span class="line">    else:</span><br><span class="line">        # 未指定列名查询默认全部字段，返回的是表实例对象 BaseOrmTable()</span><br><span class="line">        # eg: select id, username, age from user where id=1 =&gt; UserTable(id=1, username=&quot;hui&quot;, age=18)</span><br><span class="line">        return cursor_result.scalar_one()</span><br></pre></td></tr></table></figure>

<p>查询无疑就只有两种结果单条、多条结果数据。这里统一封装一个 <strong>_query</strong> 通用查询方法，以供内部使用。</p>
<ul>
<li>支持指定查询的列（cols）</li>
<li>条件查询（conds）</li>
<li>排序（orders）</li>
<li>分页（limit、offset）</li>
</ul>
<p>主要封装就是利用 sqlaichemy 提供的 select 语法进行组织sql，通过 column 兼容列名字段字符串列表。query_one 方法，如果指定了 cols 返回字典格式，不指定则是库表映射类实例对象，一开始封装的时候我想统一出参都是返回 库表映射类实例对象 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码query_ret = cursor_result.mappings().one() or &#123;&#125;</span><br><span class="line">return orm_table(**query_ret)</span><br></pre></td></tr></table></figure>

<p>如果是 <strong>id as user_id</strong> 取别名查询会导致映射不上，但可以查询时不指定别名，<code>orm_table_obj.to_dict(alias_dict={&quot;id&quot;: &quot;user_id&quot;})</code> 时进行别名转换，还有一些flat 扁平化、统计数量的时候都不能使用 <code>orm_table(**query_ret)</code> 故而不好统一，再实际web场景中，出参还是要转成dict、json格式化进行响应，故而进行保留。看看具体使用效果</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1709450dae091eba6911a0b100ec5baa1d0609740daf7fa69ce1a0e67b786145" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from sqlalchemy import String, func, label</span><br><span class="line"></span><br><span class="line">async def query_demo():</span><br><span class="line">    ret = await UserManager().query_one(cols=[&quot;username&quot;, &quot;age&quot;], conds=[UserTable.id == 1])</span><br><span class="line">    print(&quot;指定列名 ret&quot;, ret)</span><br><span class="line">    </span><br><span class="line">    ret = await UserManager().query_one(</span><br><span class="line">        cols=[UserTable.username, label(&quot;user_age&quot;, UserTable.age)], conds=[UserTable.id == 1]</span><br><span class="line">    )</span><br><span class="line">    print(&quot;取别名 ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserManager().query_one(cols=[&quot;username&quot;], conds=[UserTable.id == 1], flat=True)</span><br><span class="line">    print(&quot;指定列名，单字段扁平化处理&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserManager().query_one(cols=[func.count()], flat=True)</span><br><span class="line">    print(&quot;计算总数&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserManager().query_one(conds=[UserTable.id == 1])</span><br><span class="line">    print(&quot;不指定列名，查询全部字段, 返回表实例对象&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码指定列名 ret &#123;&apos;username&apos;: &apos;hui&apos;, &apos;age&apos;: 18&#125;</span><br><span class="line"></span><br><span class="line">取别名 ret &#123;&apos;username&apos;: &apos;hui&apos;, &apos;user_age&apos;: 18&#125;</span><br><span class="line"></span><br><span class="line">指定列名，单字段扁平化处理 hui</span><br><span class="line"></span><br><span class="line">计算总数 6</span><br><span class="line"></span><br><span class="line">不指定列名，查询全部字段, 返回表实例对象 &#123;&apos;username&apos;: &apos;hui&apos;, &apos;age&apos;: 18, &apos;password&apos;: &apos;&apos;, &apos;phone&apos;: &apos;&apos;, &apos;email&apos;: &apos;huidbk.163.com&apos;, &apos;avatar&apos;: &apos;&apos;, &apos;id&apos;: 1, &apos;created_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43), &apos;updated_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询多条"><a href="#查询多条" class="headerlink" title="查询多条"></a>查询多条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@with_session</span><br><span class="line">async def query_all(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: BaseOrmTable = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        flat: bool = False,</span><br><span class="line">        limit: int = None,</span><br><span class="line">        offset: int = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">) -&gt; Union[List[dict], List[T_BaseOrmTable], Any]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    查询多行</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表</span><br><span class="line">        flat: 单字段时扁平化处理</span><br><span class="line">        limit: 限制数量大小</span><br><span class="line">        offset: 偏移量</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cursor_result = await self._query(</span><br><span class="line">        cols=cols, orm_table=orm_table, conds=conds, orders=orders, limit=limit, offset=offset, session=session</span><br><span class="line">    )</span><br><span class="line">    if cols:</span><br><span class="line">        if flat and len(cols) == 1:</span><br><span class="line">            # 扁平化处理</span><br><span class="line">            # eg: select id from user 从 [&#123;&quot;id&quot;: 1&#125;, &#123;&quot;id&quot;: 2&#125;, &#123;&quot;id&quot;: 3&#125;] =&gt; [1, 2, 3]</span><br><span class="line">            return cursor_result.scalars().all()</span><br><span class="line"></span><br><span class="line">        # eg: select username, age from user =&gt; [&#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;, [&#123;&quot;username&quot;: &quot;dbk&quot;, &quot;age&quot;: 18&#125;]]</span><br><span class="line">        return cursor_result.mappings().all() or []</span><br><span class="line">    else:</span><br><span class="line">        # 未指定列名查询默认全部字段，返回的是表实例对象 [BaseOrmTable()]</span><br><span class="line">        # eg: select id, username, age from user</span><br><span class="line">        # [User(id=1, username=&quot;hui&quot;, age=18), User(id=2, username=&quot;dbk&quot;, age=18)</span><br><span class="line">        return cursor_result.scalars().all()</span><br></pre></td></tr></table></figure>

<p>查询多条与query_one一致内部调用 <strong>_query()</strong> 获取查询结果集，最后通过 <code>cursor_result.mappings().all()</code>、<code>cursor_result.scalars().all()</code> 获取列表数据，同样支持单字段扁平化处理，还支持分页处理。具体看如下例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from sqlalchemy import String, func, label, or_</span><br><span class="line"></span><br><span class="line">ret = await UserManager().query_all()</span><br><span class="line">user_ids = [user.id for user in ret]</span><br><span class="line">print(&quot;查询全部&quot;, user_ids)</span><br><span class="line"></span><br><span class="line">user_ids = await UserManager().query_all(cols=[UserTable.id], flat=True)</span><br><span class="line">print(&quot;查询全部的用户id（扁平化处理）&quot;, user_ids)</span><br><span class="line"></span><br><span class="line">ret = await UserManager().query_all(</span><br><span class="line">    cols=[UserTable.username],</span><br><span class="line">    conds=[</span><br><span class="line">        UserTable.id &gt; 1,</span><br><span class="line">        or_(UserTable.age &lt; 20, UserTable.email == &quot;huidbk.163.com&quot;)</span><br><span class="line">    ],</span><br><span class="line">    orders=[UserTable.id],</span><br><span class="line">    flat=True</span><br><span class="line">)</span><br><span class="line"># sql =&gt; select username from user where user.id &gt; 1 and (age &lt; 20 or email=&apos;huidbk.163.com&apos;) order by id</span><br><span class="line">print(&quot;条件查询&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码查询全部 [1, 2, 3, 4, 5, 6]</span><br><span class="line">查询全部的用户id（扁平化处理） [1, 2, 3, 4, 5, 6]</span><br><span class="line">条件查询 [&apos;zack&apos;]</span><br></pre></td></tr></table></figure>

<p>单字段扁平化处理，可以节省获取查询数据后再进行扁平化处理的一步操作。看看下面没有扁平化处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码user_infos = await UserManager().query_all(cols=[UserTable.id])</span><br><span class="line">user_ids = [user_info.get(&quot;id&quot;) for user_info in user_infos]</span><br><span class="line">print(&quot;查询全部的用户id&quot;, user_ids)</span><br><span class="line"></span><br><span class="line">ret = await UserManager().query_one(cols=[func.count()])</span><br><span class="line">count = ret.get(&quot;count&quot;) or 0</span><br><span class="line">print(&quot;计算总数&quot;, count)</span><br></pre></td></tr></table></figure>

<p>上面的获取某业务的所有id，计算总数等，直接获取扁平化的结果，有时还是比较实用。</p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码async def list_page(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: BaseOrmTable = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        curr_page: int = 1,</span><br><span class="line">        page_size: int = 20,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    单表通用分页查询</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表</span><br><span class="line">        curr_page: 页码</span><br><span class="line">        page_size: 每页数量</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: </span><br><span class="line">        total_count, data_list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    conds = conds or []</span><br><span class="line">    orders = orders or [column(&quot;id&quot;)]</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line"></span><br><span class="line">    limit = page_size</span><br><span class="line">    offset = (curr_page - 1) * page_size</span><br><span class="line">    total_count, data_list = await asyncio.gather(</span><br><span class="line">        self.query_one(</span><br><span class="line">            cols=[func.count()], orm_table=orm_table, conds=conds, orders=orders, flat=True, session=session</span><br><span class="line">        ),</span><br><span class="line">        self.query_all(</span><br><span class="line">            cols=cols, orm_table=orm_table, conds=conds, orders=orders, limit=limit, offset=offset, session=session</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    return total_count, data_list</span><br></pre></td></tr></table></figure>

<p>这里分页查询就用 query_one 查询总数，query_all 分页查询，curr_page 当前页与 page_size 每页大小计算数据偏移量 offset，然后通过 <strong>asyncio.gather</strong> 并发执行获取结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码total_count, data_list = await UserManager().list_page(</span><br><span class="line">    cols=[UserTable.id, UserTable.username, UserTable.age],</span><br><span class="line">    conds=[UserTable.id &gt; 1],</span><br><span class="line">    curr_page=2,</span><br><span class="line">    page_size=3,</span><br><span class="line">    orders=[desc(UserTable.age)]</span><br><span class="line">)</span><br><span class="line">print(&quot;分页查询 total_count&quot;, total_count)</span><br><span class="line">print(&quot;分页查询 data_list&quot;, data_list)</span><br></pre></td></tr></table></figure>

<p>分页查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码分页查询 total_count 5</span><br><span class="line">分页查询 data_list [&#123;&apos;id&apos;: 3, &apos;username&apos;: &apos;wang&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;id&apos;: 2, &apos;username&apos;: &apos;zack&apos;, &apos;age&apos;: 19&#125;]</span><br></pre></td></tr></table></figure>

<p>这里的分页查询没有使用 with_session 装饰器，由于 asyncio.gather 并发操作原因不能共享数据库会话 session，需要单独的 session，不然会报如下错误。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c9ec291c6d8167598c5d56adefc76df207d9fcabf40a14e37ee4c7cf3cd2932" alt></p>
<blockquote>
<p>sqlalchemy.exc.InvalidRequestError：无法在上下文管理器内的已关闭事务上进行操作。 请先完成上下文管理器，然后再发出进一步的命令。</p>
</blockquote>
<h1 id="三、封装说明"><a href="#三、封装说明" class="headerlink" title="三、封装说明"></a>三、封装说明</h1><p>SQL 的话还是查询用的多，查询也复杂，这里的话只封装了一些通用的查询操作，有一些分组查询、连表查询等我都没有封装，我认为这些操作还是写原生sql更直观一些，用ORM进行组装这些操作会感觉语法很别扭不简洁。如何执行原始sql，请看下一篇。<a href="https://dev.newban.cn/7358352353295106088">SQLAIchemy 异步DBManager封装-03得心应手</a></p>
<h1 id="四、Github源代码"><a href="#四、Github源代码" class="headerlink" title="四、Github源代码"></a>四、Github源代码</h1><p>源代码已上传到了Github，里面也有具体的使用Demo，欢迎大家一起体验、贡献。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357957809072619554" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD落地指南-架构师眼中的餐厅1、领域设计2、架构设计</title>
    <url>/7357957599844122624.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在去年、我整理了一篇名为《<a href="http://sd.jd.com/article/2312" target="_blank" rel="noopener">如何做架构设计？</a>》的文章，主要探讨了架构设计的目标和过程，然而、那是一篇概括性的文章，用于启发思路，并不是具体的实践指南，因此、我一直期望给出具体参考案例。</p>
<p>我几乎忘了这件事，如今回顾、我发现并没有合适的案例可供参考，现有的案例要么不完整、要么是与业务耦合的特定场景，要么无法支撑研发落地。所以我决定从实际生活中出发，虚拟一个案例场景，以便能够系统性的阐述这个问题。</p>
<p>﻿</p>
<p>正文开始</p>
<hr>
<p>﻿</p>
<p>本案例侧重于DDD的实践，从实际业务场景推导软件架构，将业务元素映射为系统元素，让系统本身成为最好的业务文档。在本案例中，我们选择餐厅作为业务场景，但不在意餐厅实现细节，而是以餐厅为主线故事，系统性的阐述DDD落地方法。希望读者能够从中吸取精华，去其糟粕，全文较长、耐心读完、必有收获。</p>
<hr>
<p>﻿</p>
<h1 id="1、领域设计"><a href="#1、领域设计" class="headerlink" title="1、领域设计"></a>1、领域设计</h1><p>领域设计的核心是业务驱动的分而治之，旨在缩小软件系统与真实业务的差异，从而减少差异带来的问题。</p>
<p>当业务与系统之间存在差异时，我们无法将业务逻辑和程序逻辑对应起来，从而分不清区域，也分不清职责，因此会觉得混乱。就像你平时不会将枕头和被子放在厨房或卫生间一样，你的床上不会放着大米白面，否则你想睡觉是一件很复杂的事情，软件系统也是如此。</p>
<p>所以、首先要把业务分析清楚，然后设计与业务模型对应的软件模型，这就是DDD的核心思想。</p>
<p>﻿</p>
<h2 id="1-1-宏观流程"><a href="#1-1-宏观流程" class="headerlink" title="1.1 宏观流程"></a>1.1 宏观流程</h2><p>假如我要设计一个餐厅，由于分而治之的需要，我会首先从宏观流程去分析，可以帮我们迅速找到重要的区域（这是功能相关性的初步划分）。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dad69a636c144ff45114faa8026d8439e0127ae2c25689605dda61b09fe5fd95" alt></p>
<p>﻿﻿</p>
<p>因此会得到几个明确的行为区域，我将餐厅划分为“菜品域”，“订单域”，“厨房域”，“用餐域”，这是宏观级别的领域划分，后续应该针对每个区域单独分析。</p>
<p>产出物是：宏观流程和参与角色</p>
<p>﻿</p>
<h2 id="1-2-统一语言"><a href="#1-2-统一语言" class="headerlink" title="1.2 统一语言"></a>1.2 统一语言</h2><p>语言贯穿于整个开发过程，从需求分析到设计、从设计到编码，因此好的语言非常重要，好的语言体现了清晰的业务概念。</p>
<p>在这个阶段，我们需要通过梳理，找到业务中都有哪些实体与行为，对其做一些归纳。我们的核心问题是“谁”通过什么“行为”影响了“谁”，其中的三个要素分别是“角色”、“行为”、“实体”，因此我的建议是先找到 “角色”、“行为”、“实体”，并对他们归类，我常常关注角色以及具体身份、行为以及包含的重要步骤、实体以及具体实例。</p>
<p><strong>角色</strong>：是施事主语、是名词，是主动发起行为的一类实体。</p>
<p><strong>行为</strong>：是动词、是做了什么事情，是行为本身。</p>
<p><strong>实体</strong>：是名词，是除“角色”之外的其他实体。</p>
<p>推荐使用脑图画出来，我认为归纳后的脑图有助于我们识别根本要素，有利于抽象。</p>
<p>产出物是：名词、概念定义、相关脑图。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3a1614f7e2c0ee3a66f2db19ed192bce04f42dde6019c4fa930e1835c1df5092" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="1-3-用例分析"><a href="#1-3-用例分析" class="headerlink" title="1.3 用例分析"></a>1.3 用例分析</h2><p>在这一步、我们使用相对宏观的分析，不需要进入用例的细节分析，主要的目的是掌握角色与行为之间的关系，理清谁在做什么，角色的职责目的是什么，用于指导领域划分以及领域服务设计。</p>
<p>产出物：用例图</p>
<p><strong>以做菜为例，如图</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/51ac3fc0da0ed091a670723bf99b41d78b9fe7c0e7ab9df8b0510704cf941d45" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="1-4-领域划分"><a href="#1-4-领域划分" class="headerlink" title="1.4 领域划分"></a>1.4 领域划分</h2><p>我们在分析宏观流程时，划分了几个行为区域，那是宏观级别的。在那基础之上，我们需要拉进某个区域的视角，再结合之前的用例分析，按照“功能相关性”、“角色相关性”进一步划分领域。我们不仅要知道谁做了什么，还需要知道谁“在哪”做了什么。</p>
<p><strong>功能相关性</strong>：也称为业务相关性，业务是由一套用例组成的，一套用例之间是符合高内聚原则的，一套用例构成了一个问题空间，也就构成了一个领域，所以“功能相关性”是划分领域的黄金标准。例如与做菜相关的用例都应该归属于厨房，所以我们确认了厨房域，这也是很自然的事。在这一步，通过划分领域、梳理领域与用例之间的关系。</p>
<p><strong>角色相关性：</strong> 角色相关性不可以作为首要参考因素，在特殊情况下用于划分子域，某个区域涉及多个角色参与，可以按照角色的分工，拆分为多个子域，从而满足不同角色的个性化需要。例如厨房的采购人员负责买菜、刀工负责切菜、大厨负责烹饪。我们就会考虑将厨房划分为“采购子域”、“加工子域”、“烹饪子域”。通常来说，子域不具备独立的问题空间，不会作为独立的领域存在。</p>
<p>划分领域的核心原则是保证领域的自治性（最小完备和自我履行），谨慎使用“实体相关性”划分领域，否则有可能将一个功能打散在多个领域上，违反了自治性原则，如果按照功能相关性划分，更容易实现领域的自治性，并且有助于将功能需要的实体聚合在一起。</p>
<p>产出物：领域、子域、领域与用例的关系</p>
<p><strong>以厨房域为例，如图</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/636f22fea81a57bd9bf193e29442074fdb03d32f3e978f95eaf8e40266f559c3" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>在复杂业务时，可以使用事件风暴方法辅助分析，并输出上述产出物。</p>
<p>﻿</p>
<h2 id="1-5-领域服务"><a href="#1-5-领域服务" class="headerlink" title="1.5 领域服务"></a>1.5 领域服务</h2><p>什么是领域服务？一个领域可以有几个领域服务？ 我们如何划分领域服务？标准是什么？</p>
<p>我认为一个领域不只有一个领域服务，我们不应该按照实体划分，也不应该按照聚合划分，也不该按照功能相关性划分。</p>
<p>领域服务用于实现用例功能，我认为应该使用角色划分领域服务。在用例图中，不同的角色发起不一样的用例，不同的领域服务提供不一样的用例，只有这样、才能确保领域服务是用例图的映射，也才能真正体现业务含义。领域服务是面向角色的，在一个领域中、每个角色对应一个领域服务。另外、同一个用例的逻辑差异是与角色的身份有关的，角色的身份对应了服务的泛化，角色的用例对应了服务的方法。对于此观点、我们在后续功能设计的部分也有体现。</p>
<p>例如：厨房域（厨师服务、刀工服务、采购员服务），菜品域（客户服务、管理者服务）。</p>
<p>产出物：领域服务类图</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d05be2480c52c89ce4292386cb88df4b38faaa01ce847e22c46fa8781abadc07" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="1-6-领域建模"><a href="#1-6-领域建模" class="headerlink" title="1.6 领域建模"></a>1.6 领域建模</h2><p>我们思考一下，到底什么才是领域驱动设计？ 例如“厨房域”被称为“菜域”，“厨师”的“做菜”功能被称为“菜服务”的“做菜”功能，也例如“菜品域”有个“菜品服务”，“菜品服务”提供了“增、删、改、查”的功能。我们往往以最核心的实体为中心，误以为业务就是在操作数据，丢掉了业务本质含义，逐渐也就走歪了。</p>
<p>不要学传统的数据模型驱动设计，实体模型驱动设计与前者的本质是一样的，是换汤不换药的，这不是技术问题，而是过度集中在实体上以至于忘记其他元素。我们必须把精力放在业务本身，防止领域驱动设计变成领域模型驱动设计。我们不应该优先思考领域模型，不应该以领域模型命名一切，不应该让领域模型决定业务的实现方式。厨房不只有菜，也有服务员和厨师，我们使用合适的语言对应合适的元素，以确保软件元素是真实业务的映射。例如“厨师在厨房做菜”，这句话中的所有元素都要在系统中得以保留，丢了一个也不行，更何况只剩下菜了。</p>
<p>所以、我们先做领域划分，再做领域服务设计，最后做领域建模，这个顺序很重要，可以避免我们错误的以领域建模为中心。先有用例才有领域，先有领域才为领域建模，实体是为了实现一组用例存在的。而一组用例不一定依赖实体。</p>
<p>回到正题、我们在这一步的重点还是菜的问题，我们分析实体与领域之间关系（领域聚合），实体与实体的关系（OO聚合）。其中OO关系影响了功能的扩展性，需要我们特别关注。实体因一套用例而聚合在一起，我推荐做法是将领域的用例放在一起分析，找到他们的共同性，充分考虑变化，使用兼容性更好的模型解决问题。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/979aeab943606c29a7fca1875e5d7552d9a854b8683e0b4aeb2ca599bfdc4b21" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<p><strong>组合、聚合</strong></p>
<p>聚合（aggregation）：聚合关系是一种弱的关系，整体和部分可以相互独立。</p>
<p>组合（composition）：组合关系是一种强的整体和部分的关系，整体和部分具有相同的生命周期。</p>
<p>可以使用如下案例，既能表达领域聚合，又能表达OO聚合的关系。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9d7a0a9e6d4d885a43ae8179ccb5320463eb1a7223a6c602bb416d0ab96e466b" alt></p>
<p>﻿﻿</p>
<p>产出物：聚合、实体、值对象、实体的属性</p>
<p>﻿</p>
<h2 id="1-7-领域上下游"><a href="#1-7-领域上下游" class="headerlink" title="1.7 领域上下游"></a>1.7 领域上下游</h2><p>领域上下游关系，不是领域的依赖关系，依赖关系指的是能力的依赖，是共用了某些能力。领域上下游关系，也不是调用关系，调用关系是与用例相关的，不是用于描述领域处境的。</p>
<p>领域上下游关系指的是影响力的关系，上游影响下游，影响力分为“逻辑影响”和“数据影响”，一般说来我们更应该关注“数据影响”，因为上下游的逻辑影响也是靠数据传递的，所以领域上下游关系是一种数据流向的限制，是业务发生的顺序限制，用于规定该领域所使用的数据，是下游领域依赖上游领域“准备就绪”的体现。合理的上下游限制，有助于减少领域之间的不必要依赖和重复的计算。</p>
<p>领域上下游是与场景相关的，并不是一成不变的，不同场景的情况下，存在不同的上下游关系，各场景应该独立说明。</p>
<p>产出物：各场景的上下游说明</p>
<p>﻿</p>
<p><strong>例：在【菜品管理】场景下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e09eeffb9d7e9119dd062848ac5e0c9cbcd2e69f82342f51708979a4afb55fbb" alt></p>
<p>﻿</p>
<p>如果厨房的某些食材不足了，或者某个厨师休假了，就会影响到菜品的展示，从而影响到客户的订单。</p>
<p>﻿</p>
<p><strong>例：在【客户消费】场景下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3976b2b629ba96be28ec2ff6b1e897289f194c77386aa7243e3c4c760396ce12" alt></p>
<p>﻿﻿</p>
<p>客户的订单、影响厨房生产的菜，从而影响刀工的行为，也影响到了采购。</p>
<p>﻿</p>
<p><strong>请对比下面两个图，用于理解领域的上下游</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f6abdca63824a3424cde317d8dcf7d928677089ad29e5acf057bf0d928a56268" alt></p>
<p>﻿﻿</p>
<p>实际上，厨师不应该依赖采购人员的采购功能，也不依赖刀工的切菜功能，他只是依赖“初加工食材”而已，而“初加工食材”就是被处理好的数据，厨师在做饭时，“初加工食材”就已经被处理好了，上面的图例只是为了说明一个关于领域上下游的问题，这是业务<strong>发生顺序</strong>以及<strong>数据来源</strong>的问题。</p>
<p>我们常常使用领域事件串联业务流程，在使用领域事件时，不止要关注点对点的解耦，更应该使业务流程符合领域上下游限定，让各个领域独立运行。</p>
<p>顺序发生优于嵌套发生，数据依赖优于功能依赖。</p>
<p>﻿</p>
<h1 id="2、架构设计"><a href="#2、架构设计" class="headerlink" title="2、架构设计"></a>2、架构设计</h1><p>架构设计是为了解决软件系统复杂度带来的问题，找到系统中的元素并搞清楚他们之间关系。</p>
<p>架构的目标是用于管理复杂性、易变性和不确定性，以确保在长期的系统演化过程中，一部分架构的变化不会对其它部分产生不必要的负面影响。这样做可以确保业务和研发效率的敏捷，让应用的易变部分能够频繁地变化，对应用的其它部分的影响尽可能地小。</p>
<p>架构设计三原则：合适原则、简单原则、演化原则</p>
<h2 id="2-1-分层架构"><a href="#2-1-分层架构" class="headerlink" title="2.1 分层架构"></a>2.1 分层架构</h2><p>我们需要按照 接口层、领域层（领域用例层、领域模型层）、依赖层、基础层 构建架构模型。</p>
<p><strong>接口层</strong>：为外部提供服务的入口，是适配层的北向网关。不实现任何业务逻辑，也不处理事务，是跨领域的，是流程编排层，是门面服务。</p>
<p><strong>领域用例层：</strong> 是领域服务层，是领域用例的实现层、隶属于某个领域、是业务逻辑层，是事务层，业务逻辑应该在这层完整体现，不要分散到其他层级。</p>
<p><strong>领域模型层：</strong> 是领域模型（实体、值对象、聚合）的所在位置，专注于领域模型自身的能力，不包含业务功能，可以处理事务，是原子化的能力，是领域对象的自我实现 <em>。</em></p>
<p><strong>依赖层</strong>： 是连接外部服务的出口，是适配层的南向网关。包括仓储，端点、RPC等，主要作用是领域和外部解耦，是跨领域的。</p>
<p><strong>基础层：</strong> 与业务无关的，与领域无关的，通用的技术能力，技术组件等。</p>
<p>﻿</p>
<h2 id="2-2-架构映射"><a href="#2-2-架构映射" class="headerlink" title="2.2 架构映射"></a>2.2 架构映射</h2><p>架构的视角，从大到小依次是：系统-&gt;应用（微服务）-&gt;模块（包）-&gt;子模块 这样的从大到小的层级。</p>
<p><strong>业务领域映射</strong>：我们将划分好的领域，按照对应的视角映射为对应的元素，领域模型映射到架构模型时，应该是视角对等的，如果餐厅是系统、那么厨房就是应用，如果餐厅是应用、那么厨房就是模块。也应该是层级匹配的，将用例的实现映射到用例层，将领域模型的实现映射到领域模型层。也应该是名称一致的，将领域名映射为应用名或包名，将实体名映射为实体类名，将角色名映射为领域服务类名，将角色身份名映射为服务类的子类名，将用例名映射为服务类的方法名。</p>
<p><strong>技术和抽象问题</strong>：有时候、业务领域分析不能体现那些共性的技术问题，所以需要适当结合技术视角，可能需要对领域模型微调。同时、我们需要找到共同需要的基础能力，例如“水”、“电”、“煤气”等等，将这些作为额外的考虑因素，要做到业务问题与技术问题解耦，不要将技术问题和业务逻辑揉成一团。</p>
<p>领域设计，类似餐厅设计师，他设计餐厅有几个区域，区域的用途是什么。</p>
<p>架构设计，类似建筑设计师，他设计如何走水电煤气、如何施工等。</p>
<p>产出物：分层架构图</p>
<p>﻿</p>
<p><strong>以厨房为视角，其架构如下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/966a1ae235eef34a3e984d09e3fb04f923a8bd148e1f979c2f59f6c3c62815af" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<p><strong>以餐厅为视角，其架构如下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ba3c0b20ee2212d3166c41277447f3edfbe144488c72efc9b939aa4b3b58a10a" alt></p>
<p>﻿﻿</p>
<p>分层架构图，体现逻辑上的层级分布，而不是代表组件的具体含义，组件是应用还是模块、需要结合实际情况而定。</p>
<p>﻿</p>
<h2 id="2-3-必要的约束"><a href="#2-3-必要的约束" class="headerlink" title="2.3 必要的约束"></a>2.3 必要的约束</h2><p>1、分层架构越往下层就越是稳定的：下层是被上层依赖的，下层不可以反向依赖上层（扩展点除外）。因为分层架构的核心原则是将容易变化的逻辑上浮，将共性的、原子化的、通用的逻辑下沉，被依赖的下层应该是稳定的，这要求上层承接更多业务变化。下层离开上层应该是可以独立存在的，例如在接口层定义的DTO不可以在下层被使用，但领域层定义的实体可以被上层使用。</p>
<p>2、在使用充血模型时，应该符合面向对象编程原则：不要随意的将一些能力都充到领域实体模型中。以“菜”为例，重量和规格是“菜”的自身的属性，激发味蕾是“菜”的能力，“菜”可以维护自身的持久化状态。但是、请注意、“菜”不可以“炒菜”，因为“炒菜”的时候，“菜”还没有出现呢，“菜”不是自己的上帝，“菜”需要被做出来，所以“菜”被做出来之前是没有“菜”的，这是个时间上的概念，不要错把“炒菜”的能力放在“菜”的身上。“炒菜”用到的“水+电+气+食材+调料+厨具”不应该是“菜”的属性范围，这些元素都在“厨房”的范围中，不要让领域的模型包含不属于自身的元素，领域的实体模型只是领域的一部分，只用于实现通用的模型能力。</p>
<p>3、接口层和依赖层是与领域无关的：他们是与技术相关的层级，不属于任何领域，这两层不能包含业务逻辑。有时候我们可以把接口层拆为两层（接口层、应用层），但是我不建议这样做，我们没有必要把很轻的一层再次拆分。我们也可以把依赖层拆分为两个（领域模型依赖、其他依赖），我非常建议这样做，因为领域模型依赖的资源不会被其他领域使用，拆开之后可以有效限制领域模型的依赖，</p>
<p>4、领域层是与环境无关的：无论某个领域是应用还是模块，都应该是完整的。应该具备独立的用例层和独立的模型层，即使多个领域在同一个应用当中，也要按照他们是分别独立去看待，无论某个领域是应用还是模块，领域对外部的交互，不可以绕过依赖层和接口层。</p>
<p>5、领域应该自治性的：把一个领域拆分为子域、子子域….. 无限拆分，子域就不完整了。或者没有按照功能相关性拆分，也可能破坏领域的完整性，不完整的领域不符合自治性原则。所以、不完整的领域不会单独存在，所以、当一个领域的内部子域不具备独立性时，子域之间不必严格解耦，不需要通过依赖层访问本领域的其他子域，他们之间可以直接调用。</p>
<p>6、领域用例层和领域模型层是两个层级：领域用例层指的就是领域服务层，不建议将领域服务与领域模型放在同一层，这可能会导致逻辑的分散（一部分在领域服务层、一部分在领域模型层）。如果将业务逻辑写在领域模型中，会导致业务逻辑进一步下沉，业务逻辑的不确定性太大，是不适合下沉的，是违反分层架构原则的。领域模型对应的是实体、领域服务对应的是用例，分开就是更有效的限制措施。</p>
<p>7、领域用例层只能承接符合自身领域的用例：我们划分出领域的目的，就是为了区分每个领域的职责所在，因此他们必须严格按照职责办事，我们在之前已明确了用例和领域之间的关系，需要严格遵守。 如果出现跨领域的编排，请在接口层串联。如果依赖其他领域的功能，请把被依赖的功能逻辑放在其他领域中。</p>
<p>8、领域模型层遵循最小依赖原则：只可以依赖必要的资源，必要资源指的是领域模型实现自身能力需要的资源，不包括实现业务逻辑依赖的资源。例如领域模型需要依赖DB完成持久化，可以依赖数据访问资源，但不应该依赖其他领域资源、不可以依赖RPC资源等。 最好的做法就是将领域模型依赖的资源单独拿出来，并且与领域模型放在一起。保持领域模型层的独立性，在多个领域应用共享领域模型时，方便使用共享内核的设计模式。</p>
<p>﻿</p>
<h2 id="2-4-微服务划分"><a href="#2-4-微服务划分" class="headerlink" title="2.4 微服务划分"></a>2.4 微服务划分</h2><p>服务划分以领域划分为参考，主要看我们要拆分到什么粒度，不建议将几个领域放在同一个服务中，不建议把一个完整的领域拆分为几个不完整的微服务。</p>
<p>产出物：微服务</p>
<p>﻿</p>
<p>例如餐厅：是有必要拆分的，餐厅的“菜品域”，“订单域”，“厨房域”有独立的问题空间，是具备自治性的。</p>
<p>例如厨房：是没有必要拆分的，厨师与刀工的耦合非常高，他们都在做饭，分开之后是不完整的，分开就是没有必要的。</p>
<p>﻿</p>
<p>所以餐厅被拆分为：<strong>厨房、菜品、订单</strong>，三个微服务。基于此、我们单独拿出<strong>餐厅门面服务</strong>作为接口层应用，再单独拿出<strong>餐厅基础服务</strong>作为水电煤气的应用。</p>
<p>一般情况下，依赖层不会作为单独的服务提供，会被以组件的形式嵌入到其他服务中。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/49ae85e1b195a812f56555e88bff5ad92e0cf49e9c090b2d108a4e8080e38540" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h1 id="3、功能设计（用例实现）"><a href="#3、功能设计（用例实现）" class="headerlink" title="3、功能设计（用例实现）"></a>3、功能设计（用例实现）</h1><p>如果说领域设计是餐厅的设计师、架构设计是餐厅的建筑师、那么功能设计就是餐厅的厨师。</p>
<p>任何设计都要落地到功能设计，如果厨师不守规则，偏偏要去洗手间洗菜，最后的结果依然是一团乱，最终会导致前面的所有设计泡汤。</p>
<p>功能设计是实现 “面向扩展开放、面向修改关闭” 的途径，</p>
<p>功能设计是为研发提供的落地支撑。</p>
<p>﻿</p>
<h2 id="3-1-功能的概念"><a href="#3-1-功能的概念" class="headerlink" title="3.1 功能的概念"></a>3.1 功能的概念</h2><p>功能迭代时，功能会发生一些变化，所以他的含义是可能变化的，所以我们需要再次审视功能的概念，及时加以调整。</p>
<p>例如、我们实现了一个“做蛋炒饭”的功能，后来又实现了一个“做辣椒炒蛋”的功能，那么我们应该将功能升级为“炒菜”，甚至是“制作菜品”等。</p>
<p>结合相关功能，系统性思考和抽象，明确功能的概念，是功能设计的前提。</p>
<p>产出物：更新语言库，更新脑图</p>
<p>﻿</p>
<h2 id="3-2-用例的位置"><a href="#3-2-用例的位置" class="headerlink" title="3.2 用例的位置"></a>3.2 用例的位置</h2><p>我们在1.3用例分析章节，明确了用例与角色的关系，在1.4领域划分章节，明确了用例与领域的关系。</p>
<p>然而一个新功能的加入，我们仍然要再次评估，以确保他处于正确的位置。按照之前的做法,根据功能相关性确认用例的领域，根据角色相关性确认用例的领域服务。</p>
<p>产出物：更新用例图</p>
<p>﻿</p>
<h2 id="3-3-事件风暴"><a href="#3-3-事件风暴" class="headerlink" title="3.3 事件风暴"></a>3.3 事件风暴</h2><p>事件风暴常用于梳理业务流程，适用于解构跨领域的复杂业务，感兴趣的朋友可以去自行学习。</p>
<p>但是、对于领域内的单功能，稍有复杂的时候，我们可以采取简化版事件风暴的方法，从而获得如下信息：</p>
<p>将功能拆分为多个子功能（步骤）。（在后续使用）</p>
<p>步骤对应的角色+角色身份。（在后续的3.6章节落地）</p>
<p>步骤的串联流程+领域事件。（在后续的3.6章节落地）</p>
<p>步骤依赖的实体。（在后续的3.7章节落地）</p>
<p>产出物：事件风暴模型</p>
<p>﻿</p>
<h2 id="3-4-用例分析"><a href="#3-4-用例分析" class="headerlink" title="3.4 用例分析"></a>3.4 用例分析</h2><p>我们暂且收回思路，首先要关注共性和差异问题，以实现功能复用或扩展。</p>
<ul>
<li>确认用例的泛化+差异点，实现功能的扩展。</li>
<li>寻找共同包含的步骤，实现逻辑的复用。</li>
</ul>
<p>产出物：用例分析图</p>
<p>﻿</p>
<p><strong>例：制作菜品（做大拌菜、做铁锅炖、做炒鸡蛋、做蒸米饭、做炒米饭）</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6524cc86f573441d9e72ac1b9b34f22d9d1fe24c33c3181a02c4a8ed1abd9a69" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="3-5-用例实现类（领域服务类）结构图"><a href="#3-5-用例实现类（领域服务类）结构图" class="headerlink" title="3.5 用例实现类（领域服务类）结构图"></a>3.5 用例实现类（领域服务类）结构图</h2><p>首要关注点是领域服务类的结构问题，结构决定了扩展，我们需要先达到“面相修改关闭，面相扩展开放”的目的。</p>
<p>领域服务的类结构图是用例图的映射，服务类结构图反向映射了角色的身份，进一步反向印证了上文的观点。</p>
<p>出物：用例层的类结构图</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/05a7a9bd08aee82f11528e059da6d42f939d3b0345ba41e569536a646362ad41" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="3-6-用例流程图"><a href="#3-6-用例流程图" class="headerlink" title="3.6 用例流程图"></a>3.6 用例流程图</h2><p>我们接回思路，更进一步，将事件风暴模型落实到代码层面。</p>
<p>我们将步骤分配到实现类中、步骤就是该类的一个方法，进一步明确由哪个类和方法来实现该步骤，从而就规定了步骤所在的领域服务。再将步骤和领域事件串联起来，规定了业务实现流程。</p>
<p>在确认步骤所在位置的时候，根据角色身份相关性定位步骤的具体实现类。</p>
<p>推荐使用泳道图表达上述内容，泳道的纵向组件是领域服务类，领域服务承接了所有子功能，流程图也需要体现所有的步骤，这是用例层的横向交互。</p>
<p>程序流程就是业务流程的映射，步骤分布体现了角色身份的差异。</p>
<p>产出物：用例流程图</p>
<p>﻿</p>
<p><strong>以炒鸡蛋为例，其用例流程图如下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c39fe5d87e2f598d66fa1c61e796cbdff8b1e4f166c0e8d356914ffebf9efdb0" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="3-7-活动图（时序图）"><a href="#3-7-活动图（时序图）" class="headerlink" title="3.7 活动图（时序图）"></a>3.7 活动图（时序图）</h2><p>进一步将事件风暴模型落实到代码层面，我们使用时序图，体现依赖和调用关系，规定了步骤与领域实体模型的关系，说明该步骤影响了谁。</p>
<p>时序图体现了领域服务内部的纵向交互，为了简便、我们可以收起领域服务类（用例层）的泳道。</p>
<p>产出物：时序图、活动图</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ffe3961bf4f225fe7319a7deba2624bfc49f3625105f3576258cbabf183835d" alt></p>
<p>﻿﻿</p>
<hr>
<p>﻿</p>
<p>在本篇文章中，通过三大步骤阐述了映射办法，让软件系统成为真实业务的说明书，软件系统似乎在对我们说“谁？在哪？做了什么事？影响了谁？是怎么做的？有什么差异？”。例如我们画的圈成为了应用名或包名，圈中的领域模型图成为了实体类+数据模型，圈中的用例图成为了领域服务和方法，功能流程成为了程序调用链，功能步骤成为了方法，领域服务类结构反向体现了角色身份，也体现了不同身份的差异…… 系统就是业务、业务就是系统、两者可以相互映射。</p>
<p>DDD的概念有很多，到底什么是DDD？是思想吗？是方法论吗？每个人都有自己的理解。在我看来、DDD是一套系统化的办法，无法用几句话说清楚，故而以此分享DDD的落地模式。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357957599844122624" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.jsVS.Net：国外网友也吵起来了！</title>
    <url>/7358295139457761317.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日有人在 Hacker News 上询问了有关 Node.js 和 .Net Core（2024）生态系统，此前在 2016 年也有过同样问题的讨论。引发激烈讨论，有喜欢 Node.js 的、有喜欢 .Net 的，还有 Go 和 Java。</p>
<p>下面摘选几个不同角度的热点评论：</p>
<h2 id="评论1：“两者都可以，但我更倾向于-Net”"><a href="#评论1：“两者都可以，但我更倾向于-Net”" class="headerlink" title="评论1：“两者都可以，但我更倾向于 .Net”"></a>评论1：“两者都可以，但我更倾向于 .Net”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a1405b03646da5c152d6cacd34a6410c12cf52c3e7ee8aeea38e435796076dfe" alt></p>
<p>网友 “Atotalnoob”：</p>
<blockquote>
<p>两者都可以。这真的取决于你的使用情况。在我看来，对于 .NET，开发体验要好得多，但它也更昂贵，通常需要 Windows（是的，Linux 上也完全可以使用 .NET）。微软在从头到尾构建更好、更简单的工具方面投入了大量资源。如果你是 Azure 店铺，部署将非常容易。</p>
<p>我还没有看最新的基准测试结果，但我曾经看过的时候，C# 在性能、多线程等方面是一个明显的赢家。Node.js 在任何方面都不慢，但也不是不慢。</p>
<p>Node.js 擅长开发速度和像 Next.js 或其他 SSG 中的 BFF 模式。.NET 将引导你进入更好的设计模式，以便未来更易于维护。在 Node.js 周围还有更多需要注意的地方，这主要是由于 JavaScript 的怪异性。</p>
<p>如果你同时使用 Node.js 后端和前端，那会非常不错。这是一种语言，如果你使用 TypeScript，你可以共享类型！</p>
<p>总的来说，两者都有取舍。当你在它们之间做出选择时，我更关心的是你的团队构成、技能组合和项目类型。</p>
<p>如果你逼我做选择，我会选择 .NET。”</p>
</blockquote>
<p>上面有一点是认同的，Node.js 服务端同前端是一种语言，因为大家都是用 JavaScript，学习成本总归是要低些的，有些通用的模块是可以共享的，例如，使用 TS 后，类型就可以共享啊！</p>
<h2 id="评论2-“Node-js-生产力方面无与伦比”"><a href="#评论2-“Node-js-生产力方面无与伦比”" class="headerlink" title="评论2: “Node.js 生产力方面无与伦比”"></a>评论2: “Node.js 生产力方面无与伦比”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bbed384f91a43f324df5141785d3383b4ee61c53e7eb279a514b38bb340418c2" alt></p>
<p>网友 @dzonga：</p>
<blockquote>
<p>.NET Core 相当不错。如果我没记错的话，它们甚至采用了与 Express 类似的 API。</p>
<p>是的，它也很快。比 Node 还要快。有类型等。但是 C# 是一种复杂的语言。而且它不断添加新特性。在 .NET 世界中有很棒的工具等。</p>
<p>但是你知道为什么 JavaScript / Node.js 会出色吗？JS 是一种简单的语言。当然，像 Clojure 这样的 Lisp 也很简单。但只有一种语言接近 JavaScript 的简洁性 – Go 语言。</p>
<p>但是 Go 语言像 JavaScript 一样灵活吗？</p>
<p>在 JavaScript 领域可能唯一不太好的是工具。但就服务器端的东西来说，比如处理 JSON / 转换 JSON，这正是信息类应用所需的 – 也就是我们大多数人工作的应用的大部分内容。Node.js 在生产力方面是无与伦比的。</p>
<p>所以，是的，Node.js 能够用 20% 的工作获得 80% 的结果。</p>
</blockquote>
<h2 id="评论3：“选择-JS-开发，因为不想与-Windows-人才打交道！”"><a href="#评论3：“选择-JS-开发，因为不想与-Windows-人才打交道！”" class="headerlink" title="评论3：“选择 JS 开发，因为不想与 Windows 人才打交道！”"></a>评论3：“选择 JS 开发，因为不想与 Windows 人才打交道！”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1daf0f27d79f0338906ae8717edd8d6393a5f4192a4231361b52d8ec15a50b7f" alt></p>
<blockquote>
<p>我知道你不是在询问技能背后的人格，但我宁愿选择一个 JS 开发，而不是一个 .NET 开发（即使（也许特别是）.NET Core 可以在 Linux 上运行），我甚至会更换整个技术栈，以避免与 Windows 人才打交道。基于 Microsoft 的生态系统中的 ClickOps 思维令人震惊。</p>
</blockquote>
<p>这哥们不知道与 Windows 有啥恩怨，以至于选择选择 JS 开发的原因是不想与 Windows 人才打交道 😂</p>
<h2 id="评论4：“我选择-go”"><a href="#评论4：“我选择-go”" class="headerlink" title="评论4：“我选择 go”"></a>评论4：“我选择 go”</h2><p>最后有一个由 @moomoo11 评论到 “正确的答案是 Go”</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d6f70ede0f59a59d80ea964427a0264fdcf165912c9773a14bb19937119c7325" alt></p>
<p>网友 @kcartlidge 回复到</p>
<blockquote>
<p>我使用 Go、Node 和 C#（还有当前的 Python、Ruby 和 PHP），正确答案是没有正确答案。</p>
<p>你能做到的最接近的就是使用你已经了解的知识。</p>
<p>如果你已经得出结论你已经了解的知识无法完成工作，那么理论上你已经掌握了缺失功能的知识，这让你能够根据特定的使用情况进行正确的技术评估。</p>
</blockquote>
<p>就好像有人说，我总是首先考虑 Go，还有人说 Go 是一个更糟糕的选择！正确上面 @kcartlidge 回复的，这里可能真的没有正确答案！</p>
<h2 id="评论5-“赚钱还得是我-PHP”"><a href="#评论5-“赚钱还得是我-PHP”" class="headerlink" title="评论5: “赚钱还得是我 PHP”"></a>评论5: “赚钱还得是我 PHP”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee29ab3ed777540b3bd7fa01f202c66a0dbb08530bdda6921691d96e6182a5eb" alt></p>
<p>这种讨论怎能没有我 PHP？网友 @delfinom 回复到：</p>
<blockquote>
<p>你要使用最适合你应用程序的工具。这就是任何语言争论的答案。</p>
<p>这就是人们即使只运行 PHP，也能赚取数百万利润的方式。</p>
</blockquote>
<p>前段时间知乎上有个 “<a href="https://www.zhihu.com/question/634587715" target="_blank" rel="noopener">2024年nodejs凉了吗？凉到什么程度了？</a>”，既然能有这么热烈的讨论，至少还没凉透吧，正常使用吧！没什么问题的。引用一句话：“世上只有两种编程语言：一种被人骂，一种没人用”。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://news.ycombinator.com/item?id=40014102" target="_blank" rel="noopener">news.ycombinator.com/item?id=400…</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358295139457761317" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>前端,Node.js,.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>一文讲透可升级合约，并通过hardhat+openzeppe</title>
    <url>/7357988193340653609.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>在我们进行合约开发时有一个痛点是，升级部署到链上后不能再更改，但如果了解<code>Solidity</code>比较深的小伙伴就知道，<code>Solidity</code>有个<code>delegate</code>方法，可以实现通过代理合约调用逻辑合约，我们的数据存储在代理合约中，执行的逻辑在逻辑合约中，我们想要升级合约时只需要部署新的逻辑合约即可。具体执行逻辑如下图：</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bd32e1d667e410a36723a9644b3beca6b073266ac1d1be2f3eaff20dfdab9d98" alt="image.png"></p>
<h3 id="一、简单可升级合约"><a href="#一、简单可升级合约" class="headerlink" title="一、简单可升级合约"></a>一、简单可升级合约</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">// wtf.academy</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">// 简单的可升级合约，管理员可以通过升级函数更改逻辑合约地址，从而改变合约的逻辑。</span><br><span class="line">// 教学演示用，不要用在生产环境</span><br><span class="line">contract SimpleUpgrade &#123;</span><br><span class="line">    address public implementation; // 逻辑合约地址</span><br><span class="line">    address public admin; // admin地址</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化admin和逻辑合约地址</span><br><span class="line">    constructor(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback函数，将调用委托给逻辑合约</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧逻辑合约</span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;old&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新逻辑合约</span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器：0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;new&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中包含了<code>3</code>个合约：</p>
<ul>
<li><code>SimpleUpgrade</code>: 代理合约</li>
<li><code>Logic1</code>: 旧逻辑合约</li>
<li><code>Logic2</code>: 新逻辑合约</li>
</ul>
<h4 id="1-代理合约SimpleUpgrade"><a href="#1-代理合约SimpleUpgrade" class="headerlink" title="1. 代理合约SimpleUpgrade"></a>1. 代理合约<code>SimpleUpgrade</code></h4><p>代理合约包含<code>3</code>个变量:</p>
<ul>
<li><code>implementation</code>: 逻辑合约地址</li>
<li><code>admin</code>: 合约管理员地址</li>
<li><code>words</code>: 字符串，通过调用逻辑合约函数来改变</li>
</ul>
<p>也包含了<code>3</code>个函数:</p>
<ul>
<li>构造函数: 初始化<code>admin</code>和<code>implementation</code>地址</li>
<li><code>fallback</code>函数: 委托函数，会将函数调用委托给逻辑合约执行，需要通过函数选择器<code>calldata</code>来调用</li>
<li><code>upgrade</code>函数: 升级函数，只能由<code>admin</code>调用，改变逻辑合约地址</li>
</ul>
<h4 id="2-旧逻辑合约"><a href="#2-旧逻辑合约" class="headerlink" title="2. 旧逻辑合约"></a>2. 旧逻辑合约</h4><p>旧逻辑合约中变量和代理合约保持一致（防止函数执行时插槽错误），通过代理合约调用时改变的状态变量是代理合约中的，有一个函数<code>foo</code>，将代理合约中的<code>words</code>值改为<code>old</code>。</p>
<h4 id="3-新逻辑合约"><a href="#3-新逻辑合约" class="headerlink" title="3. 新逻辑合约"></a>3. 新逻辑合约</h4><p>和旧逻辑合约逻辑一直，<code>foo</code>将代理合约中的<code>words</code>改为<code>new</code>。</p>
<h4 id="4-部署测试"><a href="#4-部署测试" class="headerlink" title="4. 部署测试"></a>4. 部署测试</h4><ol>
<li>在<code>Remix</code>中首先部署<code>旧逻辑合约(Logic1)</code>和<code>新逻辑合约(Logic2)</code></li>
<li>再部署<code>代理合约(SimpleUpgrade)</code>，构造函数中填入<code>旧逻辑合约(Logic1)</code>的地址</li>
<li>都部署好后可以通过<code>代理合约</code>去调用<code>旧逻辑合约</code>的<code>foo</code>函数，需要通过低级调用的方式填入函数签名在<code>calldata</code>中，这里填入<code>c2985578</code></li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7481e9d9c234ff123203cd156969d20b6fb743e1b832c2b3169cd94e0c56829b" alt="image-3.png"></p>
<p>函数签名可以通过<code>https://abi.hashex.org/</code>，来生成</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d077fadb445e31b25a3bcc5314d56fe61ef4537bc21e83feb941b71630d63925" alt="image-2.png"></p>
<ol start="4">
<li>此时查看<code>代理合约</code>中的<code>words</code>就被改成了<code>old</code></li>
<li>再调用代理合约的<code>upgrade</code>函数，填入<code>新逻辑合约</code>地址，实现逻辑合约的升级</li>
<li>最后再次通过低级调用的方式填入函数签名在<code>calldata</code>中调用新逻辑合约的<code>foo</code>函数，就可以看到代理合约中的<code>words</code>改变为了<code>new</code></li>
</ol>
<p>到此，我们就完成了可升级合约的开发和部署，但可升级合约还有可能产生选择器冲突问题。</p>
<h3 id="二、透明代理和通用可升级代理-UUPS"><a href="#二、透明代理和通用可升级代理-UUPS" class="headerlink" title="二、透明代理和通用可升级代理(UUPS)"></a>二、透明代理和通用可升级代理(UUPS)</h3><p>大家可以看到我们上面填的两个<code>foo</code>函数的函数签名其实是<code>foo</code>哈希后取的前 4 个字节，4 个字节这个范围其实很少，两个不同的函数很有可能造成<code>hash</code>的前 4 个字节一样，这就造成了选择器冲突。</p>
<p>如果选择器冲突出现在同一个合约中，那么合约是无法编译成功的，但是可升级合约会部署两个合约，比如代理合约的升级函数和逻辑合约中其中一个函数有选择器冲突，那么管理人在调用逻辑合约中的函数就可能将代理合约升级成黑洞合约，有严重的安全问题。</p>
<p>解决的方法一般有两种：</p>
<ul>
<li>透明代理</li>
<li>通用可升级代理</li>
</ul>
<h4 id="1-透明代理"><a href="#1-透明代理" class="headerlink" title="1. 透明代理"></a>1. 透明代理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">// wtf.academy</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">// 透明可升级合约的教学代码，不要用于生产。</span><br><span class="line">contract TransparentProxy &#123;</span><br><span class="line">    address implementation; // logic合约地址</span><br><span class="line">    address admin; // 管理员</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化admin和逻辑合约地址</span><br><span class="line">    constructor(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback函数，将调用委托给逻辑合约</span><br><span class="line">    // 不能被admin调用，避免选择器冲突引发意外</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        require(msg.sender != admin);</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        if (msg.sender != admin) revert();</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧逻辑合约</span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;old&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新逻辑合约</span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器：0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;new&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透明代理是通过限制管理员的权限，管理员只能调用代理合约中的升级函数，不能调用逻辑合约中函数，其他用户只能调用逻辑合约中的函数不能调用代理合约的升级函数来解决选择器冲突问题。</p>
<h4 id="2-通用可升级代理-UUPS"><a href="#2-通用可升级代理-UUPS" class="headerlink" title="2. 通用可升级代理(UUPS)"></a>2. 通用可升级代理(UUPS)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">// wtf.academy</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract UUPSProxy &#123;</span><br><span class="line">    address public implementation; // 逻辑合约地址</span><br><span class="line">    address public admin; // admin地址</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化admin和逻辑合约地址</span><br><span class="line">    constructor(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback函数，将调用委托给逻辑合约</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UUPS逻辑合约（升级函数写在逻辑合约内）</span><br><span class="line">contract UUPS1&#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;old&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span><br><span class="line">    // UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新的UUPS逻辑合约</span><br><span class="line">contract UUPS2&#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;new&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span><br><span class="line">    // UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用可升级代理(UUPS)是通过把升级函数也放在逻辑合约中，代理合约只存储状态变量和调用逻辑合约中的所有函数(升级函数和其他逻辑函数)来解决选择器冲突问题，因为通过代理合约来调用逻辑合约的升级函数时，改变的也是代理合约中存储的逻辑合约的地址，这样我们其实升级也是没有任何问题的。</p>
<h3 id="三、使用Hardhat-OpenZeppelin开发生产环境的可升级合约"><a href="#三、使用Hardhat-OpenZeppelin开发生产环境的可升级合约" class="headerlink" title="三、使用Hardhat+OpenZeppelin开发生产环境的可升级合约"></a>三、使用<code>Hardhat</code>+<code>OpenZeppelin</code>开发生产环境的可升级合约</h3><p>用上面的办法开发的可升级合约，虽然可以实现可升级功能，但对于一些安全问题没有很好的处理，所以我们一般在实际项目开发中会使用如<code>Hardhat</code>、<code>OpenZeppelin</code>等工具来开发可升级合约。</p>
<h4 id="1-初始化一个Hardhat项目"><a href="#1-初始化一个Hardhat项目" class="headerlink" title="1. 初始化一个Hardhat项目"></a>1. 初始化一个<code>Hardhat</code>项目</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm init</span><br><span class="line">npm install --save-dev hardhat</span><br><span class="line">npx hardhat init</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码$ npx hardhat init</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888</span><br><span class="line">888    888     &quot;88b 888P&quot;  d88&quot; 888 888 &quot;88b     &quot;88b 888</span><br><span class="line">888    888 .d888888 888    888  888 888  888 .d888888 888</span><br><span class="line">888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.</span><br><span class="line">888    888 &quot;Y888888 888     &quot;Y88888 888  888 &quot;Y888888  &quot;Y888</span><br><span class="line"></span><br><span class="line">👷 Welcome to Hardhat v2.22.2 👷‍</span><br><span class="line"></span><br><span class="line">? What do you want to do? …</span><br><span class="line">&gt; Create a JavaScript project</span><br><span class="line">  Create a TypeScript project</span><br><span class="line">  Create a TypeScript project (with Viem)</span><br><span class="line">  Create an empty hardhat.config.js</span><br><span class="line">  Quit</span><br></pre></td></tr></table></figure>

<h4 id="2-安装OpenZeppelin可升级合约的hardhat插件依赖和合约依赖"><a href="#2-安装OpenZeppelin可升级合约的hardhat插件依赖和合约依赖" class="headerlink" title="2. 安装OpenZeppelin可升级合约的hardhat插件依赖和合约依赖"></a>2. 安装<code>OpenZeppelin</code>可升级合约的<code>hardhat</code>插件依赖和合约依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm install --save-dev @openzeppelin/hardhat-upgrades</span><br><span class="line">npm install --save-dev @openzeppelin/contracts-upgradeable</span><br></pre></td></tr></table></figure>

<h4 id="3-合约编写"><a href="#3-合约编写" class="headerlink" title="3. 合约编写"></a>3. 合约编写</h4><p><code>contracts/Box.sol</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solidity复制代码// contracts/Box.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Box is Initializable &#123;</span><br><span class="line">    uint256 private _value;</span><br><span class="line"></span><br><span class="line">    function initialize(uint256 value) public initializer &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Emitted when the stored value changes</span><br><span class="line">    event ValueChanged(uint256 value);</span><br><span class="line"></span><br><span class="line">    // Stores a new value in the contract</span><br><span class="line">    function store(uint256 value) public &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">        emit ValueChanged(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reads the last stored value</span><br><span class="line">    function retrieve() public view returns (uint256) &#123;</span><br><span class="line">        return _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合约很简单，就是存储了一个<code>_value</code>值，并通过<code>store</code>来修改这个值，并通过<code>retrieve</code>来读取这个值。</p>
<p>其中有个很关键的<code>initialize</code>函数，这是合约的初始化函数，在以前我们写构造函数是通过<code>constructor</code>，但在<code>OpenZeppelin</code>可升级合约中需要使用<code>initialize</code>函数。并通过继承<code>Initializable</code>合约，并在<code>initialize</code>函数上添加<code>initializer</code>函数修饰器来确保这个初始化函数只能执行一次。</p>
<h4 id="4-部署合约"><a href="#4-部署合约" class="headerlink" title="4. 部署合约"></a>4. 部署合约</h4><p><code>script/deploy.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码const &#123; ethers, upgrades &#125; = require(&quot;hardhat&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  const Box = await ethers.getContractFactory(&quot;Box&quot;);</span><br><span class="line">  console.log(&quot;Deploying Box...&quot;);</span><br><span class="line">  const box = await upgrades.deployProxy(Box, [70]);</span><br><span class="line">  console.log(&quot;Box deployed to:&quot;, box.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<p>其中<code>deployProxy</code>的第二参数为初始化函数需要的参数，通过数组的形式传进去，然后通过运行下面命令来部署，<code>--network</code>为我自己添加的本地<code>ganache</code>网络，也可以改成其他网络或者不写，不写会部署到<code>hardhat</code>的本地测试网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat run script/deploy.js --network ganache</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ca8ba6c93c8270a74522eefd2127b3973de64a2d8199f2b0fe0837cc16dba2cb" alt="image-4.png"></p>
<h4 id="5-可以通过hardhat提供的console来测试"><a href="#5-可以通过hardhat提供的console来测试" class="headerlink" title="5. 可以通过hardhat提供的console来测试"></a>5. 可以通过<code>hardhat</code>提供的<code>console</code>来测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat console --network ganache</span><br><span class="line">Welcome to Node.js v12.22.1.</span><br><span class="line">Type &quot;.help&quot; for more information.</span><br><span class="line">&gt; const Box = await ethers.getContractFactory(&apos;Box&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const box = await Box.attach(&apos;0xC707173c04105676B7AbadEA745A1cc04f3A5b3A&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; (await box.retrieve()).toString();</span><br><span class="line">&apos;70&apos;</span><br></pre></td></tr></table></figure>

<p>其中<code>Box.attach</code>函数需要填入我们上面部署好的<code>Box</code>合约地址。</p>
<h4 id="6-编写新的BoxV2合约"><a href="#6-编写新的BoxV2合约" class="headerlink" title="6. 编写新的BoxV2合约"></a>6. 编写新的<code>BoxV2</code>合约</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solidity复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract BoxV2 is Initializable &#123;</span><br><span class="line">    uint256 private _value;</span><br><span class="line"></span><br><span class="line">    function initialize(uint256 value) public initializer &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Emitted when the stored value changes</span><br><span class="line">    event ValueChanged(uint256 value);</span><br><span class="line"></span><br><span class="line">    // Stores a new value in the contract</span><br><span class="line">    function store(uint256 value) public &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">        emit ValueChanged(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reads the last stored value</span><br><span class="line">    function retrieve() public view returns (uint256) &#123;</span><br><span class="line">        return _value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Increments the stored value by 1</span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        _value = _value + 1;</span><br><span class="line">        emit ValueChanged(_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>BoxV2</code>合约中我们新增了一个<code>increment</code>函数，用来增加<code>_value</code>的值。</p>
<h4 id="7-编写升级脚本"><a href="#7-编写升级脚本" class="headerlink" title="7. 编写升级脚本"></a>7. 编写升级脚本</h4><p><code>script/upgrade.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码const &#123; ethers, upgrades &#125; = require(&quot;hardhat&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  const BoxV2 = await ethers.getContractFactory(&quot;BoxV2&quot;);</span><br><span class="line">  console.log(&quot;Upgrading Box...&quot;);</span><br><span class="line">  await upgrades.upgradeProxy(</span><br><span class="line">    &quot;0xC707173c04105676B7AbadEA745A1cc04f3A5b3A&quot;,</span><br><span class="line">    BoxV2</span><br><span class="line">  );</span><br><span class="line">  console.log(&quot;Box upgraded&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<p>其中<code>upgradeProxy</code>函数需要填入我们上面部署好的<code>Box</code>合约地址，并在命令行执行下面命令来升级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat run .\scripts\upgrade.js --network ganache</span><br></pre></td></tr></table></figure>

<p>最后在通过<code>hardhat</code>的<code>console</code>来测试发现就多了一个<code>increment</code>函数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat console --network ganache</span><br><span class="line">Welcome to Node.js v12.22.1.</span><br><span class="line">Type &quot;.help&quot; for more information.</span><br><span class="line">&gt; const BoxV2 = await ethers.getContractFactory(&apos;BoxV2&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const box = await BoxV2.attach(&apos;0xC707173c04105676B7AbadEA745A1cc04f3A5b3A&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; await box.increment();</span><br><span class="line">...</span><br><span class="line">&gt; (await box.retrieve()).toString();</span><br><span class="line">&apos;71&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此我们就通过<code>Hardhat</code>和<code>OpenZeppelin</code>来实现了一个生产环境可用的可升级合约，大家开发自己的可升级合约时就可以参考这个形式开发即可。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357988193340653609" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>web3,区块链,智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Debezium在Spring应用程序中监听M</title>
    <url>/7358295139457957925.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要在 Spring 应用程序中监听 MySQL 的 binlog（二进制日志），您可以使用开源库 Debezium。Debezium 提供了一个 Kafka Connect 插件，用于捕获 MySQL、PostgreSQL、MongoDB 等数据库的数据变更事件。</p>
<p>以下是使用 Debezium 在 Spring 应用程序中监听 MySQL binlog 的步骤：</p>
<ol>
<li>在 <code>pom.xml</code> 文件中添加 Debezium 的依赖项：</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.debezium&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;debezium-connector-mysql&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 Debezium</li>
</ol>
<hr>
<p>在 application.yml 文件中添加以下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码debezium:</span><br><span class="line">  connector:</span><br><span class="line">    name: my-connector</span><br><span class="line">    connector.class: io.debezium.connector.mysql.MySqlConnector</span><br><span class="line">    tasks.max: 1</span><br><span class="line">    database.hostname: localhost</span><br><span class="line">    database.port: 3306</span><br><span class="line">    database.user: root</span><br><span class="line">    database.password: root</span><br><span class="line">    database.server.id: 184054</span><br><span class="line">    database.server.name: my-server</span><br><span class="line">    database.history.kafka.bootstrap.servers: localhost:9092</span><br><span class="line">    database.history.kafka.topic: dbhistory.my-server</span><br><span class="line">    database.include.list: mydatabase</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个配置类 <code>BinlogListenerConfiguration</code>用于设置 Debezium 的配置并启动嵌入式引擎：</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dart复制代码import io.debezium.config.Configuration;</span><br><span class="line">import io.debezium.embedded.EmbeddedEngine;</span><br><span class="line">import io.debezium.engine.ChangeEvent;</span><br><span class="line">import io.debezium.engine.DebeziumEngine;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line"> public class BinlogListenerConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        public DebeziumEngine&lt;ChangeEvent&lt;Object, Object&gt;&gt; debeziumEngine() &#123;</span><br><span class="line">            // Debezium 配置</span><br><span class="line">            Configuration config = Configuration.create()</span><br><span class="line">                    .with(&quot;connector.class&quot;, &quot;io.debezium.connector.mysql.MySqlConnector&quot;)</span><br><span class="line">                    .with(&quot;offset.storage&quot;, &quot;org.apache.kafka.connect.storage.MemoryOffsetBackingStore&quot;)</span><br><span class="line">                    .with(&quot;offset.flush.interval.ms&quot;, 60000)</span><br><span class="line">                    .with(&quot;name&quot;, &quot;mysql-connector&quot;)</span><br><span class="line">                    .with(&quot;database.hostname&quot;, &quot;localhost&quot;)</span><br><span class="line">                    .with(&quot;database.port&quot;, 3306)</span><br><span class="line">                    .with(&quot;database.user&quot;, &quot;your_database_user&quot;)</span><br><span class="line">                    .with(&quot;database.password&quot;, &quot;your_database_password&quot;)</span><br><span class="line">                    .with(&quot;database.server.id&quot;, 1)</span><br><span class="line">                    .with(&quot;database.server.name&quot;, &quot;your_database_server_name&quot;)</span><br><span class="line">                    .with(&quot;database.whitelist&quot;, &quot;your_database_name&quot;)</span><br><span class="line">                    .with(&quot;database.history&quot;, &quot;io.debezium.relational.history.MemoryDatabaseHistory&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            // 创建 Debezium 引擎</span><br><span class="line">            DebeziumEngine&lt;ChangeEvent&lt;Object, Object&gt;&gt; engine = DebeziumEngine.create(ChangeEvent.class)</span><br><span class="line">                    .using(config)</span><br><span class="line">                    .notifying(record -&gt; &#123;</span><br><span class="line">                        System.out.println(&quot;Received change event: &quot; + record);</span><br><span class="line">                    &#125;).build();</span><br><span class="line">            // 使用单独的线程启动 Debezium 引擎</span><br><span class="line">            Executor executor = Executors.newSingleThreadExecutor();</span><br><span class="line">            executor.execute(engine);</span><br><span class="line">            return engine;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这个配置类中，我们首先创建了一个 Debezium 配置对象，其中包含了连接到 MySQL 数据库所需的所有信息。然后，我们创建了一个 Debezium 引擎，该引擎在接收到 binlog 事件时调用指定的通知函数。最后，我们使用一个单独的线程启动 Debezium 引擎。</p>
<ol start="4">
<li>现在，每当数据库发生更改时，您的 Spring 应用程序都会接收到 binlog 事件。</li>
</ol>
<hr>
<p>在上面的示例中，我们只是简单地将接收到的事件打印到控制台。您可以根据需要修改通知函数以处理这些事件，例如将它们发送到消息队列、更新缓存等。</p>
<p>请注意，Debezium 仅支持 InnoDB 存储引擎。确保您的 MySQL 数据库使用 InnoDB 存储引擎。此外，确保已启用 binlog，并将 <code>binlog_format</code> 设置为 <code>ROW</code>。要了解有关 Debezium 的更多信息，如何配置过滤器等，请访问官方文档：<a href="https://debezium.io/documentation/reference/connectors/mysql.html%E3%80%82" target="_blank" rel="noopener">debezium.io/documentati…</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358295139457957925" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>MySQL,Debezium,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：循</title>
    <url>/7358302760150564876.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：循环引用与代理解决方案</strong></p>
<p>在 TypeScript 中，构建大型应用程序或框架时，可能会遇到循环引用的问题。循环引用通常发生在两个或多个模块或类相互依赖，形成一个闭环的情况。这可能导致代码难以维护，甚至在某些情况下引发运行时错误。本文将解释什么是循环引用，并通过一个 <code>UserService</code> 和 <code>OrderService</code> 的例子来说明问题，然后展示如何通过代理（Proxy）和接口（Interface）来解决循环引用。</p>
<p><strong>什么是循环引用？</strong></p>
<p>循环引用是指两个或多个对象或模块相互引用对方，形成一个闭环。在 TypeScript 中，当两个类相互导入对方时，就可能发生循环引用。例如，类 A 依赖于类 B 的实例，而类 B 又依赖于类 A 的实例，这就形成了一个循环引用。</p>
<p><strong>UserService 和 OrderService 循环引用示例</strong></p>
<p>考虑一个简单的电商应用，其中 <code>UserService</code> 负责处理用户相关的操作，<code>OrderService</code> 负责处理订单相关的操作。这两个服务在逻辑上可能需要互相调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// user-service.ts</span><br><span class="line">import &#123; OrderService &#125; from &apos;./order-service&apos;;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">  constructor(private orderService: OrderService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // ... UserService 的其他方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// order-service.ts</span><br><span class="line">import &#123; UserService &#125; from &apos;./user-service&apos;;</span><br><span class="line"></span><br><span class="line">export class OrderService &#123;</span><br><span class="line">  constructor(private userService: UserService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // ... OrderService 的其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 和 <code>OrderService</code> 都通过构造函数注入的方式依赖于对方，这直接导致了循环引用。当 TypeScript 编译器尝试编译这些文件时，会抛出一个错误，因为两个类都相互依赖，导致无法解析依赖关系。</p>
<p><strong>使用 TypeScript 的 Proxy 解决循环引用</strong></p>
<p>在 TypeScript 中，你可以使用 ES6 的 <code>Proxy</code> 对象来动态地处理对象，包括解决循环引用问题。虽然 <code>Proxy</code> 本身不直接解决循环引用的问题，但你可以用它来实现一种延迟初始化或懒加载的策略，避免在初始化时直接创建循环依赖。</p>
<p>为了解决这个问题，我们可以对 <code>UserService</code> 和 <code>OrderService</code> 的构造函数进行重构，使其接受工厂函数而不是直接实例，这样我们就可以延迟创建实例，直到真正需要的时候。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// user-service.ts</span><br><span class="line">import &#123; IOrderService &#125; from &apos;./IOrderService&apos;;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">  private orderService: IOrderService;</span><br><span class="line"></span><br><span class="line">  constructor(getOrderService: () =&gt; IOrderService) &#123;</span><br><span class="line">    this.orderService = getOrderService();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ... UserService 的其他方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// order-service.ts</span><br><span class="line">import &#123; IUserService &#125; from &apos;./IUserService&apos;;</span><br><span class="line"></span><br><span class="line">export class OrderService &#123;</span><br><span class="line">  private userService: IUserService;</span><br><span class="line"></span><br><span class="line">  constructor(getUserService: () =&gt; IUserService) &#123;</span><br><span class="line">    this.userService = getUserService();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ... OrderService 的其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们定义接口，并使用 <code>Proxy</code> 来实现延迟初始化的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// IUserService.ts</span><br><span class="line">export interface IUserService &#123;</span><br><span class="line">  // ... UserService 的方法声明</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IOrderService.ts</span><br><span class="line">export interface IOrderService &#123;</span><br><span class="line">  // ... OrderService 的方法声明</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts 或者你的应用启动文件</span><br><span class="line">import &#123; UserService &#125; from &apos;./user-service&apos;;</span><br><span class="line">import &#123; OrderService &#125; from &apos;./order-service&apos;;</span><br><span class="line">import &#123; IUserService &#125; from &apos;./IUserService&apos;;</span><br><span class="line">import &#123; IOrderService &#125; from &apos;./IOrderService&apos;;</span><br><span class="line"></span><br><span class="line">const getUserService = () =&gt; &#123;</span><br><span class="line">  return new UserService(getOrderService);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getOrderService = () =&gt; &#123;</span><br><span class="line">  return new OrderService(getUserService);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userServiceProxy = new Proxy(getUserService, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    return Reflect.apply(target, thisArg, argumentsList);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const orderServiceProxy = new Proxy(getOrderService, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    return Reflect.apply(target, thisArg, argumentsList);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const userService: IUserService = userServiceProxy();</span><br><span class="line">const orderService: IOrderService = orderServiceProxy();</span><br><span class="line"></span><br><span class="line">// 现在你可以使用 userService 和 orderService，它们之间不会有循环引用的问题</span><br></pre></td></tr></table></figure>

<p>在这个解决方案中，<code>getUserService</code> 和 <code>getOrderService</code> 是工厂函数，它们返回 <code>UserService</code> 和 <code>OrderService</code> 的实例。通过使用 <code>Proxy</code>，我们确保在第一次调用这些工厂函数时，它们会相互调用对方来创建实例，但不会立即形成循环引用，因为实际的创建操作被推迟到了第一次调用代理对象的 <code>apply</code> 陷阱时。</p>
<p>请注意，这种方法仍然需要小心处理，确保逻辑上 <code>UserService</code> 和 <code>OrderService</code> 的使用不会造成逻辑上的死循环。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358302760150564876" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的用户弹窗竟然也可以这么复杂</title>
    <url>/7358306245348851738.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，我是小趴菜，最近有一个需求，就是之后有新功能上线，那么用户在登录以后需要给个弹窗，主要是为了提醒用户，平台新增了这么一个功能，当然用户弹了一次之后，后续就不用再弹了</p>
<p>当然后续有新功能上线依然是需要弹的，需求就是这样，其实也蛮简单的对不对？？？</p>
<p>接下来我们就一步一步的来设计一下，该如何实现这个功能</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>做什么需求都是需要把流程搞明白的，不然后面麻烦就大了，</p>
<ul>
<li>1：用户登录，判断这个用户对应的这个新功能对应的弹窗是否有弹过</li>
<li>2：如果有弹过，就返回给前端一个状态值，就不需要弹了，比如 {“功能ID”:1,”是否弹过”:1}</li>
<li>3：如果没有弹过，那么返回前端一个{“功能ID”:1,”是否弹过”:0}</li>
<li>4：前端拿到这个json数据，判断是否弹过，然后再根据新功能的ID来弹出对应的弹框就行了</li>
</ul>
<h2 id="数据库存储方案"><a href="#数据库存储方案" class="headerlink" title="数据库存储方案"></a>数据库存储方案</h2><p>首先我们会想到，在数据库建一张新功能的表，然后再建一张用户与新功能之间的关联关系表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码新功能表：obility</span><br><span class="line">id：新功能的主键</span><br><span class="line">obility_name：新功能的名称</span><br><span class="line">obility_desc：新功能的描述</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用户与新功能的关联关系表:obility_user</span><br><span class="line">id：主键</span><br><span class="line">user_id：用户ID</span><br><span class="line">obility_id：新功能的id</span><br><span class="line">is_open：是否弹过 0:没有，1：弹过了</span><br></pre></td></tr></table></figure>

<p>那么判断的流程是这样的</p>
<ul>
<li>1：拿到这个登录的用户的user_id</li>
<li>2：去数据库查ubility_user表，找到这个用户所有的is_open=0的记录</li>
<li>3：如果查询不为空，那么这些就是这次用户需要弹的弹窗</li>
</ul>
<p>现在用户登录进来，首先拿到这个登录用户的ID，然后去obility_user表中查询出这个用户有哪些新功能的弹窗没有弹出来过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码select * from obility_user where user_id = 1 and is_open = 0;</span><br></pre></td></tr></table></figure>

<p>我们拿到这个用户所有没有弹过的新功能，然后进行拼接一起返回给前端就行了，好了，这个功能其实到这也就实现的差不多了</p>
<p>但是这种方案会不会存在什么弊端呢？？？</p>
<h4 id="弊端一：数据量问题"><a href="#弊端一：数据量问题" class="headerlink" title="弊端一：数据量问题"></a>弊端一：数据量问题</h4><p>其实在用户量小，并且你的新功能确定不会很多的时候，这种方式确实是可以实现的，因为数据量不是很大，后续加个索引查询也没什么问题</p>
<p>如果现在你的用户量很大，比如说有1000万，这时候加一个新功能，那么你这张obility_user表就会有1000万的数据，那如果有10个新功能，那就是1亿的数据，这时候单表肯定满足不了我们的业务了，所以你会采用分表来做，这时候的就要引入分库分表的中间件了，总的来说实现太复杂了</p>
<h4 id="弊端二：数据同步问题"><a href="#弊端二：数据同步问题" class="headerlink" title="弊端二：数据同步问题"></a>弊端二：数据同步问题</h4><p>而且这种方案其实还有一个弊端，就是我们查询的时候，这个时候这个新功能与用户的关联关系记录是已经存在表内的，也就是说我们在发布一个新功能的时候就要把所有用户跟这个新功能的关联关系都要同步到obility_user这张表中，不然用户登录的时候是查不到，那么也就不会有弹窗了</p>
<p>所以你还要保证这个新功能与所有用户的关联关系记录都成功保存到obility_user这张表中，当然少量的数据丢失也没什么影响，那这时候你是不是还要再做个数据同步的功能？？</p>
<p>还有数据同步是需要时间的，如果你有几千万的数据，对吧，所有记录维护好需要10分钟时间，这时候有个用户登录进来了，但是这个新功能与这个用户的关联关系还没保存到数据库中，这时候就不会弹这个弹窗，然后这个用户发现有这个新功能就使用了，后续用户再登录的时候，这时候这个新功能与这个用户的关联关系保存到数据库了，这时候就会弹出这个弹窗，对于用户来说就有点体验不好了</p>
<h2 id="数据库存储方案-优化"><a href="#数据库存储方案-优化" class="headerlink" title="数据库存储方案-优化"></a>数据库存储方案-优化</h2><p>之前的方案中我们发现要实现起来太麻烦了，比如数据量大需要分库分表，还要做数据同步，还有数据延迟的问题</p>
<p>之前查询的是ubility_user表，然后拿到这个用户所有 is_open这个字段等于0的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码select * from obility_user where user_id = 1 and is_open = 0;</span><br></pre></td></tr></table></figure>

<p>这时候我们换种查询流程</p>
<ul>
<li>1：获取登录用户的user_id</li>
<li>2：还是去查ubility_user这张表，查询出这个用户与哪些新功能已经存在关联记录了</li>
<li>3：与ubility表做对比，判断这个用户还有哪些新功能不存在这个关联记录的</li>
<li>4：那么不存在关联记录的这些新功能就是这次用户要弹的弹窗了</li>
<li>5：用户弹窗之后，在ubility_user表插入这几条关联关系的记录</li>
</ul>
<p>相比于之前的方案，这时候我们发布一个新功能就不需要提前做好用户与新功能的关联关系了，我们把这个流程放到登录的时候判断了，那么也就不会存在数据延迟的问题了</p>
<p>而且这个方案可以在一定程度上减少我们ubility_user这张表的数据量，试想一下，系统里面有100万的用户，难道这100万的用户真的都是真实用户吗？难道就没有一些所谓的僵尸用户？？？</p>
<p>其实这个所谓的僵尸用户是不会登录我们系统的，这些用户不登陆，那么ubility_user这张表就不会存他们的关联关系了</p>
<p>但是依然没有解决数据量的问题，即使除了那些僵尸用户，真实用户还是有很多，后续你的新功能多了，ubility_user这张表的数据量还是有很多，还是避免不了要分表</p>
<h2 id="使用redis来存储"><a href="#使用redis来存储" class="headerlink" title="使用redis来存储"></a>使用redis来存储</h2><p>仔细想想，其实我们只需要知道用户在登录的时候这个新功能的弹窗有没有弹出来过，无非就是弹过，没弹过两种，那么redis中的bitmap数据类型就很符合我们的业务了，我们一个新功能就建立一个新的bitmap,KEY呢就是这个新任务的ID，每个用户对应着一个bit位，如果这个用户对应的这个任务上的值是0,那么就没有弹过，弹窗之后把这个对应的用户的值改成1就可以了</p>
<p>这样后续即使有多个新任务也就是多几个bitmap而已，我们也不需要使用数据库来存储，也不用考虑后续数据量多了还要分库分表了，简单多了</p>
<p>而且即使redis有些时候丢了一点数据也无所谓，大不了就再弹一次嘛，对于用户来说其实影响也不大的</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358306245348851738" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：依</title>
    <url>/7358310951478804491.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：依赖注入</strong></p>
<p>在构建 Web 框架时，依赖注入（Dependency Injection, DI）是一个非常重要的概念。它允许我们在不改变类代码的情况下，将类的依赖从外部注入到类中，从而提高了代码的可测试性和可维护性。本文将介绍依赖注入的基本概念，并通过一个具体的例子，展示如何在 TypeScript 中实现依赖注入。</p>
<p><strong>什么是依赖注入？</strong></p>
<p>依赖注入是一种设计模式，它的核心思想是将一个对象所依赖的其他对象以参数的形式传入，而不是在对象内部通过 new 关键字来创建。这样做的好处是，可以轻松地替换依赖对象，使得代码更加灵活和可测试。</p>
<p><strong>UserController 中注入 UserService 的例子</strong></p>
<p>假设我们有一个 <code>IUserService</code> 接口和一个实现了该接口的 <code>UserService</code> 类，以及一个需要依赖 <code>UserService</code> 的 <code>UserController</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码// IUserService.ts</span><br><span class="line">interface IUserService &#123;</span><br><span class="line">  getUserById(id: number): Promise&lt;User&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserService.ts</span><br><span class="line">class UserService implements IUserService &#123;</span><br><span class="line">  async getUserById(id: number): Promise&lt;User&gt; &#123;</span><br><span class="line">    // 模拟从数据库获取用户信息的操作</span><br><span class="line">    return &#123; id, name: `User $&#123;id&#125;` &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IUserController.ts</span><br><span class="line">interface IUserController &#123;</span><br><span class="line">  getUser(id: number): Promise&lt;User&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserController.ts</span><br><span class="line">class UserController implements IUserController &#123;</span><br><span class="line">  constructor(private readonly userService: IUserService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  async getUser(id: number): Promise&lt;User&gt; &#123;</span><br><span class="line">    return this.userService.getUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要使用 IoC 容器来管理服务的注册和获取。同时，我们将使用 TypeScript 的反射 API 来动态获取 <code>UserController</code> 构造函数的参数类型，并从 IoC 容器中获取对应参数的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码// index.ts</span><br><span class="line">import &apos;reflect-metadata&apos;;</span><br><span class="line"></span><br><span class="line">function constructController&lt;T&gt;(ControllerClass: new (...args: any[]) =&gt; T, iocContainer: typeof IoCContainer): T &#123;</span><br><span class="line">  // 获取 ControllerClass 的构造函数参数类型</span><br><span class="line">  const constructorTypes = Reflect.getMetadata(&apos;design:paramtypes&apos;, ControllerClass);</span><br><span class="line"></span><br><span class="line">  // 假设服务名称与接口名相同（以 I 开头）</span><br><span class="line">  const dependencies = constructorTypes.map(type =&gt; &#123;</span><br><span class="line">    const serviceName = type.name.replace(/^I/, &apos;&apos;); // 去掉接口名前的 I</span><br><span class="line">    return iocContainer.resolve(serviceName);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 使用 Reflect.construct 创建 Controller 实例</span><br><span class="line">  return Reflect.construct(ControllerClass, dependencies) as T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reflect.getMetadata(‘design:paramtypes’, ControllerClass) 这行代码的作用是获取 ControllerClass 构造函数的参数类型信息。这里 ‘design:paramtypes’ 是一个特殊的元数据键，它对应的是 TypeScript 编译器在编译时自动添加的关于构造函数参数类型的元数据。</p>
<p>当你使用 TypeScript 定义一个类，并且这个类的构造函数带有参数时，TypeScript 编译器会生成一些额外的元数据来记录这些参数的类型。这些元数据在编译后的 JavaScript 代码中是不可见的，但是可以通过反射 API 在运行时访问。</p>
<p>通过 Reflect.getMetadata(‘design:paramtypes’, ControllerClass)，你可以得到一个数组，数组中的每个元素代表 ControllerClass 构造函数的一个参数的类型。这些类型通常是构造函数的函数对象本身（对于类类型），而不是字符串或其他表示形式。</p>
<p>这在你想要动态创建类的实例，并且需要知道构造函数的参数类型以便正确传递依赖时特别有用。通过获取这些类型信息，你可以从 IoC 容器中查找相应的实例，并传递给构造函数。</p>
<p>需要注意的是，为了使用 Reflect.getMetadata 和相关的反射 API，你需要在项目中包含 reflect-metadata 这个库，并且需要在 TypeScript 的配置文件中（通常是 tsconfig.json）启用发射元数据（emitDecoratorMetadata 和 experimentalDecorators）的选项。</p>
<p>现在，我们需要在 IoC 容器中注册 <code>UserService</code>，并使用 <code>constructController</code> 函数来创建 <code>UserController</code> 的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码// app.ts</span><br><span class="line">import &#123; IoCContainer &#125; from &apos;./IoCContainer&apos;;</span><br><span class="line">import &#123; IUserController, UserController &#125; from &apos;./UserController&apos;;</span><br><span class="line">import &#123; UserService &#125; from &apos;./UserService&apos;;</span><br><span class="line">import &#123; constructController &#125; from &apos;./utils&apos;;</span><br><span class="line"></span><br><span class="line">// 注册 UserService 到 IoC 容器</span><br><span class="line">IoCContainer.register(&apos;UserService&apos;, new UserService());</span><br><span class="line"></span><br><span class="line">// 创建 UserController 实例并注入 UserService</span><br><span class="line">const userController: IUserController = constructController(UserController, IoCContainer);</span><br><span class="line"></span><br><span class="line">// 现在可以使用 userController 实例进行操作了</span><br><span class="line">userController.getUser(1).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>UserController</code> 构造函数中的 <code>IUserService</code> 类型参数通过反射被获取，然后从 IoC 容器中获取了对应的 <code>UserService</code> 实例，并将其作为参数传递给 <code>Reflect.construct</code> 来创建 <code>UserController</code> 的实例。</p>
<p>通过这种方式，我们可以轻松地替换 <code>UserService</code> 的实现，只需在 IoC 容器中注册新的服务即可，而无需修改 <code>UserController</code> 的代码。这就是依赖注入带来的好处之一，它使得代码更加灵活和可维护。</p>
<p>结合文件扫描和动态导入，我们可以轻松实现自动扫描项目代码中所有的控制器文件并自动注入相关依赖项。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951478804491" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：路</title>
    <url>/7358310951478837259.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：路由映射</strong></p>
<p>在构建自己的 Web 框架时，使用装饰器来定义路由是一种非常优雅且强大的方法。通过装饰器，我们可以在控制器类上指定基础路径，并为每个方法定义具体的路由。接着，我们利用 TypeScript 的反射能力，解析这些装饰器提供的路由信息，并将其映射到 Web 服务器上。</p>
<p>在本篇文章中，我们将展示如何使用 <code>@Controller</code>、<code>@Get</code> 和 <code>@Post</code> 装饰器来定义路由，并通过反射机制将这些路由映射到 hyper-express Web 服务器上。</p>
<p><strong>一、定义装饰器</strong></p>
<p>首先，我们需要定义 <code>@Controller</code>、<code>@Get</code> 和 <code>@Post</code> 装饰器。<code>@Controller</code> 用于标记控制器类，并为其提供一个基础路径。<code>@Get</code> 和 <code>@Post</code> 分别用于标记处理 GET 和 POST 请求的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码function Controller(basePath: string) &#123;</span><br><span class="line">  return function (target: Function) &#123;</span><br><span class="line">    Reflect.defineMetadata(&apos;basePath&apos;, basePath, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Get(path: string) &#123;</span><br><span class="line">  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">    const basePath = Reflect.getMetadata(&apos;basePath&apos;, target.constructor);</span><br><span class="line">    const fullPath = `$&#123;basePath&#125;$&#123;path&#125;`;</span><br><span class="line">    Reflect.defineMetadata(&apos;route:get&apos;, fullPath, target, propertyKey);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Post(path: string) &#123;</span><br><span class="line">  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">    const basePath = Reflect.getMetadata(&apos;basePath&apos;, target.constructor);</span><br><span class="line">    const fullPath = `$&#123;basePath&#125;$&#123;path&#125;`;</span><br><span class="line">    Reflect.defineMetadata(&apos;route:post&apos;, fullPath, target, propertyKey);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、创建控制器类</strong></p>
<p>接下来，我们创建一个控制器类，并使用上面定义的装饰器来定义路由。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码@Controller(&apos;/api&apos;)</span><br><span class="line">class MyController &#123;</span><br><span class="line">  @Get(&apos;/hello&apos;)</span><br><span class="line">  public async getHello(req: any, res: any) &#123;</span><br><span class="line">    res.end(&apos;Hello from /api/hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(&apos;/submit&apos;)</span><br><span class="line">  public async postSubmit(req: any, res: any) &#123;</span><br><span class="line">    res.end(&apos;Data submitted to /api/submit&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>MyController</code> 类被 <code>@Controller</code> 装饰器标记，并指定了基础路径 <code>/api</code>。<code>getHello</code> 方法被 <code>@Get</code> 装饰器标记，并指定了路由路径 <code>/hello</code>，因此它的完整路径是 <code>/api/hello</code>。同样地，<code>postSubmit</code> 方法被 <code>@Post</code> 装饰器标记，并指定了路由路径 <code>/submit</code>，完整路径为 <code>/api/submit</code>。</p>
<p><strong>三、解析并映射路由</strong></p>
<p>现在，我们需要编写代码来解析控制器类上的路由信息，并将其映射到 hyper-express Web 服务器上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import &#123; createServer &#125; from &apos;hyper-express&apos;;</span><br><span class="line"></span><br><span class="line">const app = createServer();</span><br><span class="line"></span><br><span class="line">function mapRoutes(controller: any) &#123;</span><br><span class="line">  const basePath = Reflect.getMetadata(&apos;basePath&apos;, controller);</span><br><span class="line"></span><br><span class="line">  const methods = Object.getOwnPropertyNames(controller.prototype).filter(methodName =&gt; methodName !== &apos;constructor&apos;);</span><br><span class="line"></span><br><span class="line">  methods.forEach(methodName =&gt; &#123;</span><br><span class="line">    const getPath = Reflect.getMetadata(&apos;route:get&apos;, controller.prototype, methodName);</span><br><span class="line">    const postPath = Reflect.getMetadata(&apos;route:post&apos;, controller.prototype, methodName);</span><br><span class="line"></span><br><span class="line">    if (getPath) &#123;</span><br><span class="line">      app.get(getPath, controller.prototype[methodName].bind(controller));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (postPath) &#123;</span><br><span class="line">      app.post(postPath, controller.prototype[methodName].bind(controller));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 假设 MyController 已经定义并可用</span><br><span class="line">mapRoutes(MyController);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server started on port 3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>mapRoutes</code> 函数遍历控制器类原型上的所有方法，并检查是否存在 <code>@Get</code> 或 <code>@Post</code> 装饰器定义的路由路径。如果存在，则使用 <code>app.get</code> 或 <code>app.post</code> 方法将方法映射到相应的路由上。注意，我们使用 <code>bind(controller)</code> 来确保方法中的 <code>this</code> 指向控制器实例。</p>
<p><strong>四、总结</strong></p>
<p>结合前文的文件扫描和自动导入，我们可以轻松的将项目中约定或配置的路径下的控制器文件映射到 Web 服务器的路由系统，并且可以使用 IoC 容器实现依赖注入。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951478837259" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：代</title>
    <url>/7358310951478820875.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：代理（Proxy）</strong></p>
<p>在深入探索 IoC（控制反转）和依赖注入（Dependency Injection, DI）的细节之前，理解 TypeScript 的一些高级特性是非常有必要的。代理（Proxy）就是其中一个强大的工具，它允许我们创建对象的代理，并在对象被访问时定义一些自定义行为。</p>
<p><strong>TypeScript 中的代理（Proxy）</strong></p>
<p>在 TypeScript 中，<code>Proxy</code> 是一个用于创建对象代理的内置对象。代理可以拦截对目标对象的各种操作，如属性访问、赋值、枚举、函数调用等，并在这些操作发生时执行自定义逻辑。</p>
<p><strong>Proxy 的基本语法</strong></p>
<p>要使用 <code>Proxy</code>，我们需要提供两个参数给 <code>Proxy</code> 构造函数：目标对象（target）和处理器对象（handler）。处理器对象定义了一系列陷阱函数（trap functions），这些函数会在代理对象上执行相应操作时被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码let target = &#123;&#125;;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get(target, property, receiver) &#123;</span><br><span class="line">    console.log(`get $&#123;property&#125;`);</span><br><span class="line">    return Reflect.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo; // 输出: &quot;get foo&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们创建了一个代理对象 <code>proxy</code>，它会在访问属性 <code>foo</code> 时输出一条日志。<code>handler</code> 对象中的 <code>get</code> 函数是一个陷阱函数，它会在 <code>proxy.foo</code> 被访问时调用。</p>
<p><strong>使用 Proxy 实现属性访问的拦截</strong></p>
<p>下面是一个更具体的例子，展示了如何使用 <code>Proxy</code> 来拦截对象的属性访问，并在访问特定属性时返回模拟数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码interface User &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const users: User[] = []; // 假设这是从数据库获取的用户列表</span><br><span class="line"></span><br><span class="line">const userHandler = &#123;</span><br><span class="line">  get(target: any, propKey: string, receiver: any) &#123;</span><br><span class="line">    if (propKey === &apos;findById&apos;) &#123;</span><br><span class="line">      return function (id: number) &#123;</span><br><span class="line">        const user = users.find(user =&gt; user.id === id);</span><br><span class="line">        return user || null;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userProxy = new Proxy(&#123;&#125;, userHandler);</span><br><span class="line"></span><br><span class="line">// 使用代理对象上的方法查找用户</span><br><span class="line">const userById = userProxy.findById(1);</span><br><span class="line">console.log(userById); // 输出匹配 id 的用户对象或 null</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>userHandler</code> 对象，它有一个 <code>get</code> 陷阱函数。当尝试访问 <code>userProxy.findById</code> 时，<code>get</code> 函数会返回一个函数，该函数用于在 <code>users</code> 数组中查找具有指定 <code>id</code> 的用户。注意这里并没有在代理的目标对象上定义 <code>findById</code> 方法，它完全是由 <code>get</code> 陷阱函数动态提供的。</p>
<p><strong>总结</strong></p>
<p>代理（Proxy）是 TypeScript 中一个非常强大的特性，它允许我们创建可以拦截和自定义操作的对象代理。在构建 Web 框架时，代理可以用于实现各种高级功能，如属性访问控制、方法拦截、事件监听等。了解并掌握代理的使用，对于深入探索 IoC 和依赖注入等设计模式至关重要，因为这些模式经常需要在运行时动态地改变对象的行为。通过代理，我们可以更加灵活地控制对象的行为，实现更加健壮和可扩展的 Web 框架。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951478820875" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>我用这10招，能减少了70%的BUG</title>
    <url>/7358310951479427083.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，我是苏三，又跟大家见面了。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于大部分程序员来说，主要的工作时间是在开发和修复BUG。</p>
<p>有可能修改了一个BUG，会导致几个新BUG的产生，不断循环。</p>
<p>那么，有没有办法能够减少BUG，保证代码质量，提升工作效率？</p>
<p>答案是肯定的。</p>
<p>如果能做到，我们多出来的时间，多摸点鱼，做点自己喜欢的事情，不香吗？</p>
<p>这篇文章跟大家一起聊聊减少代码BUG的10个小技巧，希望对你会有所帮助。<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c01b46b10d66943cf57bd656ba404fbd73d81a853c86e0eaf83fb500bbf64e00" alt="图片"></p>
<h2 id="1-找个好用的开发工具"><a href="#1-找个好用的开发工具" class="headerlink" title="1 找个好用的开发工具"></a>1 找个好用的开发工具</h2><p>在日常工作中，找一款好用的开发工具，对于开发人员来说非常重要。</p>
<p>不光可以提升开发效率，更重要的是它可以帮助我们减少BUG。</p>
<p>有些好的开发工具，比如：<code>idea</code>中，对于包没有引入，会在相关的类上面<code>标红</code>。<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/adbe7500eb63d7e6bd3ab68cb3c6608750883d01575389701f4ec96b25645079" alt="图片"></p>
<p>并且idea还有<code>自动补全</code>的功能，可以有效减少我们在日常开发的过程中，有些单词手动输入的时候敲错的情况发生。</p>
<h2 id="2-引入Findbugs插件"><a href="#2-引入Findbugs插件" class="headerlink" title="2 引入Findbugs插件"></a>2 引入Findbugs插件</h2><p>Findbugs是一款Java静态代码分析工具，它专注于寻找真正的缺陷或者潜在的性能问题，它可以帮助java工程师提高代码质量以及排除隐含的缺陷。</p>
<p>Findbugs运用Apache BCEL 库分析类文件，而不是源代码，将字节码与一组缺陷模式进行对比以发现可能的问题。</p>
<p>可以直接在idea中安装FindBugs插件：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2728e9e35d2bb5e540d7b9394eabb9fe2b0c910370e460a8fd9042661e6bddc5" alt="图片"></p>
<p>之后可以选择分析哪些代码：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d8c9b1578734cc1308e5bcd1407337e68774e80e1d2fe486ed65a91d0112c65d" alt="图片">)分析结果：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/35ebc9f3babcd06e9cb35850783e44fb50793748c9038037f42a2093810b9712" alt="图片">)点击对应的问题项，可以找到具体的代码行，进行修复。<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/04c7eb365412f50cb34e0290a225f4c2ce8dda2dfd0cb5472c9e7d99d534c90b" alt="图片"></p>
<p>Findbugs的检测器已增至300多条，被分为不同的类型，常见的类型如下：</p>
<ul>
<li>Correctness：这种归类下的问题在某种情况下会导致bug，比如错误的强制类型转换等。</li>
<li>Bad practice：这种类别下的代码违反了公认的最佳实践标准，比如某个类实现了equals方法但未实现hashCode方法等。</li>
<li>Multithreaded correctness：关注于同步和多线程问题。</li>
<li>Performance：潜在的性能问题。</li>
<li>Security：安全相关。</li>
<li>Dodgy：Findbugs团队认为该类型下的问题代码导致bug的可能性很高。</li>
</ul>
<h2 id="3-引入CheckStyle插件"><a href="#3-引入CheckStyle插件" class="headerlink" title="3 引入CheckStyle插件"></a>3 引入CheckStyle插件</h2><p>CheckStyle作为检验代码规范的插件，除了可以使用配置默认给定的开发规范，如Sun、Google的开发规范之外，还可以使用像阿里的开发规范的插件。</p>
<p>目前国内用的比较多的是阿里的代码开发规范，我们可以直接通过idea下载插件：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fed66c89c096af199d05142d4dd5e1b307d1c9131ba9c73a0bb52bde02511d20" alt="图片"></p>
<p>如果想检测某个文件：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46b861020136458583023b72b73a5cc3ad11bf62de392eb18f34a8c0c430c8c1" alt="图片"></p>
<p>可以看到结果：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0bf9820ef1236626aae94aa33648970f3d4d34d25cdd7480448428e3fbd6bdb1" alt="图片"></p>
<p>阿里巴巴规约扫描包括：</p>
<ol>
<li>OOP规约</li>
<li>并发处理</li>
<li>控制语句</li>
<li>命名规约</li>
<li>常量定义</li>
<li>注释规范</li>
</ol>
<p>Alibaba Java Coding Guidelines 专注于Java代码规范，目的是让开发者更加方便、快速规范代码格式。</p>
<p>该插件在扫描代码后，将不符合规约的代码按 Blocker、Critical、Major 三个等级显示出来，并且大部分可以自动修复。</p>
<p>它还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题。</p>
<h2 id="4-用SonarQube扫描代码"><a href="#4-用SonarQube扫描代码" class="headerlink" title="4 用SonarQube扫描代码"></a>4 用SonarQube扫描代码</h2><p>SonarQube是一种自动代码审查工具，用于检测代码中的错误，漏洞和代码格式上的问题。</p>
<p>它可以与用户现有的工作流程集成，以实现跨项目分支和提取请求的连续代码检查，同时也提供了可视化的管理页面，用于查看检测出的结果。</p>
<p>SonarQube通过配置的代码分析规则，从可靠性、安全性、可维护性、覆盖率、重复率等方面分析项目，风险等级从A~E划分为5个等级；</p>
<p>同时，SonarQube可以集成pmd、findbugs、checkstyle等插件来扩展使用其他规则来检验代码质量。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0dcdf32d2bf5c87e40f440139aff51cc669177bc087c858d32ae3dcc65594caa" alt="图片"></p>
<p>一般推荐它跟Jenkins集成，做成每天定时扫描项目中test分支中的代码问题。</p>
<h2 id="5-用Fortify扫描代码"><a href="#5-用Fortify扫描代码" class="headerlink" title="5 用Fortify扫描代码"></a>5 用Fortify扫描代码</h2><p>Fortify 是一款广泛使用的静态应用程序安全测试（SAST）工具。</p>
<p>它具有代码扫描、漏斗扫描和渗透测试等功能。它的设计目的是有效地检测和定位源代码中的漏洞。</p>
<p>它能帮助开发人员识别和修复代码中的安全漏洞。</p>
<p>Fortify的主要功能：</p>
<ul>
<li>静态代码分析：它会对源代码进行静态分析，找出可能导致安全漏洞的代码片段。它能识别多种类型的安全漏洞，如 SQL 注入、跨站脚本（XSS）、缓冲区溢出等。</li>
<li>数据流分析：它不仅分析单个代码文件，还跟踪应用程序的数据流。这有助于找到更复杂的漏洞，如未经验证的用户输入在应用程序中的传播路径。</li>
<li>漏洞修复建议：发现潜在的安全漏洞时，它会为开发人员提供修复建议。</li>
<li>集成支持：它可以与多种持续集成（CI）工具（如 Jenkins）和应用生命周期管理（ALM）工具（如 Jira）集成，实现自动化的代码扫描和漏洞跟踪。</li>
<li>报告和度量：它提供了丰富的报告功能，帮助团队了解项目的安全状况和漏洞趋势。</li>
</ul>
<p>使用Fortify扫描代码的结果：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c8ae17f422294917e93ae8a76fcbb67aecea771cfd47bd40616f34aa699408d4" alt="图片"></p>
<p>一般推荐它跟Jenkins集成，定期扫描项目中test分支中的代码安全问题。</p>
<h2 id="6-写单元测试"><a href="#6-写单元测试" class="headerlink" title="6 写单元测试"></a>6 写单元测试</h2><p>有些小伙伴可能会问：写单元测试可以减少代码的BUG？</p>
<p>答案是肯定的。</p>
<p>我之前有同事，使用的测试驱动开发模式，开发一个功能模块之前，先把单元测试写好，然后再真正的开发业务代码。</p>
<p>后面发现他写的代码速度很快，而且代码质量很高，是一个开发牛人。</p>
<p>如果你后期要做系统的代码重构，你只是重写了相关的业务代码，但业务逻辑并没有修改。</p>
<p>这时，因为有了之前写好的单位测试，你会发现测试起来非常方便。</p>
<p>可以帮你减少很多BUG。</p>
<h2 id="7-功能自测"><a href="#7-功能自测" class="headerlink" title="7 功能自测"></a>7 功能自测</h2><p>功能自测，是程序员的基本要求。</p>
<p>但有些程序员自测之后，BUG还是比较多，而有些程序员自测之后，BUG非常少，这是什么原因呢？</p>
<p>可能有些人比较粗心，有些人比较细心。</p>
<p>其实更重要的是测试的策略。</p>
<p>有些人喜欢把所有相关的功能都开发完，然后一起测试。</p>
<p>这种情况下，相当于一个黑盒测试，需要花费大量的时间，梳理业务逻辑才能测试完整，大部分情况下，开发人员是没法测试完整的，可能会有很多bug测试不出来。</p>
<p>这种做法是没有经过单元测试，直接进行了集成测试。</p>
<p>看似节省了很多单元测试的时间，但其实后面修复BUG的时间可能会花费更多。</p>
<p>比较推荐的自测方式是：一步一个脚印。</p>
<p>比如：你写了一个工具类的一个方法，就测试一下。如果这个方法中，调用了另外一个关键方法，我们可以先测试一下这个关键方法。</p>
<p>这样可以写出BUG更少的代码。</p>
<h2 id="8-自动化测试"><a href="#8-自动化测试" class="headerlink" title="8 自动化测试"></a>8 自动化测试</h2><p>有些公司引入了自动化测试的功能。</p>
<p>有专门的程序，每天都会自动测试，保证系统的核心流程没有问题。</p>
<p>因为我们的日常开发中，经常需要调整核心流程的代码。</p>
<p>不可能每调整一次，都需要把所有的核心流程都测试一遍吧，这样会浪费大量的时间，而且也容易遗漏一些细节。</p>
<p>如果引入了自动化测试的功能，可以帮助我们把核心流程都测试一下。</p>
<p>避免代码重构，或者修改核心流程，测试时间不够，或者测试不完全的尴尬。</p>
<p>自动化测试，可以有效的减少核心流程调整，或者代码重构中的BUG。</p>
<p>最近就业形式比较困难，为了感谢各位小伙伴对苏三一直以来的支持，我特地创建了一些工作内推群， 看看能不能帮助到大家。</p>
<p>你可以在群里发布招聘信息，也可以内推工作，也可以在群里投递简历找工作，也可以在群里交流面试或者工作的话题。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/baa20bdc534d592c5f317a2af5942513cbc68fb8448571247d61e01a127e5787" alt="image.png"></p>
<p><strong>进群方式</strong></p>
<p>添加苏三的<strong>私人微信</strong>：su_san_java，备注：<strong>掘金+所在城市</strong>，即可加入。</p>
<h2 id="9-代码review"><a href="#9-代码review" class="headerlink" title="9 代码review"></a>9 代码review</h2><p>很多公司都有代码review机制。</p>
<p>我之前也参与多次代码review的会议，发现代码review确实可以找出很多BUG。</p>
<p>比如：一些代码的逻辑错误，语法的问题，不规范的命名等。</p>
<p>这样问题通过组内的代码review一般可以检查出来。</p>
<p>有些国外的大厂，采用<code>结对编程</code>的模式。</p>
<p>同一个组的两个人A和B一起开发，开发完之后，A reivew B的代码，同时B review A的代码。</p>
<p>因为同组的A和B对项目比较熟，对对方开发的功能更有了解，可以快速找出对外代码中的一些问题。</p>
<p>能够有效减少一些BUG。</p>
<h2 id="10-多看别人的踩坑分享"><a href="#10-多看别人的踩坑分享" class="headerlink" title="10 多看别人的踩坑分享"></a>10 多看别人的踩坑分享</h2><p>如果你想减少日常工作中的代码BUG，或者线上事故，少犯错，少踩坑。</p>
<p>经常看别人真实的踩坑分享，是一个非常不错的选择，可以学到一些别人的工作经验，帮助你少走很多弯路。</p>
<p>网上有许多博主写过自己的踩坑记录，大家可以上网搜一下。</p>
<p>也可以看看我自己总结的《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247516100&idx=1&sn=d458cae6bded3d7c449246a7f5f0b3e3&chksm=c0e8672cf79fee3a6cfb02837172f9ed921cf0e426878b42cc669fa4cd396c644ba4dc4d44be&scene=21#wechat_redirect" target="_blank" rel="noopener">程序员最常见的100个问题</a>》，里面有非常详细的记录，干货很多，还是非常值得一看的。</p>
<p>最后说一句，本文总结了10种减少代码BUG的小技巧，但我们要根据实际情况选择使用，并非所有的场景都适合。</p>
<h3 id="最后说一句-求关注，别白嫖我"><a href="#最后说一句-求关注，别白嫖我" class="headerlink" title="最后说一句(求关注，别白嫖我)"></a>最后说一句(求关注，别白嫖我)</h3><p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951479427083" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAIchemy异步DBManager封装-03得心应</title>
    <url>/7358352353295106088.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<ol>
<li><a href="https://dev.newban.cn/7357703852726911016">SQLAIchemy 异步DBManager封装-01入门理解</a></li>
<li><a href="https://dev.newban.cn/7357957809072619554">SQLAIchemy 异步DBManager封装-02熟悉掌握</a></li>
</ol>
<p>在前两篇文章中，我们详细介绍了SQLAlchemy异步DBManager的封装过程。第一篇文章帮助我们入门理解了整体的封装结构和思路，第二篇文章则帮助我们更加熟悉和掌握了这个封装的使用。我们已经介绍了添加和查询操作，并且对整体的封装思路有了深入的了解。</p>
<p>在本文中，我将继续扩展封装，介绍如何进行更新和删除操作。同时，我将演示如何执行原生的SQL语句，并介绍在异常情况下如何进行事务回滚的场景。这些内容将帮助我们更全面地应对各种数据库操作的需求。</p>
</blockquote>
<h1 id="更新封装"><a href="#更新封装" class="headerlink" title="更新封装"></a>更新封装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from sqlalchemy import Result, column, delete, func, select, text, update</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def update(</span><br><span class="line">        self,</span><br><span class="line">        values: dict,</span><br><span class="line">        *，</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    更新数据</span><br><span class="line">    Args:</span><br><span class="line">        values: 要更新的字段和对应的值，字典格式，例如 &#123;&quot;field1&quot;: value1, &quot;field2&quot;: value2, ...&#125;</span><br><span class="line">        orm_table: ORM表映射类</span><br><span class="line">        conds: 更新条件列表，每个条件为一个表达式，例如 [UserTable.username == &quot;hui&quot;, ...]</span><br><span class="line">        session: 数据库会话对象，如果为 None，则在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 影响的行数</span><br><span class="line">        cursor_result.rowcount</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    conds = conds or []</span><br><span class="line">    values = values or &#123;&#125;</span><br><span class="line">    if not values:</span><br><span class="line">        return</span><br><span class="line">    sql = update(orm_table).where(*conds).values(**values)</span><br><span class="line">    cursor_result = await session.execute(sql)</span><br><span class="line">    return cursor_result.rowcount</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def update_or_add(</span><br><span class="line">        self,</span><br><span class="line">        table_obj: [T_BaseOrmTable, dict],</span><br><span class="line">        *,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">        **kwargs,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    指定对象更新or添加数据</span><br><span class="line">    Args:</span><br><span class="line">        table_obj: 映射类实例对象 or dict，</span><br><span class="line">            e.g. UserTable(username=&quot;hui&quot;, age=18) or &#123;&quot;username&quot;: &quot;hui&quot;, &quot;v&quot;: 18, ...&#125;</span><br><span class="line">        orm_table: ORM表映射类</span><br><span class="line">        session: 数据库会话对象，如果为 None，则在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    if isinstance(table_obj, dict):</span><br><span class="line">        table_obj = orm_table(**table_obj)</span><br><span class="line"></span><br><span class="line">    return await session.merge(table_obj, **kwargs)</span><br></pre></td></tr></table></figure>

<ul>
<li>update 方法通过 sqlaichemy 的 update 来组织sql语句进行条件更新</li>
<li>update_or_add 则是指定对象进行更新或新增操作，有主键id则更新，没有则添加，具体是使用 <strong>session.merge</strong> 方法进行操作。入参的 table_obj 可以是库表映射类实例对象、dict，字典形式则是通过 Manager 下的orm_table 进行转换成映射类实例对象来操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class UserFileTable(BaseOrmTable):</span><br><span class="line">    &quot;&quot;&quot;用户文件表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user_file&quot;</span><br><span class="line">    filename: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;文件名称&quot;)</span><br><span class="line">    creator: Mapped[int] = mapped_column(default=0, comment=&quot;文件创建者&quot;)</span><br><span class="line">    file_suffix: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;文件后缀&quot;)</span><br><span class="line">    file_size: Mapped[int] = mapped_column(default=0, comment=&quot;文件大小&quot;)</span><br><span class="line">    oss_key: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;oss key（minio）&quot;)</span><br><span class="line">    is_del: Mapped[int] = mapped_column(default=0, comment=&quot;是否删除&quot;)</span><br><span class="line">    deleted_at: Mapped[datetime] = mapped_column(nullable=True, comment=&quot;删除时间&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class UserFileManager(DBManager):</span><br><span class="line">    orm_table = UserFileTable</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">async def update_demo():</span><br><span class="line">    ret = await UserFileManager().update(values=&#123;&quot;filename&quot;: &quot;hui&quot;&#125;, conds=[UserFileTable.id == 1])</span><br><span class="line">    print(&quot;update ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    # 添加</span><br><span class="line">    user_file_info = &#123;&quot;filename&quot;: &quot;huidbk&quot;, &quot;oss_key&quot;: uuid.uuid4().hex&#125;</span><br><span class="line">    user_file: UserFileTable = await UserFileManager().update_or_add(table_obj=user_file_info)</span><br><span class="line">    print(&quot;update_or_add add&quot;, user_file)</span><br><span class="line"></span><br><span class="line">    # 更新</span><br><span class="line">    user_file.file_suffix = &quot;png&quot;</span><br><span class="line">    user_file.file_size = 100</span><br><span class="line">    user_file.filename = &quot;hui-update_or_add&quot;</span><br><span class="line">    ret: UserFileTable = await UserFileManager().update_or_add(table_obj=user_file)</span><br><span class="line">    print(&quot;update_or_add update&quot;, ret)</span><br></pre></td></tr></table></figure>

<h1 id="删除封装"><a href="#删除封装" class="headerlink" title="删除封装"></a>删除封装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@with_session</span><br><span class="line">async def bulk_delete_by_ids(</span><br><span class="line">        self,</span><br><span class="line">        pk_ids: list,</span><br><span class="line">        *,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        logic_del: bool = False,</span><br><span class="line">        logic_field: str = &quot;deleted_at&quot;,</span><br><span class="line">        logic_del_set_value: Any = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据主键id批量删除</span><br><span class="line">    Args:</span><br><span class="line">        pk_ids: 主键id列表</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        logic_del: 逻辑删除，默认 False 物理删除 True 逻辑删除</span><br><span class="line">        logic_field: 逻辑删除字段 默认 deleted_at</span><br><span class="line">        logic_del_set_value: 逻辑删除字段设置的值</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 删除的记录数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    conds = [orm_table.id.in_(pk_ids)]</span><br><span class="line">    return await self.delete(</span><br><span class="line">        conds=conds,</span><br><span class="line">        orm_table=orm_table,</span><br><span class="line">        logic_del=logic_del,</span><br><span class="line">        logic_field=logic_field,</span><br><span class="line">        logic_del_set_value=logic_del_set_value,</span><br><span class="line">        session=session,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def delete_by_id(</span><br><span class="line">        self,</span><br><span class="line">        pk_id: int,</span><br><span class="line">        *,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        logic_del: bool = False,</span><br><span class="line">        logic_field: str = &quot;deleted_at&quot;,</span><br><span class="line">        logic_del_set_value: Any = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据主键id删除</span><br><span class="line">    Args:</span><br><span class="line">        pk_id: 主键id</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        logic_del: 逻辑删除，默认 False 物理删除 True 逻辑删除</span><br><span class="line">        logic_field: 逻辑删除字段 默认 deleted_at</span><br><span class="line">        logic_del_set_value: 逻辑删除字段设置的值</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 删除的记录数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    conds = [orm_table.id == pk_id]</span><br><span class="line">    return await self.delete(</span><br><span class="line">        conds=conds,</span><br><span class="line">        orm_table=orm_table,</span><br><span class="line">        logic_del=logic_del,</span><br><span class="line">        logic_field=logic_field,</span><br><span class="line">        logic_del_set_value=logic_del_set_value,</span><br><span class="line">        session=session,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def delete(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        logic_del: bool = False,</span><br><span class="line">        logic_field: str = &quot;deleted_at&quot;,</span><br><span class="line">        logic_del_set_value: Any = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    通用删除</span><br><span class="line">    Args:</span><br><span class="line">        conds: 条件列表, e.g. [UserTable.id == 1]</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        logic_del: 逻辑删除，默认 False 物理删除 True 逻辑删除</span><br><span class="line">        logic_field: 逻辑删除字段 默认 deleted_at</span><br><span class="line">        logic_del_set_value: 逻辑删除字段设置的值</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 删除的记录数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line"></span><br><span class="line">    if logic_del:</span><br><span class="line">        # 执行逻辑删除操作</span><br><span class="line">        logic_del_info = dict()</span><br><span class="line">        logic_del_info[logic_field] = logic_del_set_value or datetime.now()</span><br><span class="line">        delete_stmt = update(orm_table).where(*conds).values(**logic_del_info)</span><br><span class="line">    else:</span><br><span class="line">        # 执行物理删除操作</span><br><span class="line">        delete_stmt = delete(orm_table).where(*conds)</span><br><span class="line"></span><br><span class="line">    cursor_result = await session.execute(delete_stmt)</span><br><span class="line"></span><br><span class="line">    # 返回影响的记录数</span><br><span class="line">    return cursor_result.rowcount</span><br></pre></td></tr></table></figure>

<ul>
<li>通过主键ID单个删除，组织 <code>conds = [orm_table.id == pk_id]</code>，调用 delete 方法</li>
<li>通过主键ID列表批量删，组织 <code>conds = [orm_table.id.in_(pk_ids)]</code> 调用 delete 方法</li>
</ul>
<p>这两种删除操作都是通过调用 delete 方法实现的。默认情况下，这些操作执行的是物理删除。对于一些重要的数据，我们也可以选择执行逻辑删除。在逻辑删除中，默认使用 <code>deleted_at</code> 字段来记录删除时间。我们也可以指定具体的逻辑删除字段 <code>logic_field</code>，以及逻辑字段的赋值情况 <code>logic_del_set_value</code>，然后进行一个更新操作来实现逻辑删除。</p>
<p>如下是删除前的数据</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e1f9754184db11491688f69fa3c2021e6d4dbf28bd338faa0857622d00e68c4c" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">async def delete_demo():</span><br><span class="line">    file_count = await UserFileManager().query_one(cols=[func.count()], flat=True)</span><br><span class="line">    print(&quot;file_count&quot;, file_count)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete_by_id(file_count)</span><br><span class="line">    print(&quot;delete_by_id ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().bulk_delete_by_ids(pk_ids=[10, 11, 12])</span><br><span class="line">    print(&quot;bulk_delete_by_ids ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete(conds=[UserFileTable.id == 13])</span><br><span class="line">    print(&quot;delete ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete(conds=[UserFileTable.id == 5], logic_del=True)</span><br><span class="line">    print(&quot;logic_del ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete(</span><br><span class="line">        conds=[UserFileTable.id == 6], logic_del=True, logic_field=&quot;is_del&quot;, logic_del_set_value=1</span><br><span class="line">    )</span><br><span class="line">    print(&quot;logic_del set logic_field ret&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>删除结果展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码file_count 20</span><br><span class="line">delete_by_id ret 0</span><br><span class="line">bulk_delete_by_ids ret 3</span><br><span class="line">delete ret 1</span><br><span class="line">logic_del ret 1</span><br><span class="line">logic_del set logic_field ret 1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3968604488c7e7695d2ea2909e941a6db31a8ef07862e2157793107f37ca894a" alt></p>
<p>主键id 为5、6的被逻辑删除了，10，11，12，13 被物理删除了。</p>
<h1 id="执行原生sql"><a href="#执行原生sql" class="headerlink" title="执行原生sql"></a>执行原生sql</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">@with_session</span><br><span class="line">async def run_sql(</span><br><span class="line">        self, sql: str, *, params: dict = None, query_one: bool = False, session: AsyncSession = None</span><br><span class="line">) -&gt; Union[dict, List[dict]]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    执行并提交单条sql</span><br><span class="line">    Args:</span><br><span class="line">        sql: sql语句</span><br><span class="line">        params: sql参数, eg. &#123;&quot;:id_val&quot;: 10, &quot;:name_val&quot;: &quot;hui&quot;&#125;</span><br><span class="line">        query_one: 是否查询单条，默认False查询多条</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        执行sql的结果</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    sql = text(sql)</span><br><span class="line">    cursor_result = await session.execute(sql, params)</span><br><span class="line">    if query_one:</span><br><span class="line">        return cursor_result.mappings().one() or &#123;&#125;</span><br><span class="line">    else:</span><br><span class="line">        return cursor_result.mappings().all() or []</span><br></pre></td></tr></table></figure>

<p>内部执行sql时需要通过 sqlaichemy 的 text 函数转一下，然后根据 query_one 的值来确定查询单条还是多条。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码async def run_raw_sql_demo():</span><br><span class="line">    &quot;&quot;&quot;运行原生sql demo&quot;&quot;&quot;</span><br><span class="line">    count_sql = &quot;select count(*) as total_count from user_file&quot;</span><br><span class="line">    count_ret = await UserFileManager().run_sql(count_sql, query_one=True)</span><br><span class="line">    print(&quot;count_ret&quot;, count_ret)</span><br><span class="line"></span><br><span class="line">    data_sql = &quot;select * from user_file where id &gt; :id_val and file_size &gt;= :file_size_val&quot;</span><br><span class="line">    params = &#123;&quot;id_val&quot;: 20, &quot;file_size_val&quot;: 0&#125;</span><br><span class="line">    data_ret = await UserFileManager().run_sql(data_sql, params=params)</span><br><span class="line">    print(&quot;dict data_ret&quot;, data_ret)</span><br><span class="line"></span><br><span class="line">    data_sql = &quot;select * from user_file where id &gt; :id_val&quot;</span><br><span class="line">    data_ret = await UserFileManager().run_sql(sql=data_sql, params=&#123;&quot;id_val&quot;: 4&#125;)</span><br><span class="line">    print(&quot;dict data_ret&quot;, data_ret)</span><br><span class="line"></span><br><span class="line">    # 连表查询</span><br><span class="line">    data_sql = &quot;&quot;&quot;</span><br><span class="line">        select</span><br><span class="line">            user.id as user_id,</span><br><span class="line">            username,</span><br><span class="line">            user_file.id as file_id,</span><br><span class="line">            filename,</span><br><span class="line">            oss_key</span><br><span class="line">        from </span><br><span class="line">            user_file</span><br><span class="line">            join user on user.id = user_file.creator</span><br><span class="line">        where </span><br><span class="line">            user_file.creator = :user_id</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data_ret = await UserFileManager().run_sql(data_sql, params=&#123;&quot;user_id&quot;: 1&#125;)</span><br><span class="line">    print(&quot;join sql data_ret&quot;, data_ret)</span><br></pre></td></tr></table></figure>

<p>需要注意的执行原生sql，sql参数的展位符是 <strong>:param_name</strong> 冒号后面接参数名称，然后参数对应的值则是字典形式组织。</p>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码count_ret &#123;&apos;total_count&apos;: 16&#125;</span><br><span class="line"></span><br><span class="line">dict data_ret [&#123;&apos;id&apos;: 62, &apos;filename&apos;: &apos;aaa&apos;, &apos;creator&apos;: 0, &apos;file_suffix&apos;: &apos;&apos;, &apos;file_size&apos;: 0, &apos;oss_key&apos;: &apos;6dd01a72599e467eb3fcdd9b47e1de9c&apos;, &apos;is_del&apos;: 0, &apos;deleted_at&apos;: None&#125;, ..]</span><br><span class="line"></span><br><span class="line">dict data_ret [&#123;&apos;id&apos;: 5, &apos;filename&apos;: &apos;eee&apos;, &apos;creator&apos;: 0, &apos;file_suffix&apos;: &apos;&apos;, &apos;file_size&apos;: 0, &apos;oss_key&apos;: &apos;6892400cc83845aca89b2ebafc675471&apos;, &apos;is_del&apos;: 0, &apos;deleted_at&apos;: datetime.datetime(2024, 4, 16, 23, 56, 49)&#125;, ...]</span><br><span class="line"></span><br><span class="line">join sql data_ret [&#123;&apos;user_id&apos;: 1, &apos;username&apos;: &apos;hui&apos;, &apos;file_id&apos;: 1, &apos;filename&apos;: &apos;hui&apos;, &apos;oss_key&apos;: &apos;bbb&apos;&#125;]</span><br></pre></td></tr></table></figure>

<h1 id="事务回滚操作"><a href="#事务回滚操作" class="headerlink" title="事务回滚操作"></a>事务回滚操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码async def create_and_transaction_demo():</span><br><span class="line">    async with UserFileManager.transaction() as session:</span><br><span class="line">        await UserFileManager().bulk_add(</span><br><span class="line">            table_objs=[&#123;&quot;filename&quot;: &quot;aaa&quot;, &quot;oss_key&quot;: uuid.uuid4().hex&#125;], session=session</span><br><span class="line">        )</span><br><span class="line">        user_file_obj = UserFileTable(filename=&quot;eee&quot;, oss_key=uuid.uuid4().hex)</span><br><span class="line">        file_id = await UserFileManager().add(table_obj=user_file_obj, session=session)</span><br><span class="line">        print(&quot;file_id&quot;, file_id)</span><br><span class="line"></span><br><span class="line">        ret: UserFileTable = await UserFileManager().query_by_id(2, session=session)</span><br><span class="line">        print(&quot;query_by_id&quot;, ret)</span><br><span class="line">        </span><br><span class="line">        # 异常回滚</span><br><span class="line">        a = 1 / 0</span><br><span class="line"></span><br><span class="line">        ret = await UserFileManager().query_one(</span><br><span class="line">            cols=[UserFileTable.filename, UserFileTable.oss_key],</span><br><span class="line">            conds=[UserFileTable.filename == &quot;ccc&quot;],</span><br><span class="line">            session=session</span><br><span class="line">        )</span><br><span class="line">        print(&quot;ret&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>这里通过 transaction() 获取事务会话 session，让后面的数据库操作都指定 session 参数，with_session 装饰器就不会再次构造，实现了共用一个 session，事务内的操作要么都成功要么都失败。</p>
<h1 id="整体封装总结"><a href="#整体封装总结" class="headerlink" title="整体封装总结"></a>整体封装总结</h1><ul>
<li>SQLAIchemyManager 设计</li>
</ul>
<pre><code>+ 用于初始化数据库配置信息</code></pre><ul>
<li>BaseOrmTable、TimestampColumns、BaseOrmTableWithTS 设计</li>
</ul>
<pre><code>+ 通用库表映射类，一些主键id，时间戳字段让子类继承共享，以及 to\_dict 方法将对象属性转成字典</code></pre><ul>
<li>transaction 上下文管理器（事务会话）</li>
</ul>
<pre><code>+ 便捷的进行事务处理</code></pre><ul>
<li>with_session 装饰器</li>
</ul>
<pre><code>+ 复用开启事务会话 session 操作，减少冗余代码，没有 session 则动态的构造 session，兼容整体事务会话</code></pre><ul>
<li>orm_table 设计</li>
</ul>
<pre><code>+ 让继承DBManager的子类指定 orm\_table ，数据库操作时明确知道具体库表，减少参数传递</code></pre><ul>
<li>DBManager 设计</li>
</ul>
<pre><code>+ 封装了通用的CRUD方法，让子类可以共享和复用这些方法，推荐子类进行常用业务数据查询封装，实现业务逻辑的复用和灵活性。</code></pre><ul>
<li>查询扁平化 flat</li>
</ul>
<pre><code>+ 查询结果可以直接使用，不需要额外处理，简化了操作流程。</code></pre><ul>
<li>字典与库表映射类实例</li>
</ul>
<pre><code>+ 一些方法的入参，同时支持字典与库表映射类实例，提高了方法的通用性和灵活性。</code></pre><ul>
<li>分页查询</li>
</ul>
<pre><code>+ 指定页码、每页大小查询出总数与分页数据</code></pre><ul>
<li>逻辑删除</li>
</ul>
<pre><code>+ 支持默认的 `deleted_at` 字段 or 指定逻辑字段进行逻辑删除，保留重要数据</code></pre><ul>
<li>执行原生sql</li>
</ul>
<pre><code>+ 一些复杂sql操作，不使用 orm 组织，推荐使用原生 sql 进行操作</code></pre><p>到这就结束了，希望这些封装，可以满足各种复杂业务场景下的需求，提高数据库操作的灵活性和适用性，从而提高我们的开发效率。让代码变得更简单。</p>
<h1 id="Github源代码"><a href="#Github源代码" class="headerlink" title="Github源代码"></a>Github源代码</h1><p>源代码已上传到了Github，里面也有具体的使用Demo，欢迎大家一起体验、贡献。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358352353295106088" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>9.轻松入门SuiMove:Ability</title>
    <url>/7358337136024010803.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前面几章我们一直在说对象的ability，那什么是ability呢？ ability直译过来就是数据类型的能力。</p>
<p>Ability有四种，分别是key,store,copy,drop。基础数据类型和内建的数据类型的ability是默认的，不可修改的。他们默认有copy,drop,store这三种能力。结构体默认没有任何能力，但是我们可以自行设置结构体的能力。下面我主要讲解每种能力的含义和如何设置结构体的能力。</p>
<p>无论哪种ability，都是使用has关键字申明，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码//多个ability使用逗号隔开</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Ability"><a href="#Key-Ability" class="headerlink" title="Key Ability"></a>Key Ability</h4><p>有些资料说拥有key ability代表能在全局存储中作为key使用，这个并不适用于Sui Move。关于key ability的作用官网如下描述：</p>
<blockquote>
<p>On Sui, the <code>key</code> ability indicates that a struct is an object type and comes with an additional requirement that the first field of the struct has signature <code>id: UID</code>, to contain the object’s unique address on-chain.</p>
</blockquote>
<p>翻译过来：**如果一个类型，带有key ability就代表他是一个对象，并且要求这个结构体的第一个字段必须是id:UID。**这个id字段包含了这个对象在区块链上的地址。</p>
<p>如果我们定义了一个结构体有key ability，但是没有id字段或者id字段没在第一位置，编译都会报错：有key ability第一字段就必须是类型为UID的id。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码 public struct Test3 has key &#123;</span><br><span class="line">     name: String     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码public struct Test3 has key &#123;</span><br><span class="line">--- The &apos;key&apos; ability is used to declare objects in Sui</span><br><span class="line">name: String     </span><br><span class="line">^^^^ Invalid object &apos;Test3&apos;. Structs with the &apos;key&apos; ability must have &apos;id: sui::object::UID&apos; as their first field</span><br></pre></td></tr></table></figure>

<p>所以<strong>key ability就是用来标识结构体是否是对象的</strong>。</p>
<h4 id="Store-Ability"><a href="#Store-Ability" class="headerlink" title="Store Ability"></a>Store Ability</h4><p>key是对象必有的能力，而store则是对象可选的能力。<strong>有以下两种情况需要指定store abiity:</strong></p>
<ul>
<li><strong>1.当一个对象需要在定义他的模块之外被转交</strong></li>
<li><strong>2.当 一个结构体需要被嵌套的时候</strong></li>
</ul>
<p>如果你想限定某一个独有对象只能在定义它的模块内transfer,就无需予对象store ability。比如以下代码中的company对象，如果在定义他的模块外调用transfer方法，或者在命令行使用sui client transfer都会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码//没有store ability</span><br><span class="line">public struct Company  has key &#123;</span><br><span class="line">    id: UID,     </span><br><span class="line">    person: Person,</span><br><span class="line">    can_be_transfered: bool,</span><br><span class="line">&#125;</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想限定某个对象只有满足特定条件的时候才能转交，就可以自定义transfer方法，并且限定只能在模块内transfer，这样。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码const ECanNotTransfer = 1;</span><br><span class="line">//对象company没有store ability,只允许在定义对象的模块内transfer</span><br><span class="line">public struct Company  has key &#123;</span><br><span class="line">    id: UID,     </span><br><span class="line">    person: Person,</span><br><span class="line">    can_be_transfered: bool,</span><br><span class="line">&#125;</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line">//自定义transfer方法</span><br><span class="line">public fun transfer_company(company: Company, someone: address) &#123;</span><br><span class="line">    //只有can_be_transfered字段为true才可以transfer，否则退出程序</span><br><span class="line">    assert!(company.can_be_tra	nsfered, ECanNotTransfer);</span><br><span class="line">    transfer::transfer(company, someone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><p>与key ability相反，copy ability不能用于对象。copy ability 就是<strong>用于标记这个结构体是否可以被复制</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码public struct Company  has key &#123;</span><br><span class="line">    id: UID,     </span><br><span class="line">    person: Person,</span><br><span class="line">    can_be_transfered: bool,</span><br><span class="line">&#125;</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line">public entry fun new(ctx: &amp;mut TxContext) &#123;</span><br><span class="line">    let person = Person &#123;</span><br><span class="line">        id: object::new(ctx),</span><br><span class="line">        name: string::utf8(b&quot;hanmeimei&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let company = Company &#123;</span><br><span class="line">        id: object::new(ctx),</span><br><span class="line">        person: person,</span><br><span class="line">        can_be_transfered: false,</span><br><span class="line">    &#125;;</span><br><span class="line">    //使用关键词copy复制company对象</span><br><span class="line">    let _company2 = copy company;</span><br><span class="line">    transfer::transfer(company, tx_context::sender(ctx));</span><br><span class="line">    transfer::transfer(_company2, tx_context::sender(ctx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fd01fa0367d9eead24e9b7361839335086107f63223e361342b34fbce2d2532f" alt="copy.png"></p>
<p>那我们是不是加上copy ability就可以顺利通过编译呢？？？我们加上之后继续编译，报错如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6a73a3974d749f80ed7d16b089ce38215470c0ac15e1f45d42aadd79959aef91" alt="coyp2.png"></p>
<p><strong>如果要对一个结构体加上copy ability,那么这个结构体内所有字段都需要拥有该ability</strong>然而对象Company的id字段不具有copy ability，而这个id字段是每个对象都有的字段，所以可以得出结论：<strong>copy ability不能用于对象，只能用于非对象结构体</strong>。</p>
<p>值得注意的是在对结构体设置copy 、store 和drop能力的时候，都需要先确保结构体内所有字段包含这些能力。</p>
<h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p>跟copy同理，drop ability也只能用于非对象结构体。drop表明<strong>这个结构体是否能在作用域结束的时候自动删除</strong>。如果不能自动删除则需要手动调用删除逻辑。删除结构体的方法详见：6.轻松入门Sui Move: 结构体</p>
<p>了解更多Sui Move内容：</p>
<ul>
<li>telegram: t.me/move_cn</li>
<li>QQ群: 79489587</li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358337136024010803" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>webserverapachetomcat11-04-</title>
    <url>/7358354263868047386.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理这个官方翻译的系列，原因是网上大部分的 tomcat 版本比较旧，此版本为 v11 最新的版本。</p>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><blockquote>
<p>从零手写实现 tomcat <a href="https://github.com/houbb/minicat" target="_blank" rel="noopener">minicat</a> 别称【嗅虎】心有猛虎，轻嗅蔷薇。</p>
</blockquote>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-01-intro" target="_blank" rel="noopener">web server apache tomcat11-01-官方文档入门介绍</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-02-setup" target="_blank" rel="noopener">web server apache tomcat11-02-setup 启动</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-03-deploy" target="_blank" rel="noopener">web server apache tomcat11-03-deploy 如何部署</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-04-manager" target="_blank" rel="noopener">web server apache tomcat11-04-manager 如何管理？</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-06-host-manager" target="_blank" rel="noopener">web server apache tomcat11-06-Host Manager App – Text Interface</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-07-relam" target="_blank" rel="noopener">web server apache tomcat11-07-Realm Configuration</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-08-jndi" target="_blank" rel="noopener">web server apache tomcat11-08-JNDI Resources</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-09-jdbc-datasource" target="_blank" rel="noopener">web server apache tomcat11-09-JNDI Datasource</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-10-classloader-howto" target="_blank" rel="noopener">web server apache tomcat11-10-Class Loader</a></p>
<p>….</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在许多生产环境中，具有能够部署新的 Web 应用程序或取消部署现有应用程序的能力而无需关闭和重新启动整个容器非常有用。</p>
<p>此外，您可以请求现有应用程序重新加载自身，即使您尚未在 Tomcat 服务器配置文件中声明其可重新加载。</p>
<p>为了支持这些功能，Tomcat 包括一个 Web 应用程序（默认安装在上下文路径 /manager），支持以下功能：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>从 WAR 文件的上传内容部署新的 Web 应用程序</td>
<td></td>
</tr>
<tr>
<td>从服务器文件系统上指定的上下文路径部署新的 Web 应用程序</td>
<td></td>
</tr>
<tr>
<td>列出当前部署的 Web 应用程序以及当前为这些 Web 应用程序活动的会话</td>
<td></td>
</tr>
<tr>
<td>重新加载现有的 Web 应用程序，以反映 /WEB-INF/classes 或 /WEB-INF/lib 内容的更改</td>
<td></td>
</tr>
<tr>
<td>列出操作系统和 JVM 属性值</td>
<td></td>
</tr>
<tr>
<td>列出可用的全局 JNDI 资源，供准备嵌套在 部署描述中的 元素的部署工具使用</td>
<td></td>
</tr>
<tr>
<td>启动已停止的应用程序（使其再次可用）</td>
<td></td>
</tr>
<tr>
<td>停止现有应用程序（使其不可用），但不取消部署它</td>
<td></td>
</tr>
<tr>
<td>取消部署已部署的 Web 应用程序并删除其文档基目录（除非它是从文件系统部署的）</td>
<td></td>
</tr>
</tbody></table>
<p>默认的 Tomcat 安装包括为默认虚拟主机配置的 Manager 应用程序的实例。</p>
<p>如果您创建了额外的虚拟主机，您可能希望将 Manager 应用程序的实例添加到其中一个或多个主机中。</p>
<p>要将 Manager Web 应用程序上下文的实例添加到新主机上，请在 $CATALINA_BASE/conf/[enginename]/[hostname] 文件夹中安装 manager.xml 上下文配置文件。</p>
<p>以下是一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot;</span><br><span class="line">         docBase=&quot;$&#123;catalina.home&#125;/webapps/manager&quot;&gt;</span><br><span class="line">  &lt;CookieProcessor className=&quot;org.apache.tomcat.util.http.Rfc6265CookieProcessor&quot;</span><br><span class="line">                   sameSiteCookies=&quot;strict&quot; /&gt;</span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">         allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;</span><br><span class="line">  &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<p>有三种使用 Manager Web 应用程序的方式：</p>
<ol>
<li>作为带有用户界面的应用程序，您可以在浏览器中使用。以下是一个示例 URL，您可以将 localhost 替换为您的网站主机名：<a href="http://localhost:8080/manager/html" target="_blank" rel="noopener">http://localhost:8080/manager/html</a> 。</li>
<li>仅使用 HTTP 请求的最小版本，适用于由系统管理员设置的脚本使用。命令作为请求 URI 的一部分给出，响应以易于解析和处理的简单文本形式呈现。有关更多信息，请参阅支持的 Manager 命令。</li>
<li>适用于 Ant（版本 1.4 或更高版本）构建工具的便捷任务定义集。有关更多信息，请参阅使用 Ant 执行 Manager 命令。</li>
</ol>
<h1 id="配置-Manager-应用程序访问"><a href="#配置-Manager-应用程序访问" class="headerlink" title="配置 Manager 应用程序访问"></a>配置 Manager 应用程序访问</h1><p>以下描述使用变量名 $CATALINA_BASE 来引用相对路径解析的基本目录。</p>
<p>如果您尚未通过设置 CATALINA_BASE 目录来配置 Tomcat 以用于多个实例，则 CATALINABASE将设置为CATALINA_BASE 将设置为 CATALINAB​ASE将设置为CATALINA_HOME 的值，即您安装 Tomcat 的目录。</p>
<p>使用默认设置将允许互联网上的任何人执行您服务器上的 Manager 应用程序是相当不安全的。</p>
<p>因此，Manager 应用程序附带了这样一个要求：任何试图使用它的人必须进行身份验证，使用具有其中一个 manager-xxx 角色的用户名和密码（角色名称取决于所需的功能）。</p>
<p>此外，默认用户文件（$CATALINA_BASE/conf/tomcat-users.xml）中没有分配给这些角色的用户名。</p>
<p>因此，默认情况下完全禁用了对 Manager 应用程序的访问。</p>
<p>您可以在 Manager Web 应用程序的 web.xml 文件中找到角色名称。可用的角色包括：</p>
<ul>
<li>manager-gui — 访问 HTML 界面。</li>
<li>manager-status — 仅访问 “服务器状态” 页面。</li>
<li>manager-script — 访问本文档中描述的面向工具友好的纯文本界面，以及 “服务器状态” 页面。</li>
<li>manager-jmx — 访问 JMX 代理接口和 “服务器状态” 页面。</li>
</ul>
<p>HTML 界面受到 CSRF（跨站点请求伪造）攻击的保护，但文本和 JMX 界面无法受到保护。这意味着被允许访问文本和 JMX 界面的用户在使用 Web 浏览器访问 Manager 应用程序时必须小心。为了保持 CSRF 保护：</p>
<ul>
<li>如果您使用 Web 浏览器使用具有 manager-script 或 manager-jmx 角色的用户访问 Manager 应用程序（例如用于测试纯文本或 JMX 界面），之后必须关闭所有浏览器窗口以终止会话。如果您不关闭浏览器并访问其他站点，您可能会成为 CSRF 攻击的受害者。</li>
<li>建议永远不要将 manager-script 或 manager-jmx 角色授予具有 manager-gui 角色的用户。</li>
</ul>
<p>请注意，JMX 代理接口实际上是 Tomcat 的类似低级根的管理接口。如果知道要调用的命令，可以做很多事情。启用 manager-jmx 角色时应谨慎。</p>
<p>要启用对 Manager Web 应用程序的访问，您必须创建新的用户名/密码组合并将其中一个 manager-xxx 角色与之关联，或者将 manager-xxx 角色添加到现有用户名/密码组合中。由于本文档的大部分内容都是使用文本界面，因此此示例将使用角色名称 manager-script。用户名/密码的配置方式取决于您正在使用的 Realm 实现：</p>
<ul>
<li>UserDatabaseRealm 和 MemoryUserDatabase，或 MemoryRealm — UserDatabaseRealm 和 MemoryUserDatabase 配置在默认的 CATALINABASE/conf/server.xml中。MemoryUserDatabase和MemoryRealm默认读取位于CATALINA_BASE/conf/server.xml 中。MemoryUserDatabase 和 MemoryRealm 默认读取位于 CATALINAB​ASE/conf/server.xml中。MemoryUserDatabase和MemoryRealm默认读取位于CATALINA_BASE/conf/tomcat-users.xml 的 XML 格式文件，可以使用任何文本编辑器进行编辑。</li>
</ul>
<p>此文件包含每个个人用户的 XML <code>&lt;user&gt;</code>，可能类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;user username=&quot;craigmcc&quot; password=&quot;secret&quot; roles=&quot;standard,manager-script&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>它定义了此个人用于登录的用户名和密码，以及他们关联的角色名称。您可以将 manager-script 角色添加到一个或多个现有用户的逗号分隔的角色属性中，并/或创建具有分配了该角色的新用户。</p>
<ul>
<li>DataSourceRealm — 您的用户和角色信息存储在通过 JDBC 访问的数据库中。将 manager-script 角色添加到一个或多个现有用户，并/或按照您环境的标准程序创建一个或多个分配了此角色的新用户。</li>
<li>JNDIRealm — 您的用户和角色信息存储在通过 LDAP 访问的目录服务器中。将 manager-script 角色添加到一个或多个现有用户，并/或按照您环境的标准程序创建一个或多个分配了此角色的新用户。</li>
</ul>
<p>当您首次尝试发出下一节中描述的 Manager 命令之一时，将要求您使用 BASIC 身份验证登录。您输入的用户名和密码无关紧要，只要它们识别出具有 manager-script 角色的有效用户。</p>
<p>除了密码限制之外，还可以通过添加 RemoteAddrValve 或 RemoteHostValve 来限制对 Manager Web 应用程序的访问。</p>
<p>有关详细信息，请参阅阀门文档。以下是通过 IP 地址限制对 localhost 的访问的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;Context privileged=&quot;true&quot;&gt;</span><br><span class="line">         &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">                allow=&quot;127\.0\.0\.1&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<h1 id="HTML-用户友好界面"><a href="#HTML-用户友好界面" class="headerlink" title="HTML 用户友好界面"></a>HTML 用户友好界面</h1><p>Manager Web 应用程序的用户友好的 HTML 界面位于以下位置：</p>
<p><a href="http://%7Bhost%7D:%7Bport%7D/manager/html" target="_blank" rel="noopener">http://{host}:{port}/manager/html</a></p>
<p>如上所述，您需要 manager-gui 角色才能访问它。有一份单独的文档提供了有关此界面的帮助。请参阅：</p>
<p><a href="https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#Manager_HTML_Interface" target="_blank" rel="noopener">HTML Manager documentation</a></p>
<p>HTML 界面受到 CSRF（跨站点请求伪造）攻击的保护。每次访问 HTML 页面都会生成一个随机令牌，该令牌存储在您的会话中，并包含在页面上的所有链接中。如果您的下一个操作没有正确的令牌值，则将拒绝该操作。如果令牌已过期，您可以从 Manager 的主页面或“列出应用程序”页面重新开始。</p>
<h2 id="支持的-Manager-命令"><a href="#支持的-Manager-命令" class="headerlink" title="支持的 Manager 命令"></a>支持的 Manager 命令</h2><p>Manager 应用程序知道如何处理的所有命令都在一个单独的请求 URI 中指定，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码http://&#123;host&#125;:&#123;port&#125;/manager/text/&#123;command&#125;?&#123;parameters&#125;</span><br></pre></td></tr></table></figure>

<p>其中 {host} 和 {port} 表示 Tomcat 运行的主机名和端口号，{command} 表示您希望执行的 Manager 命令，{parameters} 表示特定于该命令的查询参数。在下面的示例中，根据您的安装情况适当地自定义主机和端口。</p>
<p>这些命令通常由 HTTP GET 请求执行。/deploy 命令有一个通过 HTTP PUT 请求执行的表单。</p>
<h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><p>大多数命令接受以下一个或多个查询参数：</p>
<ul>
<li>path - 您正在处理的 Web 应用程序的上下文路径（包括前导斜杠）。要选择 ROOT Web 应用程序，请指定“/”。</li>
</ul>
<blockquote>
<p>注意：不可能对 Manager 应用程序本身执行管理命令。<br>注意：如果未显式指定路径参数，则将使用标准上下文命名规则从 config 参数或（如果未提供 config 参数）war 参数派生路径和版本。</p>
</blockquote>
<ul>
<li>version - 此 Web 应用程序的版本，由并行部署功能使用。如果您在需要路径的任何地方使用并行部署，则必须除了路径之外指定一个版本，并且组合路径和版本必须唯一，而不仅仅是路径。</li>
</ul>
<blockquote>
<p>注意：如果未显式指定路径，则忽略版本参数。</p>
</blockquote>
<ul>
<li>war - Web 应用程序存档（WAR）文件的 URL，或包含 Web 应用程序的目录的路径名，或包含 Context 配置 “.xml” 文件的路径名。您可以使用以下任何格式的 URL：<ul>
<li>file:/absolute/path/to/a/directory - 包含 Web 应用程序解压版本的目录的绝对路径。此目录将附加到您指定的上下文路径，而不进行任何更改。</li>
<li>file:/absolute/path/to/a/webapp.war - Web 应用程序存档（WAR）文件的绝对路径。这仅适用于 /deploy 命令，并且是该命令唯一可接受的格式。</li>
<li>file:/absolute/path/to/a/context.xml - 包含 Context 配置元素的 Web 应用程序上下文配置 “.xml” 文件的绝对路径。</li>
<li>directory - Host 的应用程序基目录中的 Web 应用程序上下文的目录名称。</li>
<li>webapp.war - Host 的应用程序基目录中位于的 Web 应用程序 WAR 文件的名称。</li>
</ul>
</li>
</ul>
<p>每个命令将以 text/plain 格式（即不带 HTML 标记的纯 ASCII 文本）返回响应，使人类和程序都可以轻松阅读。</p>
<p>响应的第一行将以 OK 或 FAIL 开头，指示请求的命令是否成功。在失败的情况下，第一行的其余部分将包含遇到的问题的描述。一些命令包括如下所述的其他信息行。</p>
<p>国际化说明 - Manager 应用程序在资源包中查找其消息字符串，因此可能已为您的平台翻译了这些字符串。以下示例显示了消息的英文版本。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358354263868047386" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Redis实现基本抢红包算法简介:发红包模块:抢红</title>
    <url>/7358352353294696488.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h1><p>抢红包是我们生活常用的社交功能, 这个功能最主要的特点就是用户的并发请求高, 在系统设计上, 可以使用非常多的办法来扛住用户的高并发请求, 在本文中简要介绍使用Redis缓存中间件来实现抢红包算法, Redis是一个在内存中基于 <strong>[key, value]</strong> 的缓存数据库, Redis官方性能描述非常高, 所以面对高并发场景, 使用Redis来克服高并发压力是一个不错的手段, 本文主要基于Redis来实现基本的抢红包系统设计.</p>
<h1 id="发红包模块"><a href="#发红包模块" class="headerlink" title="发红包模块:"></a>发红包模块:</h1><h2 id="1-发红包模块流程图如下"><a href="#1-发红包模块流程图如下" class="headerlink" title="1:发红包模块流程图如下:"></a>1:发红包模块流程图如下:</h2><p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d629cff36871e2227f10723ba774d76ed69d5e983fb260b9f16763a95760a4f7" alt></p>
<p>﻿﻿</p>
<p>用户首先输入红包金额和红包个数, 然后生成当前红包唯一标识, 并使用二倍均值算法生成随机金额的红包, 然后将生成的红包存入缓存Redis数据库中, Redis数据库中会保存当前剩余的红包数量和每个红包的金额, 由于Redis数据库是作为临时存储的地方, 所以发红包记录需要持久化存储在数据库中, 这里为加快系统响应, 使用异步的方式, 将红包金额纪录存储入Mysql数据库中, 以上就是发红包模块的简要系统设计.</p>
<h2 id="2-随机生成红包金额"><a href="#2-随机生成红包金额" class="headerlink" title="2:随机生成红包金额"></a>2:随机生成红包金额</h2><p>对于抢红包来说, 生成红包金额是非常关键的, 这里有许多生成随机数方法, 在本文中介绍一种使用较多的二倍均值算法来随机生成红包金额.对于抢红包来说, 如果发送一个金额为J的红包, 那么对与抢红包的N个人来说, 公平的概率是: 每个人抢到J / N 的金额的概率是相同的, 例如100元红包发给10个人，那么最公平的策略是使每个人抢到10元的概率相同, 二倍均值算法就是基于上面这个概率策略. 二倍均值算法流程如下: 首先设置红包金额为J, 抢红包人数为N, 接下来计算随机数区间上U = J / N * 2, 得到随机数区间(0,U), 从而在这个区间里生成第一个随机数金额M, 接下来继续生成第二个随机金额. 首先更新总红包金额为J-M,总抢红包人数为N-1, 然后生成第二个随机金额区间(0, (J-M) / (N-1) *2) , 从这个区间里面生成第二个随机金额M2, 继续迭代, 直到生成最后一个红包金额, 下图是二倍均值算法的流程</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4785348eeeeb829574a81792fb773ccd7d8e29abeb2fff9569923fe84c9dbe10" alt></p>
<p>﻿﻿</p>
<p>二倍均值算法案例: 红包总金额100元, 总计10个人</p>
<p>计算第一个随机金额区间: 100/10X2 = 20, 第一个随机金额的区间是（0，20 )，区间均值为10</p>
<p>假设第一个人抢到10元，剩余金额是90 元</p>
<p>计算第二个随机金额区间: 90/9X2 = 20, 第一个随机金额的区间是（0，20 )，区间均值为10</p>
<p>假设第二个人抢到10元，剩余金额是80 元 计算第三个随机金额区间: 80/8X2 = 20, 第一个随机金额的区间是（0，20 )，区间均值为10</p>
<p>……………</p>
<p>所以使用二倍均值算法能够在不论谁先抢的情况下, 都能公平保证每个人抢到平均金额的概率是相等的, 二倍均值算法生成红包金额的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码//这里输入的totalMoney单位是分,例如100元,totalMoney = 10000</span><br><span class="line">public List&lt;Integer&gt; getRedPackage(Integer totalMoney,Integer totalPeopleCount) &#123;</span><br><span class="line">    List&lt;Integer&gt; moneyList = new ArrayList&lt;&gt;();</span><br><span class="line">    //暂存剩余金额为红包的总金额</span><br><span class="line">    Integer restMoney = totalMoney;</span><br><span class="line">    //暂存剩余的总人数-初始化时即为指定的总人数</span><br><span class="line">    Integer restPeopleCount = totalPeopleCount;    </span><br><span class="line">    //随机数对象</span><br><span class="line">    Random random = new Random();</span><br><span class="line">    //开始循环迭代生成红包</span><br><span class="line">    for (int i =0;i&lt; totalPeopleNum-1;i++)&#123;</span><br><span class="line">       //加1是为了至少抢到1分钱</span><br><span class="line">       int money = random.nextInt (restMoney / restPeopleCount * 2) + 1;</span><br><span class="line">       restMoney -= money;</span><br><span class="line">       restPeopleCount--;</span><br><span class="line">       moneyList.add(money);</span><br><span class="line">    &#125;</span><br><span class="line">    //添加最后的一个红包金额</span><br><span class="line">    amountList.add(restAmount);</span><br><span class="line">    return amountList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-红包存储"><a href="#3-红包存储" class="headerlink" title="3: 红包存储"></a>3: 红包存储</h2><p>为了应对用户高并发的请求, 也就是需要频繁读取红包金额和数量, 所以将红包金额和数量存储在Mysql中是不行的, 所以只能借助基于内存的Redis数据库来支持高并发的读取操作.Redis中有5种基本的数据结构分别是:String, List, Set, Sorted Set, Map这五种, 红包金额数量是一个List集合, 所以使用List来存储最为合适,在发红包时, 我们先用二倍均值算法随机生成一定数量的红包金额, 然后将红包金额和红包数量存入Redis缓存中,等待用户抢红包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//随机生成全局唯一的红包id</span><br><span class="line">redId = getRedId();</span><br><span class="line">//首先生成红包金额</span><br><span class="line">List&lt;Integer&gt; moneyList = getRedPackage(totalMoney,totalPeopleCount);</span><br><span class="line">//放入redis</span><br><span class="line">redisClient.lpush(redId, moneyList);</span><br><span class="line">//redis中记录红包个数</span><br><span class="line">redisClient.set(redId, moneyList.size());</span><br><span class="line">//异步存储发红包记录到Mysql数据库</span><br><span class="line">//将红包id返回</span><br><span class="line">return redId;</span><br></pre></td></tr></table></figure>

<h1 id="抢红包模块"><a href="#抢红包模块" class="headerlink" title="抢红包模块:"></a>抢红包模块:</h1><h2 id="1-抢红包模块流程图如下"><a href="#1-抢红包模块流程图如下" class="headerlink" title="1:抢红包模块流程图如下:"></a>1:抢红包模块流程图如下:</h2><p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/795d03677cc9554a409d9a08861330909d988b86649935a2d018d660ec7fbbb2" alt></p>
<p>﻿﻿</p>
<p>首先判断用户是否已经抢过红包了, 是否还有剩余的红包, 如果抢过或者剩余红包数量小于等于0, 则代表红包已经被抢完了, 直接结束用户本次抢红包流程. 如果还有剩余的红包数量, 则从Redis缓存列表中弹出一个红包金额, 然后将剩余红包数量减1, 同时异步将用户抢红包记录存入Mysql数据库, 最后将抢到的红包金额返回给用户, 结束本次抢红包流程</p>
<h2 id="2-首先判断是否已经抢过红包"><a href="#2-首先判断是否已经抢过红包" class="headerlink" title="2:首先判断是否已经抢过红包"></a>2:首先判断是否已经抢过红包</h2><p>通过在Redis中以用户ID构建一个唯一Key来判断是否抢过红包, Key的构建规则是:业务前缀+红包id+用户id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码redMoney = redisClient.get(&quot;rob&quot; + redId + useId)</span><br><span class="line">//如果不为空,则说明已经抢过了,直接返回抢过的红包金额</span><br><span class="line">if (redMoney != null) &#123;</span><br><span class="line">    return redMoney</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-判断是否还有红包"><a href="#3-判断是否还有红包" class="headerlink" title="3:判断是否还有红包"></a>3:判断是否还有红包</h2><p>通过在Redis中以红包id记录一个数量来判断是否还有红包, key的构建规则是:业务前缀+红包id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码totalNum = redisClient.get(&quot;totalNum&quot; + redId)</span><br><span class="line">//如果为空或者小于等于0则代表没有了</span><br><span class="line">if (totalNum == null || totalNum &lt;= 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-弹出一个红包金额"><a href="#4-弹出一个红包金额" class="headerlink" title="4:弹出一个红包金额"></a>4:弹出一个红包金额</h2><p>因为我们是把红包金额存储到Redis的List列表中的, 所以直接使用列表的Pop操作就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    ....</span><br><span class="line">    红包个数减1</span><br><span class="line">    存储抢红包记录</span><br><span class="line">    设置该用户已经抢过红包</span><br><span class="line">    ....</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="5-减少红包个数"><a href="#5-减少红包个数" class="headerlink" title="5:减少红包个数"></a>5:减少红包个数</h2><p>红包总数是以一个[key, value] 键值对存储在Redis中的, 所以这里使用Redis的DECR命令就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    ....</span><br><span class="line">    存储抢红包记录</span><br><span class="line">    设置该用户已经抢过红包</span><br><span class="line">    ....</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="6-异步记录抢红包记录"><a href="#6-异步记录抢红包记录" class="headerlink" title="6:异步记录抢红包记录"></a>6:异步记录抢红包记录</h2><p>采用异步的方式将记录存入Mysql数据库, 异步的方式可以采用<strong>消息队列或者多线程</strong>的方式来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    //异步存储抢红包记录</span><br><span class="line">    这里可以使用mq或者多线程的方式来实现</span><br><span class="line">    ....</span><br><span class="line">    设置该用户已经抢过红包</span><br><span class="line">    ....</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="7-设置该用户已经抢过红包"><a href="#7-设置该用户已经抢过红包" class="headerlink" title="7:设置该用户已经抢过红包"></a>7:设置该用户已经抢过红包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    //异步存储抢红包记录</span><br><span class="line">    这里可以使用mq或者多线程的方式来实现</span><br><span class="line">    //设置该用户已经抢过红包</span><br><span class="line">    redisClient.set(&quot;rob&quot; + redId + useId, money)</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="8-整体的伪代码逻辑如下"><a href="#8-整体的伪代码逻辑如下" class="headerlink" title="8: 整体的伪代码逻辑如下:"></a>8: 整体的伪代码逻辑如下:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码redMoney = redisClient.get(&quot;rob&quot; + redId + useId)</span><br><span class="line">//如果不为空,则说明已经抢过了,直接返回抢过的红包金额</span><br><span class="line">if (redMoney != null) &#123;</span><br><span class="line">    return redMoney</span><br><span class="line">&#125;</span><br><span class="line">totalNum = redisClient.get(&quot;totalNum&quot; + redId)</span><br><span class="line">//如果红包总数小于0, 则代表已经抢完了, 直接返回空</span><br><span class="line">if (totalNum == null || totalNum &lt;= 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line">money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    //异步存储抢红包记录</span><br><span class="line">    这里可以使用mq或者多线程的方式来实现</span><br><span class="line">    //设置该用户已经抢过红包</span><br><span class="line">    redisClient.set(&quot;rob&quot; + redId + useId, money)</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125; </span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="9-分布式锁"><a href="#9-分布式锁" class="headerlink" title="9:分布式锁"></a>9:分布式锁</h2><p>这里涉及到了同一个用户多次高并发来抢红包的情况, 并且代码逻辑中包含了下面这种逻辑: <strong>判断条件成立然后进行业务操作,最后设置条件.</strong> 这种业务逻辑如果不防止并发的话, 就会产生重复操作, 所以需要使用锁来限制每一个用的访问频率, 加锁的方式是使用分布式锁, 这是因为我们抢红包服务不可能只在一台服务器上部署, 同时基于Redis也能很容易的实现分布式锁, 使用Redis命令setNx命令就可以实现简单分布式锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码redMoney = redisClient.get(&quot;rob&quot; + redId + useId)</span><br><span class="line">//如果不为空,则说明已经抢过了,直接返回抢过的红包金额</span><br><span class="line">if (redMoney != null) &#123;</span><br><span class="line">    return redMoney</span><br><span class="line">&#125;</span><br><span class="line">totalNum = redisClient.get(&quot;totalNum&quot; + redId)</span><br><span class="line">//如果红包总数小于0, 则代表已经抢完了, 直接返回空</span><br><span class="line">if (totalNum == null || totalNum &lt;= 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line">//加分布式锁</span><br><span class="line">lockResut = redisClient.setNx(useId,redId,timeOut);</span><br><span class="line">//加锁失败,直接返回</span><br><span class="line">if(!lockResult)&#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">    money = redisClient.rpop(redId)</span><br><span class="line">    //如果不为空,则说明抢到了</span><br><span class="line">    if (money != null) &#123;</span><br><span class="line">        //红包个数减1</span><br><span class="line">        redisClient.decr(redId)</span><br><span class="line">        //异步存储抢红包记录</span><br><span class="line">        这里可以使用mq或者多线程的方式来实现</span><br><span class="line">        //设置该用户已经抢过红包</span><br><span class="line">        redisClient.set(&quot;rob&quot; + redId + useId, money)</span><br><span class="line">        //返回抢到的金额</span><br><span class="line">        return money</span><br><span class="line">    &#125;     </span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //删除锁</span><br><span class="line">    redisClient.del(useId)</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是完整的抢红包伪代码流程, 可以基本实现发红包以及抢红包功能, 该方法基于Redis来实现红包的存储和抢红包的操作, 基于二倍均值算法来实现红包金额的随即生成, 在整体功能上还有很多不完善的地方, 可以基于整体框架进行扩展开发, 实现更加完整的算法</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358352353294696488" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割之边缘分割法、区域分割法和形态学分割法原理及优缺点并</title>
    <url>/7358361832460337189.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图像分割是将图像划分为多个区域或对象的过程，以便于进一步分析、处理或理解。以下是三种常见的图像分割算法：</p>
<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><h3 id="1-边缘分割法-Edge-based-Segmentation"><a href="#1-边缘分割法-Edge-based-Segmentation" class="headerlink" title="1. 边缘分割法 (Edge-based Segmentation)"></a>1. 边缘分割法 (Edge-based Segmentation)</h3><p>原理：边缘分割法依赖于图像中像素强度的突变来检测边缘。这种方法通常使用边缘检测算子（如Sobel、Canny、Prewitt、Roberts等）来计算图像中每个像素点的梯度值。梯度值高的地方通常对应于边缘。通过跟踪这些高梯度值，可以确定图像中对象的轮廓。<br>优点：</p>
<ul>
<li>能够识别出对象的精确边缘。</li>
<li>对于具有清晰边界的图像效果较好。</li>
<li>算法相对简单，计算速度较快。<br>缺点：</li>
<li>对噪声敏感，噪声可能被误检为边缘。</li>
<li>对噪声敏感，噪声可能被误检为边缘。</li>
<li>难以处理边缘不连续或边缘模糊的图像。</li>
<li>需要后续处理步骤来连接断裂的边缘。</li>
</ul>
<h3 id="2-区域分割法-Region-based-Segmentation"><a href="#2-区域分割法-Region-based-Segmentation" class="headerlink" title="2. 区域分割法 (Region-based Segmentation)"></a>2. 区域分割法 (Region-based Segmentation)</h3><p>原理：区域分割法基于图像中像素之间的相似性来进行分割。这种方法包括区域生长、区域合并和区域分裂等技术。区域生长是从一个或多个种子像素开始，逐步将相邻的像素添加到生长的区域中，直到满足某些相似性准则。区域合并和分裂则是通过合并或分裂现有区域来达到更好的分割效果。<br>优点：</p>
<ul>
<li>能够处理边缘不清晰的图像。</li>
<li>适合处理边缘信息不足或不完整的情况。</li>
<li>分割结果通常是连续的区域。<br>缺点：</li>
<li>计算成本较高，尤其是对于大图像。</li>
<li>选择合适的种子点和相似性准则可能比较困难。</li>
<li>分割结果可能受初始种子选择的影响。</li>
</ul>
<h3 id="3-形态学分割法-Morphological-Segmentation"><a href="#3-形态学分割法-Morphological-Segmentation" class="headerlink" title="3. 形态学分割法 (Morphological Segmentation)"></a>3. 形态学分割法 (Morphological Segmentation)</h3><p>原理：形态学分割法基于数学形态学，一个涉及结构元素对图像进行膨胀、腐蚀、开运算和闭运算等操作的理论。通过这些操作，可以强化或减弱图像中的特定结构，从而实现分割。例如，通过闭运算可以填充小的空洞，而通过开运算可以消除小的物体。<br>优点：</p>
<ul>
<li>能够在保持图像拓扑结构的同时去除噪声。</li>
<li>适用于形状分析和提取图像结构特征。</li>
<li>可以处理复杂的图像，如文本或生物医学图像。<br>缺点：</li>
<li>需要选择合适的结构元素和操作序列。</li>
<li>对于不规则或大小多变的对象，分割效果可能不理想。</li>
<li>可能需要结合其他分割技术来达到最佳效果。</li>
</ul>
<p>每种分割方法都有其适用的场景和限制，实际应用中可能需要根据图像的特点和分割目标来选择合适的方法，或者结合多种方法来提高分割的准确性和鲁棒性。</p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><p>实现图像分割算法通常涉及图像处理库，Java中常用的图像处理库有Java Advanced Imaging (JAI)、ImageJ等。由于实现图像分割算法需要复杂的操作和较长的代码，这里我将提供一个简化版本的边缘检测算法的示例，使用Java的基本图像处理能力，对于区域分割法和形态学分割法。<br>这种使用 ；Sobel算子</p>
<p>Sobel算子是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导的概念。Sobel算子主要用于图像处理领域，尤其是在边缘检测中，以突出图像中亮度变化剧烈的区域。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>Sobel算子通过计算图像亮度的一阶空间导数来找出边缘位置。具体来说，它使用两个3x3的卷积核（也称作滤波器或模板）来分别计算水平和垂直方向上的梯度：</p>
<ul>
<li>水平方向的Sobel卷积核（Gx）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码[ -1  0  1 ]</span><br><span class="line">[ -2  0  2 ]</span><br><span class="line">[ -1  0  1 ]</span><br></pre></td></tr></table></figure>

<ul>
<li>垂直方向的Sobel卷积核（Gy）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码[ -1 -2 -1 ]</span><br><span class="line">[  0  0  0 ]</span><br><span class="line">[  1  2  1 ]</span><br></pre></td></tr></table></figure>

<p>这两个卷积核分别应用于图像的每个像素，通过与周围的像素值进行加权求和，计算出水平方向（Gx）和垂直方向（Gy）的梯度。然后，这两个梯度可以组合起来计算出每个像素点的边缘强度（梯度幅值）和方向：</p>
<ul>
<li>梯度幅值：<code>G = sqrt(Gx^2 + Gy^2)</code></li>
<li>梯度方向：<code>θ = atan2(Gy, Gx)</code></li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>相对简单：Sobel算子的实现简单，计算速度快。</li>
<li>同时考虑方向：Sobel算子能够检测水平和垂直方向的边缘。</li>
<li>抗噪声能力：由于卷积核的设计，Sobel算子在计算梯度前有一定的平滑效果，这使其对噪声有一定的抵抗能力。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>对噪声敏感：尽管有抗噪声能力，但在噪声较大的图像中，Sobel算子仍然可能产生错误的边缘。</li>
<li>边缘粗细：Sobel算子可能会产生较粗的边缘，不适合精确边缘定位。</li>
<li>边缘断裂：在边缘强度变化不连续的地方，Sobel算子可能会导致边缘断裂。</li>
<li>角点响应：Sobel算子对角点的响应不如一些其他算子（如Harris角点检测器）。</li>
</ol>
<p>在实际应用中，Sobel算子常常作为边缘检测的初步步骤，用于快速识别图像中的潜在边缘区域。针对其缺点，可以通过后续的图像处理步骤进行优化，比如使用非极大值抑制（Non-Maximum Suppression）来细化边缘，或者应用阈值方法来减少噪声影响。</p>
<p>以下是一个简单的边缘检测算法（Sobel算子）的Java实现示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.File;</span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line">/**</span><br><span class="line"> * @author Derek-samrt</span><br><span class="line"> */</span><br><span class="line">public class EdgeDetection &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 加载图像</span><br><span class="line">        File file = new File(&quot;C:\\my\\1712392252385.jpg&quot;);</span><br><span class="line">        BufferedImage image = ImageIO.read(file);</span><br><span class="line"></span><br><span class="line">        // 灰度化</span><br><span class="line">        BufferedImage grayImage = toGray(image);</span><br><span class="line">        // Sobel边缘检测</span><br><span class="line">        BufferedImage edgeImage = sobelEdgeDetection(grayImage);</span><br><span class="line"></span><br><span class="line">        // 保存结果</span><br><span class="line">        File outputFile = new File(&quot;C:\\my\\test.jpg&quot;);</span><br><span class="line">        ImageIO.write(edgeImage, &quot;jpg&quot;, outputFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BufferedImage toGray(BufferedImage image) &#123;</span><br><span class="line">        BufferedImage grayImage = new BufferedImage(</span><br><span class="line">                image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; image.getWidth(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; image.getHeight(); j++) &#123;</span><br><span class="line">                int rgb = image.getRGB(i, j);</span><br><span class="line">                int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span><br><span class="line">                int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span><br><span class="line">                int b = rgb &amp; 0xFF;</span><br><span class="line">                int gray = (int) (0.2126 * r + 0.7152 * g + 0.0722 * b);</span><br><span class="line">                int newPixel = gray | (gray &lt;&lt; 8) | (gray &lt;&lt; 16);</span><br><span class="line">                grayImage.setRGB(i, j, newPixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grayImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BufferedImage sobelEdgeDetection(BufferedImage image) &#123;</span><br><span class="line">        int x = image.getWidth();</span><br><span class="line">        int y = image.getHeight();</span><br><span class="line">        BufferedImage edgeImage = new BufferedImage(x, y, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"></span><br><span class="line">        int[][] edgeColors = new int[x][y];</span><br><span class="line">        int maxGradient = -1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; x - 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; y - 1; j++) &#123;</span><br><span class="line">                int val00 = getGrayScale(image.getRGB(i - 1, j - 1));</span><br><span class="line">                int val01 = getGrayScale(image.getRGB(i - 1, j));</span><br><span class="line">                int val02 = getGrayScale(image.getRGB(i - 1, j + 1));</span><br><span class="line"></span><br><span class="line">                int val10 = getGrayScale(image.getRGB(i, j - 1));</span><br><span class="line">                int val11 = getGrayScale(image.getRGB(i, j));</span><br><span class="line">                int val12 = getGrayScale(image.getRGB(i, j + 1));</span><br><span class="line"></span><br><span class="line">                int val20 = getGrayScale(image.getRGB(i + 1, j - 1));</span><br><span class="line">                int val21 = getGrayScale(image.getRGB(i + 1, j));</span><br><span class="line">                int val22 = getGrayScale(image.getRGB(i + 1, j + 1));</span><br><span class="line"></span><br><span class="line">                int gx = ((-1 * val00) + (0 * val01) + (1 * val02))</span><br><span class="line">                        + ((-2 * val10) + (0 * val11) + (2 * val12))</span><br><span class="line">                        + ((-1 * val20) + (0 * val21) + (1 * val22));</span><br><span class="line"></span><br><span class="line">                int gy = ((-1 * val00) + (-2 * val01) + (-1 * val02))</span><br><span class="line">                        + ((0 * val10) + (0 * val11) + (0 * val12))</span><br><span class="line">                        + ((1 * val20) + (2 * val21) + (1 * val22));</span><br><span class="line"></span><br><span class="line">                double gval = Math.sqrt((gx * gx) + (gy * gy));</span><br><span class="line">                int g = (int) gval;</span><br><span class="line"></span><br><span class="line">                if(maxGradient &lt; g) &#123;</span><br><span class="line">                    maxGradient = g;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                edgeColors[i][j] = g;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        double scale = 255.0 / maxGradient;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; x - 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; y - 1; j++) &#123;</span><br><span class="line">                int edgeColor = edgeColors[i][j];</span><br><span class="line">                edgeColor = (int)(edgeColor * scale);</span><br><span class="line">                edgeColor = 0xff000000 | (edgeColor &lt;&lt; 16) | (edgeColor &lt;&lt; 8) | edgeColor;</span><br><span class="line"></span><br><span class="line">                edgeImage.setRGB(i, j, edgeColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edgeImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getGrayScale(int rgb) &#123;</span><br><span class="line">        int r = (rgb &gt;&gt; 16) &amp; 0xff;</span><br><span class="line">        int g = (rgb &gt;&gt; 8) &amp; 0xff;</span><br><span class="line">        int b = rgb &amp; 0xff;</span><br><span class="line"></span><br><span class="line">        // from https://en.wikipedia.org/wiki/Grayscale, calculating luminance</span><br><span class="line">        int gray = (int)(0.2126 * r + 0.7152 * g + 0.0722 * b);</span><br><span class="line">        // or use a simple average</span><br><span class="line">        // int gray = (r + g + b) / 3;</span><br><span class="line"></span><br><span class="line">        return gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：<br>经典图分割：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bcf83dbe6ed450e50b878b9bafb97a105f7aad99e0354b34a2f5ec404e606f88" alt="1713235709319.png"></p>
<p>风景图分割：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/63fb7bdb54fe88381bdc8e052ba678a5871bf4154f645de0f7ef61a00779eaf4" alt="d93008b1e74f7d11cf261eadda3885a.png"></p>
<p>汽车图分割：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8092184d600010010edd9763ff2c643b13f7571d6a23e1fed23f096500601308" alt="1713316411310.png"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358361832460337189" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>算法,Java,图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title>编程之路：从零到百度，探索有表现力的代码之嘎嘎嘎~</title>
    <url>/7358355063922982963.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现在有一个国王，想要组成一个由1000鸭子组成的合唱团，要求鸭子能够嘎嘎嘎的叫，但是最后只找有999只鸭子，该怎么办？请用代码实现。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a4ad9daed46733095bbd5b726c168cbd2326aeab6c0a3fde9d8c4ee49a6f9ebb" alt="image.png"><br>分析<br>–</p>
<ol>
<li>组成合唱团，则需要定义一个choir数组对象，来存放1000只鸭子；</li>
<li>定义一个鸭子duck对象，对象用对象字面量来表达；</li>
<li>鸭子能够嘎嘎嘎的叫，那么就需要定义一个方法sing；</li>
<li>要筛选能够嘎嘎嘎的叫的鸭子，那么就需要定义一个方法joinChoir来筛选鸭子；</li>
<li>通过for循环来实现999只鸭子加入choir；</li>
<li>只有999只鸭子，但是要求1000只鸭子，那么这个时候定义一个chicken对象，并定义一个方法sing，再加入choir；</li>
<li>合唱团组成，可以嘎嘎嘎嘎嘎嘎了。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/52df3ef8770ca8be65756c484f71ba0b4c42a788729827ddaf1042f893650b97" alt="image.png"><br>代码<br>–</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;script&gt;</span><br><span class="line">        /*</span><br><span class="line">        国王 1000只鸭子合唱团 嘎嘎嘎的叫</span><br><span class="line">        */</span><br><span class="line">       //const 常量</span><br><span class="line">       //赋值语句</span><br><span class="line">       //js 弱类型，不需要像java要写明类型(用class声明对象)</span><br><span class="line">       const choir=[];//合唱团 数组也是对象</span><br><span class="line">       //对象字面量</span><br><span class="line">       const duck=&#123;</span><br><span class="line">        sing:function()&#123;</span><br><span class="line">            console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       //学外语</span><br><span class="line">       const chicken=&#123;</span><br><span class="line">        sing:function()&#123;</span><br><span class="line">            console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //封装</span><br><span class="line">       //加入合唱团有个流程</span><br><span class="line">       function joinChoir(animal)&#123;</span><br><span class="line">            //严谨性</span><br><span class="line">            if(animal &amp;&amp; typeof animal.sing==&apos;function&apos;)&#123;</span><br><span class="line">                 choir.push(animal);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&apos;恭喜加入合唱团!&apos;);</span><br><span class="line">       &#125;</span><br><span class="line">       for(let i=0;i&lt;999;i++)&#123;</span><br><span class="line">        joinChoir(duck);</span><br><span class="line">       &#125;</span><br><span class="line">       joinChoir(chicken);</span><br><span class="line">       console.log(&apos;合唱团已有&apos;+choir.length+&apos;位成员&apos;);</span><br><span class="line">       if(choir.length===1000)&#123;</span><br><span class="line">        console.log(&apos;报告国王，合唱团招聘完成!&apos;);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>组成合唱团(敏锐的逻辑能力);</li>
<li>加入合唱团应该写成一个方法(封装能力);</li>
<li>鸭子模型(深入的语言能力)(弱类型,不需要像java要写明类型(用class声明对象));</li>
<li>JS不是传统的面向对象(class Duck),是基于原型式的面向对象();</li>
<li>JS才是最面向对象的面向对象,除了简单数据类型的一切都是对象。</li>
</ol>
<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><ul>
<li>如何区分不同类型的对象=&gt;Object.prototype.toString.call()</li>
<li>例如：</li>
</ul>
<ol>
<li>Object.prototype.toString.call(choir)=&gt;’object Array’</li>
<li>Object.prototype.toString.call(duck)=&gt;’object Object’</li>
<li>Object.prototype.toString.call(sing)=&gt;’object Function’</li>
</ol>
<h6 id="记得点点赞，发表意见评论哦"><a href="#记得点点赞，发表意见评论哦" class="headerlink" title="记得点点赞，发表意见评论哦~"></a>记得点点赞，发表意见评论哦~</h6><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46698ecd645a53303662bf8a5c66fee8f589dbced2725165e23a651da9ead44f" alt="image.png"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358355063922982963" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>写一个爬虫脚本获取必应（Bing）搜索引擎首页每日的4K超清</title>
    <url>/7358381923922821146.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次写文章的封面不知道从哪里获取，每次都是去谷歌，百度搜索文章关键字 去找一些图，要么就是从代码运行结果找相关截图，总是找不到合适的文章图片显得乱糟糟的，又没有找到相关的项目能够根据关键字生成文章封面，今天就要到了一个另类的方法，用爬虫获取 必应（Bing）搜索引擎首页每日的高清大图。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>访问bing.com</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5184cf9692505b2d55657424d126bcfa43d5b192156d0390e9fc59d4964817f5" alt="微信截图_20240416230343.png"><br>很简单就能发现图片的请求地址隐藏到了网页里面</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eb0ef411be85fd0bd388efecd73ab6e559c11603aea4f6216177c615bea98a4d" alt="image.png"><br>通过网页找图片的关键的方法是有水印的，而且图不是高清的</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/269b0842d3e03520a89945e793e5541df3191669aa156c1b3ced90862a107ba1" alt="image.png"></p>
<p>最后通过GitHub找到一个公开的接口：<br><a href="https://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=ZH-CN" target="_blank" rel="noopener">cn.bing.com/HPImageArch…</a></p>
<p>直接访问就能拿到高清无水印图片的地址文本内容，稍微做一下解析就行</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/66d00388bc19cf5e20b5efbee153bf21ff44a3c3759c810cb0a9f60d9d74da8b" alt="image.png"><br>接下来就简单写一下爬虫代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# 下载并存储Bing每日壁纸到指定位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">from io import BytesIO</span><br><span class="line">from PIL import Image</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">class BingUHD(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 默认bing图片查询地址</span><br><span class="line">        self.url = &apos;https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=ZH-CN&apos;</span><br><span class="line">        self.path = &apos;./BingUHD/&apos;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &apos;</span><br><span class="line">                          &apos;Chrome/80.0.3987.132 Safari/537.36&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        self.resolution = &apos;UHD&apos;</span><br><span class="line"></span><br><span class="line">    # 取得图片相关信息</span><br><span class="line">    def get_img_info(self):</span><br><span class="line">        try:</span><br><span class="line">            # 获取图片信息</span><br><span class="line">            result = requests.get(self.url, headers=self.headers).json()</span><br><span class="line">            # 提取图片地址</span><br><span class="line">            raw_img_url = &apos;https://cn.bing.com&apos; + result[&apos;images&apos;][0][&apos;url&apos;]</span><br><span class="line">            # 得到默认图片链接</span><br><span class="line">            normal_img_url = raw_img_url[0:raw_img_url.find(&quot;.jpg&quot;) + 4]</span><br><span class="line">            # 得到UHD图片链接替换默认的 1080 图片为UHD图片链接</span><br><span class="line">            uhd_img_url = normal_img_url.replace(&quot;1920x1080&quot;, self.resolution)</span><br><span class="line">            # 提取中文标题和版权信息</span><br><span class="line">            date = result[&quot;images&quot;][0][&quot;startdate&quot;]</span><br><span class="line">            title = result[&quot;images&quot;][0][&quot;title&quot;]</span><br><span class="line">            copy_right = result[&quot;images&quot;][0][&quot;copyright&quot;]</span><br><span class="line"></span><br><span class="line">            return normal_img_url, uhd_img_url, date, title, copy_right</span><br><span class="line"></span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法获取到图片地址，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    def img_download(self,url,file_name):</span><br><span class="line">        try:</span><br><span class="line">            response = requests.get(url, stream=True)</span><br><span class="line"></span><br><span class="line">            if response.status_code == 200:</span><br><span class="line">                with open(file_name, &apos;wb&apos;) as f:</span><br><span class="line">                    response.raw.decode_content = True</span><br><span class="line">                    shutil.copyfileobj(response.raw, f)</span><br><span class="line">                print(file_name+&quot;图片下载成功&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(file_name+&quot;无法下载图片&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法下载图片，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    # 得到今日图片信息并清洗</span><br><span class="line">    def get_today_img_download(self,file_name):</span><br><span class="line">        try:</span><br><span class="line">            info = self.get_img_info()</span><br><span class="line">            normal_url = info[0]</span><br><span class="line">            uhd_url = info[1]</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            # 图片分辨率文字</span><br><span class="line">            # normal = normal_url[(normal_url.rfind(&quot;_&quot;) + 1): -4]</span><br><span class="line">            # uhd = uhd_url[(uhd_url.rfind(&quot;_&quot;) + 1): -4]</span><br><span class="line"></span><br><span class="line">            # 图片分辨率文字</span><br><span class="line">            normal = self.get_pic_size()[0]</span><br><span class="line">            uhd = self.get_pic_size()[1]</span><br><span class="line">            self.img_download(normal_url,file_name+normal+&apos;.jpg&apos;)</span><br><span class="line">            self.img_download(uhd_url,file_name+uhd+&apos;.jpg&apos;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法获取到图片信息，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 取得文件名称</span><br><span class="line">    def get_file_name(self):</span><br><span class="line">        try:</span><br><span class="line">            info = self.get_img_info()</span><br><span class="line">            # 定义文件夹</span><br><span class="line">            file_path = self.path + info[2][0:4] + &apos;-&apos; + info[2][4:6] + &apos;/&apos;</span><br><span class="line">            # 判断文件夹是否存在</span><br><span class="line">            if not os.path.exists(file_path):</span><br><span class="line">                os.makedirs(file_path)</span><br><span class="line">            # 定义文件名</span><br><span class="line">            copy_right = info[4]</span><br><span class="line">            copy_right = copy_right[0:copy_right.find(&apos; &apos;)]</span><br><span class="line">            # 绝对路径</span><br><span class="line">            name = info[2] + &apos;.&apos; + info[3] + &apos;.&apos; + copy_right + &apos;.&apos;</span><br><span class="line">            full_name = file_path + name</span><br><span class="line"></span><br><span class="line">            return full_name</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法获取到图片信息，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    # 取得图片的尺寸</span><br><span class="line">    def get_pic_size(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取远程图片的尺寸</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size_list = []</span><br><span class="line">        url = [self.get_img_info()[0], self.get_img_info()[1]]</span><br><span class="line">        for u in url:</span><br><span class="line">            r = requests.get(u)</span><br><span class="line">            img = Image.open(BytesIO(r.content))</span><br><span class="line">            pic_size = str(img.width) + &apos;x&apos; + str(img.height)</span><br><span class="line">            size_list.append(pic_size)</span><br><span class="line">        return size_list</span><br><span class="line"></span><br><span class="line">    # 取得今日美图文字</span><br><span class="line">    def get_description(self):</span><br><span class="line">        url = &apos;https://www.bing.com/?mkt=zh-CN&apos;</span><br><span class="line">        rsp = requests.get(url)</span><br><span class="line">        result = re.search(r&apos;(&#123;&quot;Description&quot;:&quot;)(.*?)(&quot;,&quot;Image&quot;)&apos;, rsp.text).group(2)</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bing = BingUHD()</span><br><span class="line">    file_name = bing.get_file_name()</span><br><span class="line">    content = bing.get_today_img_download(file_name)</span><br></pre></td></tr></table></figure>

<p>进入脚本根目录执行python脚本就能自动创建相关的文件夹，自动下载图片，项目结构内容如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fa05e15eb56182ea4b0e796e71713f19bf0ff2c4ebfc264be4f88839c5a62600" alt="image.png"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>后面文章找不到封面我就拿这个做文章封面了，上面的代码通过已知隐藏的接口获取到了更高清图片的3140*2160 4K图片地址，看上图中的两种图片体积可以看出来，图片质量完全不一样。</p>
<p>可能对于Python 新手有些不友好，如果不抗拒一段段代码复制去询问ChatGPT 然后自己慢慢打印调试尝试，其实有那种精神就能慢慢学会了，站在技术实现的角度其实直接从F12控制台就能找到这个图片的源地址右键就能保存了，我的想法是后面有机会的话做一个图片展示的网站，尝试部署这个脚本用定时任务自动爬取收集这些图片，就不用特地手动运行脚本了。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358381923922821146" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>初识并发编程</title>
    <url>/7358375367340408883.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>并发是同一时间应对多件事情的能力——<a href="https://zh.wikipedia.org/wiki/%E7%BE%85%E5%8B%83%C2%B7%E6%B4%BE%E5%85%8B" target="_blank" rel="noopener">Rob Pike</a></p>
</blockquote>
<p><strong>并发编程是指在软件开发中处理多个任务或线程的方式</strong>。它涉及到同时执行多个任务，而不是一个接一个地执行。并发编程的目标是<strong>提高程序的效率和响应能力</strong>，使得程序能够更好地处理用户的请求，<strong>提高系统的吞吐量和并发性能</strong>。</p>
<h2 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2d58c27e037d17a52577d1a2d3db48a6b95c1d19985be7ce0d34f890c59a3125" alt></p>
<blockquote>
<p>CPU（Central Processing Unit）是计算机中的中央处理器，它是计算机的大脑，负责执行程序指令、进行算术和逻辑运算，控制数据传输和处理。</p>
</blockquote>
<h3 id="单核-CPU-与多核-CPU"><a href="#单核-CPU-与多核-CPU" class="headerlink" title="单核 CPU 与多核 CPU"></a>单核 CPU 与多核 CPU</h3><p><strong>单核CPU</strong>：</p>
<ul>
<li>单核 CPU 是一种最基本的 CPU 架构，它只有一个处理器核心。</li>
<li>单核 CPU 通常只能同时执行一个任务，因此在执行多个任务时，会进行任务的排队和切换，从而导致任务执行的不连续和效率低下。</li>
</ul>
<p>单核CPU的优势在于价格低廉和简单的结构，一般适用于个人电脑、平板电脑和一些轻量级设备。</p>
<p><strong>多核CPU</strong>：</p>
<ul>
<li>多核 CPU 是一种具有多个处理器核心的 CPU 架构。</li>
<li>多核 CPU 可以同时执行多个任务，提高了计算机的处理能力和性能。</li>
</ul>
<h3 id="单核-CPU-和多核-CPU-的区别及优势"><a href="#单核-CPU-和多核-CPU-的区别及优势" class="headerlink" title="单核 CPU 和多核 CPU 的区别及优势"></a>单核 CPU 和多核 CPU 的区别及优势</h3><p><strong>区别</strong>：</p>
<ul>
<li>单核 CPU 只有一个处理器核心，而多核 CPU 具有多个处理器核心。</li>
<li>单核 CPU 只能同时执行一个任务，而多核 CPU 可以同时执行多个任务。</li>
<li>单核 CPU 的处理能力相对较低，而多核 CPU 的处理能力更高。</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>多核 CPU 相比单核 CPU 具有更高的处理能力和性能，能够更好地利用系统资源，提高计算机的吞吐量和响应速度。</li>
<li>多核 CPU 可以同时执行多个任务，提高了计算机的并发处理能力。</li>
<li>多核 CPU 通过超线程技术可以提高单个任务的执行效率。</li>
<li>多核 CPU 的价格相对较高，但对于需要高性能计算和多任务处理的场景，它是一个很好的选择。</li>
</ul>
<h3 id="多核CPU如何实现并行处理"><a href="#多核CPU如何实现并行处理" class="headerlink" title="多核CPU如何实现并行处理"></a>多核CPU如何实现并行处理</h3><p>在早期只有一个 CPU 核心时，我们的任务是怎么处理的呢？是的，并发解君愁。当然，这里还得提到操作系统的多线程，正是操作系统多线程 + CPU 核心，才实现了现代化的多任务操作系统。在 OS 级别，多线程负责管理我们的任务队列，你可以简单认为一个线程管理着一个任务队列，然后线程之间还能根据空闲度进行任务调度。我们的程序只会跟 OS 线程打交道，并不关心 CPU 到底有多少个核心，真正关心的只是 OS，当线程把任务交给 CPU 核心去执行时，<strong>如果只有一个 CPU 核心，那么它就只能同时处理一个任务</strong>。</p>
<h4 id="多核心并行"><a href="#多核心并行" class="headerlink" title="多核心并行"></a>多核心并行</h4><p>当 CPU 核心增多到 N 时，那么能够在同一时间就能有 N 个任务被处理，则并行度就是 N，相应的处理效率也变成了单核心的 N 倍。</p>
<h4 id="多核心并发"><a href="#多核心并发" class="headerlink" title="多核心并发"></a>多核心并发</h4><p>当电脑的处理器核心增多时，操作系统需要处理的任务也会增多。这些任务被分成几个队列，然后交给处理器核心去执行。虽然看起来好像所有任务都在同时进行，但实际上，每个核心在同一时刻只能处理一个任务。所以，虽然任务都在同时进行，但实际上只有少数任务能够真正地同时被处理。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程和线程是操作系统中用于执行任务的基本单位。它们之间有一些重要区别：</p>
<p><strong>进程</strong>：</p>
<ul>
<li>进程是程序的一次执行实例，拥有独立的内存空间和资源。</li>
<li>每个进程都有自己的地址空间、文件描述符、环境变量等。</li>
<li>进程之间通常是相互独立的，彼此不会影响。</li>
<li>进程之间的通信需要使用 IPC（Inter-Process Communication）机制，如管道、消息队列、共享内存等。</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程是在进程内部执行的轻量级任务单元，共享进程的资源。</li>
<li>线程共享相同的地址空间和文件描述符，可以直接访问进程的全局变量和数据。</li>
<li>线程之间的切换比进程之间的切换更快速，因为不涉及地址空间的切换。</li>
<li>线程之间的通信更容易，可以直接通过共享内存等方式进行通信。</li>
</ul>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><blockquote>
<ul>
<li>究竟什么是并发？</li>
<li>它与并行有什么区别？</li>
</ul>
</blockquote>
<p>理解并发编程的关键是理解并发的概念。</p>
<ul>
<li>并发是指在<strong>同一时间处理多个任务</strong>；并发编程主要关注如何处理多个任务。</li>
<li>并行是指<strong>真正同时执行多个任务</strong>；并行编程则关注如何真正同时执行多个任务。</li>
</ul>
<p>Erlang 之父<a href="https://zh.wikipedia.org/wiki/%E5%96%AC%C2%B7%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97" target="_blank" rel="noopener">约瑟夫·莱斯利·阿姆斯特朗</a>用一张很形象的图片解释了并发与并行的区别：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a385dbf3581f0c4955ba7a33bc3624dfa2dbef8646117c3365532623d887250e" alt></p>
<p>从上图可以看出：</p>
<ul>
<li>并发是多个队列使用同一个咖啡机，然后两个队列轮着使用（未必是1:1 轮换，也有可能是其他轮换规则），但最终每个人都能接到咖啡</li>
<li>并行是每个队列都拥有一个咖啡机，最终也是每个人都能接到咖啡，但是效率更高，因为同时可以有两个人在接咖啡</li>
</ul>
<blockquote>
<p><strong>并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理</strong>。正如 Go 语言之父 Rob Pike 曾说过：<strong>并发不是并行，并发关乎结构，并行关乎执行</strong>。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358375367340408883" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Go</tag>
      </tags>
  </entry>
  <entry>
    <title>webserverapachetomcat11-03-</title>
    <url>/7358361832461156389.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理这个官方翻译的系列，原因是网上大部分的 tomcat 版本比较旧，此版本为 v11 最新的版本。</p>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><blockquote>
<p>从零手写实现 tomcat <a href="https://github.com/houbb/minicat" target="_blank" rel="noopener">minicat</a> 别称【嗅虎】心有猛虎，轻嗅蔷薇。</p>
</blockquote>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-01-intro" target="_blank" rel="noopener">web server apache tomcat11-01-官方文档入门介绍</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-02-setup" target="_blank" rel="noopener">web server apache tomcat11-02-setup 启动</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-03-deploy" target="_blank" rel="noopener">web server apache tomcat11-03-deploy 如何部署</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-04-manager" target="_blank" rel="noopener">web server apache tomcat11-04-manager 如何管理？</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-06-host-manager" target="_blank" rel="noopener">web server apache tomcat11-06-Host Manager App – Text Interface</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-07-relam" target="_blank" rel="noopener">web server apache tomcat11-07-Realm Configuration</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-08-jndi" target="_blank" rel="noopener">web server apache tomcat11-08-JNDI Resources</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-09-jdbc-datasource" target="_blank" rel="noopener">web server apache tomcat11-09-JNDI Datasource</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-10-classloader-howto" target="_blank" rel="noopener">web server apache tomcat11-10-Class Loader</a></p>
<p>….</p>
<h1 id="Tomcat-Web-应用部署"><a href="#Tomcat-Web-应用部署" class="headerlink" title="Tomcat Web 应用部署"></a>Tomcat Web 应用部署</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>部署是指将 Web 应用程序（无论是第三方 WAR 文件还是自定义的 Web 应用程序）安装到 Tomcat 服务器的过程。</p>
<p>在 Tomcat 服务器内，可以通过多种方式来完成 Web 应用程序的部署。</p>
<ul>
<li>静态部署：在启动 Tomcat 之前设置 Web 应用程序。</li>
<li>动态部署：通过直接操作已部署的 Web 应用程序（依赖自动部署功能）或通过使用 Tomcat Manager Web 应用程序来远程部署。</li>
</ul>
<p>Tomcat Manager 是一个 Web 应用程序，可以以交互方式（通过 HTML GUI）或以编程方式（通过基于 URL 的 API）来部署和管理 Web 应用程序。</p>
<p>有许多依赖于 Manager Web 应用程序的部署方式。</p>
<p>Apache Tomcat 提供了用于 Apache Ant 构建工具的任务。</p>
<p>Apache Tomcat Maven 插件项目提供了与 Apache Maven 的集成。</p>
<p>还有一个称为 Client Deployer 的工具，可以从命令行使用，并提供了额外的功能，例如编译和验证 Web 应用程序，以及将 Web 应用程序打包成 Web 应用资源（WAR）文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>对于静态部署 Web 应用程序，不需要安装，因为 Tomcat 默认提供了此功能。对于使用 Tomcat Manager 的部署功能，虽然需要一些配置（如 Tomcat Manager 手册中详细说明的那样），但不需要安装。但是，如果要使用 Tomcat Client Deployer (TCD)，则需要安装。</p>
<p>TCD 不包含在 Tomcat 核心发行版中，因此必须从下载区域单独下载。下载通常标记为 apache-tomcat-11.0.x-deployer。</p>
<p>TCD 的先决条件是 Apache Ant 1.6.2+ 和 Java 安装。您的环境应定义一个 ANT_HOME 环境值，指向 Ant 安装的根目录，以及一个 JAVA_HOME 值，指向您的 Java 安装。</p>
<p>另外，您应确保 Ant 的 ant 命令和 Java 的 javac 编译器命令可以在您的操作系统提供的命令 shell 中运行。</p>
<ol>
<li>下载 TCD 分发包。</li>
<li>TCD 分发包不需要解压到任何现有的 Tomcat 安装中，它可以解压到任何位置。</li>
<li>阅读《使用 Tomcat Client Deployer》文档。</li>
</ol>
<h2 id="关于-Context"><a href="#关于-Context" class="headerlink" title="关于 Context"></a>关于 Context</h2><p>在讨论 Web 应用程序的部署时，需要理解 Context 的概念。Context 是 Tomcat 所称的 Web 应用程序。</p>
<p>为了在 Tomcat 中配置 Context，需要一个 Context 描述符。Context 描述符只是一个包含与 Context 相关的 Tomcat 配置的 XML 文件，例如命名资源或会话管理器配置。在较早版本的 Tomcat 中，Context 描述符配置的内容通常存储在 Tomcat 的主配置文件 server.xml 中，但现在已不鼓励这样做（尽管目前仍然有效）。</p>
<p>Context 描述符不仅帮助 Tomcat 知道如何配置 Context，还帮助其他工具（如 Tomcat Manager 和 TCD）正确执行其功能。</p>
<p>Context 描述符的位置包括：</p>
<ul>
<li><code>$CATALINA_BASE/conf/[enginename]/[hostname]/[webappname].xml</code></li>
<li><code>$CATALINA_BASE/webapps/[webappname]/META-INF/context.xml</code></li>
</ul>
<p>第一种情况的文件命名为 <code>[webappname].xml</code>，而第二种情况的文件命名为 context.xml。如果没有为 Context 提供 Context 描述符，Tomcat 将使用默认值配置 Context。</p>
<h2 id="在-Tomcat-启动时部署"><a href="#在-Tomcat-启动时部署" class="headerlink" title="在 Tomcat 启动时部署"></a>在 Tomcat 启动时部署</h2><p>如果您不想使用 Tomcat Manager 或 TCD，则需要将 Web 应用程序静态部署到 Tomcat，然后启动 Tomcat。您需要将 Web 应用程序部署到称为 appBase 的位置，该位置由 Host 指定。您可以将所谓的“已解压” Web 应用程序（即非压缩的）复制到此位置，也可以将压缩的 Web 应用程序资源 .WAR 文件复制到此位置。</p>
<p>在默认的情况下，位于主机（默认主机为“localhost”）appBase 属性（默认 appBase 为“$CATALINA_BASE/webapps”）指定的位置中存在的 Web 应用程序仅在 Host 的 deployOnStartup 属性为“true”时才会在 Tomcat 启动时部署。</p>
<p>在这种情况下，以下部署顺序将在 Tomcat 启动时发生：</p>
<ol>
<li>首先部署任何 Context 描述符。</li>
<li>然后部署任何未被任何 Context 描述符引用的已解压的 Web 应用程序。如果它们在 appBase 中有一个关联的 .WAR 文件，并且该文件比已解压的 Web 应用程序更新，则将删除已解压的目录，并重新部署 Web 应用程序。</li>
<li>部署 .WAR 文件。</li>
</ol>
<h2 id="在运行的-Tomcat-服务器上部署"><a href="#在运行的-Tomcat-服务器上部署" class="headerlink" title="在运行的 Tomcat 服务器上部署"></a>在运行的 Tomcat 服务器上部署</h2><p>可以将 Web 应用程序部署到运行中的 Tomcat 服务器上。</p>
<p>如果 Host 的 autoDeploy 属性设置为“true”，则 Host 将尝试根据需要动态部署和更新 Web 应用程序，例如</p>
<p>，如果新的 .WAR 放入了 appBase 中。要使此功能正常工作，Host 需要启用后台处理，这是默认配置。</p>
<p>autoDeploy 设置为“true”并且运行中的 Tomcat 允许：</p>
<ul>
<li>将 .WAR 文件复制到 Host 的 appBase 中进行部署。</li>
<li>将已解压的 Web 应用程序复制到 Host 的 appBase 中进行部署。</li>
<li>如果提供了新的 .WAR 文件，则重新部署已经部署的 Web 应用程序。在这种情况下，将删除已解压的 Web 应用程序，并重新展开 .WAR。请注意，如果 Host 配置为不展开 .WAR（unpackWARs 属性设置为“false”），则不会执行展开操作，此时 Web 应用程序将作为压缩的存档重新部署。</li>
<li>如果更新了 /WEB-INF/web.xml 文件（或任何其他定义为 WatchedResource 的资源），则重新加载 Web 应用程序。</li>
<li>如果更新了从中部署了 Web 应用程序的 Context 描述符文件，则重新部署 Web 应用程序。</li>
<li>如果由 Web 应用程序使用的全局或每个主机的 Context 描述符文件已更新，则重新部署依赖的 Web 应用程序。</li>
<li>如果在 <code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code> 目录中添加了一个文件（文件名对应于先前部署的 Web 应用程序的 Context 路径），则重新部署 Web 应用程序。</li>
<li>如果删除了其文档基址（docBase）的 Web 应用程序，则卸载它。请注意，在 Windows 上，这假定启用了反锁定功能（参见 Context 配置），否则无法删除正在运行的 Web 应用程序的资源。</li>
</ul>
<p>请注意，还可以在加载器中配置 Web 应用程序重新加载，这样加载的类将被跟踪以进行更改。</p>
<h2 id="使用-Tomcat-Manager-进行部署"><a href="#使用-Tomcat-Manager-进行部署" class="headerlink" title="使用 Tomcat Manager 进行部署"></a>使用 Tomcat Manager 进行部署</h2><p>Tomcat Manager 在自己的手册页面中进行了详细介绍。</p>
<h2 id="使用客户端部署包进行部署"><a href="#使用客户端部署包进行部署" class="headerlink" title="使用客户端部署包进行部署"></a>使用客户端部署包进行部署</h2><p>最后，可以使用 Tomcat 客户端部署程序来部署 Web 应用程序。这是一个可以用来验证、编译、压缩为 .WAR，并将 Web 应用程序部署到生产或开发 Tomcat 服务器的包。应该注意，此功能使用 Tomcat Manager，因此目标 Tomcat 服务器应该正在运行。</p>
<p>假设用户熟悉 Apache Ant 以使用 TCD。Apache Ant 是一个脚本化的构建工具。TCD 包含一个预打包的构建脚本。只需要对 Apache Ant 有一些基本的了解（如本页中列出的安装，并熟悉使用操作系统命令 shell 和配置环境变量）。</p>
<p>TCD 包含 Ant 任务，用于 JSP 编译的 Jasper 页面编译器，以及用于验证 Web 应用程序 Context 描述符的任务。验证器任务（类 org.apache.catalina.ant.ValidatorTask）仅允许一个参数：已解压的 Web 应用程序的基本路径。</p>
<p>TCD 使用已解压的 Web 应用程序作为输入（请参阅下面使用的属性列表）。通过 deployer 进行编程部署的 Web 应用程序可以在 /META-INF/context.xml 中包含 Context 描述符。</p>
<p>TCD 包含一个可立即使用的 Ant 脚本，具有以下目标：</p>
<ul>
<li>compile（默认）：编译和验证 Web 应用程序。这可以独立使用，不需要运行的 Tomcat 服务器。编译的应用程序仅在关联的 Tomcat X.Y.Z 服务器发布中运行，并不能保证在另一个 Tomcat 发布中工作，因为 Jasper 生成的代码依赖于其运行时组件。还应该注意，此目标还会自动编译位于 /WEB-INF/classes 文件夹中的任何 Java 源文件。</li>
<li>deploy：将 Web 应用程序（已编译或未编译）部署到 Tomcat 服务器。</li>
<li>undeploy：卸载 Web 应用程序</li>
<li>start：启动 Web 应用程序</li>
<li>reload：重新加载 Web 应用程序</li>
<li>stop：停止 Web 应用程序</li>
</ul>
<p>为了配置部署，需要在 TCD 安装目录根目录下创建一个名为 deployer.properties 的文件。在此文件中，每行添加以下名称=值对：</p>
<p>此外，您需要确保为目标 Tomcat Manager（TCD 使用的）设置了用户，否则 TCD 将无法与 Tomcat Manager 进行身份验证，部署将失败。</p>
<p>要执行此操作，请参阅 Tomcat Manager 页面。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tomcat.apache.org/tomcat-11.0-doc/deployer-howto.html" target="_blank" rel="noopener">tomcat.apache.org/tomcat-11.0…</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358361832461156389" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SpringWebMultipartFile文件上传、</title>
    <url>/7358450927110832162.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Web开发中，文件上传是一个常见的功能需求。Spring框架提供了MultipartFile接口，用于处理文件上传请求。MultipartFile可以代表一个多部分文件上传请求中的一个文件，提供了一系列方法用于获取文件的各种属性和内容，使得在后端处理文件上传变得十分方便。下面我们将介绍MultipartFile在Web应用中的几种常见使用场景。</p>
<p><strong>1. 图片上传</strong></p>
<p>在Web应用中，图片上传是一种常见的场景。用户需要上传头像、相片、证件照等图片文件，而后端需要接收并保存这些文件。使用MultipartFile接口可以轻松地实现图片文件的接收和处理。通过获取文件的原始文件名、内容类型、大小等属性，我们可以实现对图片文件的有效管理和存储。例如，我们可以将图片文件保存到服务器的文件系统中，或者将其存储到<a href="https://cloud.baidu.com/product/abc-storage.html" target="_blank" rel="noopener">云存储</a>服务中。</p>
<p><strong>2. 文件下载</strong></p>
<p>除了文件上传，文件下载也是Web应用中常见的功能需求。使用MultipartFile接口，我们可以实现文件的下载功能。在服务器端，我们可以将文件作为MultipartFile对象进行处理，并通过设置响应头信息，将文件作为下载内容返回给客户端。客户端接收到文件后，可以将其保存到本地磁盘或进行其他处理。</p>
<p><strong>3. 文件编辑</strong></p>
<p>在Web应用中，有时候用户需要对上传的文件进行编辑操作，例如修改文件名、修改文件内容等。使用MultipartFile接口，我们可以实现对文件的编辑功能。首先，我们可以通过MultipartFile接口获取上传的文件对象，然后对其进行相应的编辑操作。例如，我们可以修改文件的名称、修改文件的内容等。编辑完成后，我们可以将修改后的文件保存到服务器或返回给客户端。</p>
<p><strong>4. 文件预览和展示</strong></p>
<p>在Web应用中，有时候我们需要将上传的文件进行预览或展示。例如，在<a href="https://cloud.baidu.com/product/doc.html" target="_blank" rel="noopener">文档</a>管理系统中，用户需要预览或下载文档文件。使用MultipartFile接口，我们可以实现文件的预览和展示功能。我们可以将文件作为MultipartFile对象进行处理，然后将其内容转换为适当的格式进行展示。例如，对于PDF文件，我们可以使用PDF阅读器插件进行展示；对于图片文件，我们可以将其直接展示在网页上。</p>
<p><strong>5. 文件批量上传和处理</strong></p>
<p>在实际应用中，有时候用户需要批量上传多个文件，并对这些文件进行处理。使用MultipartFile接口，我们可以实现文件的批量上传和处理功能。我们可以将多个文件作为一个多部分文件上传请求进行处理，然后对每个文件进行相应的操作。例如，我们可以将多个图片文件批量上传到服务器，并对它们进行压缩、裁剪等处理。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package com.javagpt.back.controller;</span><br><span class="line"></span><br><span class="line">import com.javagpt.application.context.UserAppContextHolder;</span><br><span class="line">import com.javagpt.application.file.FileApplicationService;</span><br><span class="line">import com.javagpt.application.file.FileDTO;</span><br><span class="line">import com.javagpt.common.annotation.RespSuccess;</span><br><span class="line">import com.javagpt.common.constant.EMConstant;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br><span class="line">import jakarta.servlet.http.HttpServletResponse;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@Api(tags = &quot;文件接口&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(EMConstant.API_V1 + &quot;/file&quot;)</span><br><span class="line">@RespSuccess</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class FileController &#123;</span><br><span class="line"></span><br><span class="line">    private final FileApplicationService fileApplicationService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;通用文件上传&quot;)</span><br><span class="line">    @PostMapping(value = &quot;/uploadFile&quot;)</span><br><span class="line">    public FileDTO uploadFile(@RequestParam(&quot;file&quot;) MultipartFile multipartFile) throws IOException &#123;</span><br><span class="line">        Long enterpriseId = UserAppContextHolder.getCurrentUser().getEnterpriseId();</span><br><span class="line">        FileDTO fileDTO = fileApplicationService.saveFile(enterpriseId, multipartFile);</span><br><span class="line">        return fileDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //@PreAuthorize(&quot;hasAuthority(&apos;mp:file:download&apos;)&quot;)</span><br><span class="line">    @ApiOperation(&quot;下载文件&quot;)</span><br><span class="line">    @GetMapping(value = &quot;/downloadFile&quot;)</span><br><span class="line">    public void download(@RequestParam(value = &quot;id&quot;) Long id, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        fileApplicationService.downloadFile(response, id, UserAppContextHolder.getCurrentUser().getEnterpriseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;查看文件信息&quot;)</span><br><span class="line">    @GetMapping(value = &quot;/info&quot;)</span><br><span class="line">    public FileDTO fileInfo(@RequestParam(value = &quot;id&quot;) Long id) throws IOException &#123;</span><br><span class="line">        return fileApplicationService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;下载视频&quot;)</span><br><span class="line">    @GetMapping(value = &quot;/downloadFile2&quot;)</span><br><span class="line">    public void download2(@RequestParam(value = &quot;id&quot;) Long id, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        fileApplicationService.downloadVideo(request, response, id, UserAppContextHolder.getCurrentUser().getEnterpriseId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package com.javagpt.application.file;</span><br><span class="line"></span><br><span class="line">import com.javagpt.common.exception.BusinessRuntimeException;</span><br><span class="line">import com.javagpt.common.oos.OssService;</span><br><span class="line">import com.javagpt.common.util.ModelUtils;</span><br><span class="line">import com.javagpt.common.util.SpringResponseUtils;</span><br><span class="line">import com.javagpt.file.entity.FileEntity;</span><br><span class="line">import com.javagpt.file.repository.FileRepository;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br><span class="line">import jakarta.servlet.http.HttpServletResponse;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line">import org.apache.commons.io.IOUtils;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class FileApplicationService &#123;</span><br><span class="line"></span><br><span class="line">    private final OssService ossService;</span><br><span class="line"></span><br><span class="line">    private final FileRepository fileRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public FileDTO findById(Long id) &#123;</span><br><span class="line">        FileEntity fileEntity = fileRepository.findById(id);</span><br><span class="line">        return ModelUtils.convert(fileEntity, FileDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public FileDTO saveFile(Long enterpriseId, MultipartFile file) &#123;</span><br><span class="line">        FileEntity fileEntity = saveFile(enterpriseId, file, null);</span><br><span class="line">        return ModelUtils.convert(fileEntity, FileDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public FileEntity saveFile(Long enterpriseId, MultipartFile file, String fileName) &#123;</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        String name = StringUtils.isBlank(fileName) ? FilenameUtils.getBaseName(originalFilename) : fileName;</span><br><span class="line">        String suffix = FilenameUtils.getExtension(originalFilename);</span><br><span class="line">        long size = file.getSize();</span><br><span class="line">        FileEntity fileEntity = new FileEntity();</span><br><span class="line">        fileEntity.setName(name).setSuffix(suffix).setSize(size).setEnterpriseId(enterpriseId);</span><br><span class="line">        fileEntity = fileEntity.save();</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        InputStream inputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = file.getInputStream();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;saveFile error:&quot;, e);</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;上传文件失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ossService.uploadFile(inputStream, key);</span><br><span class="line">        IOUtils.closeQuietly(inputStream);</span><br><span class="line">        return fileEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public FileEntity saveFile(File file) &#123;</span><br><span class="line">        long size = file.length();</span><br><span class="line">        FileEntity fileEntity = new FileEntity();</span><br><span class="line">        String baseName = FilenameUtils.getBaseName(file.getName());</span><br><span class="line">        String extension = FilenameUtils.getExtension(file.getName());</span><br><span class="line">        fileEntity.setName(baseName).setSuffix(extension).setSize(size);</span><br><span class="line">        fileEntity = fileEntity.save();</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(file);</span><br><span class="line">            ossService.uploadFile(inputStream, key);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            log.error(&quot;saveFile error:&quot;, e);</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;上传文件失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        IOUtils.closeQuietly(inputStream);</span><br><span class="line">        return fileEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void downloadFile(HttpServletResponse response, Long fileId, Long enterpriseId) throws IOException &#123;</span><br><span class="line">        FileEntity fileEntity = fileRepository.findById(fileId);</span><br><span class="line">        if (fileEntity == null) &#123;</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;无效的文件Id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        InputStream inputStream = ossService.downloadFile(key);</span><br><span class="line">        SpringResponseUtils.writeAndFlushResponse(inputStream, response, fileEntity.fileFullName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void downloadVideo(HttpServletRequest request, HttpServletResponse response, Long fileId, Long enterpriseId) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileEntity fileEntity = fileRepository.findById(fileId);</span><br><span class="line">        if (fileEntity == null) &#123;</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;无效的文件Id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        response.setHeader(HttpHeaders.ACCEPT_RANGES, &quot;bytes&quot;);</span><br><span class="line">        Long fileSize = fileEntity.getSize();</span><br><span class="line">        long start = 0, end = fileSize - 1;</span><br><span class="line">        //判断前端需不需要分片下载</span><br><span class="line">        if (StringUtils.isNotBlank(request.getHeader(&quot;Range&quot;))) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span><br><span class="line">            String numRange = request.getHeader(&quot;Range&quot;).replaceAll(&quot;bytes=&quot;, &quot;&quot;);</span><br><span class="line">            String[] strRange = numRange.split(&quot;-&quot;);</span><br><span class="line">            if (strRange.length == 2) &#123;</span><br><span class="line">                start = Long.parseLong(strRange[0].trim());</span><br><span class="line">                end = Long.parseLong(strRange[1].trim());</span><br><span class="line">                //若结束字节超出文件大小 取文件大小</span><br><span class="line">                if (end &gt; fileSize - 1) &#123;</span><br><span class="line">                    end = fileSize - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //若只给一个长度  开始位置一直到结束</span><br><span class="line">                start = Long.parseLong(numRange.replaceAll(&quot;-&quot;, &quot;&quot;).trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long rangeLength = end - start + 1;</span><br><span class="line">        String contentRange = new StringBuffer(&quot;bytes &quot;).append(start).append(&quot;-&quot;).append(end).append(&quot;/&quot;).append(fileSize).toString();</span><br><span class="line">        response.setHeader(HttpHeaders.CONTENT_RANGE, contentRange);</span><br><span class="line">        response.setHeader(HttpHeaders.CONTENT_LENGTH, String.valueOf(rangeLength));</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        InputStream inputStream = ossService.downloadFile2(key, start, end);</span><br><span class="line">        SpringResponseUtils.writeAndFlushResponse(inputStream, response, fileEntity.fileFullName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，MultipartFile接口在Web应用中具有广泛的应用场景，可以实现文件上传、下载、编辑、预览和批量处理等功能。通过熟练掌握MultipartFile接口的使用方法和技巧，我们可以更加高效地处理文件上传和下载请求，提升Web应用的用户体验和功能性能。</p>
<blockquote>
<p>本文由博客一文多发平台 <a href="https://openwrite.cn?from=article_bottom" target="_blank" rel="noopener">OpenWrite</a> 发布！</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358450927110832162" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenTelemetry实践指南：历史、架构与基本概念</title>
    <url>/7358450927110357026.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为稀土掘金技术社区首发签约文章，30天内禁止转载，30天后未获授权禁止转载，侵权必究！</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前陆续写过一些和 OpenTelemetry 相关的文章：</p>
<ul>
<li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/" target="_blank" rel="noopener">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li>
<li><a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/" target="_blank" rel="noopener">实战：如何编写一个 OpenTelemetry Extensions</a></li>
<li><a href="https://dev.newban.cn/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a></li>
</ul>
<p>这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。</p>
<hr>
<h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>早在 <code>OpenTelemetry</code> 诞生之前可观测性这个概念就一直存在了，我记得我最早接触到这个概念是在 16 年当时的公司所使用的一个产品：<a href="https://github.com/pinpoint-apm/pinpoint" target="_blank" rel="noopener">pinpoint</a></p>
<blockquote>
<p>现如今这个项目依然比较活跃。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f20ed5174b0536cba995d1bdc03a0a1ada83d39ece822cc403f053f54ba96f88" alt><br>依然还记得当时通过它可以直接看到项目调用的拓扑图，在时间坐标上框出高延迟的点就能列出这些请求，同时还能查看此时的运行日志。</p>
<p>这样强大的功能对于一个刚工作一年的小白来说冲击力实属太大了一点。</p>
<p>后来才了解到 pinpoint 属于 APM 这类产品，类似的产品还有：</p>
<ul>
<li>Apache SkyWalking</li>
<li>美团的 CAT 等</li>
</ul>
<p>他们都是可以用于性能分析和链路追踪的产品，到后来公司的运维层面也接入过 Zabbix、open-falcon 之类的产品：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b25088ba2bea7828804b744ca33a3be750e8e43b108a5827bce76d38512f6b4a" alt></p>
<p>17之后全面切换到 spring boot 时，也用过社区提供的 <a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener">spring-boot-admin</a> 项目：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5ae14e793b0d375a9dcc59168e8f7a720da10d0df49d4abf6a6294a3b0339977" alt><br>这就是一个简单的可以监控 spring boot 应用的产品，用于展示 JVM 指标，或者自己也可以定义一些健康指标。</p>
<hr>
<p>再之后进入云原生体系后可观测性的技术栈稍有变化。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f22de62a6a74cb2d98f2b1ea89826322cd7d2e444f9512621cdaffa62d1a37f1" alt></p>
<p>日志使用 Sidecar 代理的方式通过 Agent 将数据写入 ElasticSearch 中。<br>具体日志采集方式可以参考之前的文章：</p>
<ul>
<li><a href="https://dev.newban.cn/7347000319983419411">在 kubernetes 环境下如何采集日志</a></li>
</ul>
<p>而链路追踪则是使用的 <code>skywalking</code>，在 trace 这个领域 skywalking 还是非常受大家喜爱的。</p>
<p>不过最近也从 skywalking 切换到了我们本文所讲到的 OpenTelemetry，具体可以看之前的文章：</p>
<ul>
<li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/" target="_blank" rel="noopener">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li>
</ul>
<p>指标采集使用的是自然也是 Prometheus 的那一套技术栈，只是 Prometheus 换为了与它完全兼容的 VictoriaMetric 目前是为了更省资源。</p>
<p>客户端使用则是直接使用 Prometheus 的库进行指标暴露：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;prometheus-metrics-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;prometheus-metrics-instrumentation-jvm&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;prometheus-metrics-exporter-httpserver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>最终通过配置抓取策略，由 VictoriaMetrics 的 <code>scrape</code> 程序来抓取指标最终写入到它自己的存储中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码apiVersion: operator.victoriametrics.com/v1beta1  </span><br><span class="line">kind: VMPodScrape  </span><br><span class="line">metadata:  </span><br><span class="line">  name: kubernetes-pod-scrape  </span><br><span class="line">  namespace: monitoring  </span><br><span class="line">spec:  </span><br><span class="line">  podMetricsEndpoints:  </span><br><span class="line">    - scheme: http  </span><br><span class="line">      scrape_interval: &quot;30s&quot;  </span><br><span class="line">      path: /metrics  </span><br><span class="line">      relabelConfigs:  </span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: &quot;true&quot;  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: keep  </span><br><span class="line">        # 端口相同  </span><br><span class="line">        - action: keep_if_equal  </span><br><span class="line">          source_labels: [ __meta_kubernetes_pod_annotation_prometheus_io_port, __meta_kubernetes_pod_container_port_number ]  </span><br><span class="line">        # 过滤INIT容器  </span><br><span class="line">        - action: drop  </span><br><span class="line">          source_labels: [ __meta_kubernetes_pod_container_init ]  </span><br><span class="line">          regex: &quot;true&quot;  </span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: (.+)  </span><br><span class="line">          target_label: __metrics_path__  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: replace  </span><br><span class="line">        - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: ([^:]+)(?::\d+)?;(\d+)  </span><br><span class="line">          target_label: __address__  </span><br><span class="line">          replacement: $1:$2  </span><br><span class="line">          action: replace  </span><br><span class="line">        - separator: ;  </span><br><span class="line">          regex: __meta_kubernetes_pod_label_(.+)  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: labelmap  </span><br><span class="line">        - source_labels: [__meta_kubernetes_namespace]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: (.*)  </span><br><span class="line">          target_label: kubernetes_namespace  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: replace  </span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_name]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: (.*)  </span><br><span class="line">          target_label: kubernetes_pod_name  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: replace  </span><br><span class="line">      vm_scrape_params:  </span><br><span class="line">        stream_parse: true  </span><br><span class="line">  namespaceSelector:  </span><br><span class="line">    any: true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是 VM 提供的 CRD</p>
</blockquote>
<h1 id="OpenTelemetry-诞生"><a href="#OpenTelemetry-诞生" class="headerlink" title="OpenTelemetry 诞生"></a>OpenTelemetry 诞生</h1><p>到此铺垫完成，不知道有没有发现在可观测性中关键的三个部分：日志、指标、trace 都是使用不同的开源产品，从而会导致技术栈较多，维护起来自然也是比较麻烦的。</p>
<p>这么一个软件领域的核心能力自然需要提供一个完整方案的，将以上的不同技术栈都整合在一起，更加的方便开发者使用。</p>
<p>在这之前也有两个社区想要做类似的事情：</p>
<ul>
<li>OpenTracing</li>
<li>OpenCensus</li>
</ul>
<p>不过他们并没有统一整个可观测领域，直到 2019 年 CNCF 社区宣布成立 OpenTelemetry，并且将上述两个社区进行合并共同开发 OpenTelemetry。</p>
<blockquote>
<p>背靠 CNCF 云原生社区加上许多知名厂商的支持（Google、Amazon、Redhat 等），现在已经正式成为 CNCF 的顶级项目了。</p>
</blockquote>
<h1 id="OpenTelemetry-架构介绍"><a href="#OpenTelemetry-架构介绍" class="headerlink" title="OpenTelemetry 架构介绍"></a>OpenTelemetry 架构介绍</h1><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c218188aad73dbfa126a99d5b790e19ea6bbcb7eee339bba93479f8b3c98c9b" alt></p>
<p>但我们打开 OpenTelemetry 社区的 GitHub 首页时，会看到有许多项目；第一反应应该是比较蒙的，下面我会着重介绍一些比较重要的项目。</p>
<p>在开始之前还是先简单介绍下 OpenTelemetry 的一些基础组件和概念：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77733c0ec5d07e1b1558148113cd48360d76a6167212c9daad00a86bb61ece5f" alt></p>
<p>整个 OpenTelemetry 系统其实可以简单分为三个部分：</p>
<ul>
<li>客户端</li>
<li>OTel collector</li>
<li>数据存储</li>
</ul>
<p>第一个客户端很好理解，也就是我们的业务应用；如果是 Java 应用只需要挂载一个 agent 就可以自动采集系统的指标、链路信息、日志等上传到 Collector 中。</p>
<p>也就是上图的左边部分。</p>
<p>之后就是非常关键的组件 collector，它可以通过 OTLP 协议接收刚才提到的客户端上传的数据，然后再内部进行处理，最终输出到后续的存储系统中。</p>
<h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c7e11281a19115764c48073408f3e77cc7c95ec6270e13eba126e795b95b470a" alt></p>
<blockquote>
<p>上图是 collector 的架构图</p>
</blockquote>
<p>由于 OpenTelemetry 设计之初就是要做到厂商无关，所以它就得做出更高层级的设计。</p>
<p>关键点就是这里的 Receiver 和 Exporter 都是模块化的设计，第三方开发者可以基于它的标准开发不同组件从而兼容不同的产品。</p>
<p>Receiver：用于接收客户端上报的数据，不止是自己 agent 上报的数据，也可能会来自不同的厂商，比如 kubernetes、Kafka 等。</p>
<p>Exporter：同理，可以将 receiver 收到的数据进行处理之后输出到不同的组件中；比如 Kafka/Pulsar/Promethus/Jaeger 等。</p>
<p>比如我们可以使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver" target="_blank" rel="noopener">Nginx Receiver</a>接收来着 Nginx 上报的数据。</p>
<p>使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/mysqlreceiver" target="_blank" rel="noopener">MySQL Receiver</a>接收来自 MySQL 的数据。</p>
<p>当然通常我们使用最多的还是 <a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver" target="_blank" rel="noopener">OTLP Receiver</a>，这是官方的 OTLP 协议的接收器，可以接受官方的一些指标，比如我们只使用了 Java Agent 进行数据上报时。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/45653e2ffc4bda20dc01ce32cc09f4c34f2d59d97580b722aaf0a79c0d67c9c0" alt><br><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver" target="_blank" rel="noopener">github.com/open-teleme…</a></p>
<p>在这里是可以看到目前支持的所有第三方的 Receiver。</p>
<hr>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/91aa8cf4e27df5524a07f3fb77f391629d0f28ce1de6f156ff9ab266b5d19215" alt></p>
<p>OpenTelemetry 所支持的 Exporter 也很多，比如一些常见的存储：</p>
<ul>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/clickhouseexporter" target="_blank" rel="noopener">clickhouse exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/elasticsearchexporter" target="_blank" rel="noopener">elasticsearch exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/pulsarexporter" target="_blank" rel="noopener">pulsar exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusexporter" target="_blank" rel="noopener">prometheus exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/exporter/otlphttpexporter" target="_blank" rel="noopener">otlp http exporter</a></li>
</ul>
<p>Exporter 的使用场景很多：如果是指标相关的数据可以直接写入 Prometheus，如果是日志数据也可以直接写入 ElasticSearch。</p>
<p>如果还有其他的特殊需求（删减属性等）则可以写入消息队列，自行处理完之后再发往 collector 进行后续的处理。</p>
<p>可能你已经发现了，由于 collector 非常的灵活，所以我们可以像搭积木一样组装我们的 receiver 和 exporter，它会以我们配置的流水线的方式进行调用，这样我们就可以实现任意可定制的处理逻辑。</p>
<p>而这些流水线的组装对于客户端来说都是透明的，也就是说 collector 的更改完全不会影响到业务；业务只需要按照 OTLP 的格式上报数据即可。</p>
<p>在之前的从 Skywalking 切换到 OpenTelemetry 的文章中有人问为什么要切换到 OpenTelemetry？</p>
<p>从这里也能看得出来，OpenTelemetry 的灵活度非常高，借助于 Exporter 可以任意的更换后端存储，或者增加/删减一些不需要的指标数据等。</p>
<hr>
<p>当然我们也可以统一的在这里进行搜索，可以列出所有的第三方集成的组件：<br><a href="https://opentelemetry.io/ecosystem/registry/" target="_blank" rel="noopener">opentelemetry.io/ecosystem/r…</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2dbed9e5d4e33e7a58b64537667f4f82eff8a810cab62729d3b74e28f8139430" alt></p>
<h1 id="OpenTelemetry-项目介绍"><a href="#OpenTelemetry-项目介绍" class="headerlink" title="OpenTelemetry 项目介绍"></a>OpenTelemetry 项目介绍</h1><h2 id="opentelemetry-java"><a href="#opentelemetry-java" class="headerlink" title="opentelemetry-java"></a>opentelemetry-java</h2><p>介绍完基本的概念后，我们可以看看 OTel 社区的一些主要开源项目。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/547d35675ba02d35cf2c4d499cd41ae76f6c79dfaf18e9183b5e38bdc4c9360f" alt></p>
<p>这里我们还是以刚才的那个架构图从作往右讲起，也就是主要分为客户端和 collector 端。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/882ec918332d38f78b65692c86462ae89bfa942f29f7f17ffef973da45f58424" alt><br>目前官方支持的客户端语言已经非常齐全了，大部分的版本都已经是 Stable 稳定版，意味着可以进入生产环境。</p>
<p>这里我们以 Java 客户端为例：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/509b7711106eba858255916e07db6ea10db4883c34e5b880b86e597f7009570e" alt><br>其中我们重点关注下 opentelemetry-java 和 opentelemetry-java-instrumentation 这两个项目。</p>
<p>我们用的最多的会是 <code>opentelemetry-java-instrumentation</code>，它会给我们提供一个 java agent 的 JAR 包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java -javaagent:path/to/opentelemetry-javaagent.jar \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure>

<p>我们只需要在 Java 应用中加上该 agent 就可以实现日志、指标、trace 的自动上报。</p>
<p>而且它还实现了不同框架、库的指标采集与 trace。</p>
<p>在这里可以查到支持的库与框架列表：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4cca4f6d4396e3a52bbb2e85127b900559dccc734524d6f04321fbf61b551a43" alt></p>
<p><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks" target="_blank" rel="noopener">github.com/open-teleme…</a></p>
<blockquote>
<p>总之几乎就是你能想到和不能想到的都支持了。</p>
</blockquote>
<p>而 opentelemetry-java 我们直接使用的几率会小一些，opentelemetry-java-instrumentation 本身也是基于它创建的，可以理解为是 Java 版本的核心基础库，一些社区支持的组件就可以移动到 <code>instrumentation</code> 这个库中。</p>
<p>比如我在上篇文章：<a href="https://dev.newban.cn/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a>中涉及到的 <code>HostResourceProvider</code> 资源加载就是从 <code>opentelemetry-java</code> 中移动到了 <code>opentelemetry-java-instrumentation</code>。</p>
<p>具体可以参考：<a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701" target="_blank" rel="noopener">github.com/open-teleme…</a></p>
<h2 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6a215cc3a475ae233ff274c1d5006d019c1de4c3c30211891cf9818c78109c63" alt></p>
<p>之后就是 collector 的组件了，它同样的也有两个库：<br><strong>OpenTelemetry Collector</strong> 和 <strong>OpenTelemetry Collector Contrib</strong></p>
<p>其实通过他们的名字也可以看得出来，他们的作用与刚才的 Java 库类似：</p>
<ul>
<li>opentelemetry-collector：由官方社区维护，提供了一些核心能力；比如只包含了最基本的 otlp 的 receiver 和 exporter。</li>
<li>opentelemetry-collector-contrib：包含了官方的 collector，同时更多的维护了社区提供的各种 receiver 和 exporter；就如上文提到的，一些社区组件（pulsar、MySQL、Kafka）等都维护在这个仓库。</li>
</ul>
<p>而我们生产使用时通常也是直接使用 opentelemetry-collector-contrib，毕竟它所支持的社区组件更多。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为 OpenTelemetry 想要解决的是整个可观测领域的所有需求，所以仓库非常多，社区也很开放，感兴趣的朋友可以直接参与贡献，这么多 repo 总有一个适合你的。</p>
<p>后续会继续讲解如何安装以及配置我们的 OpenTelemetry。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/pinpoint-apm/pinpoint" target="_blank" rel="noopener">github.com/pinpoint-ap…</a></li>
<li><a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener">github.com/codecentric…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
</ul>
<p>#Blog #OpenTelemetry</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358450927110357026" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>监控,开源</tag>
      </tags>
  </entry>
  <entry>
    <title>Redission排行榜、计数器实战-java示例排行榜的</title>
    <url>/7358464072545501199.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redission 是一个在 Redis 的基础上提供了许多分布式数据结构和服务的 Java 库。在实现排行榜或计数器等功能时，Redission 可以利用 Redis 的数据结构，如有序集合（sorted set）和哈希（hash），来高效地完成这些任务。</p>
<h1 id="排行榜的实现"><a href="#排行榜的实现" class="headerlink" title="排行榜的实现"></a>排行榜的实现</h1><p>在 Redis 中，有序集合（sorted set）是实现排行榜的理想数据结构，因为它能够保存唯一元素的集合，并且每个元素都关联着一个分数（score），集合中的元素会根据分数自动排序。</p>
<p>使用 Redission 实现排行榜的基本步骤如下：</p>
<ol>
<li>创建有序集合：使用 Redission 的 <code>RScoredSortedSet</code> 接口创建一个有序集合。</li>
<li>添加元素：向有序集合中添加元素（成员）及其对应的分数（score）。</li>
<li>获取排行：使用有序集合的方法获取元素的排名，以及根据排名或分数范围检索元素。</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h2><p>例如，以下是一段使用 Redission 实现排行榜的简单代码示例：</p>
<h3 id="poxm配置"><a href="#poxm配置" class="headerlink" title="poxm配置:"></a>poxm配置:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.16.4&lt;/version&gt; </span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="java-代码："><a href="#java-代码：" class="headerlink" title="java 代码："></a>java 代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.Redisson;</span><br><span class="line">import org.redisson.api.RScoredSortedSet;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">public class LeaderboardRedissonExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 配置 Redisson 客户端</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;); // 替换为你的 Redis 服务器地址和端口</span><br><span class="line"></span><br><span class="line">        // 创建 Redisson 客户端实例</span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        // 获取有序集合实例</span><br><span class="line">        RScoredSortedSet&lt;String&gt; leaderboard = redisson.getScoredSortedSet(&quot;userLeaderboard&quot;);</span><br><span class="line"></span><br><span class="line">        // 添加用户及其分数到排行榜</span><br><span class="line">        leaderboard.addScore(&quot;user1&quot;, 100);</span><br><span class="line">		  leaderboard.addScore(&quot;user2&quot;, 150);</span><br><span class="line">        leaderboard.addScore(&quot;user3&quot;, 120);</span><br><span class="line"></span><br><span class="line">        // 获取排行榜中的所有用户及其分数</span><br><span class="line">        Collection&lt;String&gt; topUsers = leaderboard.readAll();</span><br><span class="line">        for (String user : topUsers) &#123;</span><br><span class="line">            Double score = leaderboard.getScore(user);</span><br><span class="line">            System.out.println(&quot;User: &quot; + user + &quot;, Score: &quot; + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取特定用户的排名（排名从0开始，所以显示时需要加1）</span><br><span class="line">        int rank = leaderboard.rank(&quot;user2&quot;) + 1;</span><br><span class="line">        System.out.println(&quot;User2&apos;s rank: &quot; + rank);</span><br><span class="line"></span><br><span class="line">        // 获取排行榜前3名用户及其分数</span><br><span class="line">        Collection&lt;String&gt; topThreeUsers = leaderboard.entryRange(0, 2);</span><br><span class="line">        for (String user : topThreeUsers) &#123;</span><br><span class="line">            Double score = leaderboard.getScore(user);</span><br><span class="line">            System.out.println(&quot;Top User: &quot; + user + &quot;, Score: &quot; + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭 Redisson 客户端</span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了 Redisson 的 <code>RScoredSortedSet</code> 接口来实现一个排行榜。有序集合在 Redis 中以分数作为排序的依据，这使得它非常适合用来实现排行榜。</p>
<h1 id="计数器的实现"><a href="#计数器的实现" class="headerlink" title="计数器的实现"></a>计数器的实现</h1><p>Redis 的字符串（string）数据类型可以用作计数器，通过原子操作 <code>INCR</code> 和 <code>DECR</code> 来增加或减少计数器的值。</p>
<p>使用 Redission 实现计数器的基本步骤如下：</p>
<ol>
<li>创建计数器：使用 Redission 的 <code>RAtomicLong</code> 接口创建一个原子长整型计数器。</li>
<li>增加/减少值：使用计数器的 <code>incrementAndGet()</code> 或 <code>decrementAndGet()</code> 方法来原子地增加或减少计数器的值。</li>
</ol>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h2><p>例如，以下是一段使用 Redission 实现计数器的简单代码示例：</p>
<p>在Spring框架中使用Redisson实现计数器，首先需要将Redisson的依赖添加到你的Spring Boot项目中。如果你使用Maven，可以在<code>pom.xml</code>文件中添加以下依赖：</p>
<h3 id="pom-配置："><a href="#pom-配置：" class="headerlink" title="pom 配置："></a>pom 配置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.16.4&lt;/version&gt; </span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置Redisson客户端"><a href="#配置Redisson客户端" class="headerlink" title="配置Redisson客户端"></a>配置Redisson客户端</h3><p>在Spring Boot应用中，你可以创建一个配置类来设置Redisson：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.Redisson;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.redisson.config.Config;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">          // 替换为你的Redis服务器地址和端口</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring组件中注入RedissonClient"><a href="#Spring组件中注入RedissonClient" class="headerlink" title="Spring组件中注入RedissonClient"></a>Spring组件中注入<code>RedissonClient</code></h3><p>使用它来创建和操作计数器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.api.RAtomicLong;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CounterService &#123;</span><br><span class="line"></span><br><span class="line">    private final RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public CounterService(RedissonClient redissonClient) &#123;</span><br><span class="line">        this.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long incrementCounter(String counterName) &#123;</span><br><span class="line">        RAtomicLong atomicLong = redissonClient.getAtomicLong(counterName);</span><br><span class="line">        return atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getCounterValue(String counterName) &#123;</span><br><span class="line">        RAtomicLong atomicLong = redissonClient.getAtomicLong(counterName);</span><br><span class="line">        return atomicLong.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务类中，我们定义了两个方法：<code>incrementCounter</code>用于递增计数器的值，<code>getCounterValue</code>用于获取计数器的当前值。</p>
<h3 id="控制器中使用这个服务："><a href="#控制器中使用这个服务：" class="headerlink" title="控制器中使用这个服务："></a>控制器中使用这个服务：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/counter&quot;)</span><br><span class="line">public class CounterController &#123;</span><br><span class="line"></span><br><span class="line">    private final CounterService counterService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public CounterController(CounterService counterService) &#123;</span><br><span class="line">        this.counterService = counterService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/increment&quot;)</span><br><span class="line">    public long increment(@RequestParam(&quot;name&quot;) String counterName) &#123;</span><br><span class="line">        return counterService.incrementCounter(counterName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/get&quot;)</span><br><span class="line">    public long get(@RequestParam(&quot;name&quot;) String counterName) &#123;</span><br><span class="line">        return counterService.getCounterValue(counterName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个控制器中，我们创建了两个端点：一个用于递增计数器的值，另一个用于获取计数器的当前值。</p>
<p>在这个示例中，我们使用了 Redisson 的 <code>RAtomicLong</code> 接口来实现一个原子计数器。这个计数器可以安全地在多个线程或进程中增加或减少其值，因为 Redis 提供了原子操作保证。</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>Redission 的原理主要是对 Redis 的各种操作提供了方便的 Java API。它封装了 Redis 的命令，使得开发者可以像操作本地 Java 对象一样使用 Redis 的数据结构和服务。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>性能：Redis 是一个内存中的数据结构存储，提供极高的性能。</li>
<li>简单：Redission 提供了简单直观的 API，易于使用。</li>
<li>分布式：Redission 利用 Redis 的特性，可以很容易地实现分布式数据结构和服务。</li>
<li>丰富的功能：Redission 提供了丰富的分布式对象和服务，如分布式锁、队列、映射等。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>内存限制：由于 Redis 是基于内存的，数据量的大小受限于服务器内存。</li>
<li>持久性：虽然 Redis 提供了持久化机制，但在极端情况下可能会丢失数据。</li>
<li>复杂性：在大型系统中，管理 Redis 实例和确保其高可用性可能会增加系统的复杂性。</li>
</ol>
<p>总体来说，Redission 是一个功能强大的库，可以帮助 Java 开发者轻松地使用 Redis 实现排行榜、计数器和其他分布式数据结构和服务。然而，它也继承了 Redis 的限制，需要根据具体应用场景权衡其优缺点。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358464072545501199" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Redis,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊JIT是如何影响JVM性能的！方法内联分层编译逃逸</title>
    <url>/7358628571232190505.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>文章内容收录到个人网站，方便阅读</strong>：<a href="http://hardyfish.top/" target="_blank" rel="noopener">hardyfish.top/</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/328c647652bd5fae03b418d33dddf6e44b914720e1af269c2fe5a141a600132a" alt="image.png"></p>
<p>我们知道Java虚拟机栈是线程私有的，每个线程对应一个栈，每个线程在执行一个方法时会创建一个对应的栈帧，栈帧负责存储局部变量变量表、操作数栈、动态链接和方法返回地址等信息，每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈过程</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c0a39f412d57aa3967df02152fa0c344a84c76574d61a3922a8d53a17ac96167" alt="图片"></p>
<p>但是栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了。</p>
<p>另外，Java 虚拟机栈对代码的执行，采用的是字节码解释执行的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码public class A&#123;</span><br><span class="line">    int attr = 0;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        int a = attr;</span><br><span class="line">        System.out.println(&quot;月伴飞鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码javap -v A</span><br></pre></td></tr></table></figure>

<p>可以看到这段代码的字节码指令</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/00d16db6e85aee80b99ca93d0d8d6fd3d8d78e9e47f02f784c39c8d420460a9e" alt="图片"></p>
<p>我们能够看到 <code>aload_0，getfield ，istore_1</code> 这三个无用的字节码指令操作。</p>
<blockquote>
<p>❝</p>
<p>aload_0 从局部变量0中装载引用类型值，getfield 从对象中获取字段，istore_1 将int类型值存入局部变量1</p>
<p>❞</p>
</blockquote>
<p>另外，我们知道垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些。</p>
<p>其实，我们说的这几个优化的可能性，JVM 已经通过JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行。</p>
<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3750eff2246c55203ce4a60f4085fc5af08385b4223792da228d3f9878c9c163" alt="图片"></p>
<p>如上图，JVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存起来，下次调用相同方法的时候，就可以直接使用。</p>
<p>那 JIT 编译都有哪些手段呢？接下来我们详细介绍。</p>
<h1 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h1><p>方法内联它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念。</p>
<p>可以使用 <code>-XX:-Inline</code> 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码-XX:CompileCommand=exclude,java/lang/String.indexOf</span><br></pre></td></tr></table></figure>

<p>在 JDK 的源码里，也有很多被 @ForceInline注解的方法，这些方法，会在执行的时候被强制进行内联；而被@DontInline注解的方法，则始终不会被内联。</p>
<p>JIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升。</p>
<p>通过参数 <code>-XX:ReservedCodeCacheSize</code> 可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小。</p>
<h1 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h1><p>HotSpot 虚拟机包含多个即时编译器，有 C1，C2 和 Graal，JDK8 以后采用的是分层编译的模式。</p>
<p>JMV使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。JIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码。</p>
<p><strong>「JIT 编译方式有两种：一种是编译方法，另一种是编译循环。」</strong></p>
<p>具体介绍下几个编译器</p>
<p><strong>「C1 编译器」</strong></p>
<p>C1 编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，也称为Client Compiler，例如，GUI 应用对界面启动速度就有一定要求。</p>
<p><strong>「C2 编译器」</strong></p>
<p>C2 编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，也称为Server Compiler，例如，服务器上长期运行的 Java 应用对稳定运行就有一定的要求。</p>
<p>在 Java7 之前，需要根据程序的特性来选择对应的 JIT，虚拟机默认采用解释器和其中一个编译器配合工作。</p>
<p><strong>「分层编译」</strong></p>
<p>Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，我们也可以通过参数 -client或者-server 强制指定虚拟机的即时编译模式。</p>
<p>通常情况下，C2 的执行效率比 C1 高出30%以上。</p>
<p>注意：在 Java8 中，默认开启分层编译，-client 和 -server 的设置已经是无效的了。</p>
<p>如果只想开启 C2，可以关闭分层编译<code>（-XX:-TieredCompilation）</code>，如果只想用 C1，可以在打开分层编译的同时，使用参数：<code>-XX:TieredStopAtLevel=1</code>。</p>
<p>我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</span><br></pre></td></tr></table></figure>

<p>mixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用-Xint参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数-Xcomp强制虚拟机运行于只有 JIT 的编译模式下</p>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>下面着重讲解一下逃逸分析，这个知识点在面试的时候经常会被问到。</p>
<p>有这样一个问题：我们常说的对象，除了基本数据类型，一定是在堆上分配的吗？</p>
<p>答案是否定的，通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数<code>-XX:-DoEscapeAnalysis</code> 关掉它。</p>
<p>那什么样的对象算是逃逸的呢？可以看一下下面的两种典型情况。</p>
<p>如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class EscapeAttr &#123;</span><br><span class="line">    Object attr;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        attr = new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class EscapeReturn &#123;</span><br><span class="line">    Object attr;</span><br><span class="line">    public Object test() &#123;</span><br><span class="line">        Object obj = new Object();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那逃逸分析有什么好处呢？</p>
<p><strong>「1. 栈上分配」</strong></p>
<p>如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力。</p>
<p><strong>「2. 分离对象或标量替换」</strong></p>
<p>但对象结构通常都比较复杂，如何将对象保存在栈上呢？</p>
<p>JIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码。</p>
<p>从上面的描述我们可以看到，并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配。</p>
<p><strong>「3.同步消除」</strong></p>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除。</p>
<p>要开启同步消除，需要加上 <code>-XX:+EliminateLocks</code> 参数。由于这个参数依赖逃逸分析，所以同时要打开 <code>-XX:+DoEscapeAnalysis</code> 选项。</p>
<p>比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SyncEliminate &#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (new Object()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>文章内容收录到个人网站，方便阅读</strong>：<a href="http://hardyfish.top/" target="_blank" rel="noopener">hardyfish.top/</a></p>
<p>JIT 是现代 JVM 主要的优化点，能够显著地提升程序的执行效率。从解释执行到最高层次的 C2，一个数量级的性能提升也是有可能的。</p>
<p>注意：JIT 优化并不见得每次都有用，比如代码中如果发生死循环。但如果你在启动的时候，加上<code>-Djava.compiler=NONE</code> 参数，禁用 JIT，它就能够执行下去。</p>
<p>这篇文章中我们主要看了方法内联、逃逸分析等概念，了解到一些方法在被优化后，对象并不一定是在堆上分配的，它可能在被标量替换后，直接在栈上分配。这几个知识点也是在面试中经常被问到的。</p>
<p>JIT 的这些优化一般都是在后台进程默默地去做了，我们不需要关注太多。同时Code Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358628571232190505" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一款国产的开发辅助AI插件！一Comate介绍二价</title>
    <url>/7358628571231305769.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[toc]<br>昨天百度举行了 Create 2024 百度 AI 开发者大会，松哥得以近距离了解了百度的 AI 产品，以前就了解文心一言，其他的都用的少。昨天在会场上李彦宏介绍了百度的一个 AI 辅助工具 Comate，晚上回来赶紧体验了一把。</p>
<h1 id="一-Comate-介绍"><a href="#一-Comate-介绍" class="headerlink" title="一 Comate 介绍"></a>一 Comate 介绍</h1><p>百度的 Comate 插件是一款基于文心大模型的智能代码助手，它结合了百度多年积累的编程现场大数据和外部优秀开源数据，为开发者提供了全方位的编码辅助工具。这款插件的主要优势在于其智能性、丰富的应用场景、创造价值以及广泛的应用范围，能够实现“帮你想、帮你写、帮你改”的场景应用形态，从而显著提升编码效率，释放“十倍”软件生产力。</p>
<p>具体来说，“帮你想”体现在 Comate 插件的代码解释和代码知识问答功能上。它能够对整个函数代码或部分选中代码进行解释，让开发者快速理解新代码的含义。同时，开发者只需在对话框中用自然语言提问，就能立刻得到答案，极大地提高了学习和工作的效率。</p>
<p>“帮你写”的功能则包括实时续写、注释生成代码、生成函数注释、生成单元测试等。Comate 还支持单行推荐、多行推荐、多条推荐、代码生成、注释生成、注释文档生成等一系列编码相关能力。此外，它还能全面分析代码上下文、依赖文件、相邻文件的逻辑关系，使代码语法更规范、逻辑更严谨。</p>
<p>在“帮你改”方面，Comate 能够对长函数等可能存在问题的代码进行优化，发现并自动修复代码中的潜在错误，从而提高企业研发工作的脚本效率。</p>
<p>此外，Comate 插件还可以轻松集成到开发者最常用的主流集成开发环境中，如 VSCode、IntelliJ IDEA、XCode 等，开发者可以通过插件的方式在不同的软件中使用 Comate，极大地提高了开发工作的便利性和效率。</p>
<p>此外，Comate 还提供数据可视化功能，包括采纳率、采纳量趋势、采纳量按功能或语言分布等，帮助个人和企业全方位可视化提效成果，助力提效与复盘。同时，它还提供私有化部署服务以及详尽的技术支持，确保公司信息安全，让开发者在享受高效编码的同时无后顾之忧。</p>
<h1 id="二-价格"><a href="#二-价格" class="headerlink" title="二 价格"></a>二 价格</h1><p>很多小伙伴可能比较关心这个问题。</p>
<p>这是官方的三个不同的价格版本：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4bf25fa73a64a2ca560d6c6e98aa2c51877637c2281b8b68fd4c895b719e117a" alt></p>
<p>个人使用是免费的，另外，<strong>个人每周可免费使用 300 次高级功能</strong>，我觉得这个也够用了。</p>
<h1 id="三-安装"><a href="#三-安装" class="headerlink" title="三 安装"></a>三 安装</h1><p>安装比较容易，我们直接在 IDEA 的插件市场搜索 comate 安装即可：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/55f1d1276ec7c59bd23649885a55f3e223e521569f2e00eb1954057464279d49" alt></p>
<p>安装完成后，重启 IDEA。</p>
<p>重启之后我们在 IDEA 的右边栏可以看到 Baidu Comate 以及登录提示，这个插件要登录自己的百度账号后才可以使用。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/56d979657e691822e076f6a7dd2e399fa27ea915a54e24da1ef2e97da0ec90f3" alt></p>
<p>登录百度账号之后，会在 <a href="https://comate.baidu.com/zh/user" target="_blank" rel="noopener">comate.baidu.com/zh/user</a> 页面拿到自己的一个 License，然后在 IDEA 中配置一下用户名和 License，就可以使用了 Comate 了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/054d712b3cb79b5deec3f81b9bce816085033aa021e894f8477aefd3bf1c6765" alt></p>
<h1 id="四-体验"><a href="#四-体验" class="headerlink" title="四 体验"></a>四 体验</h1><p>装好之后来体验一把吧！</p>
<h2 id="4-1-智能推荐"><a href="#4-1-智能推荐" class="headerlink" title="4.1 智能推荐"></a>4.1 智能推荐</h2><h3 id="4-1-1-单行推荐"><a href="#4-1-1-单行推荐" class="headerlink" title="4.1.1 单行推荐"></a>4.1.1 单行推荐</h3><p>单行推荐是在续写代码场景中最直接、最高效的体现方式。在打开一个代码文件后，开始编码。在编码过程中稍微等待一下，即可看到 Baidu Comate 的推荐内容。</p>
<p>如下图，灰色代码就是 Comate 自动提示的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/23acb551b243ec297e61ac6fb468cef28ba2b5ba6ce7fc9ea5f2f917fd0781cf" alt></p>
<p>按 Tab 键可以选中自动提示的代码。</p>
<p>Comate 相关的操作可以参考下面这个表格：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/929ea6dffee5b4ed92ab99998c0848d7616c32413f8f7c0a71dc9860f5e6109e" alt></p>
<h3 id="4-1-2-多行推荐"><a href="#4-1-2-多行推荐" class="headerlink" title="4.1.2 多行推荐"></a>4.1.2 多行推荐</h3><p>多行推荐就是直接给一个完整的方法逻辑，类似下面这样：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/aefe051dcd99ba6c4d3ff12520be7b8f39dc39a1f5dd20a1a2662ffd9a539511" alt></p>
<p>可以按照提示给出来的快捷键，逐行采纳推荐的代码，也可以直接 Tab 键采纳所有。</p>
<p>不过对于一些涉及到最新 API 的，似乎还不能准确提示，例如下面这段提示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f6c3dec4b1e1cefac871a2bf78f8d0131bbc39beebbbf0611516a5189c613706" alt></p>
<p>实际上我现在使用的是最新版的 Spring Security，但是这里的提示不对。</p>
<h2 id="4-2-智能生成"><a href="#4-2-智能生成" class="headerlink" title="4.2 智能生成"></a>4.2 智能生成</h2><h3 id="4-2-1-注释生成代码"><a href="#4-2-1-注释生成代码" class="headerlink" title="4.2.1 注释生成代码"></a>4.2.1 注释生成代码</h3><p>写好注释之后，按回车，就会有提示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ab3c428e0dc7b0ced6db65a682bd0b927dde5b9f33bf260bc60a332f0352b70d" alt></p>
<h3 id="4-2-2-增强生成代码"><a href="#4-2-2-增强生成代码" class="headerlink" title="4.2.2 增强生成代码"></a>4.2.2 增强生成代码</h3><p>如果觉得注释生成代码中的结果不够准确，那么还可以使用增强生成代码功能调起更加精准的模型来理解和生成代码。</p>
<p>在通过注释生成代码之后，会出现<strong>增强生成</strong>按钮，如下图，点击<strong>增强生成</strong>，调出 Baidu Comate 对话框；然后等待结果返回即可。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e41ab68fc7a2bd60a6763ff29f24cc8cbf1dcc3dc12052c2a88b9e35a7ee8cf2" alt></p>
<h3 id="4-2-3-生成单元测试"><a href="#4-2-3-生成单元测试" class="headerlink" title="4.2.3 生成单元测试"></a>4.2.3 生成单元测试</h3><p>鼠标右键点击函数名前方的 Baidu Comate 图标，选择<strong>生成单测</strong>或者或右键点击函数名，选择<strong>Comate代码工具</strong> → <strong>生成单测</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5feb57a77614a4073a4ab5d080b40d983a267d8723bf0ff0bc10d995467d89fa" alt></p>
<p>单元测试生成之后，点击采纳，就可以自动在单元测试包下面生成对应的测试类：</p>
<p><img src alt="转存失败，建议直接上传图片文件"></p>
<h3 id="4-2-4-生成代码注释"><a href="#4-2-4-生成代码注释" class="headerlink" title="4.2.4 生成代码注释"></a>4.2.4 生成代码注释</h3><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><p>生成的代码注释有两种，一种是文档注释，另外一种是行间注释。</p>
<p>我们可以点击函数名上方的<strong>函数注释</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cf75dc40649b16f836ffdd8582205215d422a309c6fe747a08ab94fe722f6504" alt></p>
<p>右边会唤起 Comate，代码注释生成之后，点击采纳，就会自动添加到方法头部。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/592ebc7b1a44f721b8b7b65b75627096a3cf8b9a3a37d13412c56e8d6d7a3bdf" alt></p>
<h4 id="行间注释"><a href="#行间注释" class="headerlink" title="行间注释"></a>行间注释</h4><p>行间注释是针对一段已有的代码，按段落生成行间注释。不过这个功能有一个限制条件，就是函数少于4500个字符时才有这个功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c91794fca907436d6fb7dd1d7524db4d9e6b0f75e51bab44b94703f1108d7dbe" alt></p>
<p>右边会唤起 Comate，代码注释生成之后，点击采纳，注释就会自动添加到方法里边。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/58bf11d3e4d16f574455d8d617e983181114a3d311d5488ab185a5cb7c85b289" alt></p>
<h2 id="4-3-代码解释"><a href="#4-3-代码解释" class="headerlink" title="4.3 代码解释"></a>4.3 代码解释</h2><p>代码解释就是使用大语言模型对给定的代码进行深入理解，然后生成易于人类理解的自然语言解释。这个功能可以协助开发人员迅速理解现有的代码，从而提高研发效率。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/20ca27e875e06c9f430cd97a23bbb5519e7ae27f4362a39e87e84096f6089b9d" alt></p>
<p>大家来看下，我感觉这个生成的解释还可以：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8b77622bb322d4859608056357657673953d8c9d57c04aac6fc2585deb15d80c" alt></p>
<h2 id="4-4-调优建议"><a href="#4-4-调优建议" class="headerlink" title="4.4 调优建议"></a>4.4 调优建议</h2><p>调优建议是一个旨在帮助开发者便捷优化代码质量的功能，通过大语言模型分析所选函数，提供有针对性的建议，如使代码更加规范易读，或提高执行效率、减少资源消耗。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/924ea139cdf23ce9ed3a99b19543f23fe72e137017e04bfbbc95cc6aff66e703" alt></p>
<p>似乎也还不错：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3263ea3b3733ddac37c1faaa7e4a8df5b0a23c8f60916dcd427ac6cfa1c48077" alt></p>
<h2 id="4-5-长函数拆分"><a href="#4-5-长函数拆分" class="headerlink" title="4.5 长函数拆分"></a>4.5 长函数拆分</h2><p>长函数拆分主要用于将一个冗长的函数，拆分成多个短函数，使得代码更加简洁易读，易于复用和维护。当函数大于等于20行，且少于4500个字符时将提供该功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d355c6bc548f4cadeeb325cd8b4cef4302d55373117c6745ab4ae995779334bb" alt></p>
<p>如果你的函数长度小于 20 行，那么就没有函数拆分这个选项。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d76017e5877bdced81460fca74f6791b638a69fb7d7a37dcd539c91e6288839d" alt></p>
<p>这个生成的还不错，点击采纳可以直接使用。</p>
<h1 id="五-智能问答"><a href="#五-智能问答" class="headerlink" title="五 智能问答"></a>五 智能问答</h1><p>点击 IDEA 右边栏可以唤起 Comate。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1d2b55520660e07beef8b689e95b317f0d9f8e419f6cfb9fe1fe3719539f8801" alt></p>
<p>唤起之后就可以直接提问了，支持多轮对话。</p>
<p>另外也可以选中代码输入问题。先选中代码，然后输入问题，这样 Comate 就会围绕生成的代码来展开对话。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ec95cefea8b39e36eb938b13995d6fc2b2a6c6fbdded27d76340aa0f6b4d4bd0" alt></p>
<h1 id="六-其他能力"><a href="#六-其他能力" class="headerlink" title="六 其他能力"></a>六 其他能力</h1><h2 id="6-1-插件配置"><a href="#6-1-插件配置" class="headerlink" title="6.1 插件配置"></a>6.1 插件配置</h2><p>Comate 提供了一些插件的能力，不过目前支持的插件不多。在和 Comate 交互的时候，通过 <code>@</code> 可以唤起插件。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/79e874d41f8b7af6fde5ffd73779bed0a1d2867a35f9c90b75a212ab63122e86" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/78404e499a7459dcf9f6ff687ed7016c7534859e4eecdb1bd2694edb9a243619" alt></p>
<p>如果需要对这些插件进行配置，可以在我网页上配置：</p>
<ul>
<li><a href="https://comate.baidu.com/cop/configSet/list" target="_blank" rel="noopener">comate.baidu.com/cop/configS…</a></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/11a455382d96a48093e75050d3c96a4706ce692640ca6f04079478845cd5719d" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee203e273f3783c254928c2f007ecf4b47419c2873370a132114df246056b16c" alt></p>
<h2 id="6-2-知识中心"><a href="#6-2-知识中心" class="headerlink" title="6.2 知识中心"></a>6.2 知识中心</h2><p>利用 Comate 这个能力，我们可以非常方便的引入自己的知识集，比如松哥写了很多文档，我可以把这些文章内容构建成一个知识集，那么在发起自然语言对话的时候，就会自动使用到我的这些知识集。</p>
<p>这个我们可以在网页端进行配置。</p>
<ul>
<li><a href="https://comate.baidu.com/cop/knowledge/list" target="_blank" rel="noopener">comate.baidu.com/cop/knowled…</a></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0606ab40d59b62e2805ab97844b2b62ae0322d8497cef0994be90b4cc285a55e" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2b22ae603257494e787b6751a01eb2fcf6a8b0e4adecda096086f9d81e15d92f" alt></p>
<p>新建知识集，然后上传即可。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f08cff4b74b2aeca2bd10d5794b1237fa7da2ad208da819d62b5f000cabd618a" alt></p>
<p>当我们和 Comate 对话的时候，可以通过 <code>#</code> 唤起，然后选择自己的知识库。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/183ee85d9dfd7df66647c38511e76ad8585bcb26c063e8d64af7111f4ed0ac2f" alt></p>
<p>好啦，小伙伴们感兴趣的话不妨去体验一下哦～</p>
<p>再来一个小视频，松哥带你体验 Baidu AI 开发者大会！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358628571231305769" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>实现视频的喜欢和不喜欢功能：Node.js与Mongoose</title>
    <url>/7358664464998842406.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="实现视频的喜欢和不喜欢功能：Node-js与Mongoose的实践指南"><a href="#实现视频的喜欢和不喜欢功能：Node-js与Mongoose的实践指南" class="headerlink" title="实现视频的喜欢和不喜欢功能：Node.js与Mongoose的实践指南"></a>实现视频的喜欢和不喜欢功能：Node.js与Mongoose的实践指南</h3><p>在视频分享或社交媒体平台中，”喜欢”和”不喜欢”的功能是用户互动的重要组成部分。本篇博客将详细介绍如何在使用Node.js和Mongoose的环境中实现这一功能。我们将通过创建模型、路由和控制器来逐步搭建这一功能。</p>
<h4 id="1-路由的设置"><a href="#1-路由的设置" class="headerlink" title="1. 路由的设置"></a>1. 路由的设置</h4><p>首先，我们需要为”喜欢”和”不喜欢”功能设置路由。这些路由将处理对特定视频的喜欢或不喜欢的请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// router/video.js</span><br><span class="line">router</span><br><span class="line">  .get(&apos;/like/:videoId&apos;, verifyToken(), videoController.likeVideo)</span><br><span class="line">  .get(&apos;/dislike/:videoId&apos;, verifyToken(), videoController.disLikeVideo);</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>verifyToken()</code>中间件来确保只有认证过的用户可以进行操作。</p>
<h4 id="2-数据模型的创建"><a href="#2-数据模型的创建" class="headerlink" title="2. 数据模型的创建"></a>2. 数据模型的创建</h4><p>我们需要一个模型来存储用户对视频的喜欢或不喜欢的状态。我们创建了<code>videoLikeModel</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// model/videoLikeModel.js</span><br><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">const baseModel = require(&apos;./baseModel&apos;);</span><br><span class="line"></span><br><span class="line">const videoLikeSchema = new mongoose.Schema(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    type: mongoose.ObjectId,</span><br><span class="line">    required: true,</span><br><span class="line">    ref: &quot;User&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  video: &#123;</span><br><span class="line">    type: mongoose.ObjectId,</span><br><span class="line">    required: true,</span><br><span class="line">    ref: &quot;Video&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  like: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    enum: [1, -1], // 1 表示喜欢, -1 表示不喜欢</span><br><span class="line">    required: true</span><br><span class="line">  &#125;,</span><br><span class="line">  ...baseModel</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = videoLikeSchema;</span><br></pre></td></tr></table></figure>

<p>此模型关联了用户和视频，并记录了用户是喜欢还是不喜欢该视频。</p>
<h4 id="3-更新视频模型"><a href="#3-更新视频模型" class="headerlink" title="3. 更新视频模型"></a>3. 更新视频模型</h4><p>为了跟踪每个视频的喜欢和不喜欢的总数，我们需要在视频模型中添加这些属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// model/videoModel.js</span><br><span class="line">const videoSchema = new mongoose.Schema(&#123;</span><br><span class="line">  likeCount: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  dislikeCount: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4-控制器逻辑"><a href="#4-控制器逻辑" class="headerlink" title="4. 控制器逻辑"></a>4. 控制器逻辑</h4><p>在控制器中，我们将处理喜欢和不喜欢的逻辑。这包括检查用户当前的喜欢状态，并据此更新状态和计数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码jsCopy code</span><br><span class="line">// videoController.js</span><br><span class="line">exports.likeVideo = async (req, res) =&gt; &#123;</span><br><span class="line">  const videoId = req.params.videoId;</span><br><span class="line">  const userId = req.user.userinfo._id;</span><br><span class="line">  const video = await Video.findById(videoId);</span><br><span class="line">  if (!video) &#123;</span><br><span class="line">    return res.status(404).json(&#123; err: &quot;视频不存在&quot; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  let doc = await VideoLike.findOne(&#123; user: userId, video: videoId &#125;);</span><br><span class="line"></span><br><span class="line">  if (doc &amp;&amp; doc.like === 1) &#123;</span><br><span class="line">    await doc.deleteOne();</span><br><span class="line">    video.likeCount--;</span><br><span class="line">  &#125; else if (doc &amp;&amp; doc.like === -1) &#123;</span><br><span class="line">    doc.like = 1;</span><br><span class="line">    await doc.save();</span><br><span class="line">    video.likeCount++;</span><br><span class="line">    video.dislikeCount--;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await new VideoLike(&#123; user: userId, video: videoId, like: 1 &#125;).save();</span><br><span class="line">    video.likeCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  await video.save();</span><br><span class="line">  res.status(200).json(&#123;</span><br><span class="line">    ...video.toJSON(),</span><br><span class="line">    isLike: doc ? doc.like === 1 : true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相似的逻辑适用于<code>disLikeVideo</code>函数。</p>
<h4 id="5-测试和验证"><a href="#5-测试和验证" class="headerlink" title="5. 测试和验证"></a>5. 测试和验证</h4><p>最后，我们需要确保这些API在实际应用中表现正常。这涉及到API的测试和直接数据库验证，以确保数据的正确性。</p>
<ul>
<li>postman接口测试</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5c6893a465fd85e2ff7f46595d51f8cdd681cc076ac08b3e4b4d39bc55e7476a" alt></p>
<ul>
<li>查看数据库中数据变化</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d9013f9c07a4666455b5a88f61f33198ff602dbae5537d17ea5ca0654b1dbf16" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/55ba6a9eddd58c605a2a91e01194baf3ffd8028857d59c7f6672ff93783f8776" alt></p>
<p>通过实现这些功能，我们不仅增强了用户的互动体验，也为平台带来了更多关于用户偏好的数据，这有助于推荐系统等更高级的功能。这种实现方式展示了Node.js和Mongoose在构建现代Web应用中的灵活性和强大功能。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358664464998842406" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS解析过程</title>
    <url>/7358664464999039014.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46e52f167b865b6e955522eb397787b3a9fd267d24cd9515c49f1c1d59ed812a" alt="image.png"></p>
<p>一张图即可说明，如果能看到上图就不用往下看了。下面是上图的文字版解析</p>
<h4 id="a-用户输入-URL"><a href="#a-用户输入-URL" class="headerlink" title="a. 用户输入 URL:"></a>a. <strong>用户输入 URL</strong>:</h4><p>当你在浏览器中点击一个链接或输入一个网址时，比如点击一个图片链接 <code>http://www.example.com/image.jpg</code>，这个过程开始于你的设备尝试理解这个地址所指向的服务器位置。</p>
<h4 id="b-浏览器检查缓存"><a href="#b-浏览器检查缓存" class="headerlink" title="b. 浏览器检查缓存:"></a>b. <strong>浏览器检查缓存</strong>:</h4><p>浏览器首先检查自身缓存中是否有这个网址的 DNS 记录存在（即该网址对应的 IP 地址）。如果缓存中有记录，它会直接使用这个 IP 地址。缓存不仅包括浏览器缓存，还可能查看操作系统缓存。</p>
<h4 id="c-请求本地-DNS-服务器"><a href="#c-请求本地-DNS-服务器" class="headerlink" title="c. 请求本地 DNS 服务器:"></a>c. <strong>请求本地 DNS 服务器</strong>:</h4><p>如果缓存中没有找到记录，浏览器会向配置的本地 DNS 服务器发起一个 DNS 查询请求。本地 DNS 服务器通常由你的互联网服务提供商(ISP)提供，也可能是你在网络设置中手动指定的，如 Google 的公共 DNS 服务器（8.8.8.8 或 8.8.4.4）。</p>
<ul>
<li><strong>本地 DNS 服务器</strong>: 这是一个响应你 DNS 查询请求的服务器，通常由 ISP 提供。它有助于将域名（如 <code>www.example.com</code>）解析为 IP 地址。</li>
<li><strong>设备如何知道本地 DNS 地址</strong>: 设备通过 DHCP (Dynamic Host Configuration Protocol) 从网络路由器或 ISP 获得本地 DNS 服务器的地址。当你的设备连接到网络时，DHCP 负责分配 IP 地址及 DNS 服务器地址等网络配置信息。</li>
</ul>
<h4 id="d-递归查询"><a href="#d-递归查询" class="headerlink" title="d. 递归查询:"></a>d. <strong>递归查询</strong>:</h4><p>如果本地 DNS 服务器没有缓存该域名的记录，它会进行递归查询，向更高级的 DNS 服务器（根、顶级域和权威 DNS 服务器）查询直到获取到 IP 地址。</p>
<h4 id="e-IP-地址响应"><a href="#e-IP-地址响应" class="headerlink" title="e. IP 地址响应:"></a>e. <strong>IP 地址响应</strong>:</h4><p>一旦 IP 地址被找到，本地 DNS 服务器将其返回给你的设备，并通常会缓存这个信息以加速未来的查询。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358664464999039014" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>部署服务时保存端口被占用如何解决？杀掉进程考虑使用不同的</title>
    <url>/7358664464999006246.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有两个方法可以解决这个问题</p>
<h1 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h1><p>因为这个端口被占用的话意味着有进程占用了，所以先进行检测占用这个端口的进程。</p>
<h4 id="对于-Windows"><a href="#对于-Windows" class="headerlink" title="对于 Windows:"></a>对于 Windows:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码netstat -ano | findstr :你的端口号</span><br></pre></td></tr></table></figure>

<p>这条命令会显示所有使用指定端口的进程的列表，其中 <code>-ano</code> 参数列出了进程ID（PID），你可以通过这个PID找到对应的进程。</p>
<h4 id="对于-Linux-或-macOS"><a href="#对于-Linux-或-macOS" class="headerlink" title="对于 Linux 或 macOS:"></a>对于 Linux 或 macOS:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码sudo lsof -i :你的端口号</span><br></pre></td></tr></table></figure>

<p>检测到进程ID后杀掉它，<strong>终止进程可能会影响到依赖这个进程的服务，所以确保你了解这么做的后果。</strong></p>
<h4 id="在-Windows-上"><a href="#在-Windows-上" class="headerlink" title="在 Windows 上:"></a>在 Windows 上:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码bashCopy code</span><br><span class="line">taskkill /PID 进程号 /F</span><br></pre></td></tr></table></figure>

<p>这条命令将强制关闭PID对应的进程。</p>
<h4 id="在-Linux-或-macOS-上"><a href="#在-Linux-或-macOS-上" class="headerlink" title="在 Linux 或 macOS 上:"></a>在 Linux 或 macOS 上:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码bashCopy code</span><br><span class="line">sudo kill -9 进程号</span><br></pre></td></tr></table></figure>

<h1 id="考虑使用不同的端口"><a href="#考虑使用不同的端口" class="headerlink" title="考虑使用不同的端口"></a>考虑使用不同的端口</h1><p>如题</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358664464999006246" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯音乐：说说Redis脑裂问题？</title>
    <url>/7358670107901886501.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis 脑裂问题是指，在 Redis 哨兵模式或集群模式中，由于网络原因，导致主节点（Master）与哨兵（Sentinel）和从节点（Slave）的通讯中断，此时哨兵就会误以为主节点已宕机，就会在从节点中选举出一个新的主节点，此时 Redis 的集群中就出现了两个主节点的问题，就是 Redis 脑裂问题。</p>
<h2 id="脑裂问题影响"><a href="#脑裂问题影响" class="headerlink" title="脑裂问题影响"></a>脑裂问题影响</h2><p>Redis 脑裂问题会导致数据丢失，为什么呢？来看脑裂问题产生的过程：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f02593b823e8137fbfa474aba732bd0df94ccc451c0452a5530bcae1f0b43ece" alt="Redis脑裂问题.drawio.png"><br>而最后一步，当旧的 Master 变为 Slave 之后，它的执行流程如下：</p>
<ol>
<li>Slave（旧 Master）会向 Master（新）申请全量数据。</li>
<li>Master 会通过 bgsave 的方式生成当前 RDB 快照，并将 RDB 发送给 Slave。</li>
<li>Slave 拿到 RDB 之后，先进行 flush 清空当前数据（<strong>此时第四步旧客户端给他的发送的数据就丢失了</strong>）。</li>
<li>之后再加载 RDB 数据，初始化自己当前的数据。</li>
</ol>
<p>从以上过程中可以看出，在执行到第三步的时候，原客户端在旧 Master 写入的数据就丢失了，这就是数据丢失的问题。</p>
<h2 id="如何解决脑裂问题？"><a href="#如何解决脑裂问题？" class="headerlink" title="如何解决脑裂问题？"></a>如何解决脑裂问题？</h2><p>脑裂问题只需要在旧 Master 恢复网络之后，切换身份为 Slave 期间，不接收客户端的数据写入即可，那怎么解决这个问题呢？</p>
<p>Redis 为我们提供了以下两个配置，通过以下两个配置可以尽可能的避免数据丢失的问题：</p>
<ul>
<li><strong>min-slaves-to-write</strong>：与主节点通信的从节点数量必须大于等于该值主节点，否则主节点拒绝写入。</li>
<li><strong>min-slaves-max-lag</strong>：主节点与从节点通信的 ACK 消息延迟必须小于该值，否则主节点拒绝写入。</li>
</ul>
<p>这两个配置项必须同时满足，不然主节点拒绝写入。</p>
<p>在假故障期间满足 min-slaves-to-write 和 min-slaves-max-lag 的要求，那么主节点就会被禁止写入，脑裂造成的数据丢失情况自然也就解决了。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>设置了参数之后，Redis 脑裂问题能完全被解决吗？为什么？Zookeeper 有脑裂问题吗？它是如何解决脑裂问题的？</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener">www.javacn.site</a>，其中包含的内容有：Redis、JVM、并发、并发、MySQL、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、设计模式、消息队列等模块。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358670107901886501" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>👀那些你不知道的数据库知识：行式存储和列式存储1.列式存</title>
    <url>/7358688805157388325.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几天听课，听到老师讲数据列式存储。</p>
<p><strong>我</strong>🙋🏻‍♀️：等等，what，什么列式存储，数据一行一行的展示，然后一行一行的存在数据库里面不就好了，什么叫做列式存储，难道将数据按每一列存在数据库里面，那取出数据该有多麻烦啊，这绝对是几十年前的糟粕方法，这个课听不得了，教的东西太老套了。</p>
<p><strong>老师</strong>🧑🏻‍🏫：别急别急啊，同学，年轻人不要这么心浮气躁嘛，列式存储的存储效率在现在流行的大数据存储中发挥着重要的作用，其存储效率可比行式存储高的多。我先给你举个例子吧。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2cd3093621a6c95ab28112a48a13a7f6414f6778c045d9a5d43090b4de3ee960" alt></p>
<p>以学生信息表<code>stu</code>演示。sid为主键，表中记录这五位学生的信息。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77cdbf4092b3c4dba2b68332660893ddcb802379aa53d5b5e3938e3b6b006517" alt></p>
<p>大家比较熟悉的是<strong>行式存储</strong>，如关系型数据库（MySQL、Oracle等）的存储均采用行式存储，行式存储一目了然，如下图所示，每一位学生的信息存储在存储在存储介质上，先存储<code>zhangsan</code>同学的所有信息，再存储<code>lisi</code>同学的信息，依次存储剩下同学的信息，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/19c0bf4e9611da58cf918aff7431dc969aa39907ba34c50d446603bac24e5b85" alt></p>
<p>而列式存储，学生的信息数据都是分开保存的，即每一列的数据单独存放，如下图所示，每一列的数据存储在存储介质上，先存储sid这一列，然后存储sname这一列，依次存储剩下的列，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9a6f895fee885b704b847891b974470a94f02a8b9159012dde8ae3e1244ba4df" alt></p>
<p><strong>我</strong>🙋🏻‍♀️：好的老师，我已经明白您的背景了，快跟我讲讲列式存储的优点吧。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3fc76534ad46cd44f2d9a88b68d1201ce9acb19dae7213b311822c9fe4e6a375" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：那就先来一起看看两种存储方式存储在存储介质上的情况吧。</p>
<p>行式存储，每一个学生的信息都存储在相邻的地方，存储完一个学生的信息，再存储下一个学生的信息，以此类推，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2cc43f2f457c96758408a705be0700be9a66d9bc1941a22cd3683a6b736b65c3" alt></p>
<p>列式存储，将每一列的数据存储在相邻的地方，然后再存储下一列数据，以此类推，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/82522864fb2f08e244face386108a064d0f864388588026cd89b82d420834812" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：现在假设一种场景，我要你帮我取出所有学生的姓名，也就是<code>sname</code>这一列，你会怎么做？</p>
<p>对于SQL语句<code>select name from stu;</code>简简单单，可是在存储介质上取出数据的时候，你知道如何取出吗？</p>
<p>对于行式存储，必须从头到尾遍历存储数据，依次取出<code>sname</code>姓名的数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7fa5b172608272cade046707d54cba12fb3cbbda6e0c356f5d8545433e82b35e" alt></p>
<p>缺点就比较明显了，当我只需要访问几个列时，其他无关列的数据也会被读取，导致IO开销较大；而且数据 <strong>压缩比</strong> 较低，因为每行数据都存储在一起。</p>
<p>对于列式存储，这就简单了，直接定位到<code>sname</code>姓名的位置，就可以直接取出需要的数据了。</p>
<p>在分析型查询（OLAP）中，列式存储通常提供更高的性能。这是因为它只读取查询所需的列，大大减少了IO成本，加快了查询速度。</p>
<p>而且对于同一列的数据类型相同，便于压缩，通常具有更高的压缩比。非常适合大数据存储，如数据仓库，因为它可以快速读取和分析大量数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3e1b264900dc540887a32a7a189b59e964802cd1b14f54f8abd6acf881a207b9" alt></p>
<p><strong>我</strong>🙋🏻‍♀️：等等，MySQL不是有索引吗？我给<code>sname</code>单独加一条索引不就行了，这样查询的时候就可以利用 <strong>索引覆盖</strong> 的特性，直接拿到这一列的数据了呀！</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3fb5579a94f6e301e0ed18ff6a96d1094aa2d9fd6dd04462c7a5e6c36d7b480d" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：这位同学，请注意我们现在讲的是列式存储和行式存储，不是在讲MySQL哈。而且像你这样单独给<code>sname</code>加一条索引的做法，其实就是把同一列的数据存储在了一起，也是列式存储的一种应用方式。</p>
<p><strong>我</strong>🙋🏻‍♀️：原来MySQL里也有列式存储啊……</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d73111e11ecff76f5b8ed564e36508e17df4144677e2c1eaf0778155a31e7c67" alt></p>
<p><strong>我</strong>🙋🏻‍♀️：再等等，如果我要一个场景，请取出名字为‘zhangsan’的同学的所有信息，阁下该如何应对？</p>
<p><strong>老师</strong>🧑🏻‍🏫：啊这，角色互换了，这样列式存储的效率确实比行式存储的效率低很多了。</p>
<p>对于行式存储，只需要定位到“zhangsan”的位置，就可以直接取出需要的信息；</p>
<p>那行式存储的优点显而易见，对单行数据的操作效率更高，比较适用于事务型查询（OLTP），像频繁的增删改查的操作；当需要访问整行数据时，性能比较高；写入也会比较快，因为一次性完成整行的数据；</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2d3b161d6e2eaa985cd1bd970465009c39f80eef33d58ddfa8d3149ac739fdad" alt></p>
<p>对于列式存储，需要从头到尾遍历数据，根据元数据信息，一次取出“zhangsan”的信息。</p>
<p>列式存储的致命缺点就是行事查询、更新和删除操作比较复杂，因为需要处理多个列。而且写入性能比较低，因为需要将一行数据拆分成多个列分别写入。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/34ddedddeab2dc827e516d5a2f9c3547be9a9879bafdc3e8587bd068349f278f" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：你这小子，倒也不傻，我看你骨骼清奇，若勤加修炼，日后必得高升，我这有一本<code>数据库修炼秘籍</code>，只要九十九，你看，带不带一本走？</p>
<p><strong>我</strong>🙋🏻‍♀️：6啊，现在的广告真隐蔽。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/78e6d6e6d14af07746c048b161dac3f65a213e23f555230ccf6bf67e4fa9f9f8" alt></p>
<hr>
<p>言归正传，再来正式的聊聊行式存储和列式存储吧。</p>
<ol>
<li><h1 id="列式存储比行式存储可以节省多少空间"><a href="#列式存储比行式存储可以节省多少空间" class="headerlink" title="列式存储比行式存储可以节省多少空间"></a>列式存储比行式存储可以节省多少空间</h1></li>
</ol>
<p>大家一定非常好奇，列式存储比行式存储到底可以节省多少空间，才让博主绕这么一大圈来讲列式存储。</p>
<p>毫无疑问，列式存储比行式存储具有更高的数据压缩率。根据数据的类型和压缩技术，列式存储可以实现高达<strong>十倍</strong>甚至更高的压缩比，这意味着，列式存储能够节省大量的存储空间，降低存储成本。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7a8d957bad97223af57dac84a0e838a34b282012e3b184a14bffbce72c280486" alt></p>
<p>当然，具体节省的空间取决于多种因素，包括数据的重复性，列中数据类型的一致性以及采用的压缩算法。在实际应用中，节省的空间可能会有很大的差异，例如，如果一个数据集中的某些列包含大量重复的值，那么列式存储在这些列上的压缩效果会非常显著。</p>
<p>而对于数据变化较大，不适合压缩的场景，节省的空间可能就不那么明显了。</p>
<ol start="2">
<li><h1 id="列式存储和行式存储的区别"><a href="#列式存储和行式存储的区别" class="headerlink" title="列式存储和行式存储的区别"></a>列式存储和行式存储的区别</h1></li>
</ol>
<p>说了这么多，那列式存储和行式存储之间还有其他区别吗？</p>
<p>当然有，这区别可是非常大的，你且慢慢看来：</p>
<ol>
<li><strong>结构灵活性</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储倾向于结构弱化，更适合于不定长的记录和稀疏数据集，因为它可以有效地处理不存在的列。<ul>
<li>行式存储则倾向于结构固定，每行数据都需要有相同的列结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>主键存储</strong>:</li>
</ol>
<ul>
<li><ul>
<li>行式存储中，一行数据仅需要一个主键。<ul>
<li>列式存储中，存储一行数据可能需要多份主键，因为每个列都是独立存储的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>压缩算法的选择</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储可以针对不同列类型，选择最合适的压缩算法，因为每列数据的类型是已知的。<ul>
<li>行式存储的压缩算法选择不如列式存储灵活，因为它需要处理多种数据类型的混合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>IO消耗</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储在查询时只需要读取参与计算的列，极大地减低了IO消耗。<ul>
<li>行式存储在读取少数几列时，需要遍历其他无关列，IO开销较大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>数据更新</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储不适用于数据需要频繁更新的交易场景，因为每次更新可能涉及多个列的变更。<ul>
<li>行式存储更适合频繁更新的场景，因为整行数据通常是连续存储的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><h1 id="拓展：ORC存储"><a href="#拓展：ORC存储" class="headerlink" title="拓展：ORC存储"></a>拓展：ORC存储</h1></li>
</ol>
<p>另外，向大家推荐一种存储方式，即ORC存储，也叫混合存储结构。</p>
<p>ORC（Optimized Row Columnar）是一种高效的列式存储格式，最初由Apache Hive项目开发，用于优化Hadoop数据存储和查询速度。它并不是纯粹的列式存储，而是采用了<strong>混合存储结构</strong>，先按行组分割表，然后在每个行组内部按列存储数据。ORC文件是自描述的，其元数据使用Protocol Buffers序列化，且数据尽可能压缩以减少存储空间消耗。</p>
<p>ORC文件的主要优势包括：</p>
<ul>
<li><strong>高压缩比</strong>：列式存储运行多种文件压缩方式，提供很高的压缩比；</li>
<li><strong>文件可切分</strong>：便于在Hive等系统中分布式处理。</li>
<li><strong>索引支持</strong>：提供多种索引，如row group index和bloom filter index，以优化查询。</li>
<li><strong>复杂数据结构支持</strong>：能够处理如Map等复杂数据类型。</li>
</ul>
<p>ORC文件结构包括多个层级，如文件级元数据、stripe（包含多条记录的行组）、stripe元数据和row group，这些结构支持有效的数据读取和查询优化。例如，ORC利用三个层级的统计信息来实现谓词下推，从而避免读取不必要的数据，提高查询性能。</p>
<ol start="4">
<li><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1></li>
</ol>
<p>这篇关于数据的行式存储和列式存储，其实是我女朋友在学习大数据知识的时候了解到的，我个人对这块也只是一知半解，如果文中有错误的地方，欢迎大家在评论区指出。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/415f322efdd7bfec073d8507a95fc097dec6497571b44a5bd51bd267d57f1bbc" alt></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358688805157388325" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>数据库,MySQL,大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>你的第一款开源视频分析框架</title>
    <url>/7358687549848289331.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2ac8dfc848ab1780c777c4fe989155748b128082bb7fdddc92e3eab1cc8aa92f" alt></p>
<p>现在，刷视频已经成为我们生活中的一部分，而且很容易一看就停不下来。你有没有好奇过，它是如何在海量的视频里，找到让你感兴趣的视频？又是如何让你可以通过关键字，搜索到与之相关的视频内容的呢？这一切都离不开计算机对视频内容的分析和理解。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dc58483d1895c70511dade99108c47e4810b920690ff4850bc6bf0733fdcef6b" alt></p>
<p>计算机是如何“看懂”海量视频的呢？<strong>视频本质上是一系列连续的图像帧，按照一定的帧率播放，从而形成连续的动态效果</strong>。因此，计算机分析视频的基本原理就是：解码（视频转图片）-&gt; 分析/推理（AI 算法）-&gt; 编码（结果呈现）</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7108ceb987c73d0fd9066f998390438d96f5d3b4b779da9dbf19594a2342bd1b" alt></p>
<p>尽管这看起来就寥寥几步，但其中涉及许多技术细节和复杂的算法。比如，如何将训练好的 AI 图像算法模型，快速部署落地到实际应⽤场景中呢？对于没有接触过计算机视觉（Computer Vision，后简称 CV）的程序员，或是纯搞算法的算法工程师，要实现+落地 AI 视频分析相关功能可能会有点难度。然而，随着视频在日常生活中的普及和应用越来越广泛，处理和分析视频类数据的需求也在逐渐增加。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/484e3ecee2a913f5ecce9762f60703a82621785dfb48a3bbb35cc9cfdb63de80" alt></p>
<p>因此，今天 HelloGitHub 带来了一款开源的视频分析/结构化框架——VideoPipe，旨在让开发视频分析应用像使用 Django 写 Web 一样方便。<strong>VideoPipe 独创的管道可视化显示，让每一步的处理状态都可以一目了然</strong>。该框架能够轻松集成各种 CV 领域的模型，通过即插即用的方式轻松实现 AI 加持下的视频分析，适用于视频结构化、图片搜索、人脸识别、安防领域的行为分析（⻋牌识别、交通事故检测）等场景。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fc941c3f3bc0daf17901ad649d1f16de6382bb1902ab7ab230728f5431aea716" alt></p>
<blockquote>
<p>GitHub 地址：<a href="https://github.com/sherlockchou86/VideoPipe" target="_blank" rel="noopener">github.com/sherlockcho…</a></p>
</blockquote>
<p>下面，让我们跟着该项目的作者（周智）一起来了解、上手 VideoPipe，然后深入其内部学习更多的技术细节。</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>VideoPipe 这是一个用于视频分析和结构化的框架，采用 C++ 编写、依赖少、易上手。它就像一个管道每个节点相互独立可自行搭配，用来构建不同类型的视频分析管道，适用于视频结构化、图片搜索、人脸识别、安防领域的行为分析（如交通事件检测）等场景。</p>
<p>你只需准备好模型并了解如何解析其输出即可，推理可以基于不同的后端实现，如 OpenCV::DNN（默认）、TensorRT、PaddleInference、ONNXRuntime 等，任何你喜欢的都可以。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/43b6004ba92ebf171dd2bae4b23ed6df8a87f74eb15304a31574ab1957084d24" alt></p>
<p>通过上面的 VideoPipe 工作示意图，可以发现它提供了以下功能：</p>
<ul>
<li>流读取/推送：⽀持主流的视频流协议，如 udp、rtsp、rtmp、文件。</li>
<li>视频解码/编码：⽀持基于 OpenCV/GStreamer 的视频和图片解/编码（⽀持硬件加速）。</li>
<li>基于深度学习的算法推理：⽀持基于深度学习算法的多级推理，例如⽬标检测、图像分类、特征提取。</li>
<li>⽬标跟踪：⽀持⽬标追踪，例如 IOU、SORT 跟踪算法等。</li>
<li>⾏为分析（BA）：⽀持基于跟踪的⾏为分析，例如越线、停⻋、违章等交通判断。</li>
<li>数据代理：⽀持将结构化数据（json/xml/⾃定义格式）以 kafka/Sokcet 等⽅式推送到云端、文件或其他<br>第三⽅平台。</li>
<li>录制：⽀持特定时间段的视频录制，特定帧的截图。</li>
<li>屏幕显⽰（OSD）：支持将模型输出结果绘制到帧上。</li>
</ul>
<p>对比功能类似、耳熟能详的 DeepStream（英伟达）和 mxVision（华为）框架，<strong>VideoPipe 更易于使⽤和调试、具备更好的可移植性，它完全由原生 C++ 编写，仅依赖于少量主流的第三方模块（如 OpenCV）</strong>。同时提供了可视化管道，框架的运行状态会自动在屏幕上刷新，包括管道中每个连接点的 fps、缓存大小、延迟等信息，你可以根据这些运行信息快速定位处理时的瓶颈所在。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>是否开源</th>
<th>学习门槛</th>
<th>适用平台</th>
<th>性能</th>
<th>三方依赖</th>
</tr>
</thead>
<tbody><tr>
<td>DeepStream</td>
<td>否</td>
<td>高</td>
<td>仅限英伟达</td>
<td>高</td>
<td>多</td>
</tr>
<tr>
<td>mxVision</td>
<td>否</td>
<td>高</td>
<td>仅限华为</td>
<td>高</td>
<td>多</td>
</tr>
<tr>
<td>VideoPipe</td>
<td>是</td>
<td>低</td>
<td>不限平台</td>
<td>中</td>
<td>少</td>
</tr>
</tbody></table>
<h2 id="二、快速上手"><a href="#二、快速上手" class="headerlink" title="二、快速上手"></a>二、快速上手</h2><p>VideoPipe 对机器硬件没有要求，仅用 CPU 都可以运行，不需要额外的加速卡。而且项目中还提供了丰富的示例代码，下面让我们通过运行一个简单的「人脸识别」示例，快速上手该框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c++复制代码/*</span><br><span class="line">* 名称：1-1-N sample</span><br><span class="line">* 完整代码位于：samples/1-1-N_sample.cpp</span><br><span class="line">* 功能说明：1个视频输入，1个视频分析任务（人脸检测和识别），2个输出（屏幕输出/RTMP推流输出）</span><br><span class="line">* 注意：模型和视频文件需要自行准备</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    VP_SET_LOG_INCLUDE_CODE_LOCATION(false);</span><br><span class="line">    VP_SET_LOG_INCLUDE_THREAD_ID(false);</span><br><span class="line">    VP_LOGGER_INIT();</span><br><span class="line"></span><br><span class="line">    // 1、创建节点</span><br><span class="line">    // 视频获取 Node</span><br><span class="line">    auto file_src_0 = std::make_shared&lt;vp_nodes::vp_file_src_node&gt;(&quot;file_src_0&quot;, 0, &quot;./test_video/10.mp4&quot;, 0.6);</span><br><span class="line">    // 2、模型推理 Node</span><br><span class="line">    // 一级推理：人脸检测</span><br><span class="line">    auto yunet_face_detector_0 = std::make_shared&lt;vp_nodes::vp_yunet_face_detector_node&gt;(&quot;yunet_face_detector_0&quot;, &quot;./models/face/face_detection_yunet_2022mar.onnx&quot;);</span><br><span class="line">    // 二级推理：人脸识别</span><br><span class="line">    auto sface_face_encoder_0 = std::make_shared&lt;vp_nodes::vp_sface_feature_encoder_node&gt;(&quot;sface_face_encoder_0&quot;, &quot;./models/face/face_recognition_sface_2021dec.onnx&quot;);</span><br><span class="line">    // 3、OSD Node</span><br><span class="line">    // 处理结果绘制到帧上</span><br><span class="line">    auto osd_0 = std::make_shared&lt;vp_nodes::vp_face_osd_node_v2&gt;(&quot;osd_0&quot;);</span><br><span class="line">    // 屏幕展示</span><br><span class="line">    auto screen_des_0 = std::make_shared&lt;vp_nodes::vp_screen_des_node&gt;(&quot;screen_des_0&quot;, 0);</span><br><span class="line">    // 推流展示</span><br><span class="line">    auto rtmp_des_0 = std::make_shared&lt;vp_nodes::vp_rtmp_des_node&gt;(&quot;rtmp_des_0&quot;, 0, &quot;rtmp://192.168.77.60/live/10000&quot;);</span><br><span class="line"></span><br><span class="line">    // 构建管道，将节点的处理结果关联起来</span><br><span class="line">    yunet_face_detector_0-&gt;attach_to(&#123;file_src_0&#125;);</span><br><span class="line">    sface_face_encoder_0-&gt;attach_to(&#123;yunet_face_detector_0&#125;);</span><br><span class="line">    osd_0-&gt;attach_to(&#123;sface_face_encoder_0&#125;);</span><br><span class="line"></span><br><span class="line">    // 管道自动拆分，通过屏幕/推流输出结果</span><br><span class="line">    screen_des_0-&gt;attach_to(&#123;osd_0&#125;);</span><br><span class="line">    rtmp_des_0-&gt;attach_to(&#123;osd_0&#125;);</span><br><span class="line"></span><br><span class="line">    // 启动管道</span><br><span class="line">    file_src_0-&gt;start();</span><br><span class="line"></span><br><span class="line">    // 可视化管道</span><br><span class="line">    vp_utils::vp_analysis_board board(&#123;file_src_0&#125;);</span><br><span class="line">    board.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读上面的示例代码，可以发现 <strong>VideoPipe 框架将视频分析/处理的步骤，抽象成了一个管道（pipe），每一步的处理都是管道中的一个节点（Node）</strong>，处理流程如下：</p>
<ol>
<li>视频读取 Node：完成读取视频和解码的工作</li>
<li>模型推理 Node：分为人脸检测和人脸识别两个模型</li>
<li>OSD Node：将模型输出的处理结果绘制到帧上</li>
<li>构建管道：将上述节点依次连接，并将结果分成屏幕输出和推流输出，</li>
<li>启动：启动程序，并展示管道的运行情况</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/710a6720882ee5cbaacbccafa7ca6324cbcaed23d27b1f8c4bcf28823017abdd" alt></p>
<p>代码运⾏后，会出现上面的 3 个画⾯。它们分别是管道运⾏状态图（状态⾃动刷新）、屏幕显⽰结果（GUI）、播放器显⽰结果（RTMP），至此就算上手 VideoPipe 了！</p>
<h2 id="三、技术原理"><a href="#三、技术原理" class="headerlink" title="三、技术原理"></a>三、技术原理</h2><p>接下来，将详细介绍 VideoPipe 框架实现的技术原理和细节，干货来啦！在深入了解 VideoPipe 框架技术细节之前，我们需要先弄清楚视频的整体处理流程。</p>
<h3 id="3-1-视频结构化应⽤的核⼼环节"><a href="#3-1-视频结构化应⽤的核⼼环节" class="headerlink" title="3.1 视频结构化应⽤的核⼼环节"></a>3.1 视频结构化应⽤的核⼼环节</h3><p>视频结构化是将非结构化数据（视频/图片）转换为结构化数据的过程。非结构化数据通常包括：视频、图像、⾳频、⾃然语⾔文本，⽽结构化数据主要包括诸如 JSON、XML 或数据库中的数据表等，这些数据可以直接由机器（程序）处理。具体到视频（含图片，下同）结构化的过程，主要涉及以下核⼼部分：</p>
<ul>
<li>读取流：从⽹络或本地机器获取视频流。</li>
<li>解码：将字节流解码为帧，因为算法只能作⽤于图像。</li>
<li>推理：对图像进⾏深度学习推理，如检测、分类或特征提取。</li>
<li>跟踪：跟踪视频中的⽬标。</li>
<li>⾏为分析/逻辑处理：分析⽬标的轨迹、属性。</li>
<li>OSD：在图像上显⽰结果，⽤于调试或得到直观效果。</li>
<li>消息代理：将结构化数据推送到外部，供业务平台使⽤。</li>
<li>编码：对包含结果的帧进⾏编码，以便传输、存储。</li>
<li>推送流：将字节流推送到外部或直接保存</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ccf7090679105a13b6d15ffb975ba3f13cb45ef6fbfd8434a951132e9fe2287c" alt></p>
<p>上述每个环节对应 VideoPipe 中的⼀种插件类型，即代码中的 Node 对象。下面我们将逐一讲解 VideoPipe 的 Node、数据流、钩子的技术细节和实现。</p>
<h3 id="3-2-Node"><a href="#3-2-Node" class="headerlink" title="3.2 Node"></a>3.2 Node</h3><p>VideoPipe 中的每个 Node 负责⼀种任务（严格遵循单⼀职责原则），例如解码或推理。我们可以将许多节点串在⼀起构建成管道，并让视频数据流经整个管道。每个 Node 内部都有两个队列，⼀个⽤于缓存上游节点推送的数据，另⼀个⽤于缓存等待被推送到下游节点的数据。我们可以在两个队列之间编写逻辑代码，这是典型的⽣产者-消费者模式。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/be77369fb20e7cad50070d640c2d224ee0e044b5bfdf420341052ba263b48e35" alt></p>
<p>VideoPipe 中有三种类型的节点，分别是：</p>
<ol>
<li>SRC节点：源节点，数据被创建的地⽅（内部只有⼀个队列，⽤于缓存被推送到下游节点的数据）。</li>
<li>MID节点：中间节点，数据将在此处理。</li>
<li>DES节点：⽬标节点，数据消失的地⽅（内部只有⼀个队列，⽤于缓存来⾃上游节点的数据）。</li>
</ol>
<p>每个节点本⾝具有合并多个上游节点和拆分成多个下游节点的能⼒。注意，默认情况下节点在将数据从⼀个节点传输到另⼀个节点时使⽤浅拷⻉和等值拷⻉。如果您需要深拷⻉或希望按通道索引传输数据（希望数据不混淆），则在分裂点添加⼀个 <code>vp_split_node</code> 类型节点。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/62bddd0ace545b3e720021a3203ae044e9766e79dee2495ef6b283c88304e11c" alt></p>
<h3 id="3-3-数据流"><a href="#3-3-数据流" class="headerlink" title="3.3 数据流"></a>3.3 数据流</h3><p>视频是一种重量级数据，因此频繁进行深拷贝会降低管道的性能。实际上，VideoPipe 中两个节点之间传递的数据默认使用智能指针，一旦数据由源节点创建，数据内容在整个管道中大多数时间不会被复制。但如果需要，我们可以指定深度拷贝模式，使用 <code>vp_split_node</code> 类型节点。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d5748e7a01589f7309767c416dadb0a194c27c66374e7b8a147979aa9e3dc00a" alt></p>
<p>视频由连续的帧组成，因此 VideoPipe 逐帧处理这些帧，所以帧元数据中的帧索引也会连续增加。</p>
<h3 id="3-4-钩子"><a href="#3-4-钩子" class="headerlink" title="3.4 钩子"></a>3.4 钩子</h3><p>钩子是一种机制，让主体在发生某些事件时通知检测者，VideoPipe 也支持钩子。管道触发回调函数 <code>std::function</code> 与外部代码通信，例如实时推送管道自身的 fps、延迟和其他状态信息。我们在编写回调函数内部代码时，不允许有阻塞出现，否则影响整个管道性能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6bab2c1513b8a0dd67ef60fcc191fc13aa4672aa867bc9f9b6bca28b5580ff89" alt></p>
<p>钩子有助于调试我们的应用程序，并快速找出整个管道中的瓶颈，VideoPipe 框架中自带的可视化工具 <code>vp_analysis_board</code> 就是依赖于钩子机制实现的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/aec4355c7c80440625e00bff8c72bb5222f247ce83606f38067be8ea539d7f4e" alt></p>
<h3 id="3-5-如何实现新的-Node-类型"><a href="#3-5-如何实现新的-Node-类型" class="headerlink" title="3.5 如何实现新的 Node 类型"></a>3.5 如何实现新的 Node 类型</h3><p>首先 <code>vp_node</code> 是 VideoPipe 中所有节点的基类，我们可以定义一个从 <code>vp_node</code> 派生的新节点类，并重写一些虚函数：</p>
<ul>
<li><code>handle_frame_meta</code>：处理流经当前节点的帧数据。</li>
<li><code>handle_control_meta</code>：处理流经当前节点的控制指令数据。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/75f8af13018747130b9ca20ab9f14a6a7e6a71870b43b11f72815722e43ba6ae" alt></p>
<p>帧数据指的是 VideoPipe 中的 <code>vp_frame_meta</code>，其中包含与帧相关的数据，如帧索引、数据缓冲区、原始宽度等等。控制指令数据指的是 VideoPipe 中的 <code>vp_control_meta</code>，其中包含与命令相关的数据，例如记录视频、记录图像等。并非所有流经当前节点的数据都应该被处理，只需要处理我们感兴趣的内容。</p>
<h2 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h2><p>目前，基于深度学习的视频分析技术的入门门槛还是比较高的，一些成熟的框架比如 DeepStream、mxVision 等，它们大多晦涩难懂、上手门槛高、对于新手不太友好。所以，我就花了两年的业余时间创建了 VideoPipe 视频分析框架，我的想法很简单就是想让<strong>初学者能够快速了解视频分析相关技术栈，轻松地在自己机器上跑通一个人脸识别的应用</strong>，让更多人掌握视频分析相关技术，同时搞清楚应该从哪里开始。</p>
<p>我深知这是一件道阻且长的事情，所以 VideoPipe 在诞生之初就是完全开源，我希望能够借助开源的力量让它“发光发热”，真正地做到降低开发视频分析应用的门槛，帮助更多的开发者进入到视频分析的领域。</p>
<blockquote>
<p>GitHub 地址：<a href="https://github.com/sherlockchou86/VideoPipe" target="_blank" rel="noopener">github.com/sherlockcho…</a></p>
</blockquote>
<p>最后，感谢「HelloStar 计划」提供的机会，能够让更多人了解 VideoPipe 框架。我作为开源生态的受益者，深知开源的力量和责任，此举也是希望 VideoPipe 项目能够成为一座连接对视频分析、结构化技术感兴趣的小伙伴的桥梁，能够和大家一起交流学习、共同进步、回馈开源社区！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358687549848289331" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>10.数据库链路追踪实现设计</title>
    <url>/7358688805157404709.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式链路追踪中，记录数据库的调用是必不可少的，但是数据库的分布式链路追踪，与调用下游服务或者发送<strong>Kafka</strong>有着显著的不同，那就是链路信息不需要传递到数据库服务端，所以就不需要将<strong>Span</strong>通过某种方式进行传递，而需要做的，就是把请求数据库服务端时的一些信息记录下来并作为链路日志输出。</p>
<p>这里选择基于<strong>MyBatis</strong>实现数据库链路追踪，实现的机制是基于<strong>MyBatis</strong>的拦截器，因此实际上<strong>MyBatis-Plus</strong>也是适用的。</p>
<p><strong>github</strong>地址：<a href="https://github.com/SakuraSacrifice/honey-tracing" target="_blank" rel="noopener">honey-tracing</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一-链路日志改造说明"><a href="#一-链路日志改造说明" class="headerlink" title="一. 链路日志改造说明"></a>一. 链路日志改造说明</h3><p>之前的链路日志格式如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;</span><br><span class="line">    &quot;traceId&quot;: &quot;testTraceId&quot;, // 当前节点所属链路的Id</span><br><span class="line">    &quot;spanId&quot;: &quot;testSpanId&quot;, // 当前节点的SpanId</span><br><span class="line">    &quot;parentSpanId&quot;: &quot;testparentSpanId&quot;, // 当前节点的父节点的SpanId</span><br><span class="line">    &quot;timestamp&quot;: &quot;1704038400000&quot;, // 接收到请求那一刻的毫秒时间戳</span><br><span class="line">    &quot;duration&quot;: &quot;10&quot;, // 表示接收请求到响应请求的耗时</span><br><span class="line">    &quot;httpCode&quot;: &quot;200&quot;, // 请求的HTTP状态码</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;, // 当前节点的主机地址</span><br><span class="line">    &quot;requestStacks&quot;: [ // 请求堆栈</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;subSpanId&quot;: &quot;testSubSpanId&quot;, // 当前节点的子节点的SpanId</span><br><span class="line">            &quot;subHttpCode&quot;: &quot;200&quot;, // 请求子节点的HTTP状态码</span><br><span class="line">            &quot;subTimestamp&quot;: &quot;1704038401000&quot;, // 当前节点请求子节点的毫秒时间戳</span><br><span class="line">            &quot;subDuration&quot;: &quot;5&quot;, // 表示发起请求到收到响应的耗时</span><br><span class="line">            &quot;subHost&quot;: &quot;192.168.10.5&quot; // 当前节点的子节点的主机地址</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>requestStacks</strong>字段用于记录下游的<strong>Span</strong>信息，而由于数据库链路追踪中并不需要将链路信息传递给数据库服务端，所以<strong>requestStacks</strong>字段不再适用，我们新增加一个<strong>dbStacks</strong>字段来记录数据库操作的信息，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;</span><br><span class="line">    &quot;traceId&quot;: &quot;testTraceId&quot;, // 当前节点所属链路的Id</span><br><span class="line">    &quot;spanId&quot;: &quot;testSpanId&quot;, // 当前节点的SpanId</span><br><span class="line">    &quot;parentSpanId&quot;: &quot;testparentSpanId&quot;, // 当前节点的父节点的SpanId</span><br><span class="line">    &quot;timestamp&quot;: &quot;1704038400000&quot;, // 接收到请求那一刻的毫秒时间戳</span><br><span class="line">    &quot;duration&quot;: &quot;10&quot;, // 表示接收请求到响应请求的耗时</span><br><span class="line">    &quot;httpCode&quot;: &quot;200&quot;, // 请求的HTTP状态码</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;, // 当前节点的主机地址</span><br><span class="line">    &quot;requestStacks&quot;: [ // 请求堆栈</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;subSpanId&quot;: &quot;testSubSpanId&quot;, // 当前节点的子节点的SpanId</span><br><span class="line">            &quot;subHttpCode&quot;: &quot;200&quot;, // 请求子节点的HTTP状态码</span><br><span class="line">            &quot;subTimestamp&quot;: &quot;1704038401000&quot;, // 当前节点请求子节点的毫秒时间戳</span><br><span class="line">            &quot;subDuration&quot;: &quot;5&quot;, // 表示发起请求到收到响应的耗时</span><br><span class="line">            &quot;subHost&quot;: &quot;192.168.10.5&quot; // 当前节点的子节点的主机地址</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dbStacks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;dbServer&quot;: &quot;127.0.0.1:3306&quot;, // 数据库服务端地址</span><br><span class="line">            &quot;dbName&quot;: &quot;test&quot;, // 数据库名</span><br><span class="line">            &quot;sqlText&quot;: &quot;SELECT * FROM book WHERE id=?&quot;, // SQL语句</span><br><span class="line">            &quot;sqlParams&quot;: &quot;50&quot;, // SQL语句参数</span><br><span class="line">            &quot;sqlDuration&quot;: &quot;5&quot;, // 数据库操作耗时</span><br><span class="line">            &quot;sqlTimestamp&quot;: &quot;1704038402000&quot; // 数据库操作时的毫秒时间戳</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增字段说明如下。</p>
<ol>
<li><strong>dbServer</strong>。表示数据库服务端地址，从<strong>url</strong>连接串中解析出；</li>
<li><strong>dbName</strong>。表示操作的数据库名，从<strong>url</strong>连接串中解析出；</li>
<li><strong>sqlText</strong>。表示执行的<strong>SQL</strong>语句信息，从<strong>MyBatis</strong>的<strong>BoundSql</strong>中获取；</li>
<li><strong>sqlParams</strong>。表示执行的<strong>SQL</strong>参数，同样从<strong>MyBatis</strong>的<strong>BoundSql</strong>中获取；</li>
<li><strong>sqlDuration</strong>。表示操作数据库的耗时，单位<strong>ms</strong>，由于<strong>MyBatis</strong>拦截器的拦截时机是先于从数据源中拿出连接的，所以这里的耗时包括等待获取数据库连接的时间；</li>
<li><strong>sqlTimestamp</strong>。表示开始操作数据库的时间点的毫秒时间戳。</li>
</ol>
<h3 id="二-MyBatis拦截器回顾"><a href="#二-MyBatis拦截器回顾" class="headerlink" title="二. MyBatis拦截器回顾"></a>二. MyBatis拦截器回顾</h3><p><strong>MyBatis</strong>的拦截器也就是常说的插件，可以作用于<strong>Executor</strong>，<strong>ParameterHandler</strong>，<strong>ResultSetHandler</strong>和<strong>StatementHandler</strong>这四个组件，所有拦截器都需要实现<strong>org.apache.ibatis.plugin.Interceptor</strong>接口，一个简单的拦截器示例如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class TestInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        // 获取被拦截的对象</span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        // 获取被拦截的方法</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        // 获取被拦截的方法的参数</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line"></span><br><span class="line">        // 执行被拦截的方法前，做一些事情</span><br><span class="line"></span><br><span class="line">        // 执行被拦截的方法</span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        // 执行被拦截的方法后，做一些事情</span><br><span class="line"></span><br><span class="line">        // 返回执行结果</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面出现的@<strong>Signature</strong>注解的<strong>type</strong>，<strong>method</strong>和<strong>args</strong>三个字段共同决定拦截器会作用于哪个组件的哪个方法上，例如上面示例中，就会作用于<strong>Executor</strong>组件的<strong>update()</strong> 方法和两个重载的<strong>query()</strong> 方法，而我们又知道，<strong>MyBatis</strong>执行<strong>SQL</strong>时，无论是增删改查，其实都是会调用到<strong>Executor</strong>的<strong>update()</strong> 方法或者<strong>query()</strong> 方法，所以上面示例的拦截器，其实就可以拦截所有<strong>SQL</strong>的执行。</p>
<h3 id="三-数据库链路追踪MyBatis拦截器设计与实现"><a href="#三-数据库链路追踪MyBatis拦截器设计与实现" class="headerlink" title="三. 数据库链路追踪MyBatis拦截器设计与实现"></a>三. 数据库链路追踪MyBatis拦截器设计与实现</h3><p>在开始前，需要在<strong>pom</strong>文件中先添加如下依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们要实现数据库链路追踪，其实就是记录操作数据库的行为，所以需要拦截每一条<strong>SQL</strong>的执行，因此拦截器作用的目标组件就是<strong>Executor</strong>，作用的目标方法就是<strong>update()</strong> 和两个重载的<strong>query()</strong> 方法，拦截器实现如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * MyBaits作用于&#123;@link Executor&#125;用于记录&#123;@link Span&#125;的拦截器。</span><br><span class="line"> */</span><br><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class HoneyDbExecutorTracingInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    private final Tracer tracer;</span><br><span class="line">    private final List&lt;HoneyDbExecutorTracingDecorator&gt; decorators;</span><br><span class="line"></span><br><span class="line">    public HoneyDbExecutorTracingInterceptor(Tracer tracer, List&lt;HoneyDbExecutorTracingDecorator&gt; decorators) &#123;</span><br><span class="line">        this.tracer = tracer;</span><br><span class="line">        this.decorators = decorators;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        if (null == tracer.activeSpan()) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Span span = tracer.buildSpan(HONEY_DB_NAME)</span><br><span class="line">                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)</span><br><span class="line">                .start();</span><br><span class="line">        for (HoneyDbExecutorTracingDecorator decorator : decorators) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                decorator.onExecute(invocation, span);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // do nothing</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object result;</span><br><span class="line">        try (Scope scope = tracer.activateSpan(span)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = invocation.proceed();</span><br><span class="line">            &#125; catch (Exception e1) &#123;</span><br><span class="line">                for (HoneyDbExecutorTracingDecorator decorator : decorators) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        decorator.onError(invocation, e1, span);</span><br><span class="line">                    &#125; catch (Exception e2) &#123;</span><br><span class="line">                        // do nothing</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                throw e1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (HoneyDbExecutorTracingDecorator decorator : decorators) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    decorator.onFinish(invocation, span);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            span.finish();</span><br><span class="line">            tracer.activeSpan().log(DbStackUtil.assembleDbStack((JaegerSpan) span));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现的拦截器，主要干了下面几件事情。</p>
<ol>
<li>针对当前操作数据库的行为创建<strong>Span</strong>。这里创建<strong>Span</strong>并不是要把<strong>Span</strong>传递给数据库服务端，而是通过<strong>Span</strong>来记录开始时间，执行耗时以及数据库操作的一些信息；</li>
<li>在<strong>SQL</strong>执行前，执行成功和执行失败时分别应用装饰器的逻辑。拦截器并没有写很重的逻辑，解析<strong>url</strong>，解析<strong>SQL</strong>等逻辑全部放到装饰器中，让拦截器和记录信息的行为解耦，方便后续扩充<strong>dbStack</strong>的内容；</li>
<li>在拦截器的最后生成<strong>dbStack</strong>并记录在当前节点的<strong>Span</strong>中。注意，生成<strong>dbStack</strong>是基于我们在拦截器中创建出来的<strong>Span</strong>，在<strong>dbStack</strong>生成出来后，在拦截器中创建出来的<strong>Span</strong>的使命就完成了，后续就需要把生成出来的<strong>dbStack</strong>记录在当前节点的<strong>Span</strong>中。</li>
</ol>
<p>基于<strong>Span</strong>生成<strong>dbStack</strong>的工具类<strong>DbStackUtil</strong>实现如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * dbStack记录工具。</span><br><span class="line"> */</span><br><span class="line">public class DbStackUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成操作数据库时的dbStack。</span><br><span class="line">     */</span><br><span class="line">    public static Map&lt;String, Object&gt; assembleDbStack(JaegerSpan span) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; requestStack = new HashMap&lt;&gt;();</span><br><span class="line">        requestStack.put(LOG_EVENT_KIND, LOG_EVENT_KIND_DB_STACK);</span><br><span class="line">        requestStack.put(FIELD_DB_SERVER, span.getTags().get(FIELD_DB_SERVER));</span><br><span class="line">        requestStack.put(FIELD_DB_NAME, span.getTags().get(FIELD_DB_NAME));</span><br><span class="line">        requestStack.put(FIELD_SQL_TEXT, span.getTags().get(FIELD_SQL_TEXT));</span><br><span class="line">        requestStack.put(FIELD_SQL_PARAMS, span.getTags().get(FIELD_SQL_PARAMS));</span><br><span class="line">        requestStack.put(FIELD_SQL_DURATION, span.getDuration());</span><br><span class="line">        requestStack.put(FIELD_SQL_TIMESTAMP, span.getStart());</span><br><span class="line">        return requestStack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class CommonConstants &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">     public static final String LOG_EVENT_KIND = &quot;logEventKind&quot;;</span><br><span class="line">     public static final String LOG_EVENT_KIND_DB_STACK = &quot;dbStack&quot;;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中很关键的一点是在于将<strong>logEventKind</strong>设置为了<strong>dbStack</strong>，这样在打印链路日志时，可以根据<strong>logEventKind</strong>来知道当前要按照<strong>dbStack</strong>的格式来组装日志。</p>
<p>最后再看一下装饰器接口的定义，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * 作用于&#123;@link Executor&#125;的装饰器。</span><br><span class="line"> */</span><br><span class="line">public interface HoneyDbExecutorTracingDecorator &#123;</span><br><span class="line"></span><br><span class="line">    void onExecute(Invocation invocation, Span span);</span><br><span class="line"></span><br><span class="line">    void onFinish(Invocation invocation, Span span);</span><br><span class="line"></span><br><span class="line">    void onError(Invocation invocation, Exception exception, Span span);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-数据库链路追踪装饰器设计与实现"><a href="#四-数据库链路追踪装饰器设计与实现" class="headerlink" title="四. 数据库链路追踪装饰器设计与实现"></a>四. 数据库链路追踪装饰器设计与实现</h3><p>提供一个<strong>HoneyDbExecutorTracingDecorator</strong>接口的实现类，在<strong>SQL</strong>执行前，完成记录数据库服务端地址，数据库名，<strong>SQL</strong>语句和<strong>SQL</strong>参数，这些记录的信息，全部存储在<strong>Span</strong>的<strong>Tags</strong>字段中。</p>
<h4 id="1-数据库服务端地址和数据库名获取"><a href="#1-数据库服务端地址和数据库名获取" class="headerlink" title="1. 数据库服务端地址和数据库名获取"></a>1. 数据库服务端地址和数据库名获取</h4><p>装饰器实现如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * 作用于&#123;@link Executor&#125;的装饰器，装饰&#123;@link Span&#125;。</span><br><span class="line"> */</span><br><span class="line">public class HoneyDbExecutorTracingSpanDecorator implements HoneyDbExecutorTracingDecorator &#123;</span><br><span class="line"></span><br><span class="line">    private static final String QUESTION_MARK = &quot;?&quot;;</span><br><span class="line">    private static final String COMMA = &quot;,&quot;;</span><br><span class="line">    private static final String NULL_STR = &quot;null&quot;;</span><br><span class="line">    private static final char SPACE_CHAR = &apos; &apos;;</span><br><span class="line">    private static final String LINE_BREAK_REGEX = &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onExecute(Invocation invocation, Span span) &#123;</span><br><span class="line">        // 设置数据库服务端地址信息和数据库名</span><br><span class="line">        try &#123;</span><br><span class="line">            DataSource dataSource = ((MappedStatement) invocation.getArgs()[0]).getConfiguration().getEnvironment().getDataSource();</span><br><span class="line">            assembleDbServerAndName(dataSource, (JaegerSpan) span);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFinish(Invocation invocation, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Invocation invocation, Exception exception, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void assembleDbServerAndName(DataSource dataSource, JaegerSpan span) &#123;</span><br><span class="line">        String url = StringUtils.EMPTY;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (dataSource instanceof HikariDataSource) &#123;</span><br><span class="line">                url = ((HikariDataSource) dataSource).getJdbcUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof DruidDataSource) &#123;</span><br><span class="line">                url = ((DruidDataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof org.apache.tomcat.jdbc.pool.DataSource) &#123;</span><br><span class="line">                url = ((org.apache.tomcat.jdbc.pool.DataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 无法判断数据库连接池类型的情况下才通过连接拿url</span><br><span class="line">                Connection connection = dataSource.getConnection();</span><br><span class="line">                DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">                url = metaData.getURL();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isNotEmpty(url)) &#123;</span><br><span class="line">            // 从连接串中解析出数据库服务端地址信息</span><br><span class="line">            int left = url.indexOf(SLASH_DOUBLE) + 2;</span><br><span class="line">            int mid = url.indexOf(SLASH, left);</span><br><span class="line">            int right = url.indexOf(QUESTION_MARK);</span><br><span class="line">            span.setTag(FIELD_DB_SERVER, url.substring(left, mid));</span><br><span class="line">            if (right == -1) &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1, right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述装饰器首先会从拦截方法的参数中拿到<strong>MappedStatement</strong>，从而最终可以拿到当前使用的数据源<strong>DataSource</strong>，再然后判断数据源的类型，如果能够明确数据源的类型，那么就可以直接拿到数据库连接串<strong>url</strong>，如果无法判断出数据源类型，则可以选择先从数据源中获取一个数据库连接，然后再从数据库连接的元数据信息中拿到<strong>url</strong>。</p>
<p>获取到<strong>url</strong>后，就按照如下两种<strong>url</strong>格式来解析出数据库服务端地址和数据库名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt复制代码jdbc:mysql://数据库服务端地址/数据库名</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt复制代码jdbc:mysql://数据库服务端地址/数据库名?配置项1=配置值1</span><br></pre></td></tr></table></figure>

<h4 id="2-SQL语句和SQL参数获取"><a href="#2-SQL语句和SQL参数获取" class="headerlink" title="2. SQL语句和SQL参数获取"></a>2. SQL语句和SQL参数获取</h4><p>继续在上一小节的装饰器中添加代码，完成<strong>SQL</strong>语句和<strong>SQL</strong>参数的获取，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * 作用于&#123;@link Executor&#125;的装饰器，装饰&#123;@link Span&#125;。</span><br><span class="line"> */</span><br><span class="line">public class HoneyDbExecutorTracingSpanDecorator implements HoneyDbExecutorTracingDecorator &#123;</span><br><span class="line"></span><br><span class="line">    private static final String QUESTION_MARK = &quot;?&quot;;</span><br><span class="line">    private static final String COMMA = &quot;,&quot;;</span><br><span class="line">    private static final String NULL_STR = &quot;null&quot;;</span><br><span class="line">    private static final char SPACE_CHAR = &apos; &apos;;</span><br><span class="line">    private static final String LINE_BREAK_REGEX = &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onExecute(Invocation invocation, Span span) &#123;</span><br><span class="line">        // 设置数据库服务端地址信息和数据库名</span><br><span class="line">        try &#123;</span><br><span class="line">            DataSource dataSource = ((MappedStatement) invocation.getArgs()[0]).getConfiguration().getEnvironment().getDataSource();</span><br><span class="line">            assembleDbServerAndName(dataSource, (JaegerSpan) span);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置SQL语句和参数信息</span><br><span class="line">        try &#123;</span><br><span class="line">            assembleSqlTextAndParams(invocation.getArgs(), (JaegerSpan) span);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFinish(Invocation invocation, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Invocation invocation, Exception exception, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void assembleDbServerAndName(DataSource dataSource, JaegerSpan span) &#123;</span><br><span class="line">        String url = StringUtils.EMPTY;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (dataSource instanceof HikariDataSource) &#123;</span><br><span class="line">                url = ((HikariDataSource) dataSource).getJdbcUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof DruidDataSource) &#123;</span><br><span class="line">                url = ((DruidDataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof org.apache.tomcat.jdbc.pool.DataSource) &#123;</span><br><span class="line">                url = ((org.apache.tomcat.jdbc.pool.DataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 无法判断数据库连接池类型的情况下才通过连接拿url</span><br><span class="line">                Connection connection = dataSource.getConnection();</span><br><span class="line">                DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">                url = metaData.getURL();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isNotEmpty(url)) &#123;</span><br><span class="line">            // 从连接串中解析出数据库服务端地址信息</span><br><span class="line">            int left = url.indexOf(SLASH_DOUBLE) + 2;</span><br><span class="line">            int mid = url.indexOf(SLASH, left);</span><br><span class="line">            int right = url.indexOf(QUESTION_MARK);</span><br><span class="line">            span.setTag(FIELD_DB_SERVER, url.substring(left, mid));</span><br><span class="line">            if (right == -1) &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1, right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void assembleSqlTextAndParams(Object[] args, Span span) &#123;</span><br><span class="line">        MappedStatement mappedStatement = ((MappedStatement) args[0]);</span><br><span class="line">        // 先获取SQL</span><br><span class="line">        BoundSql boundSql;</span><br><span class="line">        if (args.length == 6) &#123;</span><br><span class="line">            boundSql = ((BoundSql) args[5]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            boundSql = mappedStatement.getBoundSql(args[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        span.setTag(FIELD_SQL_TEXT, toPrettySql(boundSql.getSql()));</span><br><span class="line"></span><br><span class="line">        // 再获取Params</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">        TypeHandlerRegistry typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">        if (null != parameterMappings) &#123;</span><br><span class="line">            String[] paramStrs = new String[parameterMappings.size()];</span><br><span class="line">            for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">                ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">                if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                    Object value;</span><br><span class="line">                    String propertyName = parameterMapping.getProperty();</span><br><span class="line">                    if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                    &#125; else if (parameterObject == null) &#123;</span><br><span class="line">                        value = null;</span><br><span class="line">                    &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                        value = parameterObject;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        MetaObject metaObject = mappedStatement.getConfiguration().newMetaObject(parameterObject);</span><br><span class="line">                        value = metaObject.getValue(propertyName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (null == value) &#123;</span><br><span class="line">                        paramStrs[i] = NULL_STR;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        paramStrs[i] = value.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String sqlParamsStr = String.join(COMMA, paramStrs);</span><br><span class="line">            span.setTag(FIELD_SQL_PARAMS, sqlParamsStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String toPrettySql(String sql) &#123;</span><br><span class="line">        // 去除换行符</span><br><span class="line">        sql = sql.replaceAll(LINE_BREAK_REGEX, StringUtils.EMPTY);</span><br><span class="line">        // 去除多余空格</span><br><span class="line">        StringBuilder sqlBuilder = new StringBuilder();</span><br><span class="line">        boolean necessarySpace = true;</span><br><span class="line">        for (int i = 0; i &lt; sql.length(); i++) &#123;</span><br><span class="line">            if (sql.charAt(i) == SPACE_CHAR) &#123;</span><br><span class="line">                if (necessarySpace) &#123;</span><br><span class="line">                    sqlBuilder.append(sql.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">                necessarySpace = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sqlBuilder.append(sql.charAt(i));</span><br><span class="line">                necessarySpace = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sqlBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从拦截的方法的参数中拿到<strong>MappedStatement</strong>，然后再从<strong>MappedStatement</strong>中拿到<strong>BoundSql</strong>，我们需要的<strong>SQL</strong>语句和<strong>SQL</strong>参数，都在<strong>BoundSql</strong>中，其中<strong>SQL</strong>语句的获取比较简单，直接通过<strong>BoundSql</strong>就可以拿到<strong>SQL</strong>语句，我们需要做的就是把多余的空格和换行符给去掉，让<strong>SQL</strong>看起来好看一些。而参数要稍微麻烦一点，因为参数是不确定的，在<strong>BoundSql</strong>中是这样来表示参数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class BoundSql &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    private final List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">    private final Object parameterObject;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际就是要使用<strong>parameterMappings</strong>和<strong>parameterObject</strong>共同来解析出<strong>SQL</strong>参数，这里的解析逻辑，直接参考的<strong>DefaultParameterHandler</strong>中的代码。</p>
<p>至此数据库链路追踪装饰器就实现完毕了，使用到的一些常量如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class CommonConstants &#123;</span><br><span class="line"></span><br><span class="line">    public static final double DEFAULT_SAMPLE_RATE = 1.0;</span><br><span class="line"></span><br><span class="line">    public static final String HONEY_TRACER_NAME = &quot;HoneyTracer&quot;;</span><br><span class="line">    public static final String HONEY_REST_TEMPLATE_NAME = &quot;HoneyRestTemplate&quot;;</span><br><span class="line">    public static final String HONEY_KAFKA_NAME = &quot;HoneyKafka&quot;;</span><br><span class="line">    public static final String HONEY_DB_NAME = &quot;HoneyDb&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String FIELD_HOST = &quot;host&quot;;</span><br><span class="line">    public static final String FIELD_API = &quot;api&quot;;</span><br><span class="line">    public static final String FIELD_HTTP_CODE = &quot;httpCode&quot;;</span><br><span class="line">    public static final String FIELD_SUB_SPAN_ID = &quot;subSpanId&quot;;</span><br><span class="line">    public static final String FIELD_SUB_HTTP_CODE = &quot;subHttpCode&quot;;</span><br><span class="line">    public static final String FIELD_SUB_TIMESTAMP = &quot;subTimestamp&quot;;</span><br><span class="line">    public static final String FIELD_SUB_DURATION = &quot;subDuration&quot;;</span><br><span class="line">    public static final String FIELD_SUB_HOST = &quot;subHost&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String FIELD_DB_SERVER = &quot;dbServer&quot;;</span><br><span class="line">    public static final String FIELD_DB_NAME = &quot;dbName&quot;;</span><br><span class="line">    public static final String FIELD_SQL_TEXT = &quot;sqlText&quot;;</span><br><span class="line">    public static final String FIELD_SQL_PARAMS = &quot;sqlParams&quot;;</span><br><span class="line">    public static final String FIELD_SQL_DURATION = &quot;sqlDuration&quot;;</span><br><span class="line">    public static final String FIELD_SQL_TIMESTAMP = &quot;sqlTimestamp&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String HOST_PATTERN_STR = &quot;(?&lt;=(https://|http://)).*?(?=/)&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String SLASH = &quot;/&quot;;</span><br><span class="line">    public static final String SLASH_DOUBLE = &quot;//&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String LOG_EVENT_KIND = &quot;logEventKind&quot;;</span><br><span class="line">    public static final String LOG_EVENT_KIND_REQUEST_STACK = &quot;requestStack&quot;;</span><br><span class="line">    public static final String LOG_EVENT_KIND_DB_STACK = &quot;dbStack&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-注册MyBatis拦截器"><a href="#五-注册MyBatis拦截器" class="headerlink" title="五. 注册MyBatis拦截器"></a>五. 注册MyBatis拦截器</h3><p>在<strong>MyBatis</strong>中注册拦截器，其实就是拿到<strong>MyBatis</strong>的<strong>Configuration</strong>后，调用其<strong>addInterceptor()</strong> 方法即可，所以有两种实现思路。</p>
<ol>
<li>提供<strong>ConfigurationCustomizer</strong>并在其<strong>customize()</strong> 方法中添加拦截器。<strong>ConfigurationCustomizer</strong>是<strong>mybatis-spring-boot-starter</strong>中提供出来专门用于定制化<strong>Configuration</strong>的，所以如果有使用<strong>mybatis-spring-boot-starter</strong>，那么可以基于<strong>ConfigurationCustomizer</strong>来添加拦截器到<strong>Configuration</strong>中；</li>
<li>自定义<strong>BeanPostProcessor</strong>并处理所有<strong>SqlSessionFactory</strong>。因为<strong>MyBatis</strong>整合到<strong>Spring</strong>中后，很核心的一点就是<strong>SqlSessionFactory</strong>会作为<strong>bean</strong>被注册到<strong>Spring</strong>容器中，所以可以提供一个<strong>BeanPostProcessor</strong>来处理所有的<strong>SqlSessionFactory</strong>，通过<strong>SqlSessionFactory</strong>拿到其持有的<strong>Configuration</strong>，然后调用<strong>addInterceptor()</strong> 方法添加拦截器。</li>
</ol>
<p>注意，在使用了<strong>mybatis-spring-boot-starter</strong>后，其实我们只需要将拦截器注册到<strong>Spring</strong>容器中即可，<strong>mybatis-spring-boot-starter</strong>提供的<strong>MybatisAutoConfiguration</strong>会获取到所有<strong>Spring</strong>容器中的拦截器，然后在构建<strong>SqlSessionFactory</strong>时会把拦截器都添加到<strong>Configuration</strong>中，所以此时我们再提供一个<strong>ConfigurationCustomizer</strong>，实际是会重复添加拦截器的，因此下面通过自定义<strong>BeanPostProcessor</strong>的方式来注册拦截器。</p>
<p>首先自定义一个<strong>BeanPostProcessor</strong>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SqlSessionFactoryBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">    public SqlSessionFactoryBeanPostProcessor(List&lt;Interceptor&gt; interceptors) &#123;</span><br><span class="line">        if (null == interceptors) &#123;</span><br><span class="line">            this.interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.interceptors = interceptors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean instanceof SqlSessionFactory) &#123;</span><br><span class="line">            for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">                ((SqlSessionFactory) bean).getConfiguration().addInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后提供一个自动装配类<strong>HoneyDbTracingConfig</strong>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@ConditionalOnClass(org.apache.ibatis.session.Configuration.class)</span><br><span class="line">@AutoConfigureAfter(HoneyTracingConfig.class)</span><br><span class="line">public class HoneyDbTracingConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HoneyDbExecutorTracingInterceptor honeyDbExecutorTracingInterceptor(</span><br><span class="line">            Tracer tracer, List&lt;HoneyDbExecutorTracingDecorator&gt; honeyDbExecutorTracingDecorators) &#123;</span><br><span class="line">        honeyDbExecutorTracingDecorators.add(new HoneyDbExecutorTracingSpanDecorator());</span><br><span class="line">        return new HoneyDbExecutorTracingInterceptor(tracer, honeyDbExecutorTracingDecorators);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingClass(&quot;org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer&quot;)</span><br><span class="line">    public BeanPostProcessor sqlSessionFactoryBeanPostProcessor(List&lt;Interceptor&gt; interceptors) &#123;</span><br><span class="line">        return new SqlSessionFactoryBeanPostProcessor(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<strong>spring.factories</strong>文件中添加上述自动装配类，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line"> com.honey.tracing.config.HoneyTracingConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyTracingFilterConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyRestTemplateTracingConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyKafkaTemplateConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyKafkaTracingConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyDbTracingConfig</span><br></pre></td></tr></table></figure>

<h3 id="六-链路日志打印"><a href="#六-链路日志打印" class="headerlink" title="六. 链路日志打印"></a>六. 链路日志打印</h3><p>现在还需要在原有链路日志打印的基础上，把<strong>dbStack</strong>添加进去。</p>
<p>定义<strong>HoneyDbStack</strong>表示链路日志中的<strong>dbStacks</strong>字段，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class HoneyDbStack &#123;</span><br><span class="line"></span><br><span class="line">    private String dbServer;</span><br><span class="line">    private String dbName;</span><br><span class="line">    private String sqlText;</span><br><span class="line">    private String sqlParams;</span><br><span class="line">    private String sqlDuration;</span><br><span class="line">    private String sqlTimestamp;</span><br><span class="line"></span><br><span class="line">    private HoneyDbStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line">    </span><br><span class="line">    public static class HoneyDbStackBuilder &#123;</span><br><span class="line">        private LogData logData;</span><br><span class="line"></span><br><span class="line">        private HoneyDbStackBuilder() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static HoneyDbStackBuilder builder() &#123;</span><br><span class="line">            return new HoneyDbStackBuilder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public HoneyDbStackBuilder withLogData(LogData logData) &#123;</span><br><span class="line">            this.logData = logData;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public HoneyDbStack build() &#123;</span><br><span class="line">            if (logData == null || logData.getFields() == null) &#123;</span><br><span class="line">                throw new HoneyTracingException();</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, ?&gt; logDataFields = logData.getFields();</span><br><span class="line">            HoneyDbStack honeyDbStack = new HoneyDbStack();</span><br><span class="line">            honeyDbStack.dbServer = (String) logDataFields.get(FIELD_DB_SERVER);</span><br><span class="line">            honeyDbStack.dbName = (String) logDataFields.get(FIELD_DB_NAME);</span><br><span class="line">            honeyDbStack.sqlText = (String) logDataFields.get(FIELD_SQL_TEXT);</span><br><span class="line">            honeyDbStack.sqlParams = (String) logDataFields.get(FIELD_SQL_PARAMS);</span><br><span class="line">            honeyDbStack.sqlDuration = new BigDecimal(String.valueOf(logDataFields.get(FIELD_SQL_DURATION)))</span><br><span class="line">                    .divide(BigDecimal.valueOf(1000), SCALE , RoundingMode.DOWN).toString();</span><br><span class="line">            honeyDbStack.sqlTimestamp = new BigDecimal(String.valueOf(logDataFields.get(FIELD_SQL_TIMESTAMP)))</span><br><span class="line">                    .divide(BigDecimal.valueOf(1000), SCALE , RoundingMode.DOWN).toString();</span><br><span class="line">            return honeyDbStack;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<strong>HoneySpanReportEntity</strong>中做如下修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class HoneySpanReportEntity &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    private List&lt;HoneyDbStack&gt; dbStacks = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addDbStack(HoneyDbStack honeyDbStack) &#123;</span><br><span class="line">        dbStacks.add(honeyDbStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    public static class HoneySpanReportEntityBuilder &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        private Consumer&lt;LogData&gt; handleLogData(HoneySpanReportEntity honeySpanReportEntity) &#123;</span><br><span class="line">            return new Consumer&lt;LogData&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(LogData logData) &#123;</span><br><span class="line">                    if (LOG_EVENT_KIND_REQUEST_STACK.equals(logData.getFields().get(LOG_EVENT_KIND))) &#123;</span><br><span class="line">                        HoneyRequestStack honeyRequestStack = HoneyRequestStack.HoneyRequestStackBuilder</span><br><span class="line">                                .builder()</span><br><span class="line">                                .withLogData(logData)</span><br><span class="line">                                .build();</span><br><span class="line">                        honeySpanReportEntity.addRequestStack(honeyRequestStack);</span><br><span class="line">                    &#125; else if (LOG_EVENT_KIND_DB_STACK.equals(logData.getFields().get(LOG_EVENT_KIND))) &#123;</span><br><span class="line">                        HoneyDbStack honeyDbStack = HoneyDbStack.HoneyDbStackBuilder</span><br><span class="line">                                .builder()</span><br><span class="line">                                .withLogData(logData)</span><br><span class="line">                                .build();</span><br><span class="line">                        honeySpanReportEntity.addDbStack(honeyDbStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，在打印链路日志时，就会带上<strong>dbStack</strong>了。</p>
<h3 id="七-演示案例"><a href="#七-演示案例" class="headerlink" title="七. 演示案例"></a>七. 演示案例</h3><p>改造<strong>example-service-1</strong>，进行数据库链路追踪的测试。</p>
<p>首先<strong>pom</strong>文件添加如下依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>由于需要把映射文件打进<strong>jar</strong>包，<strong>pom</strong>文件还需要添加如下构建步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>然后使用如下<strong>DDL</strong>语句在<strong>MySQL</strong>数据库中创建一张表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码CREATE TABLE `people` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `p_name` varchar(255) NOT NULL,</span><br><span class="line">  `p_age` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>这张表的映射接口，映射文件和对应实体对象如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public interface PeopleMapper &#123;</span><br><span class="line"></span><br><span class="line">    People selectOne(@Param(&quot;peopleName&quot;) String peopleName,</span><br><span class="line">                     @Param(&quot;peopleAge&quot;) int peopleAge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.honey.tracing.example.mapper.PeopleMapper&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;peopleResultMap&quot; type=&quot;com.honey.tracing.example.entity.People&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;peopleName&quot; column=&quot;p_name&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;peopleAge&quot; column=&quot;p_age&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;selectOne&quot; resultMap=&quot;peopleResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            p.id,</span><br><span class="line">            p.p_name,</span><br><span class="line">            p.p_age</span><br><span class="line">        FROM</span><br><span class="line">            people p</span><br><span class="line">        WHERE</span><br><span class="line">            p.p_name=#&#123;peopleName&#125;</span><br><span class="line">        AND</span><br><span class="line">            p.p_age=#&#123;peopleAge&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class People &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String peopleName;</span><br><span class="line">    private int peopleAge;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置文件中加入数据库相关配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://192.168.101.5:3306/test</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>由于并没有通过<strong>mybatis.mapper-locations</strong>来指定映射文件位置，所以我们需要在启动类上添加@<strong>MapperScan</strong>注解来扫描得到映射接口和映射文件，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@MapperScan</span><br><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后提供一个<strong>MyBatisController</strong>来查询数据库，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@RestController</span><br><span class="line">public class MyBatisController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PeopleMapper peopleMapper;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/mybatis/select&quot;)</span><br><span class="line">    public People selectOne(@RequestParam(&quot;peopleName&quot;) String peopleName,</span><br><span class="line">                            @RequestParam(&quot;peopleAge&quot;) int peopleAge) &#123;</span><br><span class="line">        return peopleMapper.selectOne(peopleName, peopleAge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<strong>example-service-1</strong>，调用如下接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt复制代码http://localhost:8080/mybatis/select?peopleName=Lee&amp;peopleAge=20</span><br></pre></td></tr></table></figure>

<p>链路日志打印如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;</span><br><span class="line">    &quot;traceId&quot;: &quot;a33ddc958ecc4a46cf2a63b19a6fd064&quot;,</span><br><span class="line">    &quot;spanId&quot;: &quot;cf2a63b19a6fd064&quot;,</span><br><span class="line">    &quot;parentSpanId&quot;: &quot;0000000000000000&quot;,</span><br><span class="line">    &quot;timestamp&quot;: &quot;1709298263420&quot;,</span><br><span class="line">    &quot;duration&quot;: &quot;7&quot;,</span><br><span class="line">    &quot;httpCode&quot;: &quot;200&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;http://localhost:8080&quot;,</span><br><span class="line">    &quot;requestStacks&quot;: [],</span><br><span class="line">    &quot;dbStacks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;dbServer&quot;: &quot;192.168.101.8:3306&quot;,</span><br><span class="line">            &quot;dbName&quot;: &quot;test&quot;,</span><br><span class="line">            &quot;sqlText&quot;: &quot;SELECT p.id, p.p_name, p.p_age FROM people p WHERE p.p_name=? AND p.p_age=?&quot;,</span><br><span class="line">            &quot;sqlParams&quot;: &quot;Lee,20&quot;,</span><br><span class="line">            &quot;sqlDuration&quot;: &quot;4&quot;,</span><br><span class="line">            &quot;sqlTimestamp&quot;: &quot;1709298263421&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于<strong>MyBatis</strong>拦截器，实现了数据库链路追踪，核心思路就是通过拦截器，拿到本次<strong>SQL</strong>执行的相关信息，并输出到链路信息中。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358688805157404709" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>NopReport的可扩展设计如何实现二维码导出</title>
    <url>/7358691823545581603.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NopReport是从零开始编写的下一代中国式报表引擎，它的核心仅有3000多行代码，但是完整实现了中国式非线性报表理论所定义的层次坐标和行列对称展开算法。</p>
<ul>
<li>使用介绍：<a href="https://zhuanlan.zhihu.com/p/620250740" target="_blank" rel="noopener">采用Excel作为设计器的开源中国式报表引擎:NopReport</a>, <a href="https://www.bilibili.com/video/BV1Sa4y1K7tD/" target="_blank" rel="noopener">视频讲解</a></li>
<li>源码分析: <a href="https://zhuanlan.zhihu.com/p/663964073" target="_blank" rel="noopener">非线性中国式报表引擎NopReport源码解析</a>，<a href="https://www.bilibili.com/video/BV17g4y1o7wr/" target="_blank" rel="noopener">视频讲解</a></li>
</ul>
<p>NopReport并没有内置二维码展现这种业务相关的组件，但是它遵循了可逆计算理论，所以内置了大量可扩展机制可以用于引入扩展组件。本文以实现二维码导出为例介绍NopReport中的可扩展机制，这些机制是基于可逆计算理论自然导出，并不限于在Nop平台中使用，对于其他框架的可扩展性也可以起到指导作用。</p>
<h2 id="一-配置导出二维码"><a href="#一-配置导出二维码" class="headerlink" title="一. 配置导出二维码"></a>一. 配置导出二维码</h2><p>目前<code>nop-report-ext</code>模块提供了二维码扩展组件。使用时需要引入如下jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.github.entropy-cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;nop-report-ext&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Excel模板中，通过单元格的注解调用<code>QRCODE()</code>扩展函数。<a href="https://gitee.com/canonical-entropy/nop-entropy/raw/master/nop-report/nop-report-demo/src/main/resources/_vfs/nop/report/demo/base/11-%E6%89%93%E5%8D%B0%E6%9D%A1%E7%A0%81%E5%92%8C%E4%BA%8C%E7%BB%B4%E7%A0%81.xpt.xlsx" target="_blank" rel="noopener">示例模板</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c47cea60b36eacea792851cf4b31bc0f0825ccfa9149fd0c2968efd1b6d43216" alt></p>
<ul>
<li>valueExpr: 这里只是通过valueExpr来直接指定一个演示用的输出值，实际开发中可以利用NopReport内置的其他机制来生成单元格的值</li>
<li>formatExpr: 因为在最终输出的Excel以及展示用的HTML页面上我们并不需要输出单元格的值，所以这里指定formatExpr返回空字符串。否则在二维码上会叠加显示对应的文本。</li>
<li>processExpr: 调用扩展函数<code>QRCODE</code>，实际生成二维码</li>
<li><code>qr:barcodeFormat</code>: 指定输出条码格式，缺省是<code>QRCODE</code>，指定为<code>CODE_128</code>生成条形码。</li>
</ul>
<p><code>qr:</code>为前缀的变量是传递给<code>QRCODE</code>函数的扩展数据，但是并不需要直接作为<code>QRCODE</code>函数的参数传递。可以设置的属性值对应于<a href="https://gitee.com/canonical-entropy/nop-entropy/blob/master/nop-integration/nop-integration-api/src/main/java/io/nop/integration/api/qrcode/QrcodeOptions.java" target="_blank" rel="noopener">QrcodeOptions.java</a>类中的成员变量。</p>
<p>可以通过<code>qr:width</code>和<code>qr:height</code>来指定输出图形的大小。如果不指定，则会自动使用当前单元格的宽高。</p>
<h2 id="二-实现原理"><a href="#二-实现原理" class="headerlink" title="二. 实现原理"></a>二. 实现原理</h2><h3 id="1-单元格模型的可扩展属性"><a href="#1-单元格模型的可扩展属性" class="headerlink" title="1. 单元格模型的可扩展属性"></a>1. 单元格模型的可扩展属性</h3><p>NopReport的设计遵循可逆计算原理，系统化的采用 <code>(data,ext_data)</code>这样的配对设计，确保在任何模型节点上都可以追加扩展属性。缺省情况下，所有具有名字空间的属性都不参与元模型校验，因此我们可以引入<code>qr</code>名字空间，通过它设置二维码输出所需要的配置信息，比如二维码格式、大小等。如果需要校验qr名字空间中的属性格式，则可以引入一个自定义的xdef元模型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;workbook xdef:check-ns=&quot;qr&quot;&gt;</span><br><span class="line">  &lt;sheets&gt;</span><br><span class="line">    &lt;sheet&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;rows&gt;</span><br><span class="line">          &lt;cell&gt;</span><br><span class="line">            &lt;model xdef:name=&quot;XptCellModel&quot;</span><br><span class="line">                   qr:barcodeFormat=&quot;string&quot; qr:margin=&quot;int&quot; qr:imgType=&quot;string&quot; qr:width=&quot;double&quot;</span><br><span class="line">                   qr:height=&quot;double&quot; qr:encoding=&quot;string&quot; qr:errorCorrection=&quot;int&quot;&gt;</span><br><span class="line">            &lt;/model&gt;</span><br><span class="line">          &lt;/cell&gt;</span><br><span class="line">        &lt;/rows&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    &lt;/sheet&gt;</span><br><span class="line">  &lt;/sheets&gt;</span><br><span class="line">&lt;/workbook&gt;</span><br></pre></td></tr></table></figure>

<p>目前NopReport采用Excel为可视化设计器，在单元格的注解中设置单元格模型信息。后续还会提供在线可视化编辑，此时就可以xdef元模型中声明的属性定义自动生成可视化编辑页面。</p>
<h3 id="2-可扩展的函数空间"><a href="#2-可扩展的函数空间" class="headerlink" title="2. 可扩展的函数空间"></a>2. 可扩展的函数空间</h3><p>NopReport提供了<code>expandExpr</code>、<code>valueExpr</code>、<code>formatExpr</code>、<code>styleIdExpr</code>、<code>processExpr</code>等多种表达式配置，可以调用外部函数来完成复杂逻辑处理。NopReport的表达式引擎从Nop平台内置的XLang表达式引擎扩展而来（在XLang EL的基础上增加了报表层次坐标语法），因此它自动继承了XLang中定义的全局函数和全局对象。同时，报表引擎还为报表执行环境引入了报表专用的一系列函数。</p>
<h4 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// 注册XLang EL全局函数</span><br><span class="line">EvalGlobalRegistry.instance().registerStaticFunctions(GlobalFunctions.class);</span><br><span class="line"></span><br><span class="line">// 注册Report执行环境专用的报表函数</span><br><span class="line">ReportFunctionProvider.INSTANCE.registerStaticFunctions(ReportExtFunctions.class);</span><br></pre></td></tr></table></figure>

<p>一般情况下可以仿照<code>nop-report-ext</code>模块中的做法，在初始化的时候注册扩展函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class ReportExtInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        ReportFunctionProvider.INSTANCE.</span><br><span class="line">                  registerStaticFunctions(ReportExtFunctions.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集成IoC容器"><a href="#集成IoC容器" class="headerlink" title="集成IoC容器"></a>集成IoC容器</h4><p>除了全局注册之外，在表达式中还可以直接通过<code>inject</code>函数获取到NopIoC容器中管理的bean，例如<code>inject(&#39;qrService&#39;).genQrCode(&#39;123456&#39;)</code>。</p>
<blockquote>
<p>因为NopIoC支持类似Spring容器的BeanScope概念，从NopIoC获取的bean不一定都是单例对象</p>
</blockquote>
<h4 id="调用时传入"><a href="#调用时传入" class="headerlink" title="调用时传入"></a>调用时传入</h4><p>在调用具体报表时还可以通过scope对象传入帮助对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码IEvalScope scope = XLang.newEvalScope();</span><br><span class="line">scope.setLocalValue(&quot;myTool&quot;, new MyTool());</span><br><span class="line">reportEngine.getRenderer(&quot;/my.xpt.xlsx&quot;,&quot;html&quot;).generateToFile(file, scope);</span><br></pre></td></tr></table></figure>

<p>在表达式中就可以调用myTool对象上的方法，例如<code>myTool.myMethod(cell.value)</code></p>
<h4 id="报表内定义"><a href="#报表内定义" class="headerlink" title="报表内定义"></a>报表内定义</h4><p>NopReport引擎与一般的报表引擎非常不一样的地方是，它非常强调报表模型的自包含性和自定义抽象的能力。在报表模型的【展开前】配置中，我们可以定义仅在这个报表中使用的函数。<strong>这个函数定义存放在报表模型中，而不需要外部注册或者传入</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/193f0f39a6875fceba5c9b2590f58ae0183cef3db93de8b65dac951943267a24" alt></p>
<p>在【展开前】配置中，我们可以利用XPL模板语言的标签库抽象，来动态加载外部标签函数。后续Nop平台将会为所有XPL配置段提供通用的逻辑编排可视化设计器，这样就可以使用可视化配置的方式为报表模型引入自定义函数。</p>
<ol start="3">
<li>隐式传递的上下文</li>
</ol>
<hr>
<p>Nop平台为开发自定义的领域模型(Domain Model)和领域特定语言(DSL, Domain Specific Language)提供了一系列标准的套路，这其中就包含在表达式语言中引入的隐式上下文的概念。</p>
<p>当我们在一个特定领域（或者特定业务场景）中工作的时候，总是会有一些系统性的背景知识，当我们编写特定的业务代码时，我们可以假定这些背景知识是已知的或者可以按照某种确定性的方式推导得到的，从而原则上并不需要在代码中明确指明。<br>但是一般情况下，我们编码使用的是通用语言和通用框架，并不存在一种简单的、标准化的方式将这些知识内置到语言中，因此我们经常会发现大量仅起粘结作用的胶水代码中，一些背景信息被重复的表达多次。</p>
<p>比如说，在报表引擎中，我们的背景知识是报表运行时总是存在一个上下文对象<code>IXptRuntime</code>，在我们调用函数的时候能否不显式传递这个参数，而是假定它是一种可以隐式传递的背景知识？<br>如果我们不希望在调用所有函数的时候都显式传递IXptRuntime，一般的做法是将上下文对象通过<code>ThreadLocal</code>这种近似全局变量的方式进行传递，这种方式会破坏函数的结构，引入不必要的复杂性。</p>
<p>Nop平台的XLang语言中引入了隐式参数的概念，它类似于Scala语言中的implicit语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scala复制代码// scala语言中的隐式参数</span><br><span class="line">def welcome(implicit name: String) = s&quot;Welcome, $name!&quot;</span><br><span class="line"></span><br><span class="line">implicit val guestName: String = &quot;Guest&quot;</span><br><span class="line"></span><br><span class="line">println(welcome) // 输出: Welcome, Guest!</span><br></pre></td></tr></table></figure>

<p>scala语言中会按照类型自动查找上下文中的implicit变量，并自动绑定为函数参数。 Nop平台的Xpl模板语言提供了implicit参数，但是它是按照name来实现隐式绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;!-- 标签库my.xlib --&gt;</span><br><span class="line"></span><br><span class="line">&lt;lib&gt;</span><br><span class="line">  &lt;tags&gt;</span><br><span class="line">    &lt;MyTag&gt;</span><br><span class="line">      &lt;attr name=&quot;xptRt&quot; implicit=&quot;true&quot; /&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        ...</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">    &lt;/MyTag&gt;</span><br><span class="line">  &lt;/tags&gt;</span><br><span class="line">&lt;/lib&gt;</span><br></pre></td></tr></table></figure>

<p>调用标签的时候可以传入xptRt参数。也可以不设置参数，则会自动绑定上下文中的同名变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;my:MyTag /&gt;</span><br></pre></td></tr></table></figure>

<p>在XLang表达式中，也提供了隐式传递IEvalScope的机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码    @EvalMethod</span><br><span class="line">    public static ExcelImage QRCODE(IEvalScope scope) &#123;</span><br><span class="line">        IXptRuntime xptRt = IXptRuntime.fromScope(scope);</span><br><span class="line">        ExpandedCell cell = xptRt.getCell();</span><br><span class="line"></span><br><span class="line">        QrcodeOptions options = new QrcodeOptions();</span><br><span class="line">        cell.getModel().readExtProps(&quot;qr:&quot;, true, options);</span><br><span class="line">        ...</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果函数上标记了<code>@EvalMethod</code>注解，则第一个参数必须是IEvalScope。在表达式中调用的时候会自动传入表达式的运行时scope。通过scope可以获取到上下文中的其他变量。</p>
<p><code>ReportExtFunctions</code>中定义的<code>QRCODE</code>函数就是使用这种隐式参数机制，因此不需要显式传递IXptRuntime上下文对象。在<code>QRCODE</code>函数中可以通过IXptRuntime得到当前正在处理的单元格对象，并进而可以获取到单元格模型上的扩展属性。</p>
<p>基于可逆计算理论设计的低代码平台NopPlatform已开源：</p>
<ul>
<li>gitee: <a href="https://gitee.com/canonical-entropy/nop-entropy" target="_blank" rel="noopener">canonical-entropy/nop-entropy</a></li>
<li>github: <a href="https://github.com/entropy-cloud/nop-entropy" target="_blank" rel="noopener">entropy-cloud/nop-entropy</a></li>
<li>开发示例：<a href="https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/tutorial/tutorial.md" target="_blank" rel="noopener">docs/tutorial/tutorial.md</a></li>
<li><a href="https://www.bilibili.com/video/BV14u411T715" target="_blank" rel="noopener">可逆计算原理和Nop平台介绍及答疑_哔哩哔哩_bilibili</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358691823545581603" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,低代码,架构</tag>
      </tags>
  </entry>
  <entry>
    <title>突破数据存储瓶颈！转转业财系统亿级数据存储优化实践</title>
    <url>/7358704806779437097.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><h3 id="1-1-现状"><a href="#1-1-现状" class="headerlink" title="1.1 现状"></a>1.1 现状</h3><p>目前转转业财系统接收了上游各个业务系统（例如：订单、oms、支付、售后等系统）的数据，并将其转换为财务数据，最终输出财务相关报表和指标数据，帮助公司有效地进行财务管理和决策。</p>
<p>转转业财系统于2021年开始构建，前期为了满足需求短时间内上线，选择了主动接收上游业务系统的数据。然而随着时间的推移，数据量在不断增长，系统已经达到无法承载的边缘，引发了许多问题。因此，我们需要对数据存储进行优化。</p>
<h3 id="1-2-数据量统计"><a href="#1-2-数据量统计" class="headerlink" title="1.2 数据量统计"></a>1.2 数据量统计</h3><p>业财系统数据量较大表统计：</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>行数</th>
<th>数据长度</th>
<th>索引长度</th>
</tr>
</thead>
<tbody><tr>
<td>出库明细表</td>
<td>106280176</td>
<td>29.48GB</td>
<td>34GB</td>
</tr>
<tr>
<td>出库单头表</td>
<td>25344110</td>
<td>7GB</td>
<td>6GB</td>
</tr>
<tr>
<td>入库明细表</td>
<td>22766910</td>
<td>8GB</td>
<td>5GB</td>
</tr>
<tr>
<td>销售订单表</td>
<td>29578659</td>
<td>10GB</td>
<td>9GB</td>
</tr>
<tr>
<td>应收单表</td>
<td>24686267</td>
<td>5GB</td>
<td>2GB</td>
</tr>
<tr>
<td>入库单表</td>
<td>20777457</td>
<td>4GB</td>
<td>6GB</td>
</tr>
<tr>
<td>应付单表</td>
<td>15387724</td>
<td>4GB</td>
<td>2GB</td>
</tr>
</tbody></table>
<p>以下是数据量较大的表数据增量趋势图，可以观察到近几个月由于新业务的增加，每月的数据增量已经达到一千万。 <img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c89e234fc5c49460148a6e0cf5e7b1b360c7f34496ab2c305585f4f676296f68" alt></p>
<h3 id="1-3-慢查询情况"><a href="#1-3-慢查询情况" class="headerlink" title="1.3 慢查询情况"></a>1.3 慢查询情况</h3><p>从慢查询监控平台可以看到，每天慢查询个数已经到达千量级别。慢查询不仅影响用户体验，还会大量消耗所在机器资源，严重可能导致机器宕机。另外，转转MySQL数据库架构属于单机多实例，一台物理机上部署多套集群的实例，所以不仅会影响系统本身集群，还会拖累其他集群，引发雪球效应。 <img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/50b3d204816435d46970ed348685fdbc7b7c66458b4b424fc7cad68dca916f83" alt></p>
<h2 id="2-设计目标"><a href="#2-设计目标" class="headerlink" title="2.设计目标"></a>2.设计目标</h2><h3 id="2-1-解决数据量问题"><a href="#2-1-解决数据量问题" class="headerlink" title="2.1 解决数据量问题"></a>2.1 解决数据量问题</h3><p>在未来五年，不用考虑数据库数据量问题，能够轻松应对未来的业务增长和覆盖公司全量业务，且具备良好的扩展性，最终可以稳定向外输出更多数据报表等。</p>
<h3 id="2-2-解决读写性能"><a href="#2-2-解决读写性能" class="headerlink" title="2.2 解决读写性能"></a>2.2 解决读写性能</h3><p>通过此次优化，提升报表查询效率，减少定时任务执行时间，避免因为慢查询导致任务失败和接口超时问题，提高服务稳定性。</p>
<h2 id="3-方案选择"><a href="#3-方案选择" class="headerlink" title="3.方案选择"></a>3.方案选择</h2><h3 id="3-1-db存储方案选型"><a href="#3-1-db存储方案选型" class="headerlink" title="3.1 db存储方案选型"></a>3.1 db存储方案选型</h3><p>为解决底层表数据量问题，我们对比了以下四个方案：</p>
<ul>
<li><strong>方案一：分库分表</strong></li>
<li>优点</li>
</ul>
<ol>
<li>将数据分散到多个数据库和表中，从而减轻单一数据库的负载压力。这样可以提高数据库的读写性能和响应速度，降低查询延迟。</li>
<li>拆分的表结构相同，程序改造较少。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>需要提前规划好分片规则，一旦定好规则就难以移动，扩展性比较差。</li>
<li>拆分规则很难抽象出来。</li>
<li>跨库事务问题。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>数据库面临高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库既采用分表策略，又采用分库策略，以便同时扩展系统的并发处理能力，以及提升单表的查询性能。</li>
<li>数据有统一的业务规则主键，使数据可以均匀分布。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>业财系统作为底层系统，接受了各个业务系统的数据，数据比较多样性和复杂性，很难定义出一个业务主键，数据分布均匀困难。</li>
<li>若某业务数据量迅速增长或接入其他业务数据，那么可能又会面对数据量问题。</li>
</ol>
<ul>
<li><strong>方案二：冷热库</strong></li>
<li>优点</li>
</ul>
<ol>
<li>将不常访问的数据从在线存储中移动到归档存储中，减少了在线存储的容量需求，从而降低了存储成本。</li>
<li>减少了在线存储中数据的数量，因此可以提高数据库读写性能。</li>
<li>可以将历史数据长期保存，避免了数据的丢失。</li>
<li>可以将数据备份到不同的存储位置，以便在需要时进行数据恢复。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>需要保证归档事务性，防止归档数据同时出现在冷热库，出现数据重复。</li>
<li>需要考虑合适的归档策略，不影响服务访问。</li>
<li>需要有明确的业务边界，业务复杂的数据不适用。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>数据库中存在大量的历史数据，且查询频率比较低。</li>
<li>数据库的写入操作比读取操作更频繁。</li>
<li>数据库的存储成本较高，需要降低成本。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>业财系统业务数据复杂，现阶段还会更改和查询历史数据，时间口径不统一，边界比较模糊，无法确认一个准确的边界。</li>
<li>考虑后续接入更多的业务数据，由于目前无法统一数据格式，那么可能就需要重新考虑边界等问题。</li>
</ol>
<ul>
<li><strong>方案三：TiDB</strong></li>
<li>优点</li>
</ul>
<ol>
<li>高度兼容 MySQL：大多数情况下，无需修改代码即可从MySQL轻松迁移至TiDB。</li>
<li>水平弹性扩展：通过简单地增加新节点即可实现 TiDB 的水平扩展，按需扩展吞吐或存储，轻松应对高并发、海量数据场景。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>仍有一些MySQL的特性和行为，TiDB目前暂时不支持或表现与MySQL有差异。</li>
<li>系统复杂，组件太多。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景。</li>
<li>对存储容量、可扩展性、并发要求较高的大量数据及高并发的OLTP场景。</li>
<li>数据汇聚、二次加工处理的场景。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>由于TiDB兼容了MySQL，所以改动点也较少。</li>
<li>近几年是不用考虑数据量问题，可以接入更多样化数据。</li>
<li>TiDB能够支持大表经常有加列减列的需求，可扩展性高，目前也比较符合业财现状。</li>
</ol>
<ul>
<li><strong>方案四：OceanBase</strong></li>
<li>优点</li>
</ul>
<ol>
<li>高性能：采用了读写分离的架构，把数据分为基线数据和增量数据。其中增量数据放在内存里（MemTable），基线数据放在SSD盘（SSTable）。对数据的修改都是增量数据，只写内存。所以DML是完全的内存操作，性能非常高。</li>
<li>高兼容：兼容常用MySQL/ORACLE功能及MySQL/ORACLE前后台协议，业务零修改或少量修改即可从MySQL/ORACLE迁移至OceanBase。</li>
<li>高可用：数据采用多副本存储，少数副本故障不影响数据可用性。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>对环境要求极高，需要采购使用其指定的服务器。</li>
<li>学习和运维成本比较高。</li>
<li>尽管OceanBase具有高可用性的特性，但其实现仍然依赖于底层硬件和网络的稳定性。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>金融级数据可靠性需求。金融环境下通常对数据可靠性有更高的要求，OceanBase 每一次事务提交，对应日志总是会在多个数据中心实时同步，并持久化。</li>
<li>数据库面对飞速增长的业务数据量。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>目前运维没有维护，所以就不考虑此方案，大家可以参考此方案是否适用于本身系统。</li>
</ol>
<p>综合以上各个方案的分析，目前最适用于转转业财系统的方案是TiDB。该方案能够在短时间内解决数据量问题，并且改动成本相对较低。</p>
<h3 id="3-2-慢查询优化方案"><a href="#3-2-慢查询优化方案" class="headerlink" title="3.2 慢查询优化方案"></a>3.2 慢查询优化方案</h3><p>在分析了慢查询语句以后，发现大部分慢查询都是由于联表查询导致的，所以此次主要解决联表问题。 联表解决方案对比如下，根据适用分析选择ES方案。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>业财适用分析</th>
</tr>
</thead>
<tbody><tr>
<td>宽表</td>
<td>1.宽表可能包含大量重复数据，导致存储空间的浪费。这会增加数据库的存储需求，尤其在大规模数据集上会更为显著 2.由于涉及到大量列和关联数据，后续性能优化可能需要考虑更多的因素，而且可能需要采用复杂的索引策略 3.复杂度增加，改动量比较大</td>
</tr>
<tr>
<td>ES</td>
<td>1.通过建立索引方式解决联表问题，也一并提高了查询效率 2.后续可扩展性比较高，增加查询条件等，都易实现 3.需要保持数据源与ES数据一致问题 4.可以减低现有的数据库索引数据量</td>
</tr>
</tbody></table>
<h2 id="4-方案实践"><a href="#4-方案实践" class="headerlink" title="4.方案实践"></a>4.方案实践</h2><h3 id="4-1-方案实践步骤"><a href="#4-1-方案实践步骤" class="headerlink" title="4.1 方案实践步骤"></a>4.1 方案实践步骤</h3><p>根据方案选择分析，最适合业财系统当前状况的方案是首先切换底层数据存储，然后再接入ES。在实施这两个方案之前，我们需要考虑它们的先后顺序，并分析业财系统的现状。 由于数据量的突增，考虑到现有业务和后续新增业务，同时在不影响现有使用的前提下，首要需要解决的问题是数据量。因此，我们建议首先切换底层数据存储。这样做的好处是，即使在后续的实施中遇到问题，我们仍然可以回滚到原有的数据存储。这样既可以保证数据的完整性，也减少了实施过程中的风险。另一方面，如果我们选择先接入ES，就需要考虑如何保证数据切换过程中的数据完整性，并且同步方式也需要考虑两种不同数据存储方案之间的兼容性，这将增加许多额外的工作量和风险。</p>
<p>综上所述，我们选择的优化步骤是首先切换底层数据存储，待其稳定后再接入ES。这样能够有效解决当前的数据量问题，同时保证系统的稳定性和数据完整性。随后，我们可以继续进行ES的接入，以进一步优化业财系统的性能。</p>
<h3 id="4-2-切换底层数据存储步骤"><a href="#4-2-切换底层数据存储步骤" class="headerlink" title="4.2 切换底层数据存储步骤"></a>4.2 切换底层数据存储步骤</h3><p>在选择数据迁移方式时，考虑到业财系统对实时性要求并不是很高，且评估了下目前大部分数据接入写入方式，是可以接受停写几分钟，这样便大大降低了整个数据迁移成本。</p>
<p>迁移过程要求：</p>
<ol>
<li>检查TiDB是否都能兼容目前服务中的SQL语句，保证迁移之后系统不会报错。</li>
<li>数据需要保证完整性，迁移之后需要保证MySQL库和TiDB库的数据是严格一致。</li>
<li>迁移过程中需要做到可以回滚，一旦迁移过程中出现问题，可以立即回滚到MySQL库，不会对系统可用性造成影响。 <img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ca8cc0dcb8368371405ac5d8db4ac494a48e229de05f76d868f282b38f4e5d59" alt></li>
</ol>
<h3 id="4-3-接入ES"><a href="#4-3-接入ES" class="headerlink" title="4.3 接入ES"></a>4.3 接入ES</h3><ol>
<li>根据报表查询页面的功能和联表SQL分析，我们进行了索引模型设计，核心是优化查询性能和提高系统的响应速度。</li>
<li>在建立索引模型之后，我们需要考虑数据库（DB）与Elasticsearch（ES）之间增量数据的同步方式。</li>
</ol>
<p>以下表格是对比了四种不同的同步方式，我们根据已设计的索引分析，考虑到每个索引涉及的表较多、相关业务代码尚未收口以及对实时性较高的需求，我们决定采用数据订阅的方式进行同步。在当前公司提供的实现方式中，我们选择了Kafka。</p>
<table>
<thead>
<tr>
<th>同步方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>同步双写</td>
<td>这种方式简单粗暴，实时性高</td>
<td>1.业务耦合：这种方式代码侵入性强，耦合大量数据同步代码，要在写DB的地方写ES的代码 2. 影响性能：写入两个存储，响应时间变长，系统的性能必然会下降 3.不便扩展：搜索可能有一些个性化需求，需要对数据进行聚合，这种方式不便实现 4.高风险：存在双写失败丢数据风险</td>
</tr>
<tr>
<td>异步双写</td>
<td>1.性能高 2.不易出现数据丢失问题 3.多源写入之间相互隔离，便于扩展更多的数据源写入</td>
<td>1.硬编码问题，接入新的数据源需要实现新的消费者代码 2.系统复杂度增加，引入了消息中间件 3.MQ是异步消费模型，用户写入的数据不一定可以马上看到，造成延时</td>
</tr>
<tr>
<td>定期同步</td>
<td>实现比较简单</td>
<td>1.实时性难以保证 2.对存储压力较大</td>
</tr>
<tr>
<td>数据订阅</td>
<td>1.业务入侵较少 2.实时性比较高</td>
<td>需要选型数据订阅框架，系统复杂度增加</td>
</tr>
</tbody></table>
<ol start="3">
<li>在增量数据同步以后，最后一步就是需要完成历史数据的同步，此次我们选择的同步方式是公司内部提供的ECP，可以参考文章： <a href="https://dev.newban.cn/7354922285094207540">不可思议！亿级数据竟然如此轻松同步至ES！</a></li>
</ol>
<h2 id="5-总结与成果"><a href="#5-总结与成果" class="headerlink" title="5.总结与成果"></a>5.总结与成果</h2><p>目前，业财系统已成功完成底层数据存储的切换，可以看到近几年来不再担心数据量存储的问题，并且成功接入了更多的业务数据。随着引入了Elasticsearch（ES），业务人员也不再反馈报表页面超时等问题。这次针对数据存储的优化实质上是对系统的重构，选择方案时考虑了对系统影响范围较小且不影响业务人员使用的因素，这也是优化的核心所在。</p>
<p>由于历史原因，业财系统仍存在许多需要优化的方面，如慢SQL的持续治理、定时任务优化等。因此，我们需要保持此优化的核心理念，并在后续的重构中继续完善，以使业财系统更加稳定。</p>
<hr>
<blockquote>
<p>关于作者</p>
</blockquote>
<p>戴美琪，转转交易中台研发工程师</p>
<p><code>&gt; 转转研发中心及业界小伙伴们的技术学习交流平台，定期分享一线的实战经验及业界前沿的技术话题。</code></p>
<p><code>&gt; 关注公众号「转转技术」（综合性）、「大转转FE」（专注于FE）、「转转QA」（专注于QA），更多干货实践，欢迎交流分享~</code></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358704806779437097" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSFTP和FTP访问时相对路径引发的问题汇总</title>
    <url>/7358699186630098979.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>常用的 Java SSH 操作工具包是 jsch ，FTP 工具包 commons-net ，本文将总结 Java 程序通过 SFTP 协议和 FTP 协议访问远程文件的过程中，需要注意的路径问题。</p>
<p>本文主要包括下面三个问题：</p>
<ol>
<li>FTPClient 获取当前用户根目录的方法</li>
<li>ChannelSftp 获取当前用户根目录的方法。</li>
<li>目录切换时，如果是相对目录，可能存在的问题。</li>
<li>目标目录不存在时，逐级创建目录的方法。</li>
</ol>
<h3 id="相对路径操作注意事项"><a href="#相对路径操作注意事项" class="headerlink" title="相对路径操作注意事项"></a>相对路径操作注意事项</h3><p>jsch 通过 ChannelSftp 访问 SFTP 时，获取当前登录用户根目录的方法有两种：</p>
<ol>
<li><code>pwd()</code> 方法</li>
<li><code>getHome()</code> 方法</li>
</ol>
<p>两者在刚刚登录成功后返回的值是一样的，都是当前登录用户的 home 目录。<br>FTPClient 获取当前登录用户的根目录方法为：<code>printWorkingDirectory()</code> 。</p>
<p><strong>注意：如果操作的目标目录是相对路径</strong>，例如目标目录变量名称为 dir，判断绝对路径的方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isNotAbsolutePath = !dir.startWith(File.separator);</span><br><span class="line">if (isNotAbsolutePath) &#123;</span><br><span class="line">   String homePath = ftpClient.printWorkingDirectory();</span><br><span class="line">   或 </span><br><span class="line">   String homePath = sftpChannel.pwd();</span><br><span class="line">   </span><br><span class="line">   // 最后拼接上根目录</span><br><span class="line">   dir = homePath + File.separator + dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正操作目标路径为绝对路径后，后面的操作就不会报文件不存在错误了。</p>
<h3 id="listFiles-的内容"><a href="#listFiles-的内容" class="headerlink" title="listFiles 的内容"></a>listFiles 的内容</h3><p>FTPClient 的 listFiles 文件列表中不包含 <code>.</code> 和 <code>..</code> 这两个特殊的文件，但是使用 jsch 的 <code>ChannelSftp</code> 的 ls 直接列出的文件却包含 <code>.</code> 和 <code>..</code> 。</p>
<p>所以在遍历文件过程中，对于 Sftp 访问操作，需要排除这两种特殊文件。</p>
<h3 id="相对路径时-ls-或-cd-异常问题"><a href="#相对路径时-ls-或-cd-异常问题" class="headerlink" title="相对路径时 ls 或 cd 异常问题"></a>相对路径时 ls 或 cd 异常问题</h3><p>如果使用相对路径，ChannelSftp 的 ls 操作会异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.jcraft.jsch.SftpException: No such file</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar:?]</span><br></pre></td></tr></table></figure>

<p>解决办法，就是第二部分「相对路径操作注意事项」的内容，必须在真正切换目录之前拼接上当前登录用户的根目录。</p>
<h3 id="逐级创建目录的方法"><a href="#逐级创建目录的方法" class="headerlink" title="逐级创建目录的方法"></a>逐级创建目录的方法</h3><p>Java 的 FTP 和 SFTP 工具操作是的 mkdir 方法，当父级目录不存在时，直接用目录创建方法会失败，只能逐级创建每个目录。</p>
<p>确实有些场景下需要自动创建一个多层级的新目录，解决办法就是逐级拆解路径，判断当前路径是否存在，如果不存在，就创建，直到到达最后一级。</p>
<p>FTPClient 逐级创建一个目标目录 <code>dirPath</code> 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createFilePath(FTPClient ftpClient, String filePath) &#123;</span><br><span class="line">    String[] dirPaths = filePath.split(&quot;/&quot;);</span><br><span class="line">    for (int i = 0; i &lt; dirPaths.length; i++) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(dirPaths[i])) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            buffer.append(dirPaths[j]).append(&quot;/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tempDir = buffer.toString();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 切换目录，如果成功，则忽略</span><br><span class="line">            boolean change= ftpClient.changeWorkingDirectory(filePath);</span><br><span class="line">            if (change) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 切换失败，则创建</span><br><span class="line">            boolean result = ftpClient.makeDirectory(tempDir);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            // ERROR</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelSftp 逐级创建一个目标目录 <code>dirPath</code> 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean createFilePath(ChannelSftp channelSftp, String filePath) &#123;</span><br><span class="line">    String[] dirPaths = filePath.split(&quot;/&quot;);</span><br><span class="line">    for (int i = 0; i &lt; dirPaths.length; i++) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(dirPaths[i])) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            buffer.append(dirPaths[j]).append(&quot;/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tempDir = buffer.toString();</span><br><span class="line">        try &#123;</span><br><span class="line">            channelSftp.mkdir(tempDir);</span><br><span class="line">        &#125; catch (SftpException ex) &#123;</span><br><span class="line">            // ERROR</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FTPClient 有 changeWorkingDirectory 方法返回一个 boolean 值，可以判断目录是否存在，不存在可以执行创建操作；ChannelSftp 的 cd 没有返回值，所以直接mkdir 逐级创建。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358699186630098979" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs开发进阶L-异步执行和优化机制</title>
    <url>/7358704808525381651.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章节笔者想要来讨论一下JavaScript异步执行相关的内容，这个内容本来是应该放在本系列中比较前面的部分的，但由于思考和规划的问题，到现在才有机会涉及和实现。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在准备本文的时候，笔者参考了一些技术博客和文档，结合以前的一些应用的经验和体验，笔者已经了解到JS代码执行的基本原理，包括其中的一些核心概念。关于同步线程这部分一般没有太多的疑问。但很多材料都提到了异步任务这里面包括了微任务和宏任务及其执行策略等，并例举了一些方法并对其进行了归类。笔者原来也是大致这么理解的，但随着深入的了解和思考，特别是参考了nodejs官方的技术文档，笔者觉得原来的一些常规的理解，好像有一些不准确或者被误导的地方，当然也可能是版本或者认知演进的结果。这里笔者想来先探讨一下。</p>
<p>这个文档在这里： <a href="https://nodejs.org/en/guides/event-loop-timers-and-nexttick" target="_blank" rel="noopener">nodejs.org/en/guides/e…</a></p>
<p>笔者觉得这个材料里面的描述应该更加准确，本文中的阐述，就以此文作为基本的依据，并结合笔者的理解展开。</p>
<p>首先我们还是来复述和熟悉和复述一下JS执行代码的基本原理和方式。和传统程序顺序式的执行方式不同，JS程序的执行特点是虽然JS主要以单线程的模式运行，但通过事件循环的调度模式，它可以支持异步代码以非阻塞的方式执行，从而获得更充分的CPU运行资源的利用，和更高效的IO操作。整个执行模型，涉及以下核心的流程和概念：</p>
<ul>
<li>单线程模型 (Single Thread)</li>
</ul>
<p>在JS程序执行时，在其主进程中，代码和程序默认是以单线程模型来进行执行的。它将要执行的代码和任务分成两个大类：同步线程和异步任务。程序会先执行同步线程中，此处所有任务完成后，会使用事件循环的调度机制来实现代码和程序的非阻塞的异步执行。</p>
<p>同步线程的执行容易理解，和常规的软件程序基本无异。但在事件循环机制中，异步化程序和任务可能是以交错的形式来进行的，但编写代码和调用程序只能使用顺序的方式，这通常是刚接触JS程序的开发者容易感到比较困惑的地方。</p>
<p>但笔者觉得不必过分担心，在对JS的执行机制有了基础的理解和认知，并且经过一段时间的实践和操作后，开发者一个个就可以比较熟练的掌握这个机制，并正确的编写和执行相关代码，来满足应用和业务的需求。</p>
<ul>
<li>同步线程（Synchronous Thread）</li>
</ul>
<p>指的是在JS的主线程中，使用同步方式，按照顺序执行的普通代码和任务。这些代码会按照书写顺序从上到下执行，每行同步代码在执行时，JavaScript引擎其实会一直阻塞，直到此任务执行完毕，然后才会执行下一个任务。这就是所谓的阻塞式执行。</p>
<p>所有同步线程代码执行完成之后，JS引擎就会使用事件循环机制来执行异步代码。整个程序进入事件循环的处理阶段。从表面上看来，这个主线程已经执行完成了，分支任务会进入非阻塞的执行模式。就是所谓的非阻塞执行。</p>
<ul>
<li>事件循环</li>
</ul>
<p>事件循环是nodejs进行异步代码执行的核心调度和控制机制。通过这个机制，nodejs可以尽量将操作卸载到操作系统内核来执行非阻塞I/O操作。由于大多数现代操作系统内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会通知nodejs，以便将适当的回调添加到轮询队列中以完成最终执行。</p>
<p>下图简化显示了事件循环的操作顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           Timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>图中，每个框被称为事件循环的一个“阶段”。整个事件循环大体分为六个阶段，并且进行循环往复的运行。在每次运行事件循环之间，系统都会检查是否正在等待任何异步I/O或计时器，如果没有，则彻底关闭当前程序(程序自动退出)。</p>
<p>每个阶段都有一个要执行的回调的FIFO(先入先出)队列。虽然每个阶段都有其特殊之处，但通常，当事件循环进入给定阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列耗尽或达到最大回调数已执行。当队列耗尽或达到回调限制时，事件循环将进入下一阶段，依此类推。</p>
<p>由于这些操作中的任何一个都可能调度更多的操作，并且在轮询阶段处理的新事件由内核排队，因此轮询事件可以在处理轮询事件时排队。因此，长时间运行的回调可能会使轮询阶段的运行时间比计时器的阈值长得多。有关更多详细信息，请参阅计时器和轮询部分。</p>
<p>Windows和Unix/Linux实现之间存在轻微差异(因为涉及到操作系统底层的执行机制)，但这对于基本原理而言并不重要。下面我们分别简单说明一下这些执行阶段。</p>
<ul>
<li>计时器 Timers</li>
</ul>
<p>这个阶段，将会执行setTimeout和setInterval计划的回调。计时器指定了一个时间阈值，在该阈值之后可以执行所提供的回调，而非指定其希望执行的确切时间。这个回调方法将在指定时间过后“尽早”运行，显然操作系统调度或其他回调的运行可能会造成它们的延迟。从技术上讲，这个执行其实是在轮询阶段启动的。</p>
<ul>
<li>待处理回调 Pending Callbacks</li>
</ul>
<p>此阶段，执行被推迟到下一个循环迭代的I/O回调方法。</p>
<p>此阶段执行一下系统操作的回调，如TCP错误。例如，如果 TCP 套接字ECONNREFUSED在尝试连接时接收，某些 *nix 系统希望等待报告错误。这将在待处理回调阶段排队执行。</p>
<ul>
<li>空闲/准备 Idle/Prepare</li>
</ul>
<p>这个阶段仅在内部使用，和用户程序无关 。</p>
<ul>
<li>轮询 Poll</li>
</ul>
<p>这个阶段，其实是事件循环处理的核心阶段。此阶段主要有两个功能，第一是计算应该阻塞和轮询I/O的时间，然后处理轮询队列中的事件。具体而言，当事件循环进入轮询阶段并且没有调度计时器时，将发生以下两种情况之一：</p>
<p>一、如果轮询队列不为空，则事件循环将迭代其回调队列，并以同步方式执行它们，直到队列耗尽或达到系统相关的硬限制</p>
<p>二、如果轮询队列为空，则会发生以下两种情况之一：如果脚本已被调度setImmediate()，事件循环将结束轮询阶段并继续到检查阶段以执行那些调度的脚本；如果脚本尚未被调度setImmediate()，事件循环将等待回调被添加到队列中，然后立即执行它们。</p>
<p>一旦轮询队列执行完毕，事件循环将检查是否已达到时间阈值的计时器。如果一个或多个计时器准备就绪，事件循环将返回到计时器阶段以执行这些计时器的回调。</p>
<ul>
<li>检查 Check</li>
</ul>
<p>此阶段允许在轮询阶段完成后立即执行回调。如果轮询阶段变得空闲并且脚本已排队setImmediate()，则事件循环可能会继续进入检查阶段而不是等待。</p>
<p>setImmediate()实际上是一个特殊的计时器，在事件循环的单独阶段运行。它使用libuv API安排回调在轮询阶段完成后执行。</p>
<p>一般来说，随着代码的执行，事件循环最终将进入轮询阶段，它将等待传入的连接、请求等。但是，如果已安排回调并且setImmediate() 轮询阶段变得空闲，则它将结束并继续 检查阶段而不是等待轮询事件。</p>
<ul>
<li>关闭回调 Close Callbacks</li>
</ul>
<p>如果系统关联的套接字或句柄突然关闭(例如socket.destroy()），该’close’事件将在此阶段发出。否则它将通过 发出process.nextTick()。</p>
<ul>
<li>setTimeout和setImmediate</li>
</ul>
<p>两者的主要差异是调用的时机不同。setImmediate设计为在当前轮询阶段完成后执行，setTimeout安排在最小时间阈值过去后运行。所以，在真正的程序中，计时器的执行顺序将根据调用它们的上下文而变化。如果两者都是从主模块内部调用的，那么计时将受到进程性能的约束，并可能受到其他程序的影响。</p>
<p>例如，如果我们运行以下不在I/O周期（即主模块）内的脚本，则两个计时器的执行顺序是不确定的，因为它受到进程性能的约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; console.log(&apos;immediate&apos;));</span><br></pre></td></tr></table></figure>

<p>有趣的是，笔者在实验中，并没有找到一个特定场景能够来验证这一点。大部分实验的结果表明，似乎setImmediate有更高的优先级和立即执行的机会。简单的理论上也可以理解，就是它会在poll阶段，有机会被执行，而不需要等待到timer阶段来处理。</p>
<p>实际上，这些细微的差异，对于我们开发普通的应用程序，几乎没有什么影响。除非是我们需要开发系统级，或者对性能和执行次序需要非常精密的控制，才有机会需要深入的理解和应用。我们只需要大致理解，回调方法，作为异步调用，可能会改变代码执行的顺序(相对于编写)，这时可能需要编写特别的代码组织方式，才可能可以控制异步代码可以按照预先的方式和顺序执行。</p>
<h2 id="回调地狱-Callback-Hell"><a href="#回调地狱-Callback-Hell" class="headerlink" title="回调地狱 Callback Hell"></a>回调地狱 Callback Hell</h2><p>按照JS异步调用函数默认的回调工作方式，当在逻辑上，对于比较复杂的有多个步骤的业务流程，可能需要将很多函数调用链接起来的时候，最简单的方式，就是将回调“嵌套起来”，就是在回调方法中，来调用其他的异步方法。这个时候，对于一个比较复杂的调用链，就会出现所谓“回调地狱”的情况(借用下图)。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c37a6971c99c1b06ba748a2e4bc162c5da550ae78843899a726d66c745aea80" alt="callback-hell.png"></p>
<p>JS程序和执行器，其实对于这个情况是无所谓的，只要逻辑不冲突，写成什么样子，都不影响它的执行。感到恐慌的其实只有开发者，特别是那些有代码洁癖的人。当然，从软件工程的角度，这样的代码也确实不好调试、移植和维护，比如要在中间加一个处理环节，就不能像普通顺序执行的代码那么轻松简单了。</p>
<p>所以我们还是希望，尽量以人类比较好理解的方式，来组织这些代码和逻辑。因此，JS语言就引入了Promise和Async/Await等模式，它们都是用来方便解决这类问题而产生的。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>解决回调地狱的一个方式，是使用Promise(承诺)机制。关于这个机制的比较官方的解释和说明，应该在这里：</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">developer.mozilla.org/en-US/docs/…</a></p>
<p>笔者的简单解读和理解如下。</p>
<p>首先Promise是一个类和对象，它用于表示一个异步操作的事件性结束(无论成功或者失败)和其结果值。这个对象，有下列三种状态之一：</p>
<ul>
<li>Pending(等待): 也是其初始状态</li>
<li>Fulfilled(实现): 操作已经成功完成</li>
<li>Rejected(拒绝): 操作失败</li>
</ul>
<p>基于这个结构，我们可以进一步理解，Promise是未来某个值的代理，就是在Promise创建时该值可能还不确定，但是它允许你用它封装一个异步操作的处理程序，来返回最终成功值或者失败的信息。然后，可以像同步方法一样调用，并返回结果，不是立即返回最终值，而是返回Promise来在将来提供值(下图)。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b586bfdc6b7e72ddbf33f957000c3b0f73cd8beb604ef012d4568ce41a9a2ac9" alt="promises.png"></p>
<p>为了便于读者理解这个问题，并对Promise的执行方式有直观的了解，笔者编写了一个简单的扔硬币游戏，用到了Promise对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// promise define</span><br><span class="line">const p = new Promise((f,r)=&gt; Math.random()*10 &gt; 5 ? f(&quot;win&quot;) : r(&quot;false&quot;));</span><br><span class="line"></span><br><span class="line">// promise call</span><br><span class="line">p</span><br><span class="line">.then(d1=&gt;&#123; return d1; &#125;)</span><br><span class="line">.then(d2=&gt;console.log(d2))</span><br><span class="line">.catch(console.log);</span><br></pre></td></tr></table></figure>

<p>眼尖的读者应该可以看到，这个游戏的规则是必须两次都扔到正面才能算赢，否则都是输。这里的要点如下:</p>
<ul>
<li>Promise的构建函数，参数是一个方法，回调参数就是fulfill和reject方法</li>
<li>开发者应该可以根据业务需求，重写回调方法内容，在其中进行业务操作</li>
<li>在业务操作代码中的合适的场景，调用fulfill或者reject，代表Promise的等待状态结束并返回结果(成功或者失败)</li>
<li>可以使用then方法，来执行Promise，并捕获处理结果</li>
<li>可以使用catch方法，来捕获失败的信息</li>
<li>then方法可以多次调用，上一次成功调用的返回值，会作为参数传递到下一个调用</li>
<li>利用then的链接式调用，Promise可以处理逻辑前后关联的多个异步业务操作</li>
</ul>
<p>Promise的正常调用方法，都是在其原型中定义的：</p>
<ul>
<li>Promise.prototype.then()</li>
</ul>
<p>用于承载和处理fulfilled的结果，这个结果将会作为then方法的参数注入，便于在then方法内部进行引用和处理。由于此方法的返回结果是Promise实例本身，所以then方法可以支持链式调用的形式，可以处理流程化执行的场景。</p>
<ul>
<li>Promise.prototype.catch()</li>
</ul>
<p>用于承载和处理reject或者错误throw的结果，这个结果将会作为catch方法的参数注入，便于在其内部进行引用和处理。</p>
<ul>
<li>Promise.prototype.finally()</li>
</ul>
<p>表示Promise调用的结束，在这里可以做一些收尾的工作。我们可以发现，这个结构其实很像JS标准的try-catch-finally结构。</p>
<h2 id="Promise扩展方法"><a href="#Promise扩展方法" class="headerlink" title="Promise扩展方法"></a>Promise扩展方法</h2><p>前面我们已经看到了Promise的典型用法，但实际上原生的Promise其实有更丰富的特性。它们体现为一系列相关的静态方法，我们可以查阅Promise的文档，获得更完整的信息。</p>
<h3 id="快捷构造方法"><a href="#快捷构造方法" class="headerlink" title="快捷构造方法"></a>快捷构造方法</h3><p>首先是一类快速构造方法，它们可以用于快速的创建确定结果的Promise对象，方便日常开发和操作。</p>
<ul>
<li>resolve</li>
</ul>
<p>resolve方法，可以用于直接创建一个只能fulfilled的Promise对象。其参数是成功处理的结果。</p>
<ul>
<li>reject</li>
</ul>
<p>和resolve方法相对，它可以用于直接创建一个只能reject的Promise对象。</p>
<ul>
<li>withResolvers()</li>
</ul>
<p>这个方法用于快速的创建一个可结构的对象，包括Promise、Resolve和Reject方法，然后可以在后续定义处理方法。下面是一个简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; promise, resolve, reject &#125; = Promise.withResolvers();</span><br><span class="line"></span><br><span class="line">// 等效于</span><br><span class="line">let resolve, reject;</span><br><span class="line">const promise = new Promise((res, rej) =&gt; &#123; resolve = res; reject = rej; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="组合Promise方法"><a href="#组合Promise方法" class="headerlink" title="组合Promise方法"></a>组合Promise方法</h3><p>其中有一类是可以将多个Promise进行组合处理的方法，包括了all、allSettled、any、race等，它们都是Promise的静态方法，输入参数是多个Promise对象，可以处理多个Promise对象和它们之间的业务逻辑关系。</p>
<ul>
<li>all</li>
</ul>
<p>all方法的输入是一个Promise实例数组，它可以迭代这个数组并生成一个新的Promise对象，如果数组中所有的Promise都fulfilled，则整体fulfilled，并返回完成结果的数组；否则返回第一个reject的值。all方法将一个Promise数组当成单一Promise对象看待，只有所有操作都成功，则返回成功结果(也是以数组方式)，否则返回第一个失败的结果作为整体失败的结果。</p>
<ul>
<li>allSettled</li>
</ul>
<p>allSettled和all方法稍有差异，它也是返回一个结果Promise，但这个Promise的结果总是fulfilled一个和输入Promise数组对应的结果数组，里面同时包括成功或者失败结果。就如它的名字一样，它是能够成功返回所有结果已经设置好的这么一个Promise，只不过结果中有成功或者失败信息而已。这个结果是一个对象数组，对象属性包括status和value（详见示例）。</p>
<ul>
<li>any</li>
</ul>
<p>这个可以和all对应，类似于与和或的逻辑关系。就是只需要有一个fulfilled，这个结果就fulfilled；只有所有Promise都reject，结果Promise才reject。</p>
<ul>
<li>race</li>
</ul>
<p>就如方法名称那样，这个方法将同步执行输入Promise的数组，并将第一个有结果(成功或者失败)的Promise作为这个race Promise整体的结果。</p>
<p>可以看到，上面几个方法的基本逻辑都是可以将多个Promise转换并作为成为单一的Promise来处理，可以用于处理很多组合式的业务操作。下面笔者编写了一个简单的示例，让我们方便的对比和理解这些操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = Promise.resolve(3);</span><br><span class="line">const p2 = Promise.reject(&quot;false2&quot;);</span><br><span class="line">const p3 = 42;</span><br><span class="line">const p4 = new Promise((f,r) =&gt; setTimeout(f, 500, &apos;bar&apos;));</span><br><span class="line">const p5 = new Promise((f,r) =&gt; setTimeout(f, 200, &apos;foo&apos;));</span><br><span class="line"></span><br><span class="line">// all </span><br><span class="line">const pAll = (plist)=&gt; </span><br><span class="line">Promise.all(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;1 OK:&quot;, values))</span><br><span class="line">.catch(err=&gt;console.log(&quot;1 False:&quot;, err));</span><br><span class="line"></span><br><span class="line">pAll([p1,p3,p4]);</span><br><span class="line">pAll([p1,p4,p2]);</span><br><span class="line"></span><br><span class="line">// all setteled</span><br><span class="line">const pAllSet = (plist)=&gt; </span><br><span class="line">Promise.allSettled(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;2 Result:&quot;, values));</span><br><span class="line"></span><br><span class="line">pAllSet([p1,p3,p4]);</span><br><span class="line"></span><br><span class="line">// all setteled</span><br><span class="line">const pAny = (plist)=&gt; </span><br><span class="line">Promise.any(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;3 Result:&quot;, values))</span><br><span class="line">.catch(err=&gt;console.log(&quot;3 False:&quot;, err));</span><br><span class="line"></span><br><span class="line">pAny([p2,p3,p4]);</span><br><span class="line"></span><br><span class="line">// all setteled</span><br><span class="line">const pRace = (plist)=&gt; </span><br><span class="line">Promise.race(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;4 Result:&quot;, values))</span><br><span class="line">.catch(err=&gt;console.log(&quot;4 False:&quot;, err));</span><br><span class="line"></span><br><span class="line">pRace([p4,p5]);</span><br><span class="line"></span><br><span class="line">// result </span><br><span class="line">3 Result: 42</span><br><span class="line">1 False: false2</span><br><span class="line">4 Result: foo</span><br><span class="line">1 OK: [ 3, 42, &apos;bar&apos; ]</span><br><span class="line">2 Result: [</span><br><span class="line">  &#123; status: &apos;fulfilled&apos;, value: 3 &#125;,</span><br><span class="line">  &#123; status: &apos;fulfilled&apos;, value: 42 &#125;,</span><br><span class="line">  &#123; status: &apos;fulfilled&apos;, value: &apos;bar&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p>我们前面已经看到，使用Promise的链接的then方法调用，可以将多个异步调用可以从先后的逻辑上组织起来，模拟顺序调用的形式。但很多人觉得，这可能离传统的代码书写方式，天然的前后逻辑关系和调用次序的组织，还是有一些差异的。因此，JS社区就在Promise的基础上，进一步提出的async/await的执行模式。</p>
<p>我们先研究一段简单的代码，方便后续讨论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const pcall2 = async()=&gt;&#123;</span><br><span class="line">    await pAll([p1,p4,p2]);</span><br><span class="line">    await pAllSet([p1,p3,p4]);</span><br><span class="line">    await pAny([p4,p5]);</span><br><span class="line">    await pRace([p4,p5]);</span><br><span class="line">&#125;; pcall2();</span><br></pre></td></tr></table></figure>

<p>如果有读者注意到前面Promise章节示例代码的执行顺序的话，就会发现，它们并不是按照代码编写的顺序来执行的，而是按照异步执行的逻辑来执行。如果我们想要强制的按照调用顺序来执行，就需要使用asnyc/await机制来进行控制。从示例中，我们可以看到这个相关代码编写的规则如下：</p>
<p>async是一个修饰符或者声明，它加在函数的定义或者声明之前。这样，这个函数就有了两个额外的特性。第一，作为被调用者，这个函数可以返回一个Promise对象，并可以被await语句；第二，作为调用者，它可以作为await方法的容器，在其中，使用await方式调用的异步方法，都会严格按照编写顺序执行。</p>
<p>await是个异步方法执行修饰符。它可以像同步方法一样用于执行一个被Promise化的异步方法，它的返回值是正常resolve值。如果需要处理reject值，则可能需要使用try-catch机制。</p>
<p>所以我们可以看到，本质而言，async/await就是一个“语法糖”，用于满足编写更简洁、优雅、直观的JS异步执行代码的需求。在很多情况下，如果弄清了调用的逻辑关系， Promise的Then方法，和await调用方式也是可以组合使用的，它们在逻辑上是等效的。</p>
<h2 id="Async-Npm"><a href="#Async-Npm" class="headerlink" title="Async Npm"></a>Async Npm</h2><p>除了Nodejs官方提供的异步执行处理机制之外，开源社区在原来Nodejs异步机制尚不是特别完善的阶段，也提出了很多相关的技术方案，并以npm的形式交付。典型的如async，bluebird等等，但随着Nodejs本身的异步机制逐渐成熟，这些第三方库的必要性也在降低。</p>
<p>即便如此，除了处理Promise之外，以Async为代表的异步库，其实可以提供更多丰富而强大的异步执行控制的扩展功能。特别是Async库，笔者认为，对其充分的了解、掌握和使用，对于业务应用开发，还是有很大的帮助的。关于这一点，笔者有机会会另外专门写一个博客来讨论。async npm的官方页面在此处：</p>
<p><a href="https://caolan.github.io/async/v3/" target="_blank" rel="noopener">caolan.github.io/async/v3/</a></p>
<p>这里考虑到篇幅限制，只讨论一个简单的应用场景和实现，就是将多个并行的任务队列化。比如业务需求，需要在短时间内，通过请求外部 HTTP API接口方式，发送大量消息。我们了解到，最佳的策略并不是完全并发执行，那样会造成服务器短时间负载过大而宕机的风险，而是使用一个队列来处理发送，才能保证比较平稳而高效的完成所有的发送任务，从整体上达到最高的效率。这通常也被形象的称为“削峰填谷”。</p>
<p>我们下面，就以async为例，探讨一下它对于任务队列(queue)这种场景实现，它使用了queue模块。我们先讨论一下它的基本原理。</p>
<p>async/queue的大致工作原理是基于通过维护和执行一个任务队列对象来完成的。首先创建一个任务队列，这个步骤需要定义任务排队后执行的回调方法和并发数量；有任务到来时，默认被添加到队列尾部；任务处理从队列头部开始，队列会依次取出并且调用执行任务，它会将任务作为参数传入回调函数，并执行这个方法；执行完成后，会执行此回调预定的完成回调方法，来标识当前任务的完成； 看到任务完成之后，队列就将任务从队列中取出下一个任务来执行；如此往复，直到这个队列中所有的任务都完成，这里有一个名词就是Drain(耗尽)，这时队列就是空的了，它会等待新的任务入队。</p>
<p>基于此原理，其相关示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import queue from &apos;async/queue&apos;;</span><br><span class="line"></span><br><span class="line">// create a queue object with concurrency 2</span><br><span class="line">const q = async.queue(function(task, callback) &#123;</span><br><span class="line">    console.log(&apos;hello &apos; + task.name);</span><br><span class="line">    callback();</span><br><span class="line">&#125;, 2);</span><br><span class="line"></span><br><span class="line">// assign an error callback</span><br><span class="line">q.error(function(err, task) &#123;</span><br><span class="line">    console.error(&apos;task experienced an error&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// assign a callback</span><br><span class="line">q.drain(function() &#123;</span><br><span class="line">    console.log(&apos;all items have been processed&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// add some items to the queue</span><br><span class="line">q.push(&#123;name: &apos;foo&apos;&#125;, function(err) &#123;</span><br><span class="line">    console.log(&apos;finished processing foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// callback is optional</span><br><span class="line">q.push(&#123;name: &apos;bar&apos;&#125;);</span><br><span class="line"></span><br><span class="line">// add some items to the queue (batch-wise)</span><br><span class="line">q.push([&#123;name: &apos;baz&apos;&#125;,&#123;name: &apos;bay&apos;&#125;,&#123;name: &apos;bax&apos;&#125;], function(err) &#123;</span><br><span class="line">    console.log(&apos;finished processing item&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// add some items to the front of the queue</span><br><span class="line">q.unshift(&#123;name: &apos;bar&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing bar&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码来自async的官方示例，笔者进行了最简单的修改，这里的要点如下：</p>
<ul>
<li>queue是async库的一个模块和类，用于处理队列，需要先引用一下</li>
<li>在使用之前，需要先创建一个queue的实例</li>
<li>构建方法包括两个参数，第一个参数定义任务处理回调，第二个参数是可选并行任务的数量</li>
<li>任务处理回调方法中，定义具体的任务执行方式(业务需求)，并且在任务执行完成后，回调执行任务完成方法</li>
<li>可选定义error方法，用于处理队列级别的错误</li>
<li>可选定义drain方法，用于处理队列耗尽时，需要进行的操作</li>
<li>使用push方法，可以将任务加入到队列的尾部，排队等待处理，并且可选使用数组，同时加入多个任务</li>
<li>使用unshift方法，可以将任务加入到队列的头部，它们会被优先执行(在当前任务接收后就会被调用)</li>
<li>单个任务，也可以选择定义完成时的回调，作为一些任务的特别处理的机会</li>
<li>这里的任务，可以只包括业务数据，相关的调用和回调方法，可以选择设置</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文探讨了Nodejs应用中，异步执行相关的话题。包括Nodejs程序和代码执行的基本工作原理，对于异步执行的理解，回调地狱，Promise，Async/Await，以及Async NPM等相关的内容，希望能够帮助读者从简单的基础理论出发，结合Promise、Async等的实际应用，对JS的异步执行有更深入和细致的理解。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358704808525381651" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,JavaScript,Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】如何在Vue&lt;component&gt;切换子组</title>
    <url>/7358702198589341734.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中使用 Vue <code>&lt;component&gt;</code> 遇到了一些挑战，特别是在需要对子组件中的表单进行校验时。问题在于，通过点击 <code>&lt;el-aside&gt;</code> 标签切换子组件时，并不能自动触发表单校验，这就需要在父组件中集成对子组件表单的校验逻辑。因此写下本篇博文记录这个问题并分享相关思考以及解决方法。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3aaea1a5f0ad04d25e6627d0bc060036b2f6921d61864b38075a7744014deb10" alt="q0.gif"></p>
<p>本篇博文所使用到的所有代码<a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components" target="_blank" rel="noopener">点击此处进行跳转</a>。</p>
<p>博文中的所有代码全部收集在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsid10t%2Fvue-learn_and_upgrade" target="_blank" rel="noopener">博主的 GitHub 仓库</a>中，相关技术栈专栏如下：</p>
<ul>
<li><a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a>;</li>
<li><a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>;</li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>Vue2；</li>
<li>element 2.15.14；</li>
</ul>
<p>这里参照 <a href="https://element.eleme.cn/#/zh-CN/component/installation" target="_blank" rel="noopener">官方文档</a> 安装 Element，并在项目的 <code>main.js</code> 文件里进行导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import ElementUI from &apos;element-ui&apos;;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure>

<p>根据 <a href="https://element.eleme.cn/#/zh-CN/component/container" target="_blank" rel="noopener">官方文档</a> 构建一个自定义化容器，效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/becc929d12271c779ec37b9f62addce915fae1767f0d62364130bad426988d58" alt="q1.gif"></p>
<p>构建容器代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-container style=&quot;height: 700px; border: 1px solid #eee&quot;&gt;</span><br><span class="line">    &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;</span><br><span class="line">      &lt;el-menu :default-openeds=&quot;[&apos;1&apos;]&quot; @select=&quot;handleSelect&quot;&gt;</span><br><span class="line">        &lt;el-submenu index=&quot;1&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;</span><br><span class="line">            &gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;导航一</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">          &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">        &lt;/el-submenu&gt;</span><br><span class="line">        &lt;el-menu-item index=&quot;2&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;导航二&lt;/template&gt;</span><br><span class="line">        &lt;/el-menu-item&gt;</span><br><span class="line">        &lt;el-menu-item index=&quot;3&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;&gt;</span><br><span class="line">            &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;导航三</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/el-menu-item&gt;</span><br><span class="line">      &lt;/el-menu&gt;</span><br><span class="line">    &lt;/el-aside&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-main&gt;</span><br><span class="line">        &lt;ItemOne v-if=&quot;currentIndex === &apos;1&apos;&quot;&gt;&lt;/ItemOne&gt;</span><br><span class="line">        &lt;GroupOne v-else-if=&quot;currentIndex === &apos;1-1&apos;&quot;&gt;&lt;/GroupOne&gt;</span><br><span class="line">        &lt;GroupTwo v-else-if=&quot;currentIndex === &apos;1-2&apos;&quot;&gt;&lt;/GroupTwo&gt;</span><br><span class="line">        &lt;ItemTwo v-else-if=&quot;currentIndex === &apos;2&apos;&quot;&gt;&lt;/ItemTwo&gt;</span><br><span class="line">        &lt;ItemThree v-else-if=&quot;currentIndex === &apos;3&apos;&quot;&gt;&lt;/ItemThree&gt;</span><br><span class="line">      &lt;/el-main&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/el-container&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import GroupOne from &quot;@/components/GroupOne.vue&quot;;</span><br><span class="line">import GroupTwo from &quot;@/components/GroupTwo.vue&quot;;</span><br><span class="line">import ItemOne from &quot;@/components/ItemOne.vue&quot;;</span><br><span class="line">import ItemTwo from &quot;@/components/ItemTwo.vue&quot;;</span><br><span class="line">import ItemThree from &quot;@/components/ItemThree.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    GroupOne,</span><br><span class="line">    GroupTwo,</span><br><span class="line">    ItemOne,</span><br><span class="line">    ItemTwo,</span><br><span class="line">    ItemThree,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentIndex: &apos;1&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSelect(index) &#123;</span><br><span class="line">      this.currentIndex = index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件模板代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;导航一&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ItemOne&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-lt-component-gt-标签优化代码"><a href="#使用-lt-component-gt-标签优化代码" class="headerlink" title="使用 &lt;component&gt; 标签优化代码"></a>使用 <code>&lt;component&gt;</code> 标签优化代码</h1><p>当构建容器组件时，我们通常希望根据不同的条件，动态地渲染不同的子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-container&gt;</span><br><span class="line">  &lt;el-main&gt;</span><br><span class="line">    &lt;ItemOne v-if=&quot;currentIndex === &apos;1&apos;&quot;&gt;&lt;/ItemOne&gt;</span><br><span class="line">    &lt;GroupOne v-else-if=&quot;currentIndex === &apos;1-1&apos;&quot;&gt;&lt;/GroupOne&gt;</span><br><span class="line">    &lt;GroupTwo v-else-if=&quot;currentIndex === &apos;1-2&apos;&quot;&gt;&lt;/GroupTwo&gt;</span><br><span class="line">    &lt;ItemTwo v-else-if=&quot;currentIndex === &apos;2&apos;&quot;&gt;&lt;/ItemTwo&gt;</span><br><span class="line">    &lt;ItemThree v-else-if=&quot;currentIndex === &apos;3&apos;&quot;&gt;&lt;/ItemThree&gt;</span><br><span class="line">  &lt;/el-main&gt;</span><br><span class="line">&lt;/el-container&gt;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，使用了 <code>if-else</code> 结构来根据 <code>currentIndex</code> 的值选择不同的子组件进行展示。虽然这种方法可以实现功能，但随着子组件数量的增加，代码会变得冗长且难以维护。</p>
<p>为了优化这段代码，我们可以引入一个用于渲染动态组件或元素的 “元组件”：<code>&lt;component&gt;</code>，这是一个对象映射的方式，使代码更加简洁和易于管理，详细原理见<a href="https://cn.vuejs.org/api/built-in-special-elements.html#component" target="_blank" rel="noopener">官方文档</a>。</p>
<p>下面是详细的优化步骤：</p>
<ol>
<li>在 <code>data()</code> 中定义一个包含组件名称与对应索引关系的映射对象 <code>componentMap</code>，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    currentIndex: &apos;1&apos;,</span><br><span class="line">    componentMap: &#123;</span><br><span class="line">      &apos;1&apos;: &apos;ItemOne&apos;,</span><br><span class="line">      &apos;1-1&apos;: &apos;GroupOne&apos;,</span><br><span class="line">      &apos;1-2&apos;: &apos;GroupTwo&apos;,</span><br><span class="line">      &apos;2&apos;: &apos;ItemTwo&apos;,</span><br><span class="line">      &apos;3&apos;: &apos;ItemThree&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，通过计算属性来返回当前需要渲染的子组件，在组件中添加计算属性 <code>currentComponent</code>，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  currentComponents() &#123;</span><br><span class="line">    return this.componentMap[this.currentIndex]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后，在模板中使用这个计算属性来渲染子组件，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-container&gt;</span><br><span class="line">  &lt;el-main&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponents&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/el-main&gt;</span><br><span class="line">&lt;/el-container&gt;</span><br></pre></td></tr></table></figure>

<h1 id="单个组件表单验证"><a href="#单个组件表单验证" class="headerlink" title="单个组件表单验证"></a>单个组件表单验证</h1><p>我们以 <strong>导航二</strong> <code>ItemTwo</code> 为例，创建一个表单 Form，效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9eb2645af6ffd724763722f76e951664e7a9ca9b5fe672f85025c49a0577bd0c" alt="v1.png"></p>
<p>如果直接点击 “提交” 按钮，即使还有选项没有填写，表单也会被直接提交，效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c1634b44293b025f313e3cc7fcab4d79f232f8ce988592899444b96fb842fd44" alt="v2.png"></p>
<p><strong>因此我们需要进行表单验证，设置数据校验规则，在防止用户犯错的前提下，尽可能让用户更早地发现并纠正错误。</strong></p>
<p>Form 组件提供了表单验证的功能，只需要通过 <code>rules</code> 属性传入约定的验证规则，并将 Form-Item 的 <code>prop</code> 属性设置为需校验的字段名即可。校验规则参见 <a href="https://github.com/yiminghe/async-validator" target="_blank" rel="noopener">async-validator</a>。</p>
<p>下面是详细的验证步骤：</p>
<ol>
<li>在 <code>data()</code> 中定义一个表单规则 <code>rules</code>，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...,</span><br><span class="line">    rules: &#123;</span><br><span class="line">      name: [&#123; required: true, message: &quot;请输入姓名&quot;, trigger: &quot;blur&quot; &#125;],</span><br><span class="line">      sex: [&#123; required: true, message: &quot;请选择性别&quot;, trigger: &quot;change&quot; &#125;],</span><br><span class="line">      food: [</span><br><span class="line">        &#123; required: true, message: &quot;请选择喜欢吃的食物&quot;, trigger: &quot;change&quot; &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接着在 Form 组件中传入验证规则，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;el-form&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后在提交表单时，进行数据的校验，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  submitForm() &#123;</span><br><span class="line">    this.$refs.form.validate((valid) =&gt; &#123;</span><br><span class="line">      if (valid) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>最终效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e9165f934cc0d7b0117c64c2894c3d694909ff351856d7be0e37a0dd38e70c65" alt="v3.png"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components/ItemTwo.vue" target="_blank" rel="noopener">【ItemTwo.vue】代码点击此处跳转</a>。</p>
<h1 id="父组件调用子组件方法"><a href="#父组件调用子组件方法" class="headerlink" title="父组件调用子组件方法"></a>父组件调用子组件方法</h1><p>在介绍父组件验证子组件表单之前，需要了解一个前置知识：父组件如何调用子组件的方法。</p>
<p>接下来我们以 <code>App.vue</code> 作为父组件，<code>ItemThree.vue</code> 作为子组件进行介绍父组件如何调用子组件的方法。</p>
<p>1、构建子组件页面，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;导航三&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      响应内容: &lt;span style=&quot;color: #e86666&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ItemThree&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;当前没有响应内容！&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6b820c499230678f472110f4cefef9885b71bd82edf3a5b565f4e4ee2e7a6113" alt="z1.png"></p>
<p>2、编写一个子组件方法，可以更改 “响应内容”，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  changeMsg(owner) &#123;</span><br><span class="line">    this.msg = `$&#123;owner&#125; 组件改变了响应内容！`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ea3410b5e16798d47613e1875080ef4b1e2ed375973f50c83b050e35e768565a" alt="z2.png"></p>
<p>3、父组件通过 <code>ref</code> 属性来调用子组件的方法。</p>
<ol>
<li>向子组件添加 <code>ref</code> 属性，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;component :is=&quot;currentComponents&quot; ref=&quot;child&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写父组件调用子组件的方法，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  this.$refs.child.changeMsg(&quot;Parent&quot;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f0ca818a15370826fd580438cc699a1f354a9e16ad7404c62090077c2f3f6123" alt="z3.png"></p>
<ul>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/App.vue" target="_blank" rel="noopener">【App.vue】代码点击此处跳转</a>。</li>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components/ItemThree.vue" target="_blank" rel="noopener">【ItemThree.vue】代码点击此处跳转</a>。</li>
</ul>
<h1 id="父组件校验子组件表单"><a href="#父组件校验子组件表单" class="headerlink" title="父组件校验子组件表单"></a>父组件校验子组件表单</h1><p>1、在子组件中创建一个校验方法 <code>handleValidForm()</code>，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleValidForm() &#123;</span><br><span class="line">  let flag = false</span><br><span class="line">  this.$refs.form.validate((valid) =&gt; &#123;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">      flag = true</span><br><span class="line">      this.submitForm()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return flag</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>上述代码先对表单进行校验，若校验通过则触发表单提交，并返回一个标识位 <code>flag</code>，用于标识表单校验是否通过。</p>
<p>2、在父组件中调用此方法，通过获取到的标识位 <code>flag</code> 来判断表单是否校验通过，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleSelect(index) &#123;</span><br><span class="line">  if (this.$refs.child.handleValidForm())</span><br><span class="line">    this.currentIndex = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码表示如果校验通过，则实现子组件的切换，否则不做任何操作。</p>
<p>需要注意的是，每个被 <code>&lt;componet&gt;</code> 所使用的子组件都需要具有 <code>handleValidForm()</code> 方法，否则会出现报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue.runtime.esm.js:4427 [Vue warn]: Error in v-on handler: &quot;TypeError: this.$refs.child.handleValidForm is not a function&quot;</span><br></pre></td></tr></table></figure>

<p>3、效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f73ccef27d5d74179d842703bc15f7735485f1cbf0d5f8221a1e390e7c009b16" alt="q2.gif"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components" target="_blank" rel="noopener">【整体】代码点击此处跳转</a>。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>如何在 Vue <code>&lt;component&gt;</code> 切换子组件时优雅地进行 Form 表单校验</em></strong> 的所有内容了，希望本篇博文对大家有所帮助！欢迎大家持续关注我的博客，一起分享学习和成长的乐趣！✨</p>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7354960709010800677">解决 ECharts 图表窗口自适应与数据不渲染问题</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注，创作不易，请多多支持；</p>
<p>👍 公众号：<strong>sidiot的技术驿站</strong>；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a>；<a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>；<a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358702198589341734" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,前端,Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端的图片一般存储在哪？图片服务器</title>
    <url>/7358702198589505574.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图片和其他静态文件通常存储在服务器的硬盘或 SSD 上，可能直接存储在本地，或通过网络文件系统（如 NFS）访问，也可能存储在专门的静态内容服务器或 CDN（内容分发网络）上。</p>
<h1 id="图片服务器"><a href="#图片服务器" class="headerlink" title="图片服务器"></a>图片服务器</h1><p>那么这种专门用于存储和提供图片及其他多媒体内容的服务器叫做图片服务器，而这些服务器通常配置有用于快速读取的优化技术，如高速缓存和特定的文件访问策略。CDN 是提高全球访问速度的一种常用方法。</p>
<h2 id="处理其故障"><a href="#处理其故障" class="headerlink" title="处理其故障"></a>处理其故障</h2><ul>
<li><strong>使用 CDN</strong>: CDN 可以缓存全球多个位置的内容，如果原服务器挂掉，请求可以被重新定向到最近的缓存节点。</li>
<li><strong>服务器冗余</strong>: 大型服务通常会部署多台服务器，或使用云服务来提高可靠性，确保至少有一台服务器能处理请求。</li>
<li><strong>自动故障转移</strong>: 在多服务器配置中，可以配置负载均衡器自动检测服务器故障，并将流量转移到正常服务器。</li>
</ul>
<h2 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h2><ul>
<li><strong>硬盘驱动器（HDD）</strong> : 传统的硬盘驱动器因其较高的容量和较低的成本而被广泛使用，适合存储大量的图片文件。</li>
<li><strong>固态驱动器（SSD）</strong> : SSDs 提供更快的数据访问速度，对于需要频繁读取的图片，如网站的图标和常用图像，使用 SSD 可以提高访问速度。</li>
<li><strong>网络附加存储（NAS）</strong> : 对于大规模的应用，可能会使用 NAS 设备来集中管理图片文件，便于维护和扩展存储容量。</li>
<li><strong>对象存储</strong>: 大型应用，尤其是在云环境中，常使用对象存储（如 Amazon S3, Google Cloud Storage）来存储图片。对象存储提供了可扩展、耐用和高度可用的存储解决方案</li>
</ul>
<p>在这里详细讲下对象存储，因为我之前做项目时有用到过这个。</p>
<blockquote>
<p>对象存储是一种以非结构化格式（称为对象）存储和管理数据的技术。现代组织需要创建和分析大量非结构化数据，例如照片、视频、电子邮件、网页、传感器数据和音频文件。云对象存储系统将这些数据分布在多个物理设备上，但允许用户从单个虚拟存储库有效地访问内容。对象存储解决方案非常适合用于构建需要扩展和灵活性的云原生应用程序；您还可以使用这些解决方案导入现有数据存储以进行分析、备份或存档。</p>
</blockquote>
<p>这是<a href="https://aws.amazon.com/cn/what-is/object-storage/" target="_blank" rel="noopener">AWS</a>上对于对象存储的解释,那么我们可以从这提取到几个特点，它的可拓展性较好，因为存储的对象是非结构化格式。它也没有传统的目录结构，都是通过一个urlId进行访问的，同时它会把数据复制到多个存储设备上，保证其可用性和持久性。</p>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><ul>
<li><strong>直接文件访问</strong>: 在小型或低负载的应用中，直接从文件系统访问图片通常是可行的。</li>
<li><strong>CDN（内容分发网络）</strong> : 对于访问量大的应用，使用 CDN 可以将图片缓存于全球多个节点，用户可以从最近的节点加载图片，大幅提高速度。</li>
<li><strong>缓存机制</strong>: 在服务器端或应用层面实施缓存策略，如使用 Redis 或 Memcached 来缓存热点图片，可以减少对存储设备的访问次数，提高响应速度。</li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358702198589505574" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂Redis的RDB、AOF以及混合持久化机制</title>
    <url>/7358704808526102547.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  Redis ⽀持 RDB 和 AOF 两种持久化机制，Redis 4.0 之后又新增了混合持久化的方式。持久化功能有效地避免因进程退出造成数据丢失问题，当下次重启时利用之前持久化的⽂件即可实现数据恢复。</p>
<h2 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.RDB 持久化</h2><p>  RDB 持久化是把<strong>当前进程数据⽣成快照保存到硬盘的过程</strong>，触发 RDB 持久化过程分为⼿动触发和⾃动触发。</p>
<h3 id="1-1-触发"><a href="#1-1-触发" class="headerlink" title="1.1 触发"></a>1.1 触发</h3><p>  ⼿动触发分别对应<code>save</code>和<code>bgsave</code>命令：</p>
<ol>
<li><code>save</code>命令：阻塞当前<code>Redis</code>服务器，直到<code>RDB</code>过程完成为⽌，当内存⽐较⼤的时候可能造成⻓时间阻塞。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ebd234f00fb12cb85d960ba5d3072aec4173a87a715ee94172b5d48a4f9772d6" alt="image-20240417184452896"></p>
<ol>
<li><code>bgsave</code>命令：<code>Redis</code>进程执⾏<code>fork</code>操作创建⼦进程，<code>RDB</code>持久化过程由⼦进程负责，完成后⾃动结束。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d7a1a071587db1e143685c02e3c1ffd17b4d2a3aafd6b2d90c327509877007e0" alt="image-20240417184441652"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/16d8c5f2e1a76a7e50c1d8130bbc970f12cf502a96bc1b216a898e372bb6d5a7" alt="image-20240417190532767"></p>
<blockquote>
<p><code>fork()</code> 操作在<code>Linux</code>中是用于创建一个新的进程的系统调用，并且子进程的创建是对父进程的复制。参考了<a href="https://dev.newban.cn/7250283546367557692?searchId=202404171908050B578BFE9B0EAC21E7B5">Linux进程 | fork()系统调用详解 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>  自动触发的情况：</p>
<ol>
<li>在配置文件中<code>redis.conf</code>，配置 <code>save</code>，如<code>&quot;save m n&quot;</code>表⽰ <code>m</code> 秒内数据集发⽣了 <code>n</code> 次修改，⾃动<code>RDB</code>持久化。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0a2bdab225f3fb12beb9155ecc027bf967e9d2719e1c653500cd6b1ed880f104" alt="image-20240417184217337"></p>
<ol start="2">
<li>执⾏<code>shutdown</code>命令关闭<code>Redis</code>时，执⾏<code>RDB</code>持久化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码shutdown save</span><br></pre></td></tr></table></figure>

<h3 id="1-2-RDB-文件的处理"><a href="#1-2-RDB-文件的处理" class="headerlink" title="1.2 RDB 文件的处理"></a>1.2 RDB 文件的处理</h3><p>  持久化的数据是默认保存在<code>“/var/lib/redis/”</code>下，文件名可以通过 <code>dbfilename</code> 指定。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8f2a15ea81e03a3d11ef566693bb96d5117297ba301fef9eef238123c78d3c53" alt="image-20240417185444048"></p>
<p>  可以通过执⾏<code>config set dir{newDir}</code>和<code>config set dbfilename{newFilename}</code>运⾏期间动态执⾏，当下次运⾏时RDB⽂件会保存到新⽬录。</p>
<p>  <code>Redis</code>默认采⽤<code>LZF</code>算法对⽣成的<code>RDB</code>⽂件做压缩处理，压缩后的⽂件远远⼩于内存⼤⼩，默认开启，可以通过参数<code>config set rdbcompression{yes|no}</code> 动态修改。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/06d967cb4a70f5365f91faf7ec2b081f9f23e5048e6e55ca38ccb445ca650d0e" alt="image-20240417185718585"></p>
<h3 id="1-3-RDB-优缺点"><a href="#1-3-RDB-优缺点" class="headerlink" title="1.3 RDB 优缺点"></a>1.3 RDB 优缺点</h3><ul>
<li>优点：<ul>
<li><strong>性能高效</strong>：RDB持久化是将内存中的数据以二进制形式保存到硬盘上，因此在持久化过程中不需要进行额外的序列化和反序列化操作，具有很高的性能。</li>
<li><strong>恢复速度快</strong>：因为 RDB 文件是一个完整的数据库快照，所以在 Redis 重启后，可以非常快速地将数据恢复到内存中。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>数据可能丢失</strong>：RDB持久化是间隔一定时间进行的，如果Redis意外崩溃，会导致最后一次持久化之后的数据丢失。</li>
<li><strong>不适合实时备份</strong>：<code>RDB</code>⽅式数据没办法做到实时持久化/秒级持久化。因为<code>bgsave</code>每次运⾏都要执⾏<code>fork</code>创建⼦进程，属于重量级操作，频繁执⾏成本过⾼。</li>
</ul>
</li>
</ul>
<h2 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2.AOF 持久化"></a>2.AOF 持久化</h2><p>  <code>AOF</code>持久化：以独⽴⽇志的⽅式<strong>记录每次写命令</strong>，重启时再重新执⾏<code>AOF</code>⽂件中的命令达到恢复数据的⽬的。<code>AOF</code>的主要作⽤是解决了数据持久化的<strong>实时性</strong>。</p>
<h3 id="2-1-开启-AOF"><a href="#2-1-开启-AOF" class="headerlink" title="2.1 开启 AOF"></a>2.1 开启 AOF</h3><ol>
<li>在配置文件中设置，<code>appendonly yes</code>，默认是不开启的。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8731a00e929fb6f5da91cb515f70e385c3be18828ed372d7970b410adb492ade" alt="image-20240417193051405"></p>
<ul>
<li>流程</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/554c60ead3ce2c56fbdc18635733e90039ed31585f95a9df35f72a5311281a92" alt="image-20240417194516818"></p>
<ol>
<li>所有的写⼊命令会追加到缓冲区中。</li>
<li>AOF 缓冲区根据对应的策略向硬盘做同步操作。</li>
<li>随着 AOF ⽂件越来越⼤，需要定期对 AOF ⽂件进⾏重写，达到压缩的⽬的。</li>
<li>当 Redis 服务器启动时，可以加载 AOF ⽂件进⾏数据恢复。</li>
</ol>
<blockquote>
<p>AOF 为什么需要缓冲区？如果每次写 AOF ⽂件都直接同步硬盘，性能从内存的读写变成 IO 读写，必然会下降。先写⼊缓冲区可以有效减少 IO 次数。</p>
</blockquote>
<h3 id="2-2-AOF缓冲区同步⽂件策略"><a href="#2-2-AOF缓冲区同步⽂件策略" class="headerlink" title="2.2 AOF缓冲区同步⽂件策略"></a>2.2 AOF缓冲区同步⽂件策略</h3><p>  可以在配置文件中设置文件同步策略。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6ce7d7322558f6f77948ce18bb75433a8b48d3fdc325fe24ac2ca15cfc30a86b" alt="image-20240417195508861"></p>
<ul>
<li>一共有三种策略<ul>
<li>always：每次写入缓冲区后直接写入 AOF 文件中。</li>
<li>everysec（默认）：写入缓冲区后，不进行同步。一秒后再进行写入 AOF 文件。</li>
<li>no：只执行 write 操作（也就是只缓存），由操作系统控制写入 AOF 文件的频率。</li>
</ul>
</li>
</ul>
<h3 id="2-3-重写机制"><a href="#2-3-重写机制" class="headerlink" title="2.3 重写机制"></a>2.3 重写机制</h3><p>  随着命令不断写⼊ AOF，⽂件会越来越⼤，当达到一定的程度后，Redis 会重写文件，减少文件的体积。</p>
<ul>
<li>AOF重写过程可以⼿动触发和⾃动触发：<ul>
<li>手动：调⽤<code>bgrewriteaof</code>命令。</li>
<li>自动：在配置文件中<ul>
<li><code>auto-aof-rewrite-min-size</code>：表⽰触发重写时AOF的最⼩⽂件⼤⼩，默认为64MB。</li>
<li><code>auto-aof-rewrite-percentage</code>：代表当前AOF占⽤⼤⼩相⽐较上次重写时增加的⽐例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c60d8861ab1ee0e8e3b446bac27c96cf646b1c91560274c950bd6ef37ce945a2" alt="image-20240417201815379"></p>
<ul>
<li>重写流程</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bc839c8e2143f4eb9a05ada27332243dec0a642b596857972fa6d1ea7adf8912" alt="image-20240417205234622"></p>
<ol>
<li>父进程执行 fork 创建子进程后。</li>
<li>重写<ol>
<li>主进程 fork 后，继续响应其它命令。所有修改操作写入 AOF 缓冲区，并根据同步策略同步到硬盘，来保证旧 AOF 文件机制的正确。</li>
<li>⼦进程只有 fork 之前的所有内存信息，⽗进程中需要将 fork 之后这段时间的修改操作写⼊ AOF <strong>重写缓冲区中</strong>。</li>
</ol>
</li>
<li>⼦进程根据内存快照，将命令合并到新的 AOF ⽂件中（这里跟 RDB 有点相似）。</li>
<li>子进程完成重写<ol>
<li>新⽂件写⼊后，⼦进程发送信号给⽗进程。</li>
<li>⽗进程把 AOF 重写缓冲区内 临时保存的命令追加到新AOF⽂件中。</li>
<li>⽤新AOF⽂件替换⽼AOF⽂件。</li>
</ol>
</li>
</ol>
<h3 id="2-4-AOF-的优缺点"><a href="#2-4-AOF-的优缺点" class="headerlink" title="2.4 AOF 的优缺点"></a>2.4 AOF 的优缺点</h3><ul>
<li>优点<ul>
<li><strong>实时性好</strong>：由于 AOF 持久化方式是将每一个写命名记录到文件中，因此实时性比 RDB 更好。</li>
<li><strong>可读性高</strong>：AOF 文件是一个纯文本文件，可以被人类读取和理解。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>写入性能略低</strong>：由于 AOF 持久化方式需要将每一个写命令记录到文件中，因此相对于 RDB 持久化方式，它的写入性能略低。</li>
<li><strong>占用磁盘空间大</strong>：由于 AOF 持久化方式需要记录每一个写命令，因此相对于 RDB 持久化方式，它占用的磁盘空间更大。</li>
</ul>
</li>
</ul>
<h2 id="3-混合模式持久化"><a href="#3-混合模式持久化" class="headerlink" title="3.混合模式持久化"></a>3.混合模式持久化</h2><p>  在开启混合持久化的情况下，<strong>AOF 重写时</strong>会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7c096db2ce974090dcaec466528c7dca4fdb83d8609d006f25dfb1fdf16e4bcd" alt="image-20240417215009418"></p>
<h3 id="3-1-开启混合持久化"><a href="#3-1-开启混合持久化" class="headerlink" title="3.1 开启混合持久化"></a>3.1 开启混合持久化</h3><ol>
<li>在配置文件中如下设置：</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/975b225af5af4291f6d13c8f2229508d0de541731fcc0a16627503fc478f0ea9" alt="image-20240417210744726"></p>
<h3 id="3-2-混合持久化的优缺点"><a href="#3-2-混合持久化的优缺点" class="headerlink" title="3.2 混合持久化的优缺点"></a>3.2 混合持久化的优缺点</h3><ul>
<li>优点</li>
</ul>
<pre><code>+ 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，又减低了大量数据丢失的风险。</code></pre><ul>
<li>缺点</li>
</ul>
<pre><code>+ **可读性差**：AOF 文件中添加了 RDB 格式的内容，就让 AOF 文件的可读性变得很差。
+ **兼容性差**：如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</code></pre><h2 id="4-启动恢复数据的流程"><a href="#4-启动恢复数据的流程" class="headerlink" title="4.启动恢复数据的流程"></a>4.启动恢复数据的流程</h2><ol>
<li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程。</li>
<li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程。</li>
<li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容。</li>
<li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e59d685384c8b36398fcc7147065805b751f2ba2855ac3d0c01fdba75249d207" alt="image-20240417212632723"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358704808526102547" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集的理论、实现与应用【纯干货】</title>
    <url>/7359077652445921330.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实现并查集数据结构的技术指南"><a href="#实现并查集数据结构的技术指南" class="headerlink" title="实现并查集数据结构的技术指南"></a>实现并查集数据结构的技术指南</h2><p>并查集（Disjoint Set Union，简称并查集）是一种常用的数据结构，用于管理元素之间的等价关系。它主要支持两种操作：合并（Union）和查找（Find）。并查集通常用于解决各种问题，如图论中的连通性问题、最小生成树算法中的边的选择等。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>并查集通过维护一棵树来表示集合，其中每个节点都指向其父节点，根节点指向自身。在实际实现中，可以使用数组来表示这棵树，数组的索引表示元素，数组的值表示指向的父节点。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol start="0">
<li><strong>初始化：</strong> 初始化时，每个元素都是独立的集合，即每个元素都是一个单独的树，且每个元素的父节点指向自身。</li>
<li><strong>查找（Find）：</strong> 查找操作用于确定元素所属的集合。通过不断向上查找父节点，直到找到根节点，即自身指向自身的节点，确定元素所在的集合。</li>
<li><strong>合并（Union）：</strong> 合并操作用于将两个集合合并为一个集合。通过找到两个元素所在集合的根节点，将其中一个根节点的父节点指向另一个根节点，从而实现集合的合并。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/718b1eb29862b37f8ca578cd6e8f1210f383c48832d5bfde56f731ac6d638701" alt="image-20240418192626687"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是并查集的简单实现，使用了路径压缩和按秩合并的优化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  # 路径压缩</span><br><span class="line">        return self.parent[x]</span><br><span class="line">    </span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        if root_x != root_y:</span><br><span class="line">            if self.rank[root_x] &lt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_x] = root_y</span><br><span class="line">            elif self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">            else:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">                self.rank[root_x] += 1</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建并查集对象，包含5个元素</span><br><span class="line">uf = UnionFind(5)</span><br><span class="line">​</span><br><span class="line"># 合并元素1和元素2所在的集合</span><br><span class="line">uf.union(1, 2)</span><br><span class="line">​</span><br><span class="line"># 合并元素3和元素4所在的集合</span><br><span class="line">uf.union(3, 4)</span><br><span class="line">​</span><br><span class="line"># 检查元素1和元素2是否属于同一个集合</span><br><span class="line">print(uf.find(1) == uf.find(2))  # 输出：True</span><br><span class="line">​</span><br><span class="line"># 检查元素1和元素3是否属于同一个集合</span><br><span class="line">print(uf.find(1) == uf.find(3))  # 输出：False</span><br></pre></td></tr></table></figure>

<h3 id="进一步优化与应用"><a href="#进一步优化与应用" class="headerlink" title="进一步优化与应用"></a>进一步优化与应用</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/07383b11675281baa05fcaff9a6b0a22821d6768885365d01c759a3a9295ba00" alt="image-20240418192715175"></p>
<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>在查找操作中，路径压缩可以进一步提高并查集的效率。路径压缩的核心思想是在查找过程中，将节点直接连接到根节点，以减少后续查找的时间复杂度。路径压缩可以通过递归或迭代实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  # 路径压缩</span><br><span class="line">        return self.parent[x]</span><br></pre></td></tr></table></figure>

<h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><p>按秩合并的思想是，始终将较小的树合并到较大的树中，以减少树的深度，进而降低查找操作的复杂度。在合并操作中，需要比较两个根节点的秩（即树的高度），并将秩较小的根节点连接到秩较大的根节点上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        if root_x != root_y:</span><br><span class="line">            if self.rank[root_x] &lt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_x] = root_y</span><br><span class="line">            elif self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">            else:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">                self.rank[root_x] += 1</span><br></pre></td></tr></table></figure>

<h4 id="应用示例：判断图中连通分量的数量"><a href="#应用示例：判断图中连通分量的数量" class="headerlink" title="应用示例：判断图中连通分量的数量"></a>应用示例：判断图中连通分量的数量</h4><p>并查集常用于图论中的连通性问题。下面是一个示例，通过并查集来判断无向图中连通分量的数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def count_components(n, edges):</span><br><span class="line">    uf = UnionFind(n)</span><br><span class="line">    for edge in edges:</span><br><span class="line">        uf.union(edge[0], edge[1])</span><br><span class="line">    </span><br><span class="line">    components = set()</span><br><span class="line">    for i in range(n):</span><br><span class="line">        components.add(uf.find(i))</span><br><span class="line">    </span><br><span class="line">    return len(components)</span><br></pre></td></tr></table></figure>

<p>用并查集解决区域填充问题。假设有一个二维网格，其中包含了若干个岛屿（由’1’表示）和海洋（由’0’表示），岛屿被海洋包围。现在需要对每个岛屿进行区域填充，使得每个岛屿都被水域包围。以下是代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  # 路径压缩</span><br><span class="line">        return self.parent[x]</span><br><span class="line">    </span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        if root_x != root_y:</span><br><span class="line">            if self.rank[root_x] &lt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_x] = root_y</span><br><span class="line">            elif self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">            else:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">                self.rank[root_x] += 1</span><br><span class="line">​</span><br><span class="line">def fill_surrounded_regions(grid):</span><br><span class="line">    if not grid:</span><br><span class="line">        return grid</span><br><span class="line">    </span><br><span class="line">    m, n = len(grid), len(grid[0])</span><br><span class="line">    uf = UnionFind(m * n + 1)  # 最后一个节点表示海洋</span><br><span class="line">    </span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if grid[i][j] == &apos;0&apos;:</span><br><span class="line">                uf.union(i * n + j, m * n)  # 将海洋连接到一个虚拟节点</span><br><span class="line">            else:</span><br><span class="line">                if i &gt; 0 and grid[i - 1][j] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, (i - 1) * n + j)</span><br><span class="line">                if i &lt; m - 1 and grid[i + 1][j] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, (i + 1) * n + j)</span><br><span class="line">                if j &gt; 0 and grid[i][j - 1] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, i * n + j - 1)</span><br><span class="line">                if j &lt; n - 1 and grid[i][j + 1] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, i * n + j + 1)</span><br><span class="line">    </span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if uf.find(i * n + j) != uf.find(m * n):</span><br><span class="line">                grid[i][j] = &apos;X&apos;</span><br><span class="line">    </span><br><span class="line">    return grid</span><br><span class="line">​</span><br><span class="line"># 示例</span><br><span class="line">grid = [</span><br><span class="line">    [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;0&quot;],</span><br><span class="line">    [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;0&quot;],</span><br><span class="line">    [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;],</span><br><span class="line">    [&quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">​</span><br><span class="line">filled_grid = fill_surrounded_regions(grid)</span><br><span class="line">for row in filled_grid:</span><br><span class="line">    print(&quot; &quot;.join(row))</span><br></pre></td></tr></table></figure>

<p>这个代码示例演示了如何使用并查集来解决区域填充问题。通过判断岛屿之间的连通性，并将与海洋相连的岛屿合并到一起，然后将不与海洋相连的岛屿标记为水域。</p>
<h3 id="并查集的应用领域"><a href="#并查集的应用领域" class="headerlink" title="并查集的应用领域"></a>并查集的应用领域</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/65d1c03b541a951c99df878473e9c2a4758f4199a7ce10f8615b84039631ad34" alt="image-20240418192728898"></p>
<p>除了在图论中的连通性问题之外，并查集还在各种领域得到广泛应用，其中包括但不限于：</p>
<h4 id="1-算法竞赛"><a href="#1-算法竞赛" class="headerlink" title="1. 算法竞赛"></a>1. 算法竞赛</h4><p>在算法竞赛中，例如ACM/ICPC、Codeforces等比赛中，并查集常被用来解决一些关于连通性的问题，比如判断图的连通性、求解最小生成树、最短路径等。并查集的高效实现可以帮助竞赛选手在有限的时间内解决问题。</p>
<h4 id="2-图像处理"><a href="#2-图像处理" class="headerlink" title="2. 图像处理"></a>2. 图像处理</h4><p>在图像处理中，像素的连通性是一个重要的概念。并查集可以用来判断图像中的像素是否连通，从而进行图像分割、边缘检测等操作。例如，可以利用并查集来合并相邻的像素，将它们视为同一连通分量。</p>
<h4 id="3-社交网络分析"><a href="#3-社交网络分析" class="headerlink" title="3. 社交网络分析"></a>3. 社交网络分析</h4><p>在社交网络分析中，常常需要判断社交网络中的用户之间是否存在关系，以及他们之间的关系强度。并查集可以用来管理用户之间的关系，快速判断两个用户是否属于同一社交圈子，进而进行社交网络分析和推荐系统的优化。</p>
<h4 id="4-数据库系统"><a href="#4-数据库系统" class="headerlink" title="4. 数据库系统"></a>4. 数据库系统</h4><p>在数据库系统中，常常需要处理大量的数据并对其进行关联。并查集可以用来管理数据之间的关系，例如在数据库中实现集合操作、聚类分析等。并查集的高效实现可以加速数据库查询和数据处理的速度。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2b48a4bf7a2c0a10bd2a7e7b015605e020f5cec9f5056b4f5d4017858f08bb42" alt="image-20240418192745041"></p>
<h4 id="5-任务调度与资源分配"><a href="#5-任务调度与资源分配" class="headerlink" title="5. 任务调度与资源分配"></a>5. 任务调度与资源分配</h4><p>在任务调度和资源分配领域，经常需要解决资源之间的依赖关系和任务之间的调度顺序。并查集可以用来管理任务和资源之间的关系，快速判断任务之间的依赖关系，进而进行任务调度和资源分配的优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了并查集数据结构的基本原理、实现方法以及优化技巧，并提供了代码示例展示了其在实际问题中的应用。首先，我们了解了并查集的基本操作：合并（Union）和查找（Find），以及如何使用数组来表示并查集中的树结构。随后，我们介绍了路径压缩和按秩合并两种优化技巧，用于提高并查集的效率。通过路径压缩，我们可以减少查找操作的时间复杂度；而按秩合并则可以降低树的深度，进而减少查找和合并操作的时间复杂度。</p>
<p>在代码示例部分，我们展示了如何实现一个简单的并查集类，并给出了一个应用示例：使用并查集解决区域填充问题。在这个示例中，我们通过并查集来判断岛屿之间的连通性，然后对每个岛屿进行区域填充，确保每个岛屿都被水域包围。这个示例展示了并查集在图论和图像处理等领域的应用。</p>
<p>综上所述，虽然并查集是一种简单的数据结构，但它在解决各种实际问题中具有广泛的应用。通过合并和查找操作，可以高效地管理元素之间的关系，解决连通性、区域填充等问题。希望本文能够帮助读者更深入地理解并查集，并在实际工作和学习中发挥作用。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359077652445921330" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>03.maven聚合和继承</title>
    <url>/7359083767564091407.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Maven聚合"><a href="#Maven聚合" class="headerlink" title="Maven聚合"></a>Maven聚合</h2><p>maven聚合需要创建一个新的maven项目， 用来管理其他的maven构件模块，新的maven项目中加入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;modules&gt;    </span><br><span class="line">    &lt;module&gt;模块1&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;模块2&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;模块n&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br><span class="line">&lt;package&gt;pom&lt;/package&gt;</span><br></pre></td></tr></table></figure>

<p>新的项目中执行任何<code>mvn</code>命令，都会<code>modules</code>中包含的所有模块执行同样的命令，而被包含的模块不需要做任何特殊的配置，正常的maven项目就行。</p>
<p>注意上面的<code>module</code>元素，这部分是被聚合的模块<code>pom.xml</code>所在目录的相对路径。</p>
<blockquote>
<p><code>package</code>的值必须为<code>pom</code></p>
</blockquote>
<p>pom.xml中的<code>module</code>元素的值为被聚合的模块pom.xml所在的目录路径，只能是相对路径，比如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;modules&gt;    </span><br><span class="line">    &lt;module&gt;zipkin-server-source-demo&lt;/module&gt;   </span><br><span class="line">    &lt;module&gt;../../../tmp/child-project&lt;/module&gt;   </span><br><span class="line">    &lt;module&gt;../../../tmp/child-project/pom.xml&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>聚合的功能中，聚合模块的pom.xml中通过<code>modules-&gt;module</code>来引用被聚合的模块，被聚合的模块是不用感知自己被聚合了，所以被聚合的模块中<code>pom.xml</code>中是不知道父模块的存在的。</p>
<h2 id="maven继承"><a href="#maven继承" class="headerlink" title="maven继承"></a>maven继承</h2><p>如果有很多项目他们依赖相同的配置，那么能不能把这些相同的配置提取出来放到父项目中，这些子项目通过继承可以自动依赖这些功能配置，这就是<code>继承</code>。</p>
<ol>
<li>创建一个父maven构件，将依赖信息放在pom.xml中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependencies&gt;   </span><br><span class="line">        &lt;dependency&gt;依赖的构件的坐标信息&lt;/dependency&gt;   </span><br><span class="line">        &lt;dependency&gt;依赖的构件的坐标信息&lt;/dependency&gt;    </span><br><span class="line">        &lt;dependency&gt;依赖的构件的坐标信息&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>将父构件的package元素的值置为pom</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;packaging&gt;pom&lt;/packaging&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>在子构件的pom.xml引入父构件的配置：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;parent&gt;    </span><br><span class="line">        &lt;groupId&gt;父构件groupId&lt;/groupId&gt; </span><br><span class="line">        &lt;artifactId&gt;父构件artifactId&lt;/artifactId&gt; </span><br><span class="line">        &lt;version&gt;父构件的版本号&lt;/version&gt;  </span><br><span class="line">        &lt;relativePath&gt;父构件pom.xml路径&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p><code>relativePath</code>表示父构件pom.xml相对路径，默认是<code>../pom.xml</code>，所以一般情况下父子结构的maven构件在目录结构上一般也采用父子关系。</p>
<h3 id="relativePath元素"><a href="#relativePath元素" class="headerlink" title="relativePath元素"></a>relativePath元素</h3><p>如果父构件和子构件的目录不是父子关系，比如都位于同等级别的目录或者位于更复杂的目录的时候，此时我们需要在子<code>pom.xml</code>的<code>parent</code>元素中使用<code>relativePath</code>元素来指定父<code>pom.xml</code>相对路径位置，这个值默认是<code>../pom.xml</code>，表示父pom.xml位于子pom.xml的上一级目录。</p>
<p>正确的设置<code>relativePath</code>是非常重要的，这个需要注意，子模块中执行<code>mvn</code>命令的时候，会去找父<code>pom.xml</code>的配置，会先通过<code>relativePath</code>指定的路径去找，如果找不到，会尝试通过坐标在本地仓库进行查找，如果本地找不到，会去远程仓库找，如果远程仓库也没有，会报错。</p>
<h3 id="可以通过继承的元素有以下这些"><a href="#可以通过继承的元素有以下这些" class="headerlink" title="可以通过继承的元素有以下这些"></a>可以通过继承的元素有以下这些</h3><p>可以从父<code>pom.xml</code>中继承过来的的元素：</p>
<ul>
<li>groupId：项目组ID，项目坐标的核心元素</li>
<li>version：项目版本，项目坐标的核心元素</li>
<li>description：项目的描述信息</li>
<li>organization：项目的组织信息</li>
<li>inceptionYear：项目的创始年份</li>
<li>url：项目的url地址</li>
<li>developers：项目的开发者信息</li>
<li>contributors：项目的贡献者信息</li>
<li>distributionManagement：项目的部署配置信息</li>
<li>issueManagement：项目的缺陷跟踪系统信息</li>
<li>ciManagement：项目的持续集成系统信息</li>
<li>scm：项目的版本控制系统信息</li>
<li>mailingLists：项目的邮件列表信息</li>
<li>properties：自定义的maven属性配置信息</li>
<li>dependencyManagement：项目的依赖管理配置</li>
<li>repositories：项目的仓库配置</li>
<li>build：包括项目的源码目录配置、输出目录配置、插件管理配置等信息</li>
<li>reporting：包括项目的报告输出目录配置、报告插件配置等信息</li>
</ul>
<h2 id="依赖管理-dependencyManagement"><a href="#依赖管理-dependencyManagement" class="headerlink" title="依赖管理(dependencyManagement)"></a>依赖管理(dependencyManagement)</h2><p>maven提供的dependencyManagement元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性，<strong>在<code>dependencyManagement</code>元素下声明的依赖不会引入实际的依赖，他只是声明了这些依赖，不过它可以对<code>dependencies</code>中使用的依赖起到一些约束作用。</strong></p>
<p>子模块如果想用到父模块<code>dependencyManagement</code>中的配置，可以<code>dependencies</code>进行引用，引用之后，依赖才会真正的起效。我们可以使用<code>mvn dependency:tree</code>验证</p>
<p>dependencyManagement不会引入实际的依赖，只有在子类中使用<code>dependency</code>来引入父<code>dependencyManagement</code>声明的依赖之后，依赖的构建才会被真正的引入。</p>
<p>使用dependencyManagement来解决继承的问题，子pom.xml中只用写<code>groupId,artifactId</code>就可以了，其他信息都会从父<code>dependencyManagement</code>中声明的依赖关系中传递过来，通常我们使用这种方式将所有依赖的构建在父pom.xml中定义好，子构件中只需要通过<code>groupId,artifactId</code>就可以引入依赖的构建，而不需要写<code>version</code>，可以很好的确保多个子项目中依赖构件的版本的一致性，对应依赖构件版本的升级也非常方便，只需要在父pom.xml中修改一下就可以了。</p>
<h2 id="单继承问题解决"><a href="#单继承问题解决" class="headerlink" title="单继承问题解决"></a>单继承问题解决</h2><p>如果一个项目X的父项目是P，但是X又想使用另外一个项目Z中<code>dependencyManagement</code>中声明的依赖，此时该咋办？这个就是<code>单继承的问题</code></p>
<p>解决办法：在项目X中增加以下配置，然后项目X就可以使用项目Z中<code>dependencyManagement</code>声明的依赖了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;!-- 下面的配置相当于把项目Z的pom.xml中的dependencyManagement元素中声明的所有依赖导入到当前pom.xml的dependencyManagement中 --&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;项目Z&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;项目Z&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">            &lt;!-- type的值必须是pom，scope元素的值必须是import --&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>上的配置相当于把项目Z的pom.xml中的dependencyManagement元素中声明的所有依赖导入到当前pom.xml的dependencyManagement中</p>
<h2 id="插件管理-pluginManagement"><a href="#插件管理-pluginManagement" class="headerlink" title="插件管理(pluginManagement)"></a>插件管理(pluginManagement)</h2><p>maven中提供了解决插件继承问题的<code>pluginManagement</code>元素，在父pom中可以在这个元素中声明插件的配置信息，但是子pom.xml中不会引入此插件的配置信息，只有在子pom.xml中使用<code>plugins-&gt;plugin</code>元素正在引入这些声明的插件的时候，插件才会起效，子插件中只需要写<code>groupId、artifactId</code>，其他信息都可以从父构件中传递过来。</p>
<p>比如我在父项目pom.xml中声明以下插件配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;!--在default生命周期的verify阶段执行jar-no-fork目标--&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-source&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>在子项目中使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--如果没有executions，那就会完全引用父插件中的配置，</span><br><span class="line">            如果有executions，那么就会合并父插件中的配置</span><br><span class="line">            可以使用mvn help:effective-pom验证最终的pom.xml</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;attach-source&lt;/id&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;help&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>mvn help:effective-pom</code>查看子项目生成的最终的pom.xml文件是咋样的来验证插件管理是否生效</p>
<h2 id="聚合与继承的关系"><a href="#聚合与继承的关系" class="headerlink" title="聚合与继承的关系"></a>聚合与继承的关系</h2><ul>
<li>聚合：主要是为了方便多模块快速构建。对于聚合来说，聚合模块是知道被聚合模块的存在的，而被聚合模块是感知不到聚合模块的存在。</li>
<li>继承：主要是为了重用相同的配置。对于继承来说，父构件是感知不到子构件的存在，而子构件需要使用<code>parent</code>来引用父构件。</li>
</ul>
<p>两者的共同点是，聚合模块和继承中的父模块的package属性都必须是pom类型的，同时，聚合模块和父模块中的除了pom.xml，一般都是没有什么内容的。</p>
<p>实际使用是，我们经常将聚合和继承一起使用，能同时使用到两者的优点。</p>
<p>本文参考：<a href="http://www.itsoku.com/course/2/68" target="_blank" rel="noopener">www.itsoku.com/course/2/68</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359083767564091407" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,maven</tag>
      </tags>
  </entry>
  <entry>
    <title>签到功能_redis_bitmap实现笔记</title>
    <url>/7359083483237957671.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>签到功能：签到，补签，查询当月签到记录。</p>
<blockquote>
<p>笔记记录签到最核心代码，无涉及什么条件下可签到等业务需求。</p>
</blockquote>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ul>
<li>redis服务</li>
<li>springboot项目</li>
</ul>
<p>使用到的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.27&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: redis服务地址</span><br><span class="line">    password: redis服务密码</span><br></pre></td></tr></table></figure>

<h2 id="利用redis中bitmap数据结构来应用签到需求"><a href="#利用redis中bitmap数据结构来应用签到需求" class="headerlink" title="利用redis中bitmap数据结构来应用签到需求"></a>利用redis中bitmap数据结构来应用签到需求</h2><p>签到命令：<code>SETBIT key offset value</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码&gt; SETBIT sign:1001:202404 0 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>解释：用户1001在2024年4月1号签到。</p>
<p><strong>重复签到执行命令的结果</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码&gt; SETBIT sign:1001:202404 0 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>解释：如果返回<code>1</code>代表已经签到了。</p>
<h3 id="Java代码实现签到功能："><a href="#Java代码实现签到功能：" class="headerlink" title="Java代码实现签到功能："></a>Java代码实现签到功能：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public void signIn(String uid) &#123;</span><br><span class="line"></span><br><span class="line">    // 拼接业务key</span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line"></span><br><span class="line">    // 哪一天签到</span><br><span class="line">    int offset = now.getDayOfMonth() - 1;</span><br><span class="line"></span><br><span class="line">    // 提交签到记录</span><br><span class="line">    Boolean res = redisTemplate.opsForValue().setBit(key, offset, true);</span><br><span class="line"></span><br><span class="line">    if (BooleanUtil.isTrue(res)) &#123;</span><br><span class="line">        log.error(&quot;用户：&#123;&#125; 签到失败，重复签到，签到时间：&#123;&#125;&quot;, uid, now);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;用户：&#123;&#125; 签到成功，签到时间：&#123;&#125;&quot;, uid, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补签需求"><a href="#补签需求" class="headerlink" title="补签需求"></a>补签需求</h2><p>补签需求使用到的命令与签到命令一样，需要加入补签的业务条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public void repairSignIn(String uid, LocalDate date) &#123;</span><br><span class="line"></span><br><span class="line">    // 业务要求补签只能补当月缺少签到的天进行补签</span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    if (now.getYear() != date.getYear() || now.getMonthValue() != date.getMonthValue()) &#123;</span><br><span class="line">        log.error(&quot;用户：&#123;&#125; 补签失败，补签日期不在当月，补签日期：&#123;&#125;&quot;, uid, date);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String format = date.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line">    int offset = date.getDayOfMonth() - 1;</span><br><span class="line">    Boolean res = redisTemplate.opsForValue().setBit(key, offset, true);</span><br><span class="line"></span><br><span class="line">    if (BooleanUtil.isTrue(res)) &#123;</span><br><span class="line">        log.error(&quot;用户：&#123;&#125; 补签失败，重复签到，签到时间：&#123;&#125;&quot;, uid, date);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;用户：&#123;&#125; 补签成功，签到时间：&#123;&#125;&quot;, uid, date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1f40294c3245b533e42c8f24350a8d0cc0d5a16f9292899968cabc1634066edc" alt="image.png"></p>
<h2 id="查询当月当下连续签到的天数"><a href="#查询当月当下连续签到的天数" class="headerlink" title="查询当月当下连续签到的天数"></a>查询当月当下连续签到的天数</h2><p>redis命令：<code>bitfield key get u获取的数量 开始的下标</code>,这里的<code>u</code>代表返回时是<code>无符号位</code>，结果返回十进制数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码&gt; bitfield sign:in:uid:1001:202404 get u18 0</span><br><span class="line">131135</span><br></pre></td></tr></table></figure>

<h3 id="Java代码实现查询当月当下连续签到次数"><a href="#Java代码实现查询当月当下连续签到次数" class="headerlink" title="Java代码实现查询当月当下连续签到次数"></a>Java代码实现查询当月当下连续签到次数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public int continuousDays(String uid) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line"></span><br><span class="line">    int day = now.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    List&lt;Long&gt; res = redisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands</span><br><span class="line">                    .create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(day))</span><br><span class="line">                    .valueAt(0));</span><br><span class="line">    if (CollUtil.isEmpty(res)) &#123;</span><br><span class="line">        log.error(&quot;无签到记录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取十进制数</span><br><span class="line">    Long num = res.get(0);</span><br><span class="line"></span><br><span class="line">    // 记录连续签到数量</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    // 利用 &amp; 1 判断最低位是否为1</span><br><span class="line">    while ((num &amp; 1) == 1) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num &gt;&gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在处理redis返回的十进制数时，使用 <code>&amp;运算</code>，<code>无符号右移机制</code>，实现对签到<code>1</code>的判断与记录。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5d44d8f3466e1a0291f5f7280fd3fb7937a6bb0d84b2c9fab0880b7c5dc2de9c" alt="image.png"></p>
<p>查询结果应该为：6。<code>bitmap初始化8位，当位数不够时，每次增加8位。</code></p>
<h2 id="查询当月签到记录"><a href="#查询当月签到记录" class="headerlink" title="查询当月签到记录"></a>查询当月签到记录</h2><p>Java代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public byte[] signInRecord(String uid) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line">    int day = now.getDayOfMonth();</span><br><span class="line">    List&lt;Long&gt; res = redisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands</span><br><span class="line">                    .create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(day))</span><br><span class="line">                    .valueAt(0));</span><br><span class="line">    if (CollUtil.isEmpty(res)) &#123;</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">    Long num = res.get(0);</span><br><span class="line"></span><br><span class="line">    byte[] bytes = new byte[day];</span><br><span class="line">    int i = day - 1;</span><br><span class="line">    while (i &gt;= 0) &#123;</span><br><span class="line">        bytes[i] = (byte) (num &amp; 1);</span><br><span class="line">        num &gt;&gt;&gt;= 1;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    return bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<code>[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]</code>，返回给前端，使用相应组件显示效果如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e684eec96277a7478f22514c2137d0eb2815135ae58828eb05a3a3daf6875362" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户在某年某月某日签到的数据记录存储在redis中，利用bitmap数据类型的先天优势，0与1代表未签到与签到的设定，实现签到功能。</p>
<p>在获取签到数据时，redis返回的数据是十进制，需要加工处理，利用到 &amp;运算 与 无符号右移，进行二进制的操作计算。</p>
<p>从效率和存储空间来看，redis的bitmap来实现签到功能还是非常合适的。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359083483237957671" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言是如何实现协程的</title>
    <url>/7359083767564795919.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在文章开头"><a href="#写在文章开头" class="headerlink" title="写在文章开头"></a>写在文章开头</h2><p><code>go语言</code>的精华就在于协程的设计，只有理解协程的设计思想和工作机制，才能确保我们能够完全的利用协程编写强大的并发程序。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b231c2cf2efa76b739a757c889700c7e3b0e5df17d6f44a4685a63cdc34da777" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<p>Hi，我是 <strong>sharkChili</strong> ，是个不断在硬核技术上作死的 <strong>java coder</strong> ，是 <strong>CSDN的博客专家</strong> ，也是开源项目 <strong>Java Guide</strong> 的维护者之一，熟悉 <strong>Java</strong> 也会一点 <strong>Go</strong> ，偶尔也会在 <strong>C源码</strong> 边缘徘徊。写过很多有意思的技术博客，也还在研究并输出技术的路上，希望我的文章对你有帮助，非常欢迎你关注我的公众号： <strong>写代码的SharkChili</strong> 。</p>
<p>因为近期收到很多读者的私信，所以也专门创建了一个交流群，感兴趣的读者可以通过上方的公众号获取笔者的联系方式完成好友添加，点击备注 <strong>“加群”</strong> 即可和笔者和笔者的朋友们进行深入交流。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cc5e08f46f41722a78eec887a399b58dc6faa5cd50760dfc014a006ee88f694a" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<h2 id="详解协程工作机制和实现"><a href="#详解协程工作机制和实现" class="headerlink" title="详解协程工作机制和实现"></a>详解协程工作机制和实现</h2><h3 id="协程示例"><a href="#协程示例" class="headerlink" title="协程示例"></a>协程示例</h3><p>正式介绍底层之前，我们给出一段协程的代码示例，可以看到笔者开启一个协程进行函数内部调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码func foo1() &#123;</span><br><span class="line"> fmt.Println(&quot;foo1 调用 foo2&quot;)</span><br><span class="line"> foo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func foo2() &#123;</span><br><span class="line"> fmt.Println(&quot;foo2调用foo3&quot;)</span><br><span class="line"> foo3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func foo3() &#123;</span><br><span class="line"> fmt.Println(&quot;foo3 执行了&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> //设置WaitGroup等待协程结束</span><br><span class="line"> var wg sync.WaitGroup</span><br><span class="line"> wg.Add(1)</span><br><span class="line"></span><br><span class="line"> go func() &#123;</span><br><span class="line">  foo1()</span><br><span class="line">  defer wg.Done()</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> //等待上述协程运行结束</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码foo1 调用 foo2</span><br><span class="line">foo2调用foo3</span><br><span class="line">foo3 执行了</span><br></pre></td></tr></table></figure>

<p>结合debug我们可以看到当前协程的调用栈帧，在函数调用前插入一个<code>goexit</code>的东西，结合这一点我们开始对协程的深入剖析：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fadee10358da21e3205f3d4ab4905f35840a0a372d3021332b0b77591d5b637c" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<h3 id="协程实现结构"><a href="#协程实现结构" class="headerlink" title="协程实现结构"></a>协程实现结构</h3><p>在<code>go语言</code>的协程结构为:</p>
<ol>
<li>通过一个<code>stack</code>记录其高地址和低地址。</li>
<li>通过<code>sched</code>的<code>sp(即stackpointer)栈帧的指针</code>和<code>程序计数器pc(指向下一条运行的指令)</code>.</li>
<li>采用<code>goid</code>生成唯一标识。</li>
<li>然后再用<code>atomicstatus</code>记录其执行状态。</li>
</ol>
<p>基于这几点我们结合上述的代码给出协程的底层结构，如下图所示，当前协程的<code>stack</code>记录整个foo1函数的高低地址，假设我们当前的协程<code>go</code>来到<code>foo2</code>函数准备调用<code>foo3</code>函数，我们的<code>sched</code>中的sp即<code>stackpointer</code>记录foo2的指针，同时因为<code>foo2</code>内部会调用<code>foo3</code>所以程序计数器<code>pc</code>记录着调用<code>foo3</code>的指令。</p>
<p>最后因为协程都是由线程调度的，所以协程的内部也有一个变量记录着当前线程的指针m：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/becb6b23e5cc1710193a22f486133323c8b2faae8379df0382015bb1c5377a0a" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<p>到此我们了解了协程核心结构，同时我们也在<code>runtime2.go</code>这一文件中即给出上述所说的核心变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码type g struct &#123;</span><br><span class="line"> //记录栈帧的高地址和低地址</span><br><span class="line"> stack       stack   // offset known to runtime/cgo</span><br><span class="line"> //......</span><br><span class="line"> m         *m //执行当前协程的线程指针</span><br><span class="line"> //记录当前堆栈的指针以及下一条指令的运行地址</span><br><span class="line"> sched     gobuf</span><br><span class="line"> atomicstatus atomic.Uint32</span><br><span class="line"> goid         uint64</span><br><span class="line"> </span><br><span class="line"> //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步入<code>stack</code>可以看到<code>lo</code>和<code>hi</code>两个专门记录栈帧高低地址的指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码type stack struct &#123;</span><br><span class="line"> lo uintptr</span><br><span class="line"> hi uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的我们也给出<code>sched</code> 的类型<code>gobuf</code>，可以看到<code>sp</code>和<code>pc</code>两个核心指针变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码type gobuf struct &#123;</span><br><span class="line"> </span><br><span class="line"> sp   uintptr</span><br><span class="line"> pc   uintptr</span><br><span class="line"> //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="谈谈go语言对于线程的抽象"><a href="#谈谈go语言对于线程的抽象" class="headerlink" title="谈谈go语言对于线程的抽象"></a>谈谈go语言对于线程的抽象</h3><p>上文我们提出线程的用<code>m</code>指针记录，如下源码所示，我们都知道在go语言中每个线程都会从一个协程队列中获取协程执行，所以执行时它会用<code>curg</code>记录当前运行的协程，然后通过id对自己进行唯一标识，而<code>mOS</code>则是及记录当前操作系统信息，这其中最核心的就是<code>g0</code>它就是每一个线程的操作调度器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码type m struct &#123;</span><br><span class="line"> g0      *g     // goroutine with scheduling stack</span><br><span class="line"> id            int64 </span><br><span class="line"> </span><br><span class="line"> curg          *g       // current running goroutine</span><br><span class="line"> </span><br><span class="line"> mOS</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解整体结构之后我们再来聊聊go语言线程的g0栈是如何工作的，如下图所示，每一个g0栈都会通过schedule开始工作：</p>
<ol>
<li>通过execute从协程队列中获取任务。</li>
<li>调用gogo方法在协程调用前插入<code>go exit</code>指针它记录g0栈帧，这个指针就是用于协程执行退出或者挂起是可以通过这个指针跳回<code>g0</code>栈。</li>
<li>然后就是执行当前协程。</li>
<li>协程执行完成切换回<code>g0</code>栈，重新调用schedule方法再次从步骤1开始执行，由此构成一个循环。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a7d8241129c186004355b2a67382372e9cbf7a493830864364ce5ea90c7999df" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<p>这里我们也给出<code>asm_amd64.s</code>中关于<code>gogo</code>的汇编代码，可以看到gobuf_sp方法它会记录当前<code>stack pointer</code>也就是我们上文针对<code>g0</code>所说的<code>g0</code>栈地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码TEXT gogo&lt;&gt;(SB), NOSPLIT, $0</span><br><span class="line"> get_tls(CX)</span><br><span class="line"> MOVQ DX, g(CX)</span><br><span class="line"> MOVQ DX, R14  // set the g register</span><br><span class="line"> //记录g0栈地址</span><br><span class="line"> MOVQ gobuf_sp(BX), SP // restore SP</span><br><span class="line"> MOVQ gobuf_ret(BX), AX</span><br><span class="line"> MOVQ gobuf_ctxt(BX), DX</span><br><span class="line"> MOVQ gobuf_bp(BX), BP</span><br><span class="line"> MOVQ $0, gobuf_sp(BX) // clear to help garbage collector</span><br><span class="line"> MOVQ $0, gobuf_ret(BX)</span><br><span class="line"> MOVQ $0, gobuf_ctxt(BX)</span><br><span class="line"> MOVQ $0, gobuf_bp(BX)</span><br><span class="line"> MOVQ gobuf_pc(BX), BX</span><br><span class="line"> JMP BX</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>自此我们从go语言底层实现的角度完整的剖析的协程与线程的关系和实现，希望对你有帮助。</p>
<p>我是 <strong>sharkchili</strong> ，<strong>CSDN Java 领域博客专家</strong>，<strong>开源项目—JavaGuide contributor</strong>，我想写一些有意思的东西，希望对你有帮助，如果你想实时收到我写的硬核的文章也欢迎你关注我的公众号： <strong>写代码的SharkChili</strong> 。 因为近期收到很多读者的私信，所以也专门创建了一个交流群，感兴趣的读者可以通过上方的公众号获取笔者的联系方式完成好友添加，点击备注 <strong>“加群”</strong> 即可和笔者和笔者的朋友们进行深入交流。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/010663761676d3b15cab65c855e8765c963fd6f297397fe69d33a99caba0e519" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>程序计数器（PC）、堆栈指针（SP）与函数调用过程:<a href="https://www.cnblogs.com/uestcliming666/p/11488782.html" target="_blank" rel="noopener">www.cnblogs.com/uestcliming…</a></p>
<p>本文使用 <a href="https://markdown.com.cn" target="_blank" rel="noopener">markdown.com.cn</a> 排版</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359083767564795919" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Go下载安装及切换不同版本的方法</title>
    <url>/7359084604663300148.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、下载安装"><a href="#一、下载安装" class="headerlink" title="一、下载安装"></a>一、下载安装</h2><p><a href="https://go.dev/dl/" target="_blank" rel="noopener">Go下载地址</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4753ee60e1bb255882601b3d9de93b4e313522b35cedc43c4a07be9036b14e7a" alt="go-switch-version-image.png"></p>
<p>Go提供了Windows、MacOS(ARM64) 和 MacOS(x86-64)、Linux版本，也可以下载源码自己编译安装。</p>
<blockquote>
<p>Linux &amp;&amp; MacOS</p>
</blockquote>
<ul>
<li>下载压缩包</li>
<li>解压到指定目录，如：/usr/local</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.22.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>把go的bin目录添加到环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码在 ~/.zshrc或~/.bashrc中添加如下行</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>使用环境变量立即生效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码source ~/.zshrc 或 source ~/.bashrc</span><br></pre></td></tr></table></figure>

<ul>
<li>测试go是否安装成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码go version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows</p>
</blockquote>
<ul>
<li>直接双击 .msi文件进行引导安装</li>
<li>安装完成后打开 cmd 或 power shell 输入 go version 验证安装是否成功</li>
</ul>
<h2 id="二、如何切换Go版本？"><a href="#二、如何切换Go版本？" class="headerlink" title="二、如何切换Go版本？"></a>二、如何切换Go版本？</h2><h3 id="方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本"><a href="#方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本" class="headerlink" title="方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本"></a>方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本</h3><ul>
<li>下载完压缩包，解压到其他目录，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码tar -C ~/Downloads -xzf go1.21.9.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>把go目录重命名为 go1.21.9</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码mv go go1.21.9</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个go全局目录，如：go_version</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码mkdir ~/go_version</span><br></pre></td></tr></table></figure>

<ul>
<li>做一个软链接指向go1.21.9版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码ln -s ~/Downloads/go1.21.9 ~/go_version/go</span><br></pre></td></tr></table></figure>

<ul>
<li>把~/go_version/go/bin目录加到到环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码export PATH=~/go_version/go/bin:$PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否安装成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码go1.21.9 version</span><br></pre></td></tr></table></figure>

<p>扩展：此法为切换软件的通法，其他软件也适用。</p>
<h3 id="方法二：使用go-install-命令安装其他版本"><a href="#方法二：使用go-install-命令安装其他版本" class="headerlink" title="方法二：使用go install 命令安装其他版本"></a>方法二：使用go install 命令安装其他版本</h3><p>已经安装go的情况下(例如当前版本为：1.22.2)，可以通过go install 来安装其他版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码go install golang.org/dl/go1.22.1@latest</span><br><span class="line"></span><br><span class="line">go1.22.1 download</span><br></pre></td></tr></table></figure>

<p>go install 命令会把go1.22.1版本作为1.22.2的可执行安装包，存放在 ~/go/bin下面</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5f1f580ca6b165ca37c6fd8515869b2ca7ceeede6d58185574301254d4f4cbe4" alt="go-switch-version-image-1.png"></p>
<p>再去用go1.22.1 download 则会下载1.22.1的源码，放到~/sdk下面</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e7ab2ed5c25850eebfe022d8ac4129b8e0425ba411e448fbb48ea5c8fc207a9b" alt="go-switch-version-image-2.png"></p>
<p>此时就可以用go1.22.1 version来验证是否安装成功了</p>
<p>为什么可以直接敲go1.22.1呢？实际上执行的是<del>/go/bin/go1.22.1这个二进制文件，而</del>/go/bin又加入了PATH变量，所以能执行。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d18e875e8df1697b8f9dc2317d6f6edbe5a4192f7bc99947367e795fd57c528a" alt="go-switch-version-image-3.png"></p>
<p>sdk是不能删除的，go1.22.1会读取sdk里面的源码，删除后会提示sdk没有下载。</p>
<h3 id="方法三：使用gvm来切换"><a href="#方法三：使用gvm来切换" class="headerlink" title="方法三：使用gvm来切换"></a>方法三：使用gvm来切换</h3><p>gvm全称：Go Version Manager (GVM)是一个用于管理Go环境的开源工具。它支持安装多个Go版本，并使用GVM “pkgsets” 管理每个项目的模块。GVM(与Ruby中的RVM一样)最初是由Josh Bussdieker开发的，它允许为每个项目或项目组创建开发环境，分离不同的Go版本和包依赖关系，以提供更大的灵活性并防止版本问题。</p>
<blockquote>
<p>安装gvm</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br><span class="line"></span><br><span class="line">命令解析：</span><br><span class="line"></span><br><span class="line">-s -S 连用表示禁用进度条但可以显示错误信息</span><br><span class="line"></span><br><span class="line">-L 表示重定向跟随</span><br><span class="line"></span><br><span class="line">&lt;(...) 此处为&lt;(curl ...) ，此语法表示curl的执行结果被视作文件</span><br><span class="line"></span><br><span class="line">bash &lt; 表示拿到curl的执行结果作为标准输入传给bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过gvm安装go</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm install go1.22.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过gvm切换go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm use go1.22.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有通过gvm安装的go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm list</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有可用的线上go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shel复制代码gvm listall</span><br></pre></td></tr></table></figure>

<blockquote>
<p>卸载go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm uninstall go1.22.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完全移除gvm及其所有安装的go版本和依赖包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm implode</span><br><span class="line"></span><br><span class="line">如果卸载失败，直接 rm -rf ~/.gvm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>管理go的依赖包</p>
</blockquote>
<p>pkgset允许独立管理不同的Go包集及其版本，从而更容易在不同的项目依赖关系之间切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码// 创建包集合</span><br><span class="line">gvm pkgset create [name]</span><br><span class="line"></span><br><span class="line">// 选择包集合</span><br><span class="line">gvm pkgset use [name]</span><br><span class="line"></span><br><span class="line">// 列出创建的包集合</span><br><span class="line">gvm pkgset list</span><br><span class="line"></span><br><span class="line">// 删除包集合</span><br><span class="line">gvm pkgset delete [name]</span><br></pre></td></tr></table></figure>

<p>切换到指定的包集后，后续使用go build、go run命令时会把下载的包安装到包集目录</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dd8fcb56ca51e9857ea590082e8d8bf74a222dd653a6255eefe66d2e54d9862c" alt="go-switch-version-image-4.png"></p>
<blockquote>
<p>其他gvm命令</p>
</blockquote>
<ul>
<li>打印gvm版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm version</span><br></pre></td></tr></table></figure>

<ul>
<li>获取gvm最新版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm get</span><br></pre></td></tr></table></figure>

<ul>
<li>打印帮助信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm help</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gvm 原理</p>
</blockquote>
<p>其内部核心也是使用软连接，通过指向不同的版本使用不同的环境变量</p>
<p>后面再进行源码分析</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359084604663300148" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>【tokio实战】如何在rust中调用腾讯&amp;百度的翻译服务</title>
    <url>/7359084920596103206.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何在rust中调用腾讯-amp-百度的翻译服务"><a href="#如何在rust中调用腾讯-amp-百度的翻译服务" class="headerlink" title="如何在rust中调用腾讯&amp;百度的翻译服务"></a>如何在rust中调用腾讯&amp;百度的翻译服务</h2><p><strong>阅读本篇博客后，您将掌握关于Tokio库实现批量任务处理的实用技巧，并了解如何有效地进行并发限制。</strong></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在开发<a href="https://github.com/yexiyue/Comfyui-Startup" target="_blank" rel="noopener">ComfyUI Startup</a>插件管理和模型管理功能的过程中，我发现对模型数据和插件数据的需求。在研究ComfyUI Manager如何实现将模型下载至特定目录时，我注意到其仓库中包含的数据文件仅提供英文版本。为了满足国际化需求，我决定着手翻译这些数据文件。然而，显然逐一手动翻译并不现实。<strong>因此，我选择利用<code>tokio</code>和<code>reqwest</code>库调用百度或腾讯的翻译API，以自动化的方式进行翻译工作。</strong></p>
<h3 id="先实现一个翻译请求的调用"><a href="#先实现一个翻译请求的调用" class="headerlink" title="先实现一个翻译请求的调用"></a>先实现一个翻译请求的调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码use crate::CLIENT;</span><br><span class="line">use anyhow::&#123;anyhow, Result&#125;;</span><br><span class="line">use once_cell::sync::Lazy;</span><br><span class="line">use serde_json::Value;</span><br><span class="line"></span><br><span class="line">static APP_ID: Lazy&lt;String&gt; = Lazy::new(|| std::env::var(&quot;APP_ID&quot;).unwrap());</span><br><span class="line">static APP_KEY: Lazy&lt;String&gt; = Lazy::new(|| std::env::var(&quot;APP_KEY&quot;).unwrap());</span><br><span class="line">static URL: &amp;str = &quot;http://api.fanyi.baidu.com/api/trans/vip/translate&quot;;</span><br><span class="line"></span><br><span class="line">// 对请求进行封装，只获取想要的数据</span><br><span class="line">pub async fn trans(src: &amp;str, from: &amp;str, to: &amp;str) -&gt; Result&lt;Value&gt; &#123;</span><br><span class="line">    let res: Value = CLIENT</span><br><span class="line">        .get(URL)</span><br><span class="line">        .query(&amp;[</span><br><span class="line">            (&quot;q&quot;, src),</span><br><span class="line">            (&quot;appid&quot;, &amp;APP_ID),</span><br><span class="line">            (&quot;from&quot;, from),</span><br><span class="line">            (&quot;to&quot;, to),</span><br><span class="line">            (&quot;salt&quot;, &quot;10086&quot;),</span><br><span class="line">            (&quot;sign&quot;, &amp;sign(src)),</span><br><span class="line">        ])</span><br><span class="line">        .send()</span><br><span class="line">        .await?</span><br><span class="line">        .json()</span><br><span class="line">        .await?;</span><br><span class="line"></span><br><span class="line">    let trans_result = res[&quot;trans_result&quot;]</span><br><span class="line">        .as_array()</span><br><span class="line">        .ok_or(anyhow!(&quot;&#123;res&#125;&quot;))?</span><br><span class="line">        .first()</span><br><span class="line">        .unwrap()[&quot;dst&quot;]</span><br><span class="line">        .clone();</span><br><span class="line"></span><br><span class="line">    Ok(trans_result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 签名方法，参考百度翻译API文档</span><br><span class="line">fn sign(q: &amp;str) -&gt; String &#123;</span><br><span class="line">    let str = format!(&quot;&#123;&#125;&#123;&#125;10086&#123;&#125;&quot;, &amp;*APP_ID, q, &amp;*APP_KEY);</span><br><span class="line">    let digest = md5::compute(str);</span><br><span class="line">    format!(&quot;&#123;:x&#125;&quot;, digest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="然后再实现批量调用"><a href="#然后再实现批量调用" class="headerlink" title="然后再实现批量调用"></a>然后再实现批量调用</h3><p>起初，我设想采用for循环逐个调用的方式实现功能，但这种方式未能充分利用Tokio框架提供的高并发特性。这一思考受到了TypeScript编程经验的影响，在TypeScript中，Promise会在定义后立即执行，而Rust语言中的Future则不同，它们仅在遇到await表达式时才会真正执行其异步操作。因此，为了适应Rust及Tokio的异步编程模型，我们需要采取更恰当的方式来调度并发任务以发挥其优势。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码pub async fn run&lt;P: AsRef&lt;Path&gt;&gt;(</span><br><span class="line">    url: &amp;str,</span><br><span class="line">    target_field: &amp;str,</span><br><span class="line">    path: P,</span><br><span class="line">    from: &amp;str,</span><br><span class="line">    to: &amp;str,</span><br><span class="line">    field: Option&lt;&amp;str&gt;,</span><br><span class="line">) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">    let custom_nodes: Value = CLIENT.get(url).send().await?.json().await?;</span><br><span class="line">    let nodes = if field.is_some() &#123;</span><br><span class="line">        &amp;custom_nodes[field.unwrap()]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &amp;custom_nodes</span><br><span class="line">    &#125;;</span><br><span class="line">    // 前面都不重要，只需要知道nodes就是要翻译的数据数组</span><br><span class="line">    let nodes = nodes.as_array().ok_or(anyhow!(&quot;&#123;nodes:#?&#125;&quot;))?;</span><br><span class="line"></span><br><span class="line">    let mut new_nodes = nodes.clone();</span><br><span class="line">    let time = std::time::Instant::now();</span><br><span class="line"></span><br><span class="line">    for node in new_nodes.iter_mut() &#123;</span><br><span class="line">        let src = node[target_field]</span><br><span class="line">            .as_str()</span><br><span class="line">            .ok_or(anyhow!(&quot;no description&quot;))?;</span><br><span class="line"></span><br><span class="line">        let zh = match trans(src, from, to).await &#123;</span><br><span class="line">            Ok(zh) =&gt; zh,</span><br><span class="line">            Err(e) =&gt; &#123;</span><br><span class="line">                error!(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                return Err(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        info!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, src, zh);</span><br><span class="line">        node[format!(&quot;&#123;to&#125;_&#123;target_field&#125;&quot;)] = zh;</span><br><span class="line">        warn!(&quot;one task time:&#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将数据写入文件中</span><br><span class="line">    info!(&quot;all time: &#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    let file = std::fs::File::create(&amp;path)?;</span><br><span class="line">    serde_json::to_writer_pretty(file, &amp;new_nodes)?;</span><br><span class="line">    info!(&quot;write to &#123;&#125;&quot;, path.as_ref().display().to_string());</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二版本，使用join-all来批量执行"><a href="#第二版本，使用join-all来批量执行" class="headerlink" title="第二版本，使用join_all来批量执行"></a>第二版本，使用join_all来批量执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码pub async fn run2&lt;P: AsRef&lt;Path&gt;&gt;(</span><br><span class="line">    url: &amp;str,</span><br><span class="line">    target_field: &amp;str,</span><br><span class="line">    path: P,</span><br><span class="line">    from: &amp;str,</span><br><span class="line">    to: &amp;str,</span><br><span class="line">    field: Option&lt;&amp;str&gt;,</span><br><span class="line">) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">    let custom_nodes: Value = CLIENT.get(url).send().await?.json().await?;</span><br><span class="line">    let nodes = if field.is_some() &#123;</span><br><span class="line">        &amp;custom_nodes[field.unwrap()]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &amp;custom_nodes</span><br><span class="line">    &#125;;</span><br><span class="line">    // 前面都不重要，只需要知道nodes就是要翻译的数据数组</span><br><span class="line">    let nodes = nodes.as_array().ok_or(anyhow!(&quot;&#123;nodes:#?&#125;&quot;))?;</span><br><span class="line"></span><br><span class="line">    let mut new_nodes = nodes.clone();</span><br><span class="line">    let time = std::time::Instant::now();</span><br><span class="line">		</span><br><span class="line">  	// 这里使用map转换成异步任务，但还没执行</span><br><span class="line">    let tasks = new_nodes.iter_mut().map(|node| async &#123;</span><br><span class="line">        let src = node[target_field]</span><br><span class="line">            .as_str()</span><br><span class="line">            .ok_or(anyhow!(&quot;no description&quot;))?;</span><br><span class="line"></span><br><span class="line">        let zh = match trans(src, from, to).await &#123;</span><br><span class="line">            Ok(zh) =&gt; zh,</span><br><span class="line">            Err(e) =&gt; &#123;</span><br><span class="line">                error!(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                return Err(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        info!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, src, zh);</span><br><span class="line">        node[format!(&quot;&#123;to&#125;_&#123;target_field&#125;&quot;)] = zh;</span><br><span class="line">        warn!(&quot;one task time:&#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">  	// 使用futures::future::join_all来批量执行这些任务  	</span><br><span class="line">    join_all(tasks).await;</span><br><span class="line">    // 将数据写入文件中</span><br><span class="line">    info!(&quot;all time: &#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    let file = std::fs::File::create(&amp;path)?;</span><br><span class="line">    serde_json::to_writer_pretty(file, &amp;new_nodes)?;</span><br><span class="line">    info!(&quot;write to &#123;&#125;&quot;, path.as_ref().display().to_string());</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将数据转换成批量异步任务，再使用join_all来等待他们所有执行完成。</p>
<p>其实这里有更好的方法就是使用<code>futures::stream::FuturesUnordered</code>，这里为了简便就使用了join_all。</p>
<h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>在实践高并发场景时，我发现百度API存在一定的调用频率限制，即每秒允许的请求次数有限制。因此，为了避免超出限制，我不得不对并发任务进行控制。鉴于这种情况下的时间敏感性，我没有选择使用<code>tokio::sync::Semaphore</code>作为并发限制工具，而是采用了批量分时执行策略：将任务划分为多个批次，每一批次之间的执行间隔为3秒，确保每批任务在前一批次执行满3秒后才开始执行，从而符合接口调用频率要求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码pub async fn run&lt;P: AsRef&lt;Path&gt;&gt;(</span><br><span class="line">    url: &amp;str,</span><br><span class="line">    target_field: &amp;str,</span><br><span class="line">    path: P,</span><br><span class="line">    from: &amp;str,</span><br><span class="line">    to: &amp;str,</span><br><span class="line">    field: Option&lt;&amp;str&gt;,</span><br><span class="line">) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">    let custom_nodes: Value = CLIENT.get(url).send().await?.json().await?;</span><br><span class="line">    let nodes = if field.is_some() &#123;</span><br><span class="line">        &amp;custom_nodes[field.unwrap()]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &amp;custom_nodes</span><br><span class="line">    &#125;;</span><br><span class="line">    let nodes = nodes.as_array().ok_or(anyhow!(&quot;&#123;nodes:#?&#125;&quot;))?;</span><br><span class="line"></span><br><span class="line">    let mut new_nodes = nodes.clone();</span><br><span class="line">    let time = std::time::Instant::now();</span><br><span class="line">		// 按5个进行分批</span><br><span class="line">    for i in (0..new_nodes.len()).step_by(5) &#123;</span><br><span class="line">        let time = std::time::Instant::now();</span><br><span class="line">      	// 对边界进行限制</span><br><span class="line">        let last = std::cmp::min(i + 5, new_nodes.len());</span><br><span class="line">      </span><br><span class="line">      	// 将这5个数据转换成批量任务</span><br><span class="line">        let tasks = &amp;mut new_nodes[i..last];</span><br><span class="line">        let tasks = tasks.iter_mut().map(|node| async move &#123;</span><br><span class="line">            let src = node[target_field]</span><br><span class="line">                .as_str()</span><br><span class="line">                .ok_or(anyhow!(&quot;no description&quot;))?;</span><br><span class="line"></span><br><span class="line">            let zh = match trans(src, from, to).await &#123;</span><br><span class="line">                Ok(zh) =&gt; zh,</span><br><span class="line">                Err(e) =&gt; &#123;</span><br><span class="line">                    error!(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                    return Err(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            info!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, src, zh);</span><br><span class="line">            node[format!(&quot;&#123;to&#125;_&#123;target_field&#125;&quot;)] = zh;</span><br><span class="line">            Ok::&lt;(), anyhow::Error&gt;(())</span><br><span class="line">        &#125;);</span><br><span class="line">				</span><br><span class="line">      	// 使用join等待两个异步任务一起执行完成</span><br><span class="line">      	// 设置时间为3秒</span><br><span class="line">      	// 注意下面注释的实际上是等待任务执行完后再等5秒。</span><br><span class="line">      	// join_all(tasks).await;</span><br><span class="line">      	// sleep(Duration::from_secs(3);</span><br><span class="line">        join!(join_all(tasks), sleep(Duration::from_secs(3)));</span><br><span class="line">        warn!(&quot;one task time:&#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    &#125;</span><br><span class="line">    info!(&quot;all time: &#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    let file = std::fs::File::create(&amp;path)?;</span><br><span class="line">    serde_json::to_writer_pretty(file, &amp;new_nodes)?;</span><br><span class="line">    info!(&quot;write to &#123;&#125;&quot;, path.as_ref().display().to_string());</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面代码在我的<a href="https://github.com/yexiyue/Comfyui-Startup" target="_blank" rel="noopener">GitHub</a> <code>translate</code>目录中，如果觉得有用，请给我点个赞吧，另外也恳请您为我的仓库点个Star，谢谢客官老爷。</strong></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359084920596103206" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Rust,前端</tag>
      </tags>
  </entry>
  <entry>
    <title>消息幂等</title>
    <url>/7359086041796542498.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景-amp-问题"><a href="#背景-amp-问题" class="headerlink" title="背景 &amp; 问题"></a>背景 &amp; 问题</h2><p>本位柯苏远写于2024年4月18日22点15分</p>
<p>还是在公司的整个电商业务中要接入sms 短信发送功能。</p>
<p>上一篇文章地址：<a href="https://dev.newban.cn/7354929072957702144#comment">分布式锁实战 - 掘金 (juejin.cn)</a></p>
<p>这周到实际开发过程了，首先将整个需求的技术方案设计好了，然后进行开发。整个方案的设计图如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f198debdf9ff77afa45db5b5111390d4c4d20f6b63a53893d0306ac84176a28d" alt="接口幂等 (1).jpg"></p>
<p>A服务：表示每个会产生sms消息的触发点，不单单是一个服务，而是很多个。<br>B服务：对外提供一个插入消息表的接口，所有触发发送sms短信的服务点都调用这个接口。<br>C服务：是一个轮询服务，对短信表进行轮询，找到待发送的sms 短信，然后调用sms api 发送短信给客户。</p>
<p>红框部分有个问题：</p>
<blockquote>
<p>当A向B推送消息的时候，在B收到消息往数据库成功插入数据之后，当要给A服务返回成功标识的时候，由于网络问题接口超时了，A那边收到的返回就是接口超时，那么对于A服务来说我并不知道这个消息到底成功推送没有？A此时应该怎么做？如果重新推送的话可能会在数据库存入一个一模一样的消息。如果不重新推送的话，那消息可能就丢失了。<br><strong>归根结底就是由于在第一步消息推送的时候如果发送接口超时，在A服务中我不知道如何处理当前超时的消息。</strong></p>
</blockquote>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>再次重申问题：</p>
<ol>
<li>如果推送消息接口超时，我按推送失败处理，继续推送这个消息，那么就可能往数据库插入两条一模一样的消息，导致的结果就是客户收到两条一模一样的消息。</li>
<li>如果推送消息接口超时，我按推送成功处理，不对这个消息再次推送，那么可能造成的问题就更大了，消息丢失了，这肯定不允许。</li>
</ol>
<p>既然存在两个问题，那么我们就分别想解决方案。</p>
<p>针对问题1：解决思路挺直观的，因为会往数据库插入重复数据，所以我们给每个消息一个唯一id，当这个消息插入数据库之后，这个消息唯一id也存入了，然后<strong>对这个消息唯一id字段进行设置唯一键</strong>。这样在数据库层面就避免了消息存储重复的可能。</p>
<p>针对问题2：推送接口超时，不推的话，大部分业务是接受不了的，因为消息丢了，所以我们继续推一次这个消息，不用担心会重复发送，因为在存储层面我们用了消息唯一id做唯一键。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>消息的唯一id怎么产生？</p>
<p>唯一id有很多种，用uuid，或者雪花算法都可以，我们这里用的是uuid。</p>
<p>将一个消息和一个uuid绑定的时候，当超时之后，这个消息对应的uuid要不要改？</p>
<p><strong>肯定是不能改的，改了的话，在数据库层面就会重复插入同一条消息</strong></p>
<p>那么不能改的话，当这个消息推送超时，如何解决继续用这个uuid推送？</p>
<p><strong>其实很简单，让uuid变成这个消息的一个属性，然后推送超时，将这个消息弄到一个本地的队列里去，进行重试。一定要注意，每个消息的唯一id是不会变的。</strong></p>
<h2 id="后续安排"><a href="#后续安排" class="headerlink" title="后续安排"></a>后续安排</h2><p>这个是我目前在工作中接触的第一个幂等场景，后续再看看其它幂等情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>消息重复发送的可能性。</li>
<li>引入消息唯一id在数据库层面做唯一索引。</li>
<li>消息推送超时，在内存进行重试，消息的唯一id是和每个消息强绑的，<strong>也就是说再重试的时候不能给消息生成新的唯一id</strong></li>
</ol>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359086041796542498" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于AssertionError:Torchnotc</title>
    <url>/7359086027581210660.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你好，我是 shengjk1，多年大厂经验，努力构建 通俗易懂的、好玩的编程语言教程。 欢迎关注！你会有如下收益：</p>
<ol>
<li>了解大厂经验</li>
<li>拥有和大厂相匹配的技术等</li>
</ol>
<p>希望看什么，评论或者私信告诉我！</p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>最近喜欢上了 ComfyUI ，在安装的过程中，出现了</p>
<blockquote>
<p>AssertionError: Torch not compiled with CUDA enabled</p>
</blockquote>
<p>网上有很多文章都在讲怎么解决，没啥意思，本篇会视图搞懂啥是 CUDA，为 Torch 是基于 CUDA 的</p>
<h1 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h1><h2 id="2-1-CUDA-是什么"><a href="#2-1-CUDA-是什么" class="headerlink" title="2.1 CUDA 是什么"></a>2.1 CUDA 是什么</h2><p>全称：Compute Unified Architecture，是 Nvidia’s GPUs 上的通用处理平台。不需要顺序执行的任务，可以利用GPU中的 CUDA 实现并行计算</p>
<p>借助 C、C++ 和 Fortran 语言支持，使用 CUDA 将计算密集型任务运行到 Nvidia GPU 非常容易。 CUDA 被用于需要大量计算能力的领域，或者可以并行化并且需要高性能的场景。机器学习、医学研究和分析、物理学、超级计算、加密货币挖掘、科学建模和模拟等领域都在使用 CUDA。</p>
<h2 id="2-2-Intel-R-Lris-R）Xe-Graphics-是什么"><a href="#2-2-Intel-R-Lris-R）Xe-Graphics-是什么" class="headerlink" title="2.2 Intel(R) Lris(R）Xe Graphics 是什么"></a>2.2 Intel(R) Lris(R）Xe Graphics 是什么</h2><p>为什么介绍它呢？原因很简单，因为我使用的笔记本的显卡就是它。它是 Intel 的集成显卡。所以如果你的也是这样的。那么恭喜你。网上多数解决方案，肯定解决不了 AssertionError: Torch not compiled with CUDA enabled 。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/12ec972cc059de0986ee1cb74ce1fc183d0103ea5640dccdfd083c3a276d7204" alt></p>
<h1 id="三、AssertionError-Torch-not-compiled-with-CUDA-enabled-怎么解"><a href="#三、AssertionError-Torch-not-compiled-with-CUDA-enabled-怎么解" class="headerlink" title="三、AssertionError: Torch not compiled with CUDA enabled 怎么解"></a>三、AssertionError: Torch not compiled with CUDA enabled 怎么解</h1><h2 id="3-1-步骤1：检查GPU是否支持CUDA"><a href="#3-1-步骤1：检查GPU是否支持CUDA" class="headerlink" title="3.1 步骤1：检查GPU是否支持CUDA"></a>3.1 步骤1：检查GPU是否支持CUDA</h2><p>首先，确保你的GPU支持CUDA。你可以访问NVIDIA官网查看你的GPU是否支持CUDA。如果你的GPU不支持CUDA，那么你需要更换支持CUDA的GPU或者在CPU上运行你的PyTorch程序。</p>
<h2 id="3-2-安装支持CUDA的PyTorch版本"><a href="#3-2-安装支持CUDA的PyTorch版本" class="headerlink" title="3.2 安装支持CUDA的PyTorch版本"></a>3.2 安装支持CUDA的PyTorch版本</h2><p>如果你确定你的GPU支持CUDA，那么接下来需要安装支持CUDA的PyTorch版本。你可以从PyTorch官网下载对应你GPU型号和操作系统的安装包。在下载安装包时，请确保选择支持CUDA的版本。</p>
<h2 id="3-3-安装CUDA工具包"><a href="#3-3-安装CUDA工具包" class="headerlink" title="3.3 安装CUDA工具包"></a>3.3 安装CUDA工具包</h2><p>在安装PyTorch之前，你需要先安装CUDA工具包。你可以从NVIDIA官网下载对应你GPU型号和操作系统的CUDA工具包。安装完成后，你需要将CUDA工具包的路径添加到系统环境变量中。具体操作方法可以参考CUDA安装文档。</p>
<h2 id="3-4-重新安装PyTorch"><a href="#3-4-重新安装PyTorch" class="headerlink" title="3.4 重新安装PyTorch"></a>3.4 重新安装PyTorch</h2><p>安装好CUDA工具包后，重新安装PyTorch。按照之前下载的PyTorch安装包进行安装，确保选择与你的GPU和操作系统相匹配的版本。在安装过程中，确保勾选“Install CUDA”选项，以便将PyTorch与CUDA集成。</p>
<h2 id="3-5-验证安装"><a href="#3-5-验证安装" class="headerlink" title="3.5 验证安装"></a>3.5 验证安装</h2><p>完成以上步骤后，验证PyTorch是否正确安装了CUDA支持。打开Python终端，输入以下命令：</p>
<p>import torch</p>
<p>如果成功导入PyTorch库，那么说明你已经成功安装了支持CUDA的PyTorch版本。接下来，你可以尝试运行你的PyTorch程序，看看是否还会出现“AssertionError: Torch not compiled with CUDA enabled”错误。</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ol>
<li>如何解：<br>进入 pytorch官网，<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">pytorch.org/get-started…</a> 选择合适的方式下载合适的包</li>
<li>合适选择方法，例如 inter 显卡，不要用 cuda 相关的方法：</li>
</ol>
<blockquote>
<p>torch.device(torch.cuda.current_device())</p>
</blockquote>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>CUDA 是 Nvidia’s GPUs 上的通用处理平台，用于实现并行计算。如果出现 “AssertionError: Torch not compiled with CUDA enabled” 错误，需要检查GPU是否支持CUDA，并安装支持CUDA的PyTorch版本以及CUDA工具包，然后重新安装PyTorch进行验证。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359086027581210660" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd学习之udevudev</title>
    <url>/7359138355181043739.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h1><p>udev - Dynamic device management 动态地址管理</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>udev 能够处理设备事件、管理设备文件的权限、 在 <code>/dev</code> 目录中创建额外的符号链接、重命名网络接口，等等。 内核通常仅根据设备被发现的先后顺序给设备文件命名， 因此很难在设备文件与物理硬件之间建立稳定的对应关系。 而根据设备的物理属性或配置特征创建有意义的符号链接名称或网络接口名称， 就可以在物理设备与设备文件名称之间建立稳定的对应关系。</p>
<p>udev守护进程(<a href="https://man7.org/linux/man-pages/man8/systemd-udevd.service.8.html" target="_blank" rel="noopener">systemd-udevd.service(8)</a>) 直接从内核接收设备的插入、拔出、改变状态等事件， 并根据这些事件的各种属性， 到规则库中进行匹配，以确定触发事件的设备。 被匹配成功的规则有可能提供额外的设备信息，这些信息可能会被记录到udev数据库中， 也可能会被用于创建符号链接。</p>
<p>udev处理的所有设备信息都存储在udev数据库中， 并且会发送给可能的设备事件的订阅者。 可以通过 libudev 库访问udev数据库以及设备事件源。</p>
<h2 id="规则文件"><a href="#规则文件" class="headerlink" title="规则文件"></a>规则文件</h2><blockquote>
<p>可以直接看示例，参照示例来匹配规则说明</p>
</blockquote>
<p>规则文件分别位于： 系统规则目录(<code>/usr/lib/udev/rules.d</code>)、 运行时规则目录(<code>/run/udev/rules.d</code>)、 本机规则目录(<code>/etc/udev/rules.d</code>)。 无论位于哪个目录中，所有的规则文件统一按照文件名的字典顺序处理。 对于不同目录下的同名规则文件，仅以优先级最高的目录中的那一个为准。 也就是说3个目录按照a-z的顺序： <code>/etc/</code> 的优先级最高、 <code>/run/</code> 的优先级居中、 <code>/usr/lib/</code> 的优先级最低。 如果系统管理员想要屏蔽 <code>/usr/lib/</code> 目录中的某个规则文件， 那么最佳做法是在 <code>/etc/</code> 目录中创建一个指向 <code>/dev/null</code> 的同名符号链接， 即可彻底屏蔽 <code>/usr/lib/</code> 目录中的同名文件。 注意，规则文件必须以 <code>.rules</code> 作为后缀名，否则将被忽略。</p>
<p>规则文件中以 “<code>#</code>“ 开头的行以及空行将被忽略， 其他不以 “<code>#</code>“ 开头的非空行，每行必须至少包含一个”键-值”对。 “键”有两种类型：匹配与赋值。 如果某条规则的所有匹配键的值都匹配成功，那么就表示此条规则匹配成功， 也就是此条规则中的所有赋值键都会被赋予指定的值。</p>
<p>一条匹配成功的规则可以 重命名一个网络接口、为某个设备文件添加一个软连接、运行一个指定的程序作为事件处理的一部分。</p>
<p>每条规则都是由一系列逗号分隔的”键-值”对组成。 根据操作符的不同，每个键都对应着一个唯一的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ ls /usr/lib/udev/rules.d</span><br><span class="line">50-firmware.rules		   60-input-id.rules		     60-serial.rules	    73-special-net-names.rules	       80-net-setup-link.rules</span><br><span class="line">50-kdump-tools.rules		   60-persistent-alsa.rules	     64-btrfs.rules	    73-usb-net-by-mac.rules	       85-hdparm.rules</span><br><span class="line">50-udev-default.rules		   60-persistent-input.rules	     69-lvm-metad.rules     75-net-description.rules	       85-hwclock.rules</span><br><span class="line">55-dm.rules			   60-persistent-storage-dm.rules    70-joystick.rules	    75-persistent-net-generator.rules  90-console-setup.rules</span><br><span class="line">56-lvm.rules			   60-persistent-storage.rules	     70-mouse.rules	    75-probe_mtd.rules		       90-rdma-umad.rules</span><br><span class="line">60-block.rules			   60-persistent-storage-tape.rules  70-power-switch.rules  75-rdma-description.rules	       95-dm-notify.rules</span><br><span class="line">60-bridge-network-interface.rules  60-persistent-v4l.rules	     70-touchpad.rules	    78-sound-card.rules		       99-systemd.rules</span><br><span class="line">60-cdrom_id.rules		   60-rdma-ndd.rules		     70-uaccess.rules	    80-debian-compat.rules</span><br><span class="line">60-drm.rules			   60-rdma-persistent-naming.rules   71-seat.rules	    80-drivers.rules</span><br><span class="line">60-evdev.rules			   60-sensor.rules		     73-seat-late.rules     80-ifupdown.rules</span><br></pre></td></tr></table></figure>

<h3 id="匹配-赋值操作符"><a href="#匹配-赋值操作符" class="headerlink" title="匹配/赋值操作符"></a>匹配/赋值操作符</h3><p>匹配</p>
<ul>
<li>“<code>==</code>“：(匹配)”等于”</li>
<li>“<code>!=</code>“：(匹配)”不等于”</li>
</ul>
<p>赋值</p>
<ul>
<li>“<code>=</code>“：(赋值)为键赋予指定的值。 此键之前的值(可能是个列表)将被丢弃。</li>
<li>“<code>+=</code>“：(赋值)在键的现有值列表中增加此处指定的值。</li>
<li>“<code>-=</code>“：(赋值)在键的现有值列表中删除此处指定的值。<strong>- Added in version 217</strong></li>
<li>“<code>:=</code>“：(赋值)为键赋予指定的值，并视为最终值，也就是禁止被继续修改。<strong>- Added in version 247</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ systemd --version</span><br><span class="line">systemd 247 (247.3-7+deb11u2)</span><br><span class="line">+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +ZSTD +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=unified</span><br></pre></td></tr></table></figure>

<h3 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h3><p>值需要用双引号包裹，例如：<code>&quot;string&quot;</code>，如果值需要使用双引号，则使用<code>\&quot;</code>，除此（<code>\&quot;</code>）之外的其他反斜杠后面的字符都不会被还原成其原始的形式。也就是说，<code>&quot;\t\n&quot;</code>会被视为4个字符：反斜杠、小写字母t、反斜杠、小写字母n。</p>
<p>字符串可以以小写字母e作为前缀（<code>e&quot;string\n&quot;</code>）来标记字符串为C风格转义字符串，参见C中的转义序列。例如，<code>e&quot;string\n&quot;</code>会被解析为7个字符：6个小写字母和一个换行符。这对于在内核驱动程序需要特殊字符时是有用的。</p>
<p>请注意，在任何字符串变体中都不允许使用<code>NUL</code>。</p>
<h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p><strong>以下Keys可用于与设备属性进行匹配。其中一些键也可以与sysfs中的父设备属性匹配，而不仅仅是生成事件的设备。如果在单个规则中指定了与父设备匹配的多个键，则所有这些键都必须在同一个父设备上匹配。</strong></p>
<ul>
<li><code>ACTION</code>：匹配事件的动作。例如<code>&quot;add&quot;</code>表示插入一个设备。</li>
<li><code>DEVPATH</code>：匹配设备的路径(也就是该设备在sysfs文件系统下的相对路径)。例如：<code>/dev/sda1</code> 对应的 devpath 是<code>/sys/block/sda/sda1</code>。</li>
<li><code>KERNEL</code>：匹配设备的内核名称。”内核名称”是指设备在sysfs里的名称，也就是默认的设备文件名称，例如”sda”。</li>
<li><code>NAME</code>：匹配网络接口的名称。 仅在先前的规则中已将 NAME 键赋值的前提下，才可将此键用于匹配。</li>
<li><code>SYMLINK</code>：匹配指向节点的符号链接的名称。一旦在先前的规则中设置了SYMLINK键，就可以使用它。可能有多个符号链接；只需要一个匹配。如果操作符是”!=”，则只有在没有匹配到符号链接时，该标记才返回true。</li>
<li><code>SUBSYSTEM</code>：匹配设备所属的子系统。例如”sound”或”net”</li>
<li><code>SUBSYSTEMS</code>：沿着devpath向上搜索匹配的SUBSYSTEM名称。</li>
<li><code>DRIVER</code>：匹配设备的驱动程序名称。 仅在设备事件发生时，此设备确实正好绑定着一个驱动程序情况下，此键才会被设置</li>
<li><code>DRIVERS</code>：沿着devpath向上搜索匹配的DRIVER名称。</li>
<li><code>ATTR{filename}</code>：匹配设备在sysfs中的属性值。属性值中的尾部空白会被忽略，除非指定的值自身就包含尾部空白。大括号中的”文件”是指设备路径(devpath)下的文件。 例如，对于 <code>/dev/sda1</code> 来说，<code>ATTR{size}</code> 的含义其实是指 <code>/sys/block/sda/sda1/size</code> 文件的内容。</li>
<li><code>ATTRS{filename}</code>：沿着devpath向上搜索具有匹配sysfs属性值的设备。如果指定了多个ATTRS匹配，那么所有这些匹配都必须在同一个设备上匹配。</li>
<li><code>SYSCTL{kernel参数}</code>：匹配”内核参数”的值。所谓”内核参数”其实是指 <code>/proc/sys/</code> 中的”内核参数”。例如，可以用 <code>SYSCTL{kernel/hostname}</code> 匹配 <code>/proc/sys/kernel/hostname</code> 的值。<strong>- Added in version 240</strong></li>
<li><code>ENV{key}</code>：匹配设备的属性。可以通过 <code>udevadm info --query=property /dev/sda</code> 命令查看 /dev/sda 的所有属性，例如 “DEVTYPE”, “ID_PATH”, “SYSTEMD_WANTS” 等等。</li>
<li><code>CONST{key}</code>：匹配系统范围的常量。支持的键包括：</li>
</ul>
<pre><code>+ &quot;arch&quot;：系统的架构。有关可能的值，请参阅[systemd.unit(5)](https://man7.org/linux/man-pages/man5/systemd.unit.5.html)中的`ConditionArchitecture=values`。
+ &quot;virt&quot;：系统的虚拟化环境。有关可能的值，请参阅[systemd-detect-virt(1)](https://man7.org/linux/man-pages/man1/systemd-detect-virt.1.html)。
+ &quot;cvm&quot;：系统的保密虚拟化技术。有关可能的值，请参阅[systemd-detect-virt(1)](https://man7.org/linux/man-pages/man1/systemd-detect-virt.1.html)。未知的键将永远不会匹配。</code></pre><ul>
<li><code>TAG</code>：根据设备标签中的一个进行匹配。只要前面的规则中设置了一个TAG键，就可以使用该功能。可能有多个标签；只需要一个匹配。如果运算符是”!=”，则仅当没有标签匹配时，该标记才返回true。</li>
<li><code>TAGS</code>：沿着devpath向上搜索匹配的TAG名称。</li>
<li><code>TEST{八进制模式掩码}</code>：检测指定的文件是否存在。如果有必要，还可以额外指定一个八进制的访问模式掩码。</li>
<li><code>PROGRAM</code>：执行指定的程序并检查返回值， 如果返回值为零，则匹配成功，否则匹配失败。 设备的属性会转化为该程序的环境变量供其使用。 同时该程序的标准输出会被 自动保存在 <code>RESULT</code> 键中。注意，仅可用于执行时间很短的前台程序。 参见 <code>RUN</code></li>
<li><code>RESULT</code>：匹配最近一次 <code>PROGRAM</code> 程序的输出字符串， 必须位于 <code>PROGRAM</code> 之后(但可出现在同一条规则中)。</li>
</ul>
<p><strong>可以在用于匹配的”值”中使用shell风格的通配符， 具体说来就是：</strong></p>
<ul>
<li>“<code>*</code>“：匹配任意数量的字符(包括零个)</li>
<li>“<code>?</code>“：匹配单独一个字符</li>
<li>“<code>[]</code>“：匹配中括号内的任意一个字符。 例如 “<code>tty[SR]</code>“ 可以匹配 “<code>ttyS</code>“ 或 “<code>ttyR</code>“ 。 还可以使用 “<code>-</code>“ 符号表示一个区间。 例如 “<code>[0-9]</code>“ 可以匹配任意数字。 如果在左括号 “<code>[</code>“ 后紧接着一个 “<code>!</code>“ 则表示匹配非括号内的字符。</li>
<li>“<code>|</code>“：用于分隔两个可相互替代的匹配模式(也就是”或”的意思)。 例如 “<code>abc|x*</code>“ 的意思是匹配 “<code>abc</code>“ 或 “<code>x*</code>“</li>
</ul>
<p><strong>下面的keys可用于赋值</strong></p>
<ul>
<li><code>NAME</code>：设置网络接口的名称。参见 <a href="https://man7.org/linux/man-pages/man5/systemd.link.5.html" target="_blank" rel="noopener">systemd.link(5)</a> 以了解设置网络接口名称的高级机制。 实际上，udev 并不能直接修改设备节点的名称， 它只能为设备节点创建额外的符号链接(相当于添加了别名)。</li>
<li><code>SYMLINK</code>：设置指向此设备节点的 软连接名称。</li>
</ul>
<pre><code>+ 软连接的名字中仅允许使用下列字符： &quot;`0-9A-Za-z#+-.:=@_/`&quot; 、有效的UTF-8字符、 &quot;`\x00`&quot; 风格的十六进制编码(实际的文件名并不转码)。 其他字符将被替换为 &quot;`_`&quot; 字符。
+ 只需在多个名称之间使用空格分隔，即可一次指定多个软连接名称。 如果为多个不同的设备指定了相同的软连接， 那么实际的软连接将指向 link\_priority 值最高的设备。 如果 link\_priority 值最高的设备被移除， 那么该软连接将重新指向下一个 link\_priority 值最高的设备，以此类推。 对于未指定 link\_priority 值或者 link\_priority 值相等的设备， 它们之间的顺序是不确定的。
+ 符号连接的名称必须不能与内核的默认名称相同， 否则会得到无法预知的结果。</code></pre><ul>
<li><code>OWNER</code>, <code>GROUP</code>, `MODE：设置设备节点的属主、属组、权限。 会覆盖内置的默认值。</li>
<li><code>SECLABEL{模块}</code>：设置设备节点的Linux安全模块标签。<strong>- Added in version 209</strong></li>
<li><code>ATTR{key}</code>：应写入到事件设备的sysfs属性的数值。</li>
<li><code>SYSCTL{kernel parameter}</code>：应写入到内核参数的数值。<strong>- Added in version 220</strong></li>
<li><code>ENV{key}</code>：设置设备属性值。具有前缀”.”的属性名称既不存储在数据库中，也不导出到事件或外部工具（例如，由PROGRAM匹配键运行）。</li>
<li><code>TAG</code>：将标签附加到设备。用于过滤libudev监视功能的用户的事件，或者用于枚举带有标签的设备组。实现仅在将少量标签附加到设备时才能有效工作。仅应在具有特定设备过滤要求的上下文中使用，而不是作为通用标志。过度使用可能导致事件处理效率低下。</li>
<li><code>RUN{type}</code>：指定在处理事件的所有规则之后要执行的程序。使用”+=”将此调用添加到列表中，使用”=”或”:=”替换列表的任何先前内容。请注意，下面描述的”program”和”builtin”类型共享一个公共列表，因此使用”:=”和”=”清除列表会影响两种类型。<br>type可以是：</li>
</ul>
<pre><code>+ &quot;program&quot;：执行分配值指定的外部程序。如果没有给出绝对路径，则预期程序位于/usr/lib/udev；否则，必须指定绝对路径。如果未指定类型，则此为默认设置。
+ &quot;builtin&quot;：与&quot;program&quot;相同，但使用内置程序之一，而不是外部程序。程序名称和后续参数由空格分隔。可以使用单引号指定带有空格的参数。</code></pre><p>这仅可用于非常短暂的前台任务。长时间运行事件进程可能会阻塞此设备或依赖设备的所有进一步事件。</p>
<p>请注意，在udev规则内部不允许运行访问网络或挂载/卸载文件系统的程序，这是由于systemd-udevd.service上强制执行的默认沙箱。</p>
<p>不允许启动守护程序或其他长时间运行的进程；分叉的进程，无论是否分离，都将在事件处理完成后被无条件终止。为了从udev规则激活长时间运行的进程，提供一个服务单元，并使用SYSTEMD_WANTS设备属性从udev设备中引入它。有关详细信息，请参阅<a href="https://man7.org/linux/man-pages/man5/systemd.device.5.html" target="_blank" rel="noopener">systemd.device(5)</a>。</p>
<ul>
<li><code>LABEL</code>：设置一个可用作 GOTO 跳转目标的标签。</li>
<li><code>GOTO</code>：跳转到下一个匹配的 LABEL 标签所在的规则。</li>
<li><code>IMPORT{type}</code>：将一组变量导入为设备的属性。</li>
<li><code>OPTIONS</code>：规则与设备的选项</li>
</ul>
<pre><code>+ `link_priority=value`：指定创建符号链接时的优先级。 数值越大优先级越高。默认值是&quot;0&quot;。
+ `string_escape=none|replace`：在对设备进行命名时，如何处理设备名字中的非常规字符(比如控制字符与不安全的字符)。 none 表示不做处理，保持原样； replace 表示将这些非常规字符替换为&quot;\_&quot;(下划线)。
+ `static_node=`：将本条规则设定的权限 应用到此选项指定的静态设备节点上。 同时，如果在本规则中指定了标签(tag)， 那么还会在 `/run/udev/static_node-tags/*`tag`*` 目录中创建一个指向该静态设备节点的软连接。 注意，在 systemd-udevd 启动之前， 静态设备节点就已经由 systemd-tmpfiles 创建完成了。 创建静态设备节点时，并不要求存在对应的内核设备， 因为当这些设备节点被访问时，会触发内核模块的自动加载功能。
+ `watch`：使用文件系统的 inotify 功能监视设备节点。 当节点被打开并写入之后又被关闭， 将会触发一个&quot;设备状态已变化&quot;的事件。
+ `nowatch`：禁用针对设备节点的 inotify 监视功能。
+ `db_persist`：在事件设备的 udev 数据库项上设置 粘滞位(sticky bit)。 这样，即使调用了 **udevadm info --cleanup-db** 命令， 设备的属性也依然会保存在数据库中。 在某些情况下(例如 Device Mapper 设备)， 此选项可用于从 initramfs 切换至真实的根文件系统时，依然保持设备的状态。**- Added in version 241**
+ `log_level=level`：允许设置日志级别名称，如&quot;debug&quot;或&quot;info&quot;，或特殊值&quot;reset&quot;。当指定日志级别名称时，最大日志级别将更改为该级别。设置为&quot;reset&quot;时，则撤销先前指定的日志级别。默认情况下，它使用systemd-udevd的主进程的日志级别。此功能对于调试与特定设备相关的事件非常有用。注意，日志级别是在行时应用的
包含此规则进行处理。因此，对于调试，它建议在较早的地方指定，例如00-debug.rules的第一行：`SUBSYSTEM==&quot;net&quot;, OPTIONS=&quot;log_level=debug&quot;`。**- Added in version 248**</code></pre><p><strong><code>NAME</code>, <code>SYMLINK</code>, <code>PROGRAM</code>, <code>OWNER</code>, <code>GROUP</code>, <code>MODE</code>, <code>SECLABEL</code>, <code>RUN</code> 都支持简单的字符串替换。 <code>RUN</code> 的替换发生在 所有规则全部处理完成之后、程序将要执行之前， 因此可以使用由匹配成功的规则所设置的设备属性。 而其他键的替换发生在该键所在规则被处理完成的当时。 可用的替换标记如下：</strong></p>
<ul>
<li><code>$kernel, %k</code>：设备的内核名称</li>
<li><code>$number, %n</code>：设备在内核中的序号。例如，对于 “<code>sda3</code>“ 来说，此值为 “<code>3</code>“</li>
<li><code>$devpath, %p</code>：设备路径(devpath)。也就是该设备在sysfs文件系统下的相对路径。例如，/dev/sda1 对应的设备路径是 /block/sda/sda1 (一般对应着 /sys/block/sda/sda1 目录)。</li>
<li><code>$id, %b</code>：被 <code>SUBSYSTEMS</code>, <code>KERNELS</code>, <code>DRIVERS</code>, <code>ATTRS</code> 成功匹配到的设备的设备名称（The name of the device）</li>
<li><code>$driver</code>：被 <code>SUBSYSTEMS</code>, <code>KERNELS</code>, <code>DRIVERS</code>, <code>ATTRS</code> 成功匹配到的设备的驱动名称（The driver name of the device）</li>
<li><code>$attr{file}, %s{file}</code>：在规则匹配成功时， 设备路径(devpath)下”文件”的内容(用于表示设备的属性)。 如果该设备路径下没有此文件，则从先前 KERNELS, SUBSYSTEMS, DRIVERS, ATTRS 匹配的父设备中提取。如果”文件”是一个软连接， 则一直追踪软连接到最终的实际文件。</li>
<li><code>$env{key}, %E{key}</code>：备的属性值。例如 “DEVTYPE”, “ID_PATH”, “SYSTEMD_WANTS” 等等。[提示]可以通过 udevadm info –query=property /dev/sda 命令查看 /dev/sda 的所有属性。</li>
<li><code>$major, %M</code>：设备的主设备号</li>
<li><code>$minor, %m</code>：设备的次设备号</li>
<li><code>$result, %c</code>：外部程序 PROGRAM 的输出字符串。 可以使用 “%c{N}” 提取第N个子字符串(以空格为分隔符，从”1”开始计数)。 也可以通过 “%c{N+}”(也就是在数字后附加一个 “+”)提取 从第N个子字符串开始一直到结尾的部分。</li>
<li><code>$parent, %P</code>：父设备的节点名称</li>
<li><code>$name</code>：设备的当前名称。如果没有被任何udev规则修改， 那么等于该设备的内核名称。</li>
<li><code>$links</code>：一个空格分隔的软链接名称列表，这些软链接都指向该设备的节点。 该值仅在两种情况下存在：(1)发生”remove”事件；(2)先前的规则已对 SYMLINK 赋值。</li>
<li><code>$root, %r</code>：udev_root 的值</li>
<li><code>$sys, %S</code>：sysfs 文件系统的挂载点</li>
<li><code>$devnode, %N</code>：设备节点的名称(也就是设备文件的名称)</li>
<li><code>%%</code>：”<code>%</code>“ 自身</li>
<li><code>$$</code>：”<code>$</code>“ 自身</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>systemd-udevd.service可以从内核监测网卡状态的改变，根据事件来触发相应的操作。例如我们常用的修改网卡名称规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ cat /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;e8:eb:d3:36:b3:1a&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth0&quot;</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;e8:eb:d3:36:b3:1b&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth1&quot;</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;9c:c2:c4:0e:24:e0&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth2&quot;</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;9c:c2:c4:0e:24:e1&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth3&quot;</span><br></pre></td></tr></table></figure>

<p>关键点</p>
<ul>
<li>/etc/udev/rules.d 优先级最高</li>
<li>所有带<code>==</code>都是匹配，最后的<code>=</code>才是赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ cat  /usr/lib/udev/rules.d/75-net-description.rules</span><br><span class="line"># do not edit this file, it will be overwritten on update</span><br><span class="line"></span><br><span class="line">ACTION==&quot;remove&quot;, GOTO=&quot;net_end&quot;</span><br><span class="line">SUBSYSTEM!=&quot;net&quot;, GOTO=&quot;net_end&quot;</span><br><span class="line"></span><br><span class="line">IMPORT&#123;builtin&#125;=&quot;net_id&quot;</span><br><span class="line"></span><br><span class="line">SUBSYSTEMS==&quot;usb&quot;, IMPORT&#123;builtin&#125;=&quot;usb_id&quot;, IMPORT&#123;builtin&#125;=&quot;hwdb --subsystem=usb&quot;</span><br><span class="line">SUBSYSTEMS==&quot;usb&quot;, GOTO=&quot;net_end&quot;</span><br><span class="line"></span><br><span class="line">SUBSYSTEMS==&quot;pci&quot;, ENV&#123;ID_BUS&#125;=&quot;pci&quot;, ENV&#123;ID_VENDOR_ID&#125;=&quot;$attr&#123;vendor&#125;&quot;, ENV&#123;ID_MODEL_ID&#125;=&quot;$attr&#123;device&#125;&quot;</span><br><span class="line">SUBSYSTEMS==&quot;pci&quot;, IMPORT&#123;builtin&#125;=&quot;hwdb --subsystem=pci&quot;</span><br><span class="line"></span><br><span class="line">LABEL=&quot;net_end&quot;</span><br></pre></td></tr></table></figure>

<p>关键点</p>
<ul>
<li>ACTION为remove、非net就跳转到net_end，啥都不做</li>
<li>IMPORT{builtin}=”net_id”：执行net_id载入变量</li>
<li>如果子系统是USB，则导入内置的”usb_id”和”hwdb –subsystem=usb”规则，并跳转到标签net_end。</li>
<li>如果子系统是PCI，则设置环境变量”ID_BUS”为”pci”，并设置”ID_VENDOR_ID”和”ID_MODEL_ID”为设备的供应商ID和设备ID。同时执行内置的”hwdb –subsystem=pci”规则。</li>
</ul>
<hr>
<p>参考：<a href="https://man7.org/linux/man-pages/man7/udev.7.html" target="_blank" rel="noopener">man7.org/linux/man-p…</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359138355181043739" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>强烈推荐，好用的时序图开源插件PlantUML！</title>
    <url>/7359138355181600795.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每开发一个新需求，做系统设计时，<code>系统时序图</code>一般都少不了，你用的画图软件有没有给你带来一些问题呢？</p>
<h3 id="1、比如不美观，图形线条不好对齐，比如下面这个："><a href="#1、比如不美观，图形线条不好对齐，比如下面这个：" class="headerlink" title="1、比如不美观，图形线条不好对齐，比如下面这个："></a>1、比如<code>不美观</code>，图形线条<code>不好对齐</code>，比如下面这个：</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8bb57eb1ecbc58ca81fc478fd83ec6b68822f23ee25f13a1d8013f7a2398c642" alt="image.png"></p>
<p>这个图没有完全对齐，而且是我比较费劲去尽量对齐了，线条都需要自己一根根对齐，比较麻烦，画图的时间都用在对齐线条上去了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3cf69374ca4e88af7c33f07f153de51c7df5b53b2628bcc7afdf166c331a9607" alt="image.png"></p>
<h3 id="2、逻辑判断选择不好表示，比如if-else，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择"><a href="#2、逻辑判断选择不好表示，比如if-else，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择" class="headerlink" title="2、逻辑判断选择不好表示，比如if/else，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择"></a>2、<code>逻辑判断</code>选择不好表示，比如<code>if/else</code>，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c61aa2f688e704ef531858561eafd8ad6f4e1e2cba59284c81ea5b5912ef84f6" alt="image.png"></p>
<h3 id="3、没有循环处理"><a href="#3、没有循环处理" class="headerlink" title="3、没有循环处理"></a>3、没有<code>循环处理</code></h3><h3 id="4、想给文字或者某个核心流程加上颜色"><a href="#4、想给文字或者某个核心流程加上颜色" class="headerlink" title="4、想给文字或者某个核心流程加上颜色"></a>4、想给文字或者某个核心流程加上<code>颜色</code></h3><h3 id="5、时序上的流程需要手动去编号，也很麻烦，比如下面的图"><a href="#5、时序上的流程需要手动去编号，也很麻烦，比如下面的图" class="headerlink" title="5、时序上的流程需要手动去编号，也很麻烦，比如下面的图"></a>5、时序上的流程需要手动去<code>编号</code>，也很麻烦，比如下面的图</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c9aa6dd65b0648080ff465db00313dfdffc3a738ae158b879e5995ddeb123522" alt="image.png"></p>
<p>今天要介绍的这个插件软件，上面的问题都可以解决。如果你也遇到了上面的问题，强烈推荐你收藏用起来，看下面画的OpenFeign负载均衡的核心时序图。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3d9e9af646e1a525b738fef4fca64f59cf0862c30c30d2213ec9d0adb9cc4aaa" alt="image.png"></p>
<h2 id="PlantUML介绍与优势"><a href="#PlantUML介绍与优势" class="headerlink" title="PlantUML介绍与优势"></a>PlantUML介绍与优势</h2><p>PlantUML是一个开源项目，官网：<code>https://plantuml.com/sequence-diagram</code></p>
<p>它既支持常用的uml图，也支持非uml图，比如思维导图，我最常用的就是<code>时序图</code>。</p>
<p>我觉得它有如下优点：</p>
<h3 id="1、语法简单，快速上手，可视化制作"><a href="#1、语法简单，快速上手，可视化制作" class="headerlink" title="1、语法简单，快速上手，可视化制作"></a>1、<code>语法简单</code>，快速上手，可视化制作</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c1985465333c43245a753847c046a0f56c7d60cae4b8e33dca94adb672739589" alt="image.png"></p>
<h3 id="2、图形线条关联是自动关联的，不需要手动关联"><a href="#2、图形线条关联是自动关联的，不需要手动关联" class="headerlink" title="2、图形线条关联是自动关联的，不需要手动关联"></a>2、图形线条关联是<code>自动关联</code>的，不需要手动关联</h3><h3 id="3、支持循环，if-else等逻辑表示"><a href="#3、支持循环，if-else等逻辑表示" class="headerlink" title="3、支持循环，if/else等逻辑表示"></a>3、支持<code>循环</code>，<code>if/else</code>等逻辑表示</h3><h3 id="4、制作的图形更美观和和谐"><a href="#4、制作的图形更美观和和谐" class="headerlink" title="4、制作的图形更美观和和谐"></a>4、制作的图形<code>更美观和和谐</code></h3><h3 id="5、修改比较容易，有些制作完成导出成图片了不好改，PlatUML可以改"><a href="#5、修改比较容易，有些制作完成导出成图片了不好改，PlatUML可以改" class="headerlink" title="5、修改比较容易，有些制作完成导出成图片了不好改，PlatUML可以改"></a>5、<code>修改比较容易</code>，有些制作完成导出成图片了不好改，PlatUML可以改</h3><h2 id="PlantUML案例"><a href="#PlantUML案例" class="headerlink" title="PlantUML案例"></a>PlantUML案例</h2><h3 id="1、声明参与者"><a href="#1、声明参与者" class="headerlink" title="1、声明参与者"></a>1、声明参与者</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/84a0a471dfd1f0fdb8a009541314b2aabece4bd881a8425c9419eaf328df21af" alt="image.png"></p>
<h3 id="2、发送消息和返回消息"><a href="#2、发送消息和返回消息" class="headerlink" title="2、发送消息和返回消息"></a>2、发送消息和返回消息</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ffc9ec0c4f59420cf174f3f46edb5c8e5a70e445cf3276821ce8de4d6397990" alt="image.png"></p>
<h3 id="3、if-else表示"><a href="#3、if-else表示" class="headerlink" title="3、if/else表示"></a>3、if/else表示</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d40f91bd4a21d04c3397fd97aa7426dfa8634c110286dfa9791203789e47a600" alt="image.png"></p>
<h3 id="4、关键流程加颜色"><a href="#4、关键流程加颜色" class="headerlink" title="4、关键流程加颜色"></a>4、关键流程加颜色</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1fa4659a9d2bed7477a556021a7e170ad069efa2f6909979588fe8a3888f4663" alt="image.png"></p>
<h3 id="5、自动编号"><a href="#5、自动编号" class="headerlink" title="5、自动编号"></a>5、自动编号</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1cf275d56920bd439a28fa5db2c5c8fa0306b75649b436414227e67383b9ba30" alt="image.png"></p>
<p>具体的画图代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uml复制代码autonumber</span><br><span class="line">actor 普通用户 as person</span><br><span class="line">participant 用户服务 as user</span><br><span class="line">participant 订单服务 as order</span><br><span class="line">participant 支付服务 as pay</span><br><span class="line"></span><br><span class="line">person -&gt; user:登录系统</span><br><span class="line">person&lt;--user: 登录结果</span><br><span class="line"></span><br><span class="line">alt 登录失败</span><br><span class="line">person&lt;--user: 提示失败，不可下单</span><br><span class="line">loop 用户重试</span><br><span class="line">person -&gt; user:登录系统</span><br><span class="line">person&lt;--user: 登录结果</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">else #Gold 登录成功</span><br><span class="line">person-&gt;order:下单</span><br><span class="line">person&lt;--order:下单成功</span><br><span class="line">person-&gt;pay:支付</span><br><span class="line">person&lt;--pay:支付成功</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="PlantUML总结"><a href="#PlantUML总结" class="headerlink" title="PlantUML总结"></a>PlantUML总结</h2><p>使用 PlantUML 创建序列图非常简单。这种易用性主要归功于其语法的用户友好性，既直观又易记。</p>
<p>你如果是一个<code>新入职场</code>的朋友，掌握这个工具也能画出很<code>美观的时序图</code>，是不是会很开心呢？刚工作时候，我是比较困惑的？没有找到好的画图软件，直到知道了PlantUML,还是很好用的，不仅可以在<code>intellij idea</code>里面使用，<code>confluence</code>里面也有插件支持的，在公司办公工作中也用的到。</p>
<p>这个文章如果对你有帮助，收藏关注我们，一起学习技术干货，学习好用的工具。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d38ca2b705abf16f0c0885097dc4a5024f7c8a24068d140b97628406dbac4ec6" alt="image.png"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359138355181600795" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,程序员,前端</tag>
      </tags>
  </entry>
</search>
