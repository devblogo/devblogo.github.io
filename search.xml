<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>你真的了解Python中的类class？</title>
    <url>/6958375754505650213.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote>
<p>在Python的类中，有着类属性、实例属性，静态方法、类方法、实例方法的区别。到底有什么不一样呢？接下来我们就一探究竟。</p>
</blockquote>
<h2 id="类属性、实例属性"><a href="#类属性、实例属性" class="headerlink" title="类属性、实例属性"></a>类属性、实例属性</h2><p>来看下简单的 <code>Student</code> 类的例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    # 类属性</span><br><span class="line">    school = &apos;井冈山大学&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line"></span><br><span class="line">        # 实例属性</span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure>

<p>其中 <code>school</code> 是 <code>Student</code> 类的类属性，<code>name</code> 则是实例属性。</p>
<p>在 <code>ipython</code> 中测试一下如何访问其属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [5]: stu1 = Student(&apos;hui&apos;)</span><br><span class="line"></span><br><span class="line">In [6]: stu2 = Student(&apos;wang&apos;)</span><br><span class="line"></span><br><span class="line">In [7]: stu3 = Student(&apos;zack&apos;)</span><br><span class="line"></span><br><span class="line">In [8]: stu1.name, Student.school</span><br><span class="line">Out[8]: (&apos;hui&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [9]: stu2.name, Student.school</span><br><span class="line">Out[9]: (&apos;wang&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [10]: stu3.name, Student.school</span><br><span class="line">Out[10]: (&apos;zack&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line"># 看看实例对象能不能访问类属性，类对象能不能访问实例属性</span><br><span class="line">In [11]: stu1.name, stu1.school</span><br><span class="line">Out[11]: (&apos;hui&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [12]: Student.name, stu1.school</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-12-b897e001b174&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 Student.name, stu1.school</span><br><span class="line"></span><br><span class="line">AttributeError: type object &apos;Student&apos; has no attribute &apos;name&apos;</span><br></pre></td></tr></table></figure>

<p>经过测试可以发现 <strong>实例属性需要通过实例对象来访问，类属性通过类来访问</strong>，但在测验中 <code>stu1.school</code> 实例对象也能访问类属性，为什么呢？</p>
<p>其实，实例对象也是间接的通过类对象进行访问的，在每一个实例对象中都有一个 <code>__class__</code> 的属性，其指向的就是创建实例对象的类对象。<code>stu1.__class__</code> 的指向就是 <code>Student</code>类对象。然后实例对象访问属性的规则是先访问实例属性，然后再根据实例对象的 <code>__class__</code> 来访问类属性。如果都没有找到则报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [15]: dir(stu1)</span><br><span class="line">Out[15]:</span><br><span class="line">[&apos;__class__&apos;,</span><br><span class="line"> &apos;__delattr__&apos;,</span><br><span class="line"> &apos;__dict__&apos;,</span><br><span class="line"> &apos;__dir__&apos;,</span><br><span class="line"> </span><br><span class="line"> ....</span><br><span class="line"> </span><br><span class="line"> &apos;name&apos;,</span><br><span class="line"> &apos;school&apos;]</span><br><span class="line"></span><br><span class="line">In [16]: stu1.__class__</span><br><span class="line">Out[16]: __main__.Student</span><br><span class="line"></span><br><span class="line">In [17]: stu1.__class__.school</span><br><span class="line">Out[17]: &apos;井冈山大学&apos;</span><br><span class="line"></span><br><span class="line">In [18]: id(Student)</span><br><span class="line">Out[18]: 2011692023944</span><br><span class="line"></span><br><span class="line">In [19]: id(stu1.__class__)</span><br><span class="line">Out[19]: 2011692023944</span><br></pre></td></tr></table></figure>

<p>可以看出 <code>Student</code>，<code>stu1.__class__</code> 的 <code>id()</code> 都一样，说明其内存地址都一样。因此实例属性可以通过 <code>__class__</code> 访问类属性。</p>
<p>存储方式如下图</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1a80c4aadeb83f0cb3d9b4dcf496641f851f8687cc0f6efabe9e66d35ee38dda" alt="类对象派生实例对象"></p>
<p>由上图可以看出：</p>
<ul>
<li>类属性在内存中只保存一份</li>
<li>实例属性在每个对象中都要保存一份</li>
</ul>
<p>还是以上面的例子在 <code>ipython</code> 中对类属性的修改进行测验</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [24]: class Student(object):</span><br><span class="line">    ...:</span><br><span class="line">    ...:     # 类属性</span><br><span class="line">    ...:     school = &apos;井冈山大学&apos;</span><br><span class="line">    ...:</span><br><span class="line">    ...:     def __init__(self, name):</span><br><span class="line">    ...:</span><br><span class="line">    ...:         # 实例属性</span><br><span class="line">    ...:         self.name = name</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [25]: stu1 = Student(&apos;hui&apos;)</span><br><span class="line"></span><br><span class="line">In [26]: stu2 = Student(&apos;jack&apos;)</span><br><span class="line"></span><br><span class="line">In [27]: stu1.name, stu1.school</span><br><span class="line">Out[27]: (&apos;hui&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [28]: stu2.name, stu2.school</span><br><span class="line">Out[28]: (&apos;jack&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line"># 通过类对象进行修改</span><br><span class="line">In [29]: Student.school = &apos;清华大学&apos;</span><br><span class="line"></span><br><span class="line">In [30]: stu2.name, stu2.school</span><br><span class="line">Out[30]: (&apos;jack&apos;, &apos;清华大学&apos;)</span><br><span class="line"></span><br><span class="line">In [31]: stu1.name, stu1.school</span><br><span class="line">Out[31]: (&apos;hui&apos;, &apos;清华大学&apos;)</span><br><span class="line"></span><br><span class="line"># 通过实例对象进行修改</span><br><span class="line">IIn [33]: stu1.school = &apos;北京大学&apos;</span><br><span class="line"></span><br><span class="line">In [34]: stu1.name, stu1.school</span><br><span class="line">Out[34]: (&apos;hui&apos;, &apos;北京大学&apos;)</span><br><span class="line"></span><br><span class="line">In [35]: stu2.name, stu2.school</span><br><span class="line">Out[35]: (&apos;jack&apos;, &apos;清华大学&apos;)</span><br><span class="line"></span><br><span class="line">In [36]: Student.school</span><br><span class="line">Out[36]: &apos;清华大学&apos;</span><br><span class="line"></span><br><span class="line">In [37]: stu1.__class__.school</span><br><span class="line">Out[37]: &apos;清华大学&apos;</span><br><span class="line">    </span><br><span class="line">In [39]: id(stu2.school)</span><br><span class="line">Out[39]: 2011720409808</span><br><span class="line"></span><br><span class="line">In [40]: id(Student.school)</span><br><span class="line">Out[40]: 2011720409808</span><br><span class="line"></span><br><span class="line">In [41]: id(stu1.school)</span><br><span class="line">Out[41]: 2011720494992</span><br><span class="line"></span><br><span class="line"># 通过实例对象的__class__属性修改</span><br><span class="line">IIn [42]: stu2.__class__.school = &apos;井冈山大学&apos;</span><br><span class="line"></span><br><span class="line">In [43]: stu1.name, stu1.school</span><br><span class="line">Out[43]: (&apos;hui&apos;, &apos;北京大学&apos;)</span><br><span class="line"></span><br><span class="line">In [44]: stu2.name, stu2.school</span><br><span class="line">Out[44]: (&apos;jack&apos;, &apos;井冈山大学&apos;)</span><br><span class="line"></span><br><span class="line">In [45]: Student.school</span><br><span class="line">Out[45]: &apos;井冈山大学&apos;</span><br></pre></td></tr></table></figure>



<p><strong>说明：</strong> <strong>实例对象.类属性 = xxx</strong> 并没有修改到其类属性，而是在实例对象中创建了一个与类属性同名的实例属性。因此修改类属性，应该使用类对象进行修改。再外界最好不要使用 <strong>实例对象.新属性 = xxx</strong>，动态创建实例属性。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>到底是用类属性，还是实例属性？</p>
<blockquote>
<p>如果每个实例对象需要具有相同值的属性，那么就使用类属性，用一份既可。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">class Province(object):</span><br><span class="line">    # 类属性</span><br><span class="line">    country = &apos;中国&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        # 实例属性</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">p1 = Province(&apos;江西省&apos;)</span><br><span class="line">p2 = Province(&apos;四川省&apos;)</span><br></pre></td></tr></table></figure>



<h2 id="实例方法、静态方法和类方法"><a href="#实例方法、静态方法和类方法" class="headerlink" title="实例方法、静态方法和类方法"></a>实例方法、静态方法和类方法</h2><p>类中方法包括：<strong>实例方法、静态方法和类方法</strong>，三种方法在内存中都归属于类，区别在于<strong>调用方式不同</strong>。</p>
<ul>
<li><strong>实例方法</strong>：由对象调用，至少一个 <code>self</code> 参数；执行实例方法时，自动将调用该方法的对象赋值给 <code>self</code>。</li>
<li><strong>类方法</strong>：由类调用，至少一个 <code>cls</code> 参数；执行类方法时，自动将调用该方法的类赋值给 <code>cls</code>。</li>
<li><strong>静态方法</strong>：由类调用，无默认参数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    foo = &apos;Foo&apos;</span><br><span class="line"></span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    def instance_func(self):</span><br><span class="line">        print(self.name)</span><br><span class="line">        print(self.foo)</span><br><span class="line">        print(&apos;实例方法&apos;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_func1(cls):</span><br><span class="line">        print(cls.foo)</span><br><span class="line">        print(&apos;类方法1&apos;)</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def class_func2(cls):</span><br><span class="line">        print(cls.name)</span><br><span class="line">        print(&apos;类方法二&apos;)</span><br><span class="line"></span><br><span class="line">    @staticmethod</span><br><span class="line">    def static_func():</span><br><span class="line">        print(&apos;静态方法&apos;)</span><br></pre></td></tr></table></figure>



<p>其中 <code>@classmethod</code> 是装饰器，说明这是类方法，<code>@staticmethod</code> 则说明是静态方法。关于装饰器的内容这里就不在赘述了。</p>
<p>在 <code>ipython</code> 中测验一下各方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# 实例对象调用</span><br><span class="line">In [71]: f = Foo(&apos;hui&apos;)</span><br><span class="line"></span><br><span class="line">In [72]: f.instance_func()</span><br><span class="line">hui</span><br><span class="line">Foo</span><br><span class="line">实例方法</span><br><span class="line"></span><br><span class="line">In [73]: f.class_func1()</span><br><span class="line">Foo</span><br><span class="line">类方法1</span><br><span class="line"></span><br><span class="line">In [74]: f.class_func2()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">AttributeError                            Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-74-7d161e9e60ec&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 f.class_func2()</span><br><span class="line"></span><br><span class="line">&lt;ipython-input-60-7fc48649a96a&gt; in class_func2(cls)</span><br><span class="line">     18     @classmethod</span><br><span class="line">     19     def class_func2(cls):</span><br><span class="line">---&gt; 20         print(cls.name)</span><br><span class="line">     21         print(&apos;类方法二&apos;)</span><br><span class="line">     22</span><br><span class="line"></span><br><span class="line">AttributeError: type object &apos;Foo&apos; has no attribute &apos;name&apos;</span><br><span class="line"></span><br><span class="line">In [75]: f.static_func()</span><br><span class="line">静态方法</span><br><span class="line"></span><br><span class="line"># 类对象自身调用</span><br><span class="line">In [76]: Foo.instance_func()</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line">TypeError                                 Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-76-883efcb56130&gt; in &lt;module&gt;</span><br><span class="line">----&gt; 1 Foo.instance_func()</span><br><span class="line"></span><br><span class="line">TypeError: instance_func() missing 1 required positional argument: &apos;self&apos;</span><br><span class="line"></span><br><span class="line">In [77]: Foo.class_func1()</span><br><span class="line">Foo</span><br><span class="line">类方法1</span><br><span class="line"></span><br><span class="line">In [78]: Foo.static_func()</span><br><span class="line">静态方法</span><br></pre></td></tr></table></figure>

<p>可以发现实例对象三种方法都可以调用，但 <code>cls</code> 类对象不能访问实例属性。类对象不能直接调用实例方法，类、静态方法可以。</p>
<h3 id="self与cls的区别"><a href="#self与cls的区别" class="headerlink" title="self与cls的区别"></a>self与cls的区别</h3><ul>
<li><code>self</code> 指的是类实例对象本身(注意：不是类本身)。</li>
<li><code>cls</code> 指的是类对象本身</li>
<li><code>self</code> 可以访问到类属性、实例属性，<code>cls</code> 只能访问类属性。</li>
</ul>
<p>其中 <code>self, cls</code> 只是代指实例对象和类对象，因此换成其他变量也可以，<strong>但是约定成俗</strong>（为了和其他编程语言统一，减少理解难度），不要搞另类，大家会不明白的。</p>
<h3 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h3><p>需要操作类属性的定义成类方法。</p>
<p>需要操作实例属性的定义成实例方法。</p>
<p>既不需要操作类属性，也不需要操作实例属性就定义成静态方法。</p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p> <strong>新建文件夹X</strong></p>
<blockquote>
<p>大自然用数百亿年创造出我们现实世界，而程序员用几百年创造出一个完全不同的虚拟世界。我们用键盘敲出一砖一瓦，用大脑构建一切。人们把1000视为权威，我们反其道行之，捍卫1024的地位。我们不是键盘侠，我们只是平凡世界中不凡的缔造者 。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6958375754505650213" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>追溯Python类的鼻祖——元类</title>
    <url>/6957631734343008269.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Python中万物皆对象"><a href="#Python中万物皆对象" class="headerlink" title="Python中万物皆对象"></a>Python中万物皆对象</h2><blockquote>
<p>Python是一门面向对象的语言，所以Python中数字、字符串、列表、集合、字典、函数、类等都是对象。</p>
</blockquote>
<p>利用 <code>type()</code> 来查看Python中的各对象类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [11]: # 数字</span><br><span class="line"></span><br><span class="line">In [12]: type(10)</span><br><span class="line">Out[12]: int</span><br><span class="line"></span><br><span class="line">In [13]: type(3.1415926)</span><br><span class="line">Out[13]: float</span><br><span class="line"></span><br><span class="line">In [14]: # 字符串</span><br><span class="line"></span><br><span class="line">In [15]: type(&apos;a&apos;)</span><br><span class="line">Out[15]: str</span><br><span class="line"></span><br><span class="line">In [16]: type(&quot;abc&quot;)</span><br><span class="line">Out[16]: str</span><br><span class="line"></span><br><span class="line">In [17]: # 列表</span><br><span class="line"></span><br><span class="line">In [18]: type(list)</span><br><span class="line">Out[18]: type</span><br><span class="line"></span><br><span class="line">In [19]: type([])</span><br><span class="line">Out[19]: list</span><br><span class="line"></span><br><span class="line">In [20]: # 集合</span><br><span class="line"></span><br><span class="line">In [21]: type(set)</span><br><span class="line">Out[21]: type</span><br><span class="line"></span><br><span class="line">In [22]: my_set = &#123;1, 2, 3&#125;</span><br><span class="line"></span><br><span class="line">In [23]: type(my_set)</span><br><span class="line">Out[23]: set</span><br><span class="line"></span><br><span class="line">In [24]: # 字典</span><br><span class="line"></span><br><span class="line">In [25]: type(dict)</span><br><span class="line">Out[25]: type</span><br><span class="line"></span><br><span class="line">In [26]: my_dict = &#123;&apos;name&apos;: &apos;hui&apos;&#125;</span><br><span class="line"></span><br><span class="line">In [27]: type(my_dict)</span><br><span class="line">Out[27]: dict</span><br><span class="line"></span><br><span class="line">In [28]: # 函数</span><br><span class="line"></span><br><span class="line">In [29]: def func():</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [30]: type(func)</span><br><span class="line">Out[30]: function</span><br><span class="line"></span><br><span class="line">In [31]: # 类</span><br><span class="line"></span><br><span class="line">In [32]: class Foo(object):</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [33]: type(Foo)</span><br><span class="line">Out[33]: type</span><br><span class="line"></span><br><span class="line">In [34]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [35]: type(f)</span><br><span class="line">Out[35]: __main__.Foo</span><br><span class="line"></span><br><span class="line">In [36]: # type</span><br><span class="line"></span><br><span class="line">In [37]: type(type)</span><br><span class="line">Out[37]: type</span><br></pre></td></tr></table></figure>

<p>可以看出</p>
<ul>
<li>数字 <code>1</code> 是 <strong>int类型</strong> 的对象</li>
<li>字符串 <code>abc</code> 是 <strong>str类型</strong> 的对象</li>
<li>列表、集合、字典是 <strong>type类型</strong> 的对象，其创建出来的对象才分别属于 <code>list、set、dict</code> 类型</li>
<li>函数 <code>func</code> 是 <strong>function类型</strong> 的对象</li>
<li>自定义类 <code>Foo</code> 创建出来的对象 <code>f</code> 是 <code>Foo</code> 类型，其类本身 <code>Foo</code> 则是 <strong>type类型</strong> 的对象。</li>
<li><strong>连 <code>type</code> 本身都是type类型的对象</strong></li>
</ul>
<ol>
<li>类也是对象</li>
</ol>
<hr>
<blockquote>
<p>类就是拥有相等功能和相同的属性的对象的集合</p>
</blockquote>
<p>在大多数编程语言中，<strong>类就是一组用来描述如何生成一个对象的代码段</strong>。在 Python 中这一点仍然成立：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [1]: class ObjectCreator(object):</span><br><span class="line">   ...:     pass</span><br><span class="line">   ...:</span><br><span class="line"></span><br><span class="line">In [2]: my_object = ObjectCreator()</span><br><span class="line"></span><br><span class="line">In [3]: print(my_object)</span><br><span class="line">&lt;__main__.ObjectCreator object at 0x0000021257B5A248&gt;</span><br></pre></td></tr></table></figure>

<p>但是，Python中的类还远不止如此。<strong>类同样也是一种对象</strong>。是的，没错，就是对象。只要你 <strong>使用关键字 <code>class</code>，Python解释器在执行的时候就会创建一个对象</strong>。</p>
<p>下面的代码段：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码&gt;&gt;&gt; class ObjectCreator(object):</span><br><span class="line">…       pass</span><br><span class="line">…</span><br></pre></td></tr></table></figure>

<p>将在内存中创建一个对象，名字就是 <code>ObjectCreator</code>。这个 <strong>对象（类对象ObjectCreator）拥有创建对象（实例对象）的能力</strong>。但是，它的本质仍然是一个对象，于是乎你可以对它做如下的操作：</p>
<ol>
<li>你可以将它赋值给一个变量</li>
<li>你可以拷贝它</li>
<li>你可以为它增加属性</li>
<li>你可以将它作为函数参数进行传递</li>
</ol>
<p>如下示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [39]: class ObjectCreator(object):</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [40]: print(ObjectCreator)</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [41]:# 当作参数传递</span><br><span class="line"></span><br><span class="line">In [41]: def out(obj):</span><br><span class="line">    ...:     print(obj)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [42]: out(ObjectCreator)</span><br><span class="line">&lt;class &apos;__main__.ObjectCreator&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [43]: # hasattr 判断一个类是否有某种属性</span><br><span class="line"></span><br><span class="line">In [44]: hasattr(ObjectCreator, &apos;name&apos;)</span><br><span class="line">Out[44]: False</span><br><span class="line"></span><br><span class="line">In [45]: # 新增类属性</span><br><span class="line"></span><br><span class="line">In [46]: ObjectCreator.name = &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [47]: hasattr(ObjectCreator, &apos;name&apos;)</span><br><span class="line">Out[47]: True</span><br><span class="line"></span><br><span class="line">In [48]: ObjectCreator.name</span><br><span class="line">Out[48]: &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [49]: # 将类赋值给变量</span><br><span class="line"></span><br><span class="line">In [50]: obj = ObjectCreator</span><br><span class="line"></span><br><span class="line">In [51]: obj()</span><br><span class="line">Out[51]: &lt;__main__.ObjectCreator at 0x212596a7248&gt;</span><br><span class="line"></span><br><span class="line">In [52]:</span><br></pre></td></tr></table></figure>



<ol start="2">
<li>动态地创建类</li>
</ol>
<hr>
<p>因为类也是对象，你可以在运行时动态的创建它们，就像其他任何对象一样。首先，你可以在函数中创建类，使用 <code>class</code> 关键字即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码def cls_factory(cls_name):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    创建类工厂</span><br><span class="line">    :param: cls_name 创建类的名称</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    if cls_name == &apos;Foo&apos;:</span><br><span class="line">        class Foo():</span><br><span class="line">            pass</span><br><span class="line">        return Foo  # 返回的是类，不是类的实例</span><br><span class="line"></span><br><span class="line">    elif cls_name == &apos;Bar&apos;:</span><br><span class="line">        class Bar():</span><br><span class="line">            pass</span><br><span class="line">        return Bar</span><br></pre></td></tr></table></figure>



<p><strong>IPython 测验</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码MyClass = cls_factory(&apos;Foo&apos;)</span><br><span class="line"></span><br><span class="line">In [60]: MyClass</span><br><span class="line">Out[60]: __main__.cls_factory.&lt;locals&gt;.Foo # 函数返回的是类，不是类的实例</span><br><span class="line"></span><br><span class="line">In [61]: MyClass()</span><br><span class="line">Out[61]: &lt;__main__.cls_factory.&lt;locals&gt;.Foo at 0x21258b1a9c8&gt;</span><br></pre></td></tr></table></figure>

<p>但这还不够动态，因为你仍然需要自己编写整个类的代码。由于类也是对象，所以它们必须是通过什么东西来生成的才对。</p>
<p>当你使用class关键字时，Python解释器自动创建这个对象。但就和Python中的大多数事情一样，Python仍然提供给你手动处理的方法。</p>
<ol start="3">
<li>使用 type 创建类</li>
</ol>
<hr>
<p>type 还有一种完全不同的功能，动态的创建类。</p>
<p>type可以接受一个类的描述作为参数，然后返回一个类。（要知道，根据传入参数的不同，同一个函数拥有两种完全不同的用法是一件很傻的事情，但这在Python中是为了保持向后兼容性）</p>
<p>type 可以像这样工作：</p>
<p>type(类名, 由父类名称组成的元组（针对继承的情况，可以为空），包含属性的字典（名称和值）)</p>
<p>比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [63]: class Test:</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [64]: Test()</span><br><span class="line">Out[64]: &lt;__main__.Test at 0x21258b34048&gt;</span><br><span class="line"></span><br><span class="line">In [65]:</span><br></pre></td></tr></table></figure>

<p>可以手动像这样创建：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [69]:# 使用type定义类</span><br><span class="line"></span><br><span class="line">In [69]: Test2 = type(&apos;Test2&apos;, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [70]: Test2()</span><br><span class="line">Out[70]: &lt;__main__.Test2 at 0x21259665808&gt;</span><br></pre></td></tr></table></figure>

<p>我们使用 <code>Test2</code> 作为类名，并且也可以把它当做一个变量来作为类的引用。类和变量是不同的，这里没有任何理由把事情弄的复杂。即 type函数 中第1个实参，也可以叫做其他的名字，这个名字表示类的名字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [71]: UserCls = type(&apos;User&apos;, (), &#123;&#125;)</span><br><span class="line"></span><br><span class="line">In [72]: print(UserCls)</span><br><span class="line">&lt;class &apos;__main__.User&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [73]:</span><br></pre></td></tr></table></figure>



<p>使用 <code>help</code> 来测试这2个类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [74]: # 用 help 查看 Test类</span><br><span class="line"></span><br><span class="line">In [75]: help(Test)</span><br><span class="line">Help on class Test in module __main__:</span><br><span class="line"></span><br><span class="line">class Test(builtins.object)</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [76]: # 用 help 查看 Test2类</span><br><span class="line"></span><br><span class="line">In [77]: help(Test2)</span><br><span class="line">Help on class Test2 in module __main__:</span><br><span class="line"></span><br><span class="line">class Test2(builtins.object)</span><br><span class="line"> |  Data descriptors defined here:</span><br><span class="line"> |</span><br><span class="line"> |  __dict__</span><br><span class="line"> |      dictionary for instance variables (if defined)</span><br><span class="line"> |</span><br><span class="line"> |  __weakref__</span><br><span class="line"> |      list of weak references to the object (if defined)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">In [78]:</span><br></pre></td></tr></table></figure>



<ol start="4">
<li>使用type创建带有属性的类</li>
</ol>
<hr>
<p>type 接受一个字典来为类定义属性，因此</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br></pre></td></tr></table></figure>

<p>可以翻译为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Parent(object):</span><br><span class="line">	name = &apos;hui&apos;</span><br></pre></td></tr></table></figure>

<p>并且可以将 <code>Parent</code> 当成一个普通的类一样使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [79]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [80]: print(Parent)</span><br><span class="line">&lt;class &apos;__main__.Parent&apos;&gt;</span><br><span class="line"></span><br><span class="line">In [81]: Parent.name</span><br><span class="line">Out[81]: &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [82]: p = Parent()</span><br><span class="line"></span><br><span class="line">In [83]: p.name</span><br><span class="line">Out[83]: &apos;hui&apos;</span><br></pre></td></tr></table></figure>

<p>当然，你可以继承这个类，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Child1(Parent):</span><br><span class="line">    name = &apos;jack&apos;</span><br><span class="line">    sex =  &apos;男&apos;</span><br><span class="line">    </span><br><span class="line">class Child2(Parent):</span><br><span class="line">    name = &apos;mary&apos;</span><br><span class="line">    sex = &apos;女&apos;</span><br></pre></td></tr></table></figure>

<p>就可以写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码 Child1 = type(&apos;Child1&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;jack&apos;, &apos;sex&apos;: &apos;男&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [85]: Child2 = type(&apos;Child2&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;mary&apos;, &apos;sex&apos;: &apos;女&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [87]: Child1.name, Child1.sex</span><br><span class="line">Out[87]: (&apos;jack&apos;, &apos;男&apos;)</span><br><span class="line"></span><br><span class="line">In [88]: Child2.name, Child2.sex</span><br><span class="line">Out[88]: (&apos;mary&apos;, &apos;女&apos;)</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>type 的第2个参数，<strong>元组中是父类的名字，而不是字符串</strong></li>
<li>添加的属性是 <strong>类属性</strong>，并不是实例属性</li>
</ul>
<ol start="5">
<li>使用type创建带有方法的类</li>
</ol>
<hr>
<p>最终你会希望为你的类增加方法。只需要定义一个有着恰当签名的函数并将其作为属性赋值就可以了。</p>
<h3 id="添加实例方法"><a href="#添加实例方法" class="headerlink" title="添加实例方法"></a>添加实例方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [89]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [90]: # 定义函数</span><br><span class="line"></span><br><span class="line">In [91]: def get_name(self):</span><br><span class="line">    ...:     return self.name</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [92]: Child3 = type(&apos;Child3&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;blob&apos;, &apos;get_name&apos;: get_name&#125;)</span><br><span class="line"></span><br><span class="line">In [93]: c3 = Child3()</span><br><span class="line"></span><br><span class="line">In [94]: c3.name</span><br><span class="line">Out[94]: &apos;blob&apos;</span><br><span class="line"></span><br><span class="line">In [95]: c3.get_name()</span><br><span class="line">Out[95]: &apos;blob&apos;</span><br></pre></td></tr></table></figure>



<h3 id="添加静态方法"><a href="#添加静态方法" class="headerlink" title="添加静态方法"></a>添加静态方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [96]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [97]: # 定义静态方法</span><br><span class="line">    </span><br><span class="line">In [98]: @staticmethod</span><br><span class="line">    ...: def test_static():</span><br><span class="line">    ...:     print(&apos;static method called...&apos;)</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [100]: Child4 = type(&apos;Child4&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;zhangsan&apos;, &apos;test_static&apos;: test_static&#125;)</span><br><span class="line"></span><br><span class="line">In [101]: c4 = Child4()</span><br><span class="line"></span><br><span class="line">In [102]: c4.test_static()</span><br><span class="line">static method called...</span><br><span class="line"></span><br><span class="line">In [103]: Child4.test_static()</span><br><span class="line">static method called...</span><br></pre></td></tr></table></figure>



<h3 id="添加类方法"><a href="#添加类方法" class="headerlink" title="添加类方法"></a>添加类方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [105]: Parent = type(&apos;Parent&apos;, (), &#123;&apos;name&apos;: &apos;hui&apos;&#125;)</span><br><span class="line"></span><br><span class="line">In [106]: # 定义类方法</span><br><span class="line"></span><br><span class="line">In [107]: @classmethod</span><br><span class="line">     ...: def test_class(cls):</span><br><span class="line">     ...:     print(cls.name)</span><br><span class="line">     ...:</span><br><span class="line"></span><br><span class="line">In [108]: Child5 = type(&apos;Child5&apos;, (Parent, ), &#123;&apos;name&apos;: &apos;lisi&apos;, &apos;test_class&apos;: test_class&#125;)</span><br><span class="line"></span><br><span class="line">In [109]: c5 = Child5()</span><br><span class="line"></span><br><span class="line">In [110]: c5.test_class()</span><br><span class="line">lisi</span><br><span class="line"></span><br><span class="line">In [111]: Child5.test_class()</span><br><span class="line">lisi</span><br></pre></td></tr></table></figure>

<p>你可以看到，在Python中，类也是对象，你可以动态的创建类。这就是<strong>当你使用关键字 <code>class</code> 时 <code>Python</code> 在幕后做的事情，就是通过元类来实现的</strong>。</p>
<p>较为完整的使用 type 创建类的方式:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Animal(object):</span><br><span class="line">    </span><br><span class="line">    def eat(self):</span><br><span class="line">        print(&apos;吃东西&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def dog_eat(self):</span><br><span class="line">    print(&apos;喜欢吃骨头&apos;)</span><br><span class="line"></span><br><span class="line">def cat_eat(self):</span><br><span class="line">    print(&apos;喜欢吃鱼&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Dog = type(&apos;Dog&apos;, (Animal, ), &#123;&apos;tyep&apos;: &apos;哺乳类&apos;, &apos;eat&apos;: dog_eat&#125;)</span><br><span class="line"></span><br><span class="line">Cat = type(&apos;Cat&apos;, (Animal, ), &#123;&apos;tyep&apos;: &apos;哺乳类&apos;, &apos;eat&apos;: cat_eat&#125;)</span><br><span class="line"></span><br><span class="line"># ipython 测验</span><br><span class="line">In [125]: animal = Animal()</span><br><span class="line"></span><br><span class="line">In [126]: dog = Dog()</span><br><span class="line"></span><br><span class="line">In [127]: cat = Cat()</span><br><span class="line"></span><br><span class="line">In [128]: animal.eat()</span><br><span class="line">吃东西</span><br><span class="line"></span><br><span class="line">In [129]: dog.eat()</span><br><span class="line">喜欢吃骨头</span><br><span class="line"></span><br><span class="line">In [130]: cat.eat()</span><br><span class="line">喜欢吃鱼</span><br></pre></td></tr></table></figure>



<ol start="6">
<li>到底什么是元类（终于到主题了）</li>
</ol>
<hr>
<p><strong>元类就是用来创建类的【东西】</strong>。你创建类就是为了创建类的实例对象，不是吗？但是我们已经学习到了Python中的类也是对象。</p>
<p>元类就是用来创建这些类（对象）的，元类就是类的类，你可以这样理解为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码MyClass = MetaClass() # 使用元类创建出一个对象，这个对象称为“类”</span><br><span class="line">my_object = MyClass() # 使用“类”来创建出实例对象</span><br></pre></td></tr></table></figure>

<p>你已经看到了type可以让你像这样做：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码MyClass = type(&apos;MyClass&apos;, (), &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>这是因为函数 <code>type</code> 实际上是一个元类。<strong><code>type</code> 就是 Python在背后用来创建所有类的元类</strong>。现在你想知道那为什么 type 会全部采用小写形式而不是 Type 呢？好吧，我猜这是为了和 str 保持一致性，str是用来创建字符串对象的类，而 int 是用来创建整数对象的类。type 就是创建类对象的类。你可以通过检查 <code>__class__</code> 属性来看到这一点。因此 <strong>Python中万物皆对象</strong></p>
<p>现在，对于任何一个 <code>__class__</code> 的 <code>__class__</code> 属性又是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [136]: a = 10</span><br><span class="line"></span><br><span class="line">In [137]: b = &apos;acb&apos;</span><br><span class="line"></span><br><span class="line">In [138]: li = [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [139]: a.__class__.__class__</span><br><span class="line">Out[139]: type</span><br><span class="line"></span><br><span class="line">In [140]: b.__class__.__class__</span><br><span class="line">Out[140]: type</span><br><span class="line"></span><br><span class="line">In [141]: li.__class__.__class__</span><br><span class="line">Out[141]: type</span><br><span class="line"></span><br><span class="line">In [142]: li.__class__.__class__.__class__</span><br><span class="line">Out[142]: type</span><br></pre></td></tr></table></figure>

<p>因此，元类就是创建类这种对象的东西。type 就是 Python的内建元类，当然了，你也可以创建自己的元类。</p>
<ol start="7">
<li><code>__metaclass__</code> 属性</li>
</ol>
<hr>
<p>你可以在定义一个类的时候为其添加 <code>__metaclass__</code> 属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(object):</span><br><span class="line">    __metaclass__ = something…</span><br><span class="line">    ...省略...</span><br></pre></td></tr></table></figure>

<p>如果你这么做了，Python就会用元类来创建类Foo。小心点，这里面有些技巧。你首先写下 <code>class Foo(object)</code>，但是类Foo还没有在内存中创建。Python会在类的定义中寻找 <code>__metaclass__</code> 属性，如果找到了，Python就会用它来创建类Foo，如果没有找到，就会用内建的 <code>type</code> 来创建这个类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(Bar):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>Python做了如下的操作：</p>
<ol>
<li>Foo中有 <code>__metaclass__</code> 这个属性吗？如果有，Python会通过 <code>__metaclass__</code> 创建一个名字为Foo的类(对象)</li>
<li>如果Python没有找到 <code>__metaclass__</code>，它会继续在 <strong>Bar（父类）</strong> 中寻找 <code>__metaclass__</code> 属性，并尝试做和前面同样的操作。</li>
<li>如果Python在任何父类中都找不到 <code>__metaclass__</code>，它就会在模块层次中去寻找 <code>__metaclass__</code>，并尝试做同样的操作。</li>
<li>如果还是找不到 <code>__metaclass__</code> ，Python就会用内置的 <code>type</code> 来创建这个类对象。</li>
</ol>
<p>现在的问题就是，你可以在 <code>__metaclass__</code> 中放置些什么代码呢？</p>
<p>答案就是：可以创建一个类的东西。那么什么可以用来创建一个类呢？type，或者任何使用到type或者子类化的type都可以。</p>
<ol start="8">
<li>自定义元类</li>
</ol>
<hr>
<blockquote>
<p>元类的主要目的就是为了当创建类时能够自动地改变类。</p>
</blockquote>
<p>假想一个很傻的例子，你决定在你的模块里所有的类的属性都应该是大写形式。有好几种方法可以办到，但其中一种就是通过在模块级别设定 <code>__metaclass__</code>。采用这种方法，这个模块中的所有类都会通过这个元类来创建，我们只需要告诉元类把所有的属性都改成大写形式就万事大吉了。</p>
<p>幸运的是，<code>__metaclass__</code> 实际上可以被任意调用，它并不需要是一个正式的类。所以，我们这里就先以一个简单的函数作为例子开始。</p>
<h3 id="python2中"><a href="#python2中" class="headerlink" title="python2中"></a>python2中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# -*- coding:utf-8 -*-</span><br><span class="line">def upper_attr(class_name, class_parents, class_attr):</span><br><span class="line"></span><br><span class="line">    # class_name 会保存类的名字 Foo</span><br><span class="line">    # class_parents 会保存类的父类 object</span><br><span class="line">    # class_attr 会以字典的方式保存所有的类属性</span><br><span class="line"></span><br><span class="line">    # 遍历属性字典，把不是__开头的属性名字变为大写</span><br><span class="line">    new_attr = &#123;&#125;</span><br><span class="line">    for name, value in class_attr.items():</span><br><span class="line">        if not name.startswith(&quot;__&quot;):</span><br><span class="line">            new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    # 调用type来创建一个类</span><br><span class="line">    return type(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">class Foo(object):</span><br><span class="line">    __metaclass__ = upper_attr # 设置Foo类的元类为upper_attr</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line"># Flase</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br><span class="line"># True</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br></pre></td></tr></table></figure>



<h3 id="python3中"><a href="#python3中" class="headerlink" title="python3中"></a>python3中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# -*- coding:utf-8 -*-</span><br><span class="line">def upper_attr(class_name, class_parents, class_attr):</span><br><span class="line"></span><br><span class="line">    #遍历属性字典，把不是__开头的属性名字变为大写</span><br><span class="line">    new_attr = &#123;&#125;</span><br><span class="line">    for name,value in class_attr.items():</span><br><span class="line">        if not name.startswith(&quot;__&quot;):</span><br><span class="line">            new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">    #调用type来创建一个类</span><br><span class="line">    return type(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line"># 再类的继承()中使用metaclass</span><br><span class="line">class Foo(object, metaclass=upper_attr):</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line"># Flase</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br><span class="line"># True</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br></pre></td></tr></table></figure>



<p>再做一次，这一次用一个真正的 <code>class</code> 来当做元类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class UpperAttrMetaClass(type):</span><br><span class="line">    </span><br><span class="line">    def __new__(cls, class_name, class_parents, class_attr):</span><br><span class="line">        # 遍历属性字典，把不是__开头的属性名字变为大写</span><br><span class="line">        new_attr = &#123;&#125;</span><br><span class="line">        for name, value in class_attr.items():</span><br><span class="line">            if not name.startswith(&quot;__&quot;):</span><br><span class="line">                new_attr[name.upper()] = value</span><br><span class="line"></span><br><span class="line">        # 方法1：通过&apos;type&apos;来做类对象的创建</span><br><span class="line">        return type(class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">        # 方法2：复用type.__new__方法</span><br><span class="line">        # 这就是基本的OOP编程，没什么魔法</span><br><span class="line">        # return type.__new__(cls, class_name, class_parents, new_attr)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"># python3的用法</span><br><span class="line">class Foo(object, metaclass=UpperAttrMetaClass):</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line"># python2的用法</span><br><span class="line">class Foo(object):</span><br><span class="line">	__metaclass__ = UpperAttrMetaClass</span><br><span class="line">    bar = &apos;bip&apos;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">print(hasattr(Foo, &apos;bar&apos;))</span><br><span class="line"># 输出: False</span><br><span class="line">print(hasattr(Foo, &apos;BAR&apos;))</span><br><span class="line"># 输出: True</span><br><span class="line"></span><br><span class="line">f = Foo()</span><br><span class="line">print(f.BAR)</span><br><span class="line"># 输出: &apos;bip&apos;</span><br></pre></td></tr></table></figure>




<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__new__ 是在__init__之前被调用的特殊方法</span><br><span class="line">__new__是用来创建对象并返回之的方法</span><br><span class="line">而__init__只是用来将传入的参数初始化给对象</span><br><span class="line">这里，创建的对象是类，我们希望能够自定义它，所以我们这里改写__new__</span><br></pre></td></tr></table></figure>

<p>就是这样，除此之外，关于元类真的没有别的可说的了。但就元类本身而言，它们其实是很简单的：</p>
<ol>
<li>拦截类的创建</li>
<li>修改类</li>
<li>返回修改之后的类</li>
</ol>
<h3 id="究竟为什么要使用元类？"><a href="#究竟为什么要使用元类？" class="headerlink" title="究竟为什么要使用元类？"></a>究竟为什么要使用元类？</h3><p>现在回到我们的大主题上来，究竟是为什么你会去使用这样一种容易出错且晦涩的特性？</p>
<p>好吧，一般来说，你根本就用不上它：</p>
<blockquote>
<p>“元类就是深度的魔法，99%的用户应该根本不必为此操心。如果你想搞清楚究竟是否需要用到元类，那么你就不需要它。那些实际用到元类的人都非常清楚地知道他们需要做什么，而且根本不需要解释为什么要用元类。” —— Python界的领袖 Tim Peters</p>
</blockquote>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码已上传到 <code>Gitee</code> <a href="https://gitee.com/huiDBK/PythonKnowledge" target="_blank" rel="noopener">PythonKnowledge: Python知识宝库</a>，欢迎大家来访。</p>
<p><strong>✍ 码字不易，还望各位大侠多多支持❤️。</strong></p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p> <strong>新建文件夹X</strong></p>
<blockquote>
<p>大自然用数百亿年创造出我们现实世界，而程序员用几百年创造出一个完全不同的虚拟世界。我们用键盘敲出一砖一瓦，用大脑构建一切。人们把1000视为权威，我们反其道行之，捍卫1024的地位。我们不是键盘侠，我们只是平凡世界中不凡的缔造者 。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6957631734343008269" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的魔法属性</title>
    <url>/6959490821934710797.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="魔法属性"><a href="#魔法属性" class="headerlink" title="魔法属性"></a>魔法属性</h2><blockquote>
<p>在Python中，所有以 <code>__</code> 双下划线包起来的方法，都统称为 <code>Magic Method</code>，例如类的初始化方法 <code>__init__()</code> ，实例对象创造方法 <code>__new__()</code>等。</p>
<p>魔法属性和方法是Python内置的一些属性和方法，有着特殊的含义。命名时前后加上两个下划线，在执行系统特定操作时，会自动调用。</p>
</blockquote>
<h2 id="常见的魔法属性"><a href="#常见的魔法属性" class="headerlink" title="常见的魔法属性"></a>常见的魔法属性</h2><h3 id="doc"><a href="#doc" class="headerlink" title="__doc__"></a>__doc__</h3><blockquote>
<p>表示类的描述信息</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line"># __doc__</span><br><span class="line">class Foo:</span><br><span class="line">    &quot;&quot;&quot; 描述类信息，这是用于测试的类 &quot;&quot;&quot;</span><br><span class="line">    </span><br><span class="line">    def func(self):</span><br><span class="line">        pass</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># ipython 测验</span><br><span class="line">In [2]: Foo.__doc__</span><br><span class="line">Out[2]: &apos; 描述类信息，这是用于测试的类 &apos;</span><br></pre></td></tr></table></figure>



<h3 id="module-和-class"><a href="#module-和-class" class="headerlink" title="__module__ 和 __class__"></a>__module__ 和 __class__</h3><ul>
<li><code>__module__</code> 表示当前操作的对象在那个模块</li>
<li><code>__class__</code> 表示当前操作的对象的类是什么</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line"># __module__、__class__</span><br><span class="line"># oop.py</span><br><span class="line">class Student(object):</span><br><span class="line">    </span><br><span class="line">    def __init__(self, name):</span><br><span class="line">        self.name = name</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line"># main.py</span><br><span class="line">from oop import Student</span><br><span class="line"></span><br><span class="line">s = Student()</span><br><span class="line">print(s.__module__)  # 输出 oop 即：输出模块</span><br><span class="line">print(s.__class__)   # 输出 &lt;class &apos;oop.Student&apos;&gt; 即：输出类</span><br></pre></td></tr></table></figure>



<h3 id="init-、-new"><a href="#init-、-new" class="headerlink" title="__init__ 、__new__"></a>__init__ 、__new__</h3><blockquote>
<p><code>__init__()</code> 初始化方法 和 <code>__new__()</code>，通过类创建对象时，自动触发执行。<code>__new__</code> 是用来创建类并返回这个类的实例，而 <code>__init__</code> 只是将传入的参数来初始化该实例。</p>
</blockquote>
<ul>
<li><code>__new__()</code> 创建对象时调用，会返回当前对象的一个实例</li>
<li><code>__init__()</code> 创建完对象后调用，对当前对象的一些实例初始化，无返回值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line"># __init__ 、 __new__</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        print(&apos;__init__() called&apos;)</span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&apos;__new__() called&apos;)</span><br><span class="line">        print(cls, args, kwargs)</span><br><span class="line">        return super().__new__(cls)</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># ipython 测验</span><br><span class="line">In [26]: s1 = Student(&apos;hui&apos;, age=21)</span><br><span class="line">__new__() called</span><br><span class="line">&lt;class &apos;__main__.Student&apos;&gt; (&apos;hui&apos;,) &#123;&apos;age&apos;: 21&#125;</span><br><span class="line">__init__() called</span><br><span class="line"></span><br><span class="line">In [27]: s2 = Student(&apos;jack&apos;, age=20)</span><br><span class="line">__new__() called</span><br><span class="line">&lt;class &apos;__main__.Student&apos;&gt; (&apos;jack&apos;,) &#123;&apos;age&apos;: 20&#125;</span><br><span class="line">__init__() called</span><br></pre></td></tr></table></figure>



<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a>__del__</h3><blockquote>
<p>当对象在内存中被释放时，自动触发执行。</p>
</blockquote>
<p>注：此方法一般无须定义，因为Python是一门高级语言，有 <strong>内存管理、垃圾回收机制</strong>，程序员在使用时无需关心内存的分配和释放，因为此工作都是交给Python解释器来执行，所以，<code>__del__</code> 的调用是由解释器在进行垃圾回收时自动触发执行的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __del__</span><br><span class="line">class Foo:</span><br><span class="line">    def __del__(self):</span><br><span class="line">        print(&apos;__del__() called&apos;)</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"># ipython 测验</span><br><span class="line">In [29]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [30]: del f</span><br><span class="line">__del__() called</span><br></pre></td></tr></table></figure>



<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a>__call__</h3><blockquote>
<p>让类的实例的行为表现的像函数一样，你可以调用它们，将一个函数当做一个参数传到另外一个函数中等等。这是一个非常强大的特性，其让Python编程更加舒适甜美。<strong>对象后面加括号，触发执行</strong>。</p>
</blockquote>
<p>注：<code>__init__</code> 方法的执行是由创建对象触发的，即：<code>对象 = 类名()</code> ；而对于 <code>__call__</code> 方法的执行是由对象后加括号触发的，即：<code>对象()</code> 或者 <code>类()()</code></p>
<p><code>__call__</code> 在那些 <strong>类的实例经常改变状态的时候会非常有效</strong>。调用这个实例是一种改变这个对象状态的直接和优雅的做法。用一个实例来表达最好不过了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __call__</span><br><span class="line">class Rect(object)</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    调用实例对象来改变矩形的位置</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, x, y):</span><br><span class="line">        # x, y代表矩形坐标</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line">    def __call__(self, x, y):        </span><br><span class="line">        # 改变实体的位置</span><br><span class="line">        self.x, self.y = x, y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ipython 测验</span><br><span class="line">In [33]: r = Rect(10, 10)</span><br><span class="line"></span><br><span class="line">In [34]: r.x, r.y</span><br><span class="line">Out[34]: (10, 10)</span><br><span class="line"></span><br><span class="line">In [35]: r(0, 0)</span><br><span class="line"></span><br><span class="line">In [36]: r.x, r.y</span><br><span class="line">Out[36]: (0, 0)</span><br><span class="line"></span><br><span class="line">In [37]: r(100, 100)</span><br><span class="line"></span><br><span class="line">In [38]: r.x, r.y</span><br><span class="line">Out[38]: (100, 100)</span><br></pre></td></tr></table></figure>



<h3 id="dict"><a href="#dict" class="headerlink" title="__dict__"></a>__dict__</h3><blockquote>
<p>类或对象中的所有属性</p>
</blockquote>
<p>类的实例属性属于对象；类中的类属性和方法等属于类，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __dict__</span><br><span class="line">class Student(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self, name, age):</span><br><span class="line">        self.name = name</span><br><span class="line">        self._age = age</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def age(self):</span><br><span class="line">        return self._age</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"># ipython 测验</span><br><span class="line">In [47]: # 获取类属性</span><br><span class="line"></span><br><span class="line">In [48]: Student.__dict__</span><br><span class="line">Out[48]:</span><br><span class="line">mappingproxy(&#123;&apos;__module__&apos;: &apos;__main__&apos;,</span><br><span class="line">              &apos;__init__&apos;: &lt;function __main__.Student.__init__(self, name, age)&gt;,</span><br><span class="line">              &apos;age&apos;: &lt;property at 0x210e2a005e8&gt;,</span><br><span class="line">              &apos;__dict__&apos;: &lt;attribute &apos;__dict__&apos; of &apos;Student&apos; objects&gt;,</span><br><span class="line">              &apos;__weakref__&apos;: &lt;attribute &apos;__weakref__&apos; of &apos;Student&apos; objects&gt;,</span><br><span class="line">              &apos;__doc__&apos;: None&#125;)</span><br><span class="line"></span><br><span class="line">In [49]: # 获取实例对象的属性</span><br><span class="line"></span><br><span class="line">In [50]: s = Student(&apos;hui&apos;, 21)</span><br><span class="line"></span><br><span class="line">In [51]: s.__dict__</span><br><span class="line">Out[51]: &#123;&apos;name&apos;: &apos;hui&apos;, &apos;_age&apos;: 21&#125;</span><br><span class="line"></span><br><span class="line">In [52]: s2 = Student(&apos;jack&apos;, 20)</span><br><span class="line"></span><br><span class="line">In [53]: s2.__dict__</span><br><span class="line">Out[53]: &#123;&apos;name&apos;: &apos;jack&apos;, &apos;_age&apos;: 20&#125;</span><br></pre></td></tr></table></figure>



<h3 id="str"><a href="#str" class="headerlink" title="__str__"></a>__str__</h3><blockquote>
<p>如果一个类中定义了__str__方法，那么在打印 对象 时，默认输出该方法的返回值。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码In [65]: # __str__</span><br><span class="line">    ...: class Foo(object):</span><br><span class="line">    ...:     pass</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [66]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [67]: print(f)</span><br><span class="line">&lt;__main__.Foo object at 0x00000210E2715608&gt;</span><br><span class="line"></span><br><span class="line">In [68]: class Foo(object):</span><br><span class="line">    ...:</span><br><span class="line">    ...:     def __str__(self):</span><br><span class="line">    ...:         return &apos;&lt; Custom Foo object str &gt;&apos;</span><br><span class="line">    ...:</span><br><span class="line"></span><br><span class="line">In [69]: f = Foo()</span><br><span class="line"></span><br><span class="line">In [70]: print(f)</span><br><span class="line">&lt; Custom Foo object str &gt;</span><br></pre></td></tr></table></figure>



<h3 id="getitem-、-setitem-、-delitem"><a href="#getitem-、-setitem-、-delitem" class="headerlink" title="__getitem__、__setitem__、__delitem__"></a>__getitem__、__setitem__、__delitem__</h3><blockquote>
<p>用于索引操作，如字典。以上分别表示获取、设置、删除数据。</p>
<p>用于切片操作，如列表。</p>
</blockquote>
<h4 id="字典示例"><a href="#字典示例" class="headerlink" title="字典示例"></a>字典示例</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# __getitem__、__setitem__、__delitem__</span><br><span class="line">class MyDict(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.my_dict = dict()</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, key):</span><br><span class="line">        print(&apos;__getitem__() &apos;, key)</span><br><span class="line">        return self.my_dict.get(key, None)</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, key, value):</span><br><span class="line">        print(&apos;__setitem__() &apos;, key, value)</span><br><span class="line">        self.my_dict.update(key=value)</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, key):</span><br><span class="line">        print(&apos;__delitem__() &apos;, key)</span><br><span class="line">        del self.my_dict[key]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># ipython 测验        </span><br><span class="line">In [33]: mdict = MyDict()</span><br><span class="line"></span><br><span class="line">In [34]: print(mdict[&apos;name&apos;])</span><br><span class="line">__getitem__()  name</span><br><span class="line">None</span><br><span class="line"></span><br><span class="line">In [35]: # 新增</span><br><span class="line"></span><br><span class="line">In [36]: mdict[&apos;name&apos;] = &apos;hui&apos;</span><br><span class="line">__setitem__()  name hui</span><br><span class="line"></span><br><span class="line">In [37]: mdict[&apos;age&apos;] = 21</span><br><span class="line">__setitem__()  age 21</span><br><span class="line"></span><br><span class="line">In [38]: mdict[&apos;name&apos;]</span><br><span class="line">__getitem__()  name</span><br><span class="line">Out[38]: &apos;hui&apos;</span><br><span class="line"></span><br><span class="line">In [39]: mdict[&apos;age&apos;]</span><br><span class="line">__getitem__()  age</span><br><span class="line">Out[39]: 21</span><br><span class="line"></span><br><span class="line">In [40]: # 更新</span><br><span class="line"></span><br><span class="line">In [41]: mdict[&apos;name&apos;] = &apos;jack&apos;</span><br><span class="line">__setitem__()  name jack</span><br><span class="line"></span><br><span class="line">In [42]: mdict[&apos;name&apos;]</span><br><span class="line">__getitem__()  name</span><br><span class="line">Out[42]: &apos;jack&apos;</span><br><span class="line"></span><br><span class="line">In [43]: # 删除</span><br><span class="line"></span><br><span class="line">In [44]: del mdict[&apos;age&apos;]</span><br><span class="line">__delitem__()  age</span><br><span class="line"></span><br><span class="line">In [45]: print(mdict[&apos;age&apos;])</span><br><span class="line">__getitem__()  age</span><br><span class="line">None</span><br></pre></td></tr></table></figure>



<h4 id="列表示例"><a href="#列表示例" class="headerlink" title="列表示例"></a><strong>列表示例</strong></h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# 切片操作</span><br><span class="line">class MyList(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.mlist = list()</span><br><span class="line"></span><br><span class="line">    def __getitem__(self, index):</span><br><span class="line">        print(&apos;__getitem__() called&apos;)</span><br><span class="line">        print(index)</span><br><span class="line">        if isinstance(index, slice):</span><br><span class="line">            return self.mlist[index]</span><br><span class="line"></span><br><span class="line">    def __setitem__(self, index, value):</span><br><span class="line">        print(&apos;__getitem__() called&apos;)</span><br><span class="line">        print(index, value)</span><br><span class="line">        if isinstance(index, slice):</span><br><span class="line">            self.mlist[index] = value</span><br><span class="line"></span><br><span class="line">    def __delitem__(self, index):</span><br><span class="line">        print(&apos;__delitem__() called&apos;)</span><br><span class="line">        if isinstance(index, slice):</span><br><span class="line">            del self.mlist[index]</span><br><span class="line">     </span><br><span class="line">    </span><br><span class="line"># ipython 测验</span><br><span class="line">In [70]: mlist = MyList()</span><br><span class="line"></span><br><span class="line">In [71]: mlist[0]</span><br><span class="line">__getitem__() called</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">In [72]: mlist[0:-1]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(0, -1, None)</span><br><span class="line">Out[72]: []</span><br><span class="line"></span><br><span class="line">In [73]: mlist[:] = [1,2,3]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, None) [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [74]: mlist[:]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, None)</span><br><span class="line">Out[74]: [1, 2, 3]</span><br><span class="line"></span><br><span class="line">In [75]: mlist[0:2]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(0, 2, None)</span><br><span class="line">Out[75]: [1, 2]</span><br><span class="line"></span><br><span class="line">In [76]: mlist[::-1]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, -1)</span><br><span class="line">Out[76]: [3, 2, 1]</span><br><span class="line"></span><br><span class="line">In [77]: mlist[0]</span><br><span class="line">__getitem__() called</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">In [78]: mlist[0:1]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(0, 1, None)</span><br><span class="line">Out[78]: [1]</span><br><span class="line"></span><br><span class="line">In [79]: del mlist[0:1]</span><br><span class="line">__delitem__() called</span><br><span class="line"></span><br><span class="line">In [80]: mlist[:]</span><br><span class="line">__getitem__() called</span><br><span class="line">slice(None, None, None)</span><br><span class="line">Out[80]: [2, 3]</span><br></pre></td></tr></table></figure>



<p><strong>注意：</strong> 当进行 <code>mlist[0]</code> 操作的时候传递并不是一个 <code>slice</code> 对象，不是一个 <code>int</code> 类型的数字，所以不能把索引为 <code>0</code> 的值取出来，改成 <code>mlist[0, 1]</code> 或者在 <code>__getitem__()</code> 的方法中新增数字判断，大家可以尝试一下。</p>
<h3 id="enter-、-exit"><a href="#enter-、-exit" class="headerlink" title="__enter__、__exit__"></a>__enter__、__exit__</h3><p><code>with</code> 声明是从 <code>Python2.5</code> 开始引进的关键词。你应该遇过这样子的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码with open(&apos;foo.txt&apos;) as bar:</span><br><span class="line">    # do something with bar</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<p>在 <code>with</code> 声明的代码段中，我们可以做一些对象的开始操作和退出操作,还能对异常进行处理。这需要实现两个魔术方法: __enter__ 和 __exit__。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__enter__(self):</span><br></pre></td></tr></table></figure>

<p>定义了当使用 <code>with</code> 语句的时候，会话管理器在块被初始创建时要产生的行为。请注意，<code>__enter__</code> 的返回值与 <code>with</code> 语句的目标或者 <code>as</code> 后的名字绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__exit__(self, exception_type, exception_value, traceback):</span><br></pre></td></tr></table></figure>

<p>定义了当一个代码块被执行或者终止后，会话管理器应该做什么。它可以被用来处理异常、执行清理工作或做一些代码块执行完毕之后的日常工作。如果代码块执行成功，<code>exception_type，exception_value，和traceback</code> 将会为 <code>None</code> 。否则，你可以选择处理这个异常或者是直接交给用户处理。如果你想处理这个异常的话，请确保<code>__exit__</code> 在所有语句结束之后返回 <code>True</code>。如果你想让异常被会话管理器处理的话，那么就让其产生该异常。</p>
<h3 id="copy-、-deepcopy"><a href="#copy-、-deepcopy" class="headerlink" title="__copy__、__deepcopy__"></a>__copy__、__deepcopy__</h3><p>　　有时候，尤其是当你在处理可变对象时，你可能想要复制一个对象，然后对其做出一些改变而不希望影响原来的对象。这就是Python的copy所发挥作用的地方。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__copy__(self):</span><br></pre></td></tr></table></figure>

<p>　　定义了当对你的类的实例调用 <code>copy.copy()</code> 时所产生的行为。<code>copy.copy()</code> 返回了你的对象的一个浅拷贝——这意味着，当实例本身是一个新实例时，它的所有数据都被引用了——例如，当一个对象本身被复制了，它的数据仍然是被引用的（因此，对于浅拷贝中数据的更改仍然可能导致数据在原始对象的中的改变）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码__deepcopy__(self, memodict=&#123;&#125;):</span><br></pre></td></tr></table></figure>

<p>　　定义了当对你的类的实例调用 <code>copy.deepcopy()</code>时所产生的行为。<code>copy.deepcopy()</code> 返回了你的对象的一个深拷贝——对象和其数据都被拷贝了。<code>memodict</code> 是对之前被拷贝的对象的一个缓存——这优化了拷贝过程并且阻止了对递归数据结构拷贝时的无限递归。当你想要进行对一个单独的属性进行深拷贝时，调用<code>copy.deepcopy()</code>，并以 <code>memodict</code> 为第一个参数。</p>
<p>　　<strong>这些魔术方法的用例看起来很小，并且确实非常实用. 它们反应了关于面向对象程序上一些重要的东西在<code>Python</code> 上，并且总的来说 <code>Python</code> 总是一个简单的方法去找某些事情，即使是没有必要的。这些魔法方法可能看起来不是很有用，但是一旦你需要它们，你会感到庆幸它们的存在。</strong></p>
<h2 id="其他魔法方法"><a href="#其他魔法方法" class="headerlink" title="其他魔法方法"></a>其他魔法方法</h2><p>由于魔法属性、方法太多了在这就不一一描述和展示了，其他的就以表格形式呈现吧。</p>
<h3 id="用于比较的魔术方法"><a href="#用于比较的魔术方法" class="headerlink" title="用于比较的魔术方法"></a>用于比较的魔术方法</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__cmp__(self, other)</code></td>
<td>比较方法里面最基本的的魔法方法</td>
</tr>
<tr>
<td><code>__eq__(self, other)</code></td>
<td>定义相等符号的行为，<strong>==</strong></td>
</tr>
<tr>
<td><code>__ne__(self,other)</code></td>
<td>定义不等符号的行为，<strong>!=</strong></td>
</tr>
<tr>
<td><code>__lt__(self,other)</code></td>
<td>定义小于符号的行为，<strong>&lt;</strong></td>
</tr>
<tr>
<td><code>__gt__(self,other)</code></td>
<td>定义大于符号的行为，<strong>&gt;</strong></td>
</tr>
<tr>
<td><code>__le__(self,other)</code></td>
<td>定义小于等于符号的行为，<strong>&lt;=</strong></td>
</tr>
<tr>
<td><code>__ge__(self,other)</code></td>
<td>定义大于等于符号的行为，<strong>&gt;=</strong></td>
</tr>
</tbody></table>
<h3 id="数值计算的魔术方法"><a href="#数值计算的魔术方法" class="headerlink" title="数值计算的魔术方法"></a>数值计算的魔术方法</h3><h4 id="单目运算符和函数"><a href="#单目运算符和函数" class="headerlink" title="单目运算符和函数"></a>单目运算符和函数</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__pos__(self)</code></td>
<td>实现一个取正数的操作</td>
</tr>
<tr>
<td><code>__neg__(self)</code></td>
<td>实现一个取负数的操作</td>
</tr>
<tr>
<td><code>__abs__(self)</code></td>
<td>实现一个内建的 <code>abs()</code> 函数的行为</td>
</tr>
<tr>
<td><code>__invert__(self)</code></td>
<td>实现一个取反操作符（～操作符）的行为</td>
</tr>
<tr>
<td><code>__round__(self, n)</code></td>
<td>实现一个内建的 <code>round()</code> 函数的行为</td>
</tr>
<tr>
<td><code>__floor__(self)</code></td>
<td>实现 <code>math.floor()</code> 的函数行为</td>
</tr>
<tr>
<td><code>__ceil__(self)</code></td>
<td>实现 <code>math.ceil()</code> 的函数行为</td>
</tr>
<tr>
<td><code>__trunc__(self)</code></td>
<td>实现 <code>math.trunc()</code> 的函数行为</td>
</tr>
</tbody></table>
<h4 id="双目运算符或函数"><a href="#双目运算符或函数" class="headerlink" title="双目运算符或函数"></a>双目运算符或函数</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__add__(self, other)</code></td>
<td>实现一个加法</td>
</tr>
<tr>
<td><code>__sub__(self, other)</code></td>
<td>实现一个减法</td>
</tr>
<tr>
<td><code>__mul__(self, other)</code></td>
<td>实现一个乘法</td>
</tr>
<tr>
<td><code>__floordiv__(self, other)</code></td>
<td>实现一个 <strong>//</strong> 操作符产生的整除操作</td>
</tr>
<tr>
<td><code>__div__(self, other)</code></td>
<td>实现一个 <strong>/</strong> 操作符代表的除法操作</td>
</tr>
<tr>
<td><code>__truediv__(self, other)</code></td>
<td>实现真实除法</td>
</tr>
<tr>
<td><code>__mod__(self, other)</code></td>
<td>实现一个 <strong>%</strong> 操作符代表的取模操作</td>
</tr>
<tr>
<td><code>__divmod__(self, other)</code></td>
<td>实现一个内建函数 <code>divmod()</code></td>
</tr>
<tr>
<td><code>__pow__(self, other)</code></td>
<td>实现一个指数操作( ****** 操作符）的行为</td>
</tr>
<tr>
<td><code>__lshift__(self, other)</code></td>
<td>实现一个位左移操作**（&lt;&lt;）**的功能</td>
</tr>
<tr>
<td><code>__rshift__(self, other)</code></td>
<td>实现一个位右移操作**（&gt;&gt;）**的功能</td>
</tr>
<tr>
<td><code>__and__(self, other)</code></td>
<td>实现一个按位进行与操作**（&amp;）**的行为</td>
</tr>
<tr>
<td><code>__or__(self, other)</code></td>
<td>实现一个按位进行或操作的行为</td>
</tr>
<tr>
<td><code>__xor__(self, other)</code></td>
<td>异或运算符相当于 <strong>^</strong></td>
</tr>
</tbody></table>
<h4 id="增量运算"><a href="#增量运算" class="headerlink" title="增量运算"></a>增量运算</h4><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__iadd__(self, other)</code></td>
<td>加法赋值</td>
</tr>
<tr>
<td><code>__isub__(self, other)</code></td>
<td>减法赋值</td>
</tr>
<tr>
<td><code>__imul__(self, other)</code></td>
<td>乘法赋值</td>
</tr>
<tr>
<td><code>__ifloordiv__(self, other)</code></td>
<td>整除赋值，地板除，相当于 <strong>//=</strong> 运算符</td>
</tr>
<tr>
<td><code>__idiv__(self, other)</code></td>
<td>除法赋值，相当于 <strong>/=</strong> 运算符</td>
</tr>
<tr>
<td><code>__itruediv__(self, other)</code></td>
<td>真除赋值</td>
</tr>
<tr>
<td><code>__imod_(self, other)</code></td>
<td>模赋值，相当于 <strong>%=</strong> 运算符</td>
</tr>
<tr>
<td><code>__ipow__(self, other)</code></td>
<td>乘方赋值，相当于 <code>**=</code> 运算符</td>
</tr>
<tr>
<td><code>__ilshift__(self, other)</code></td>
<td>左移赋值，相当于 <strong>&lt;&lt;=</strong> 运算符</td>
</tr>
<tr>
<td><code>__irshift__(self, other)</code></td>
<td>左移赋值，相当于 <strong>&gt;&gt;=</strong> 运算符</td>
</tr>
<tr>
<td><code>__iand__(self, other)</code></td>
<td>与赋值，相当于 <strong>&amp;=</strong> 运算符</td>
</tr>
<tr>
<td><code>__ior__(self, other)</code></td>
<td>或赋值</td>
</tr>
<tr>
<td><code>__ixor__(self, other)</code></td>
<td>异或运算符，相当于 <strong>^=</strong> 运算符</td>
</tr>
</tbody></table>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td><code>__int__(self)</code></td>
<td>转换成整型</td>
</tr>
<tr>
<td><code>__long__(self)</code></td>
<td>转换成长整型</td>
</tr>
<tr>
<td><code>__float__(self)</code></td>
<td>转换成浮点型</td>
</tr>
<tr>
<td><code>__complex__(self)</code></td>
<td>转换成 复数型</td>
</tr>
<tr>
<td><code>__oct__(self)</code></td>
<td>转换成八进制</td>
</tr>
<tr>
<td><code>__hex__(self)</code></td>
<td>转换成十六进制</td>
</tr>
<tr>
<td><code>__index__(self)</code></td>
<td>如果你定义了一个可能被用来做切片操作的数值型，你就应该定义<code>__index__</code></td>
</tr>
<tr>
<td><code>__trunc__(self)</code></td>
<td>当 <code>math.trunc(self)</code> 使用时被调用 <code>__trunc__</code> 返回自身类型的整型截取</td>
</tr>
<tr>
<td><code>__coerce__(self, other)</code></td>
<td>执行混合类型的运算</td>
</tr>
</tbody></table>
<h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>源代码已上传到 <code>Gitee</code> <a href="https://gitee.com/huiDBK/PythonKnowledge" target="_blank" rel="noopener">PythonKnowledge: Python知识宝库</a>，欢迎大家来访。</p>
<p><strong>✍ 码字不易，还望各位大侠多多支持❤️。</strong></p>
<h2 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h2><p> <strong>新建文件夹X</strong></p>
<blockquote>
<p>大自然用数百亿年创造出我们现实世界，而程序员用几百年创造出一个完全不同的虚拟世界。我们用键盘敲出一砖一瓦，用大脑构建一切。人们把1000视为权威，我们反其道行之，捍卫1024的地位。我们不是键盘侠，我们只是平凡世界中不凡的缔造者 。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6959490821934710797" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入剖析Python的单例模式实现一、引言二、单例的应用</title>
    <url>/7272006755265380367.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><blockquote>
<p>单例模式是一种常见的设计模式，它限制一个类只能生成一个实例。在Python开发中，我们该如何实现单例模式呢？本文将通过一个简单的例子，使用Python的元类来实现一个线程安全的单例类，并比较说明使用装饰器实现单例的优劣。</p>
<p>单例模式看起来简单，但是想要做到完全线程安全并支持子类继承，还有一定的难度。本文将从单例模式的概念和应用场景开始，一步步分析线程安全的单例类该如何设计，加锁来保证线程安全等。</p>
</blockquote>
<h1 id="二、单例的应用场景"><a href="#二、单例的应用场景" class="headerlink" title="二、单例的应用场景"></a>二、单例的应用场景</h1><ol>
<li>系统只需要一个实例对象，比如配置类、日志、工具类等。使用单例可以直接保证全局只存在一个实例。</li>
<li>控制资源访问，比如一个硬件资源只允许一个进程访问，或者打印机只允许一个任务执行打印操作。</li>
<li>频繁创建和销毁实例会带来较高的系统开销，使用单例可以减少内存占用和性能消耗。比如任务池、连接池等。</li>
<li>想确保一个类只有一个可见的实例，并提供一个全局访问点，如线程池、缓存、会话对象等。</li>
<li>当类状态需要频繁保存和恢复时，可以让类成为单例，避免每次获取实例后都要恢复状态的操作。</li>
<li>在面向对象中，如果有状态共享的需求，可以将共享状态和逻辑封装在一个单例类中。</li>
<li>单例可以简化代码，从而降低维护成本。在不需要多个实例的情况下，单例可以消除判断逻辑。</li>
</ol>
<p>如下是一些伪代码的单例DEMO</p>
<p><strong>配置类</strong></p>
<p>配置类信息在程序运行期间仅需要一个实例，使用单例模式可以保证全局唯一:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Config(metaclass=SingletonMetaCls):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.config = &#123;&apos;timeout&apos;:100， &apos;port&apos;:8000&#125;</span><br><span class="line"></span><br><span class="line"># 访问配置    </span><br><span class="line">print(Config().config)</span><br></pre></td></tr></table></figure>

<p><strong>2. 日志类</strong></p>
<p>日志类也只需要一个实例输出日志信息即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Logger(metaclass=SingletonMetaCls):</span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;初始化logger&quot;)</span><br><span class="line">        </span><br><span class="line">    def log(self， msg):</span><br><span class="line">        print(f&quot;log: &#123;msg&#125;&quot;)</span><br><span class="line">        </span><br><span class="line"># 使用        </span><br><span class="line">Logger().log(&quot;测试日志&quot;)</span><br></pre></td></tr></table></figure>

<p><strong>任务池</strong></p>
<p>控制任务池的资源个数，只初始化指定数量的连接:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class TaskPool(metaclass=SingletonMetaCls):</span><br><span class="line">    def __init__(self， size=10):</span><br><span class="line">        print(f&quot;初始化&#123;size&#125;个任务到池中&quot;)</span><br><span class="line">        </span><br><span class="line"># 初始化一个10大小的任务池        </span><br><span class="line">pool = TaskPool()</span><br></pre></td></tr></table></figure>

<p>总之，任何只需要一个实例、不保存状态的工具/帮助类，你需要限制实例个数的场景，都可以考虑使用单例模式实现。</p>
<h1 id="三、单例的实现"><a href="#三、单例的实现" class="headerlink" title="三、单例的实现"></a>三、单例的实现</h1><h2 id="重写-new-方法"><a href="#重写-new-方法" class="headerlink" title="重写 __new__ 方法"></a>重写 __new__ 方法</h2><p>Python 的 new 对象不像java等其他语言一样，一些初学者可能会误认为 __init__ 方法是构造对象，实则不是，__init__方法是初始化对象属性，而__new__ 方法才是真正构造类实例对象。因此我们可以通过 <strong>重写__new__方法</strong> 并在方法内部添加判断逻辑，来限制一个类只创建一个实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Singleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        # 重写 __new__ 实现单例</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化实例属性</span><br><span class="line">        self.demo_name = &quot;Singleton Demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Singleton()</span><br><span class="line">s2 = Singleton()</span><br><span class="line"></span><br><span class="line">print(&quot;s1 demo_name&quot;, s1.demo_name)</span><br><span class="line">print(&quot;s2 demo_name&quot;, s2.demo_name)</span><br><span class="line">print(&quot;s1&quot;, s1)</span><br><span class="line">print(&quot;s2&quot;, s2)</span><br><span class="line">print(&quot;s1 is s2&quot;, s1 is s2)</span><br><span class="line">print(&quot;s1 == s2&quot;, s1 == s2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">s1 demo_name Singleton Demo</span><br><span class="line">s2 demo_name Singleton Demo</span><br><span class="line">s1 &lt;__main__.Singleton object at 0x1051dcb80&gt;</span><br><span class="line">s2 &lt;__main__.Singleton object at 0x1051dcb80&gt;</span><br><span class="line">s1 is s2 True</span><br><span class="line">s1 == s2 True</span><br></pre></td></tr></table></figure>

<p>通过重写 <code>__new__</code> 实现单例，就可以实现最简单的单例模式。可以发现创建的对象的内存地址都是一样的。</p>
<p>上面的实现模式属于懒汉模式，还有一种叫做饿汉模式。先简单介绍下这两种模式概念。</p>
<p><strong>懒汉模式</strong></p>
<p>懒汉模式是等到<strong>需要才创建实例</strong>，比如:</p>
<p>一个游戏需要读取玩家存档数据的类，如果玩家没有存档,就不需要创建该类的实例，等玩家第一次存档时再实例化该类，读取并保存游戏状态。这种情况下使用懒汉模式更合适，不会提前占用内存资源。</p>
<p><strong>饿汉模式</strong></p>
<p>饿汉模式是<strong>提前创建实例</strong>，比如:</p>
<p>一个数据库连接池类，系统启动时就需要初始化一个指定大小的连接池，以备后续使用。这里需要饿汉模式提前创建并准备好数据库连接池，否则后面需要数据库连接时会出现延迟。</p>
<ul>
<li>懒汉是按需创建，节省资源</li>
<li>饿汉是准备实例，避免后续延迟</li>
</ul>
<p><strong>饿汉代码实现</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码#!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author: Hui</span><br><span class="line"># @Desc: &#123; 单例DEMO &#125;</span><br><span class="line"># @Date: 2023/08/22 09:27</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseSingleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def instance(cls):</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            cls._instance = cls()</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Singleton(BaseSingleton):</span><br><span class="line">    # _instance = Singleton() 这是错误的语法</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            BaseSingleton.instance()</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化实例属性</span><br><span class="line">        self.demo_name = &quot;Singleton Demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s1 = Singleton.instance()</span><br><span class="line">s2 = Singleton.instance()</span><br><span class="line">s3 = Singleton()</span><br><span class="line">s4 = Singleton()</span><br><span class="line"></span><br><span class="line">print(&quot;s1&quot;, s1)</span><br><span class="line">print(&quot;s2&quot;, s2)</span><br><span class="line">print(&quot;s3&quot;, s3)</span><br><span class="line">print(&quot;s4&quot;, s4)</span><br><span class="line">print(&quot;s1 is s2&quot;, s1 is s2)</span><br><span class="line">print(&quot;s2 is s3&quot;, s2 is s3)</span><br><span class="line">print(&quot;s3 is s4&quot;, s3 is s4)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">s1 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s2 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s3 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s4 &lt;__main__.BaseSingleton object at 0x1051dcf70&gt;</span><br><span class="line">s1 is s2 True</span><br><span class="line">s2 is s3 True</span><br><span class="line">s3 is s4 True</span><br></pre></td></tr></table></figure>

<p>python的饿汉模式，不能直接在类中构造自身对象，如下是错误的写法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Singleton(BaseSingleton):</span><br><span class="line">    _instance = Singleton() # 这是错误的语法</span><br></pre></td></tr></table></figure>

<p>因此这里通过添加一个静态方法 instance() 来实现饿汉单例模式，但感觉有点不太像，就是要在new 对象前先通过 instance() 方法初始化下对象实例，到后面在其他模块使用已经存在的实例即可。但有时候就是想，instance() 是单例，Singleton() 这种new 对象不是，那就不要重写 <code>__new__</code> 方法即可。因为有时候new对象想重新初始化属性。</p>
<blockquote>
<p>虽然通过重写 <code>__new__</code> 方法，实现了单例模式，但不够完善，在并发的情况下还是会创建多个实例，属于线程不安全，因此还是需要改造下，这里先展示并发问题，具体改造看下面装饰器的写法。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Singleton(object):</span><br><span class="line">    _instance = None</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        # 重写 __new__ 实现单例</span><br><span class="line">        if not cls._instance:</span><br><span class="line">            print(&quot;new instance&quot;)</span><br><span class="line">            cls._instance = super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 初始化实例属性</span><br><span class="line">        self.demo_name = &quot;Singleton Demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_obj(num):</span><br><span class="line">    s = Singleton()</span><br><span class="line">    print(f&quot;s&#123;num&#125;&quot;, s)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 多线程测试并发</span><br><span class="line">with ThreadPoolExecutor() as pool:</span><br><span class="line">    for i in range(3, 10):</span><br><span class="line">        pool.submit(create_obj, i)</span><br></pre></td></tr></table></figure>

<p>测试效果，这个要多运行几遍才有概率复现</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4bf364d376781e1cc0a6b1040a1965d3c9d61c15f845f41abc8edcd33ee989d0" alt></p>
<p>可以发现，多线程的打印是凌乱的，但已经可以证明有2个线程创建了两实例对象 new instance，对象的内存地址也不一样。这是由于 <strong>if not cls._instance:</strong> 操作是非原子性操作的导致的并发问题。</p>
<h2 id="装饰器写法"><a href="#装饰器写法" class="headerlink" title="装饰器写法"></a>装饰器写法</h2><p>重写 <code>__new__</code> 方法还是比较容易懂，但不太方便使用，每个类都要重写这个方法就很麻烦，逻辑都是一样的，因此我上面抽了一个 <strong>BaseSingleton</strong> 类来做，通过继承来复用代码。还有一种方式就是通过装饰器来实现单例，把共用的逻辑放到装饰器中做，然后再处理下并发问题。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码def singleton(cls_obj):</span><br><span class="line">    &quot;&quot;&quot;单例装饰器&quot;&quot;&quot;</span><br><span class="line">    _instance_dic = &#123;&#125;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    @functools.wraps(cls_obj)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        if cls_obj in _instance_dic:</span><br><span class="line">            # 实例字典中存在则直接返回</span><br><span class="line">            return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">        with _instance_lock:  # 互斥锁，防止多线程竞争，导致创建多实例</span><br><span class="line">            if cls_obj not in _instance_dic:</span><br><span class="line">                # 实例字典中没有，则创建对象实例，存入字典中</span><br><span class="line">                _instance_dic[cls_obj] = cls_obj(*args, **kwargs)</span><br><span class="line">        return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>

<p>由于 <strong>if cls_obj not in _instance_dic</strong> 判断是非原子性操作故而会引发多线程并发问题。</p>
<p>它大致会转换成以下字节码指令执行:</p>
<ol>
<li>加载<code>_instance_dic</code>到栈顶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">LOAD_GLOBAL   0 (_instance_dic)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>加载<code>cls_obj</code>到栈顶</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">LOAD_FAST    0 (cls_obj)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>调用<code>__contains__</code>方法检查是否在字典中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">CONTAINS_OP</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>根据返回值进行跳转</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码Copy code</span><br><span class="line">POP_JUMP_IF_FALSE  &lt;target&gt;</span><br></pre></td></tr></table></figure>

<p>如果<code>cls_obj</code>不在<code>_instance_dic</code>中,就会跳转到<code>target</code>位置,也就是if块内的代码。</p>
<p>可以看到校验是否在字典中是在多个指令中完成，不是一个原子操作。</p>
<p>在多线程环境下，如果多个线程同时执行到这里，都可能会通过校验,然后创建实例添加到字典中，从而导致线程不安全。</p>
<p>故而在装饰器中通过线程的互斥锁来解决并发问题，然后通过字典来判断是否存在类的实例对象，存在直接返回，不存在创建对象实例存入字典中来达到单例的效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@singleton</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Demo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.demo_name = &quot;singleton_demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = Foo()</span><br><span class="line">f2 = Foo()</span><br><span class="line">print(f1)</span><br><span class="line">print(f2)</span><br><span class="line">print(&quot;f1 is f2&quot;, f1 is f2)</span><br><span class="line"></span><br><span class="line">d1 = Demo()</span><br><span class="line">d2 = Demo()</span><br><span class="line">print(d1)</span><br><span class="line">print(d2)</span><br><span class="line">print(&quot;d1 is d2&quot;, d1 is d2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">&lt;__main__.Foo object at 0x102f56c70&gt;</span><br><span class="line">&lt;__main__.Foo object at 0x102f56c70&gt;</span><br><span class="line">f1 is f2 True</span><br><span class="line">&lt;__main__.Demo object at 0x102f56d60&gt;</span><br><span class="line">&lt;__main__.Demo object at 0x102f56d60&gt;</span><br><span class="line">d1 is d2 True</span><br></pre></td></tr></table></figure>

<p>并发安全验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">@singleton</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def two_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def create_obj(num):</span><br><span class="line">    foo = Foo()</span><br><span class="line">    print(f&quot;foo&#123;num&#125;&quot;, foo)</span><br><span class="line">    return foo</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">with ThreadPoolExecutor() as pool:</span><br><span class="line">    for i in range(10):</span><br><span class="line">        pool.submit(create_obj, i)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fe09da082dc62e4fe844e7e00da0fce61861d767ee844567ef4d7a47c0d9208d" alt></p>
<p>ok，对象实例都是 <strong>&lt;</strong>main<strong>.Foo object at 0x1016ed700&gt;，</strong> 大家可以多运行几次，加了锁不会出现多个实例对象了。</p>
<p>这里发现被装饰的类都实现了单例模式，接下来我们一探究竟，在装饰器内部打印些东西，看看其工作原理。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">def singleton(cls_obj):</span><br><span class="line">    &quot;&quot;&quot;单例装饰器&quot;&quot;&quot;</span><br><span class="line">    print(&quot;cls_obj&quot;, cls_obj)</span><br><span class="line"></span><br><span class="line">    _instance_dic = &#123;&#125;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    @functools.wraps(cls_obj)</span><br><span class="line">    def wrapper(*args, **kwargs):</span><br><span class="line">        if cls_obj in _instance_dic:</span><br><span class="line">            # 实例字典中存在则直接返回</span><br><span class="line">            return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">        with _instance_lock:  # 互斥锁，防止多线程竞争，导致创建多实例</span><br><span class="line">            if cls_obj not in _instance_dic:</span><br><span class="line">                # 实例字典中没有，则创建对象实例，存入字典中</span><br><span class="line">                _instance_dic[cls_obj] = cls_obj(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        print(&quot;_instance_dic&quot;, _instance_dic, &quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">        return _instance_dic.get(cls_obj)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Foo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@singleton</span><br><span class="line">class Demo(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.demo_name = &quot;singleton_demo&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">f1 = Foo()</span><br><span class="line">f2 = Foo()</span><br><span class="line">print(f1)</span><br><span class="line">print(f2)</span><br><span class="line">print(&quot;f1 is f2&quot;, f1 is f2)</span><br><span class="line"></span><br><span class="line">d1 = Demo()</span><br><span class="line">d2 = Demo()</span><br><span class="line">print(d1)</span><br><span class="line">print(d2)</span><br><span class="line">print(&quot;d1 is d2&quot;, d1 is d2)</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/60a067e3c913629f84a361e7ad342e2b0e7c4a3b4687af4c5047169db045a21b" alt></p>
<p>模块在初始化的时候，其实就会把类初始化形成<strong>类对象，注意不是类的实例对象。</strong></p>
<ul>
<li>装饰器的原理就是python解释器识别到 <strong>@singleton</strong> 的语法糖时自动把类对象的引用传递给 singleton 装饰器函数</li>
<li>此时装饰器会返回一个新的函数对象（wrapper）出去，把类对象重新赋值了</li>
</ul>
<pre><code>+ **Foo = singleton(Foo) = wrapper**
+ **Demo = singleton(Demo) = wrapper**</code></pre><ul>
<li>到创建对象实例时，Foo() 实则变成了是调用函数 wrapper() 来创建对象</li>
<li>然后每个类都维护了一份 _instance = {} 实例字典，来确保这个类创建的对象只有一份</li>
</ul>
<pre><code>+ Key 是类对象，eg：Foo、Demo
+ Value 是类的实例对象，eg：Foo()，Demo()</code></pre><p>可能大家会不了解类对象的概念，可以先看看我这篇文章 <a href="https://dev.newban.cn/6958375754505650213">你真的了解Python中的类class? - 掘金</a> 然后再回来看就更容易看懂了。</p>
<p>但装饰器实现的单例模式装饰方便、代码简洁，但是破坏了类的类型，把类变成了函数，导致编写代码的时候没有提示，也不知道有什么属性与方法，所以实际使用起来及其不方便。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a91c46fd372b859ee89bcf2e4a43721fd37b0c76702d8565d463dbe3996ff71a" alt></p>
<p>接下来就是引出另一种写法，元类实现单例。</p>
<h2 id="元类写法"><a href="#元类写法" class="headerlink" title="元类写法"></a>元类写法</h2><blockquote>
<p>元类是一种非常晦涩的知识点，一般场景都用不上，但知道元类的原理，后面需要用到时，可以帮助你更好的抽象与封装。</p>
<p>元类就是创建 <strong>类对象的类，type 就是元类</strong></p>
<p>可以先了解下元类的知识点：<a href="https://dev.newban.cn/6957631734343008269">追溯Python类的鼻祖——元类 - 掘金</a></p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码#!/usr/bin/python3</span><br><span class="line"># -*- coding: utf-8 -*-</span><br><span class="line"># @Author: Hui</span><br><span class="line"># @Desc: &#123; 元类模块 &#125;</span><br><span class="line"># @Date: 2022/11/26 16:43</span><br><span class="line">import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonMetaCls(type):</span><br><span class="line">    &quot;&quot;&quot; 单例元类 &quot;&quot;&quot;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(cls， *args， **kwargs):</span><br><span class="line">        cls._instance = None</span><br><span class="line">        super().__init__(*args， **kwargs)</span><br><span class="line"></span><br><span class="line">    def __call__(cls， *args， **kwargs):</span><br><span class="line">        if cls._instance:</span><br><span class="line">            # 存在实例对象直接返回，减少锁竞争，提高性能</span><br><span class="line">            return cls._instance</span><br><span class="line"></span><br><span class="line">        with cls._instance_lock:</span><br><span class="line">            if not cls._instance:</span><br><span class="line">                cls._instance = super().__call__(*args， **kwargs)</span><br><span class="line">        return cls._instance</span><br></pre></td></tr></table></figure>

<p>使用单例元类进行单例的封装会比装饰器的更好一些，装饰器封装的单例，再实际使用的过程中不太方便，IDE一些开发工具不知道这个类有什么属性，元类就不会，继承也可以实现单例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">foo1 is foo2 True</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/36dd0fd8008c3666db7e7f6d71e151f4ca0ee9865bbb4f6ade53f574b2ffea7a" alt></p>
<p>继承案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Demo(Foo):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;demo_bar&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">demo1 = Demo()</span><br><span class="line">demo2 = Demo()</span><br><span class="line">print(&quot;demo1 is demo2&quot;, demo1 is demo2)</span><br><span class="line">print(&quot;demo2 two_bar&quot;, demo2.tow_bar())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">foo1 is foo2 True</span><br><span class="line">foo2 two_bar barbar</span><br><span class="line">demo1 is demo2 True</span><br><span class="line">demo2 two_bar demo_bardemo_bar</span><br></pre></td></tr></table></figure>

<p><strong>元类实现原理</strong></p>
<ul>
<li>加载Foo、Demo等类时，发现指定了元类 <strong>metaclass=SingletonMetaCls，</strong> 则会让指定的元类来帮助创建类对象</li>
<li>此时 <strong>SingletonMetaCls 会调用__init__ 来创建类对象，然后通过super() 让 type 来创建类对象</strong></li>
</ul>
<pre><code>+ type(类名, 父类元组, 类属性字典)
+ 并动态加了个 cls.\_instance 属性</code></pre><ul>
<li>Foo()、Demo()，创建实例对象时，是Foo、Demo类对象触发了()，所以调用 <strong>call</strong>() 魔法属性来构造对象实例，存到cls._instance中</li>
<li>下次再创建实例对象，则是先判断是否有，有直接返回，没有则创建</li>
</ul>
<p>可以打印一些信息来验证</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码import threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class SingletonMetaCls(type):</span><br><span class="line">    &quot;&quot;&quot; 单例元类 &quot;&quot;&quot;</span><br><span class="line">    _instance_lock = threading.Lock()</span><br><span class="line"></span><br><span class="line">    def __init__(cls, *args, **kwargs):</span><br><span class="line">        cls._instance = None</span><br><span class="line">        print(&quot;SingletonMetaCls __init__&quot;, cls)</span><br><span class="line">        print(&quot;args&quot;, args)</span><br><span class="line">        print(&quot;kwargs&quot;, kwargs)</span><br><span class="line">        super().__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def _init_instance(cls, *args, **kwargs):</span><br><span class="line">        if cls._instance:</span><br><span class="line">            # 存在实例对象直接返回，减少锁竞争，提高性能</span><br><span class="line">            print(&quot;cls._instance&quot;, cls._instance)</span><br><span class="line">            return cls._instance</span><br><span class="line"></span><br><span class="line">        with cls._instance_lock:</span><br><span class="line">            if cls._instance is None:</span><br><span class="line">                cls._instance = super().__call__(*args, **kwargs)</span><br><span class="line">        return cls._instance</span><br><span class="line"></span><br><span class="line">    def __call__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;SingletonMetaCls __call__ cur cls&quot;, cls)</span><br><span class="line">        instance = cls._init_instance()</span><br><span class="line">        reinit = kwargs.get(&quot;reinit&quot;, True)</span><br><span class="line">        if reinit:</span><br><span class="line">            # 默认都重新初始化单例对象属性</span><br><span class="line">            instance.__init__(*args, **kwargs)</span><br><span class="line">        return instance</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from py_tools.meta_cls import SingletonMetaCls</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Foo __init__&quot;)</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Foo __new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># foo1 = Foo()</span><br><span class="line"># foo2 = Foo()</span><br><span class="line"># print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br><span class="line"># print(&quot;foo2 two_bar&quot;, foo2.tow_bar())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class Demo(Foo):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.bar = &quot;demo_bar&quot;</span><br></pre></td></tr></table></figure>

<p>模块加载时就会走元类的__init__</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码SingletonMetaCls __init__ &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">args (&apos;Foo&apos;, (), &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;Foo&apos;, &apos;__init__&apos;: &lt;function Foo.__init__ at 0x100eb0310&gt;, &apos;__new__&apos;: &lt;function Foo.__new__ at 0x100ed53a0&gt;, &apos;tow_bar&apos;: &lt;function Foo.tow_bar at 0x100ed5430&gt;, &apos;__classcell__&apos;: &lt;cell at 0x100eaafd0: SingletonMetaCls object at 0x1217193b0&gt;&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br><span class="line"></span><br><span class="line">SingletonMetaCls __init__ &lt;class &apos;__main__.Demo&apos;&gt;</span><br><span class="line">args (&apos;Demo&apos;, (&lt;class &apos;__main__.Foo&apos;&gt;,), &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;Demo&apos;, &apos;__init__&apos;: &lt;function Demo.__init__ at 0x100ed54c0&gt;&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>看看new对象的时候的打印信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class Foo(metaclass=SingletonMetaCls):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        print(&quot;Foo __init__&quot;)</span><br><span class="line">        self.bar = &quot;bar&quot;</span><br><span class="line"></span><br><span class="line">    def __new__(cls, *args, **kwargs):</span><br><span class="line">        print(&quot;Foo __new__&quot;)</span><br><span class="line">        return super().__new__(cls, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    def tow_bar(self):</span><br><span class="line">        return self.bar * 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo1 = Foo()</span><br><span class="line">foo2 = Foo()</span><br><span class="line">print(&quot;foo1 is foo2&quot;, foo1 is foo2)</span><br></pre></td></tr></table></figure>

<p>输出信息如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码SingletonMetaCls __init__ &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">args (&apos;Foo&apos;, (), &#123;&apos;__module__&apos;: &apos;__main__&apos;, &apos;__qualname__&apos;: &apos;Foo&apos;, &apos;__init__&apos;: &lt;function Foo.__init__ at 0x104998550&gt;, &apos;__new__&apos;: &lt;function Foo.__new__ at 0x1049d5550&gt;, &apos;tow_bar&apos;: &lt;function Foo.tow_bar at 0x1049d55e0&gt;, &apos;__classcell__&apos;: &lt;cell at 0x104991fd0: SingletonMetaCls object at 0x12f626fb0&gt;&#125;)</span><br><span class="line">kwargs &#123;&#125;</span><br><span class="line"></span><br><span class="line">SingletonMetaCls __call__ cur cls &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">Foo __new__</span><br><span class="line">Foo __init__</span><br><span class="line">Foo __init__</span><br><span class="line"></span><br><span class="line">SingletonMetaCls __call__ cur cls &lt;class &apos;__main__.Foo&apos;&gt;</span><br><span class="line">cls._instance &lt;__main__.Foo object at 0x1049b3f70&gt;</span><br><span class="line">Foo __init__</span><br><span class="line">foo1 is foo2 True</span><br></pre></td></tr></table></figure>

<p>可以发现跟我上面的说的一致，这里引出了好多魔法属性来验证，可以先看看 <a href="https://dev.newban.cn/6959490821934710797">Python中的魔法属性 - 掘金</a></p>
<h1 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h1><ul>
<li>类重写 <strong>new</strong> 易懂，但每个类都要重写太冗余了</li>
</ul>
<pre><code>+ 故抽出 BaseSingleton 基类，复用逻辑通过 instance() 来实现单例（**推荐**）
+ 如果要构造实例属性会有点不太方便</code></pre><ul>
<li>装饰器写法也是复用了创建单例的逻辑，装饰起来方便、简洁</li>
</ul>
<pre><code>+ 但实际使用装饰过的类不方便，没有类属性提示</code></pre><ul>
<li>元类的写法会有点难与绕，实际使用起来方便，多继承也实现了单例（<strong>推荐</strong>）</li>
</ul>
<pre><code>+ 使用起来和平常使用类没有区别
+ 还可以通过**reinit**参数来控制是否重新初始化实例对象属性</code></pre><ul>
<li>通过线程的互斥锁来解决并发问题</li>
</ul>
<pre><code>+ 双重判断来减少锁竞争，提高性能</code></pre><ul>
<li>当然还有其他的方式实现单例，例如通过Python的模块导入，来保证只会创建一个实例</li>
</ul>
<h1 id="五、源代码"><a href="#五、源代码" class="headerlink" title="五、源代码"></a>五、源代码</h1><p>有些细节，我没有展开讲，大家可以下载源代码，亲自实践下。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7272006755265380367" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决swagger2默认地址失效前言修改</title>
    <url>/7221525689856688184.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>本文正在参加<a href="https://dev.newban.cn/7207698564641996856/">「金石计划」</a></em></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有段时间没用 Java 写过项目了，今天因为需求要搭建一个小项目，果然是略显生疏，一路磕磕碰碰的，不过总算都是让我解决了。</p>
<p>回归正题，本篇博文要讲的是，关于配置好 <code>swagger2</code> 之后，访问其页面却被告诉页面不存在，即默认地址失效的问题。</p>
<p>当然也顺带讲解一下 SpringBoot 和 Springfox 的版本兼容性问题。以下就先讲解如何简单地解决版本兼容性问题。</p>
<h1 id="修改路径匹配策略"><a href="#修改路径匹配策略" class="headerlink" title="修改路径匹配策略"></a>修改路径匹配策略</h1><p>先介绍一下相关的配置信息，<code>SpringBoot</code> 用的版本是 2.7.10，<code>maven</code> 是 3.6.1，用的是阿里云的镜像。</p>
<p><code>swagger2</code> 的安装配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;!--swagger2--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.springfox&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.9.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后新建一个 <code>SwaggerConfig.java</code> 类，用于配置一些与 <code>Swagger2</code> 相关的内容，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public Docket examApi() &#123;</span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .apiInfo(apiInfo())</span><br><span class="line">                .groupName(&quot;xxx&quot;)</span><br><span class="line">                .select()</span><br><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.sidiot.xxx.controller&quot;))</span><br><span class="line">                .paths(PathSelectors.any())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ApiInfo apiInfo() &#123;</span><br><span class="line">        return new ApiInfoBuilder().title(&quot;xxx&quot;)</span><br><span class="line">                .description(&quot;xxx&quot;)</span><br><span class="line">                .contact(new Contact(&quot;sid10t.&quot;, &quot;https://www.sid10t.com&quot;, &quot;e-mail&quot;))</span><br><span class="line">                .version(&quot;1.0.0&quot;)</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将程序启动，发现报错了：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/123a826a9092dc63887b1de5fabbc7e768568e37e435ec308753fe977a6ecb61" alt="image.png"></p>
<p>错误原因是 <code>org.springframework.context.ApplicationContextException: Failed to start bean &#39;documentationPluginsBootstrapper&#39;; nested exception is java.lang.NullPointerException</code>；</p>
<p>这个异常表示在启动 Spring 应用程序上下文时，<code>documentationPluginsBootstrapper</code> 这个 Bean 启动失败，并且嵌套异常是 <code>NullPointerException</code>。通常这种错误发生在调用一个空对象的方法或者访问一个空对象的属性时。</p>
<p>这是因为 SpringBoot 在 2.6.1 之后，SpringMVC 处理程序映射匹配请求路径的默认策略已从 <code>AntPathMatcher</code> 更改为 <code>PathPatternParser</code>。而 Springfox 使用的路径匹配还是 <code>AntPathMatcher</code>，因此导致了这个错误的发生。</p>
<p>那么这里只需要在配置文件 <code>application.properties</code> 中，重新修改策略即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">properties复制代码spring.mvc.pathmatch.matching-strategy=ant-path-matcher</span><br></pre></td></tr></table></figure>

<p>用 <code>.yml</code> 的小伙伴这样改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yml复制代码spring:</span><br><span class="line">  mvc:</span><br><span class="line">    pathmatch:</span><br><span class="line">      matching-strategy: ant_path_matcher</span><br></pre></td></tr></table></figure>

<p>修改完成之后就能正常访问到页面了！</p>
<p>关于 SpringBoot 在 2.6.1 之后的一些变化，可以参考这篇博文：<a href="https://xie.infoq.cn/article/514f30865d7dfffc0c23eb78b" target="_blank" rel="noopener">Springboot 升级到 2.6.1 的坑</a>；</p>
<p><strong>用这个方法解决兼容性问题的小伙伴，是不会碰到 <code>swagger2</code> 默认地址失效的问题的，用下面一种方法解决兼容性问题就会遇到！</strong></p>
<h1 id="使用-EnableWebMvc-注解"><a href="#使用-EnableWebMvc-注解" class="headerlink" title="使用 @EnableWebMvc 注解"></a>使用 @EnableWebMvc 注解</h1><p>是的，除了上述提到的修改匹配策略之外，还有一种方式也能解决兼容性问题，那就是使用注解 <code>@EnableWebMvc</code>；</p>
<p>我们只需要在启动类上加上 <code>@EnableWebMvc</code> 这个注解就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@EnableWebMvc</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class xxxApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(xxxApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加上注解之后，启动我们的程序看一看，发现没有报错，是正常运行的，在打开 <code>swagger</code> 的页面瞅瞅，</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4512665197b7075b583eb25d8c4696ce4dd0e178c6ce6068eaaba3cb0fa99080" alt="image.png"></p>
<p>发现找不到页面，在看看控制台也是如此：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码2023-04-13 17:34:54.885  WARN 17948 --- [nio-8080-exec-1] o.s.web.servlet.PageNotFound             : No mapping for GET /swagger-ui.html</span><br></pre></td></tr></table></figure>

<p>试了试其他相关的 url 路径也是找不到，这是为什么呢？</p>
<p>先简单介绍一下 <code>@EnableWebMvc</code> 这个注解：</p>
<p><code>@EnableWebMvc</code> 是 SpringMVC 框架中的一个注解，它的作用是开启对 SpringMVC 的支持。</p>
<p>具体来说，使用 <code>@EnableWebMvc</code> 注解会导入一系列与 SpringMVC 相关的配置类，并且会自动注册多个关键组件，如 HandlerMapping、HandlerAdapter、ViewResolver 等。这些组件可以让开发者方便地处理 HTTP 请求和响应、实现 MVC 模式以及生成视图。</p>
<p>但需要注意的是，如果使用了 <code>@EnableWebMvc</code> 注解，则默认情况下会禁用 SpringBoot 中的自动配置，因为 <code>@EnableWebMvc</code> 已经提供了类似的功能。如果想要同时使用 SpringBoot 的自动配置和<code>@EnableWebMvc</code>，可以通过在配置类上添加 <code>@Import({WebMvcAutoConfiguration.class})</code> 注解来实现。</p>
<p>而 <code>Swagger</code> 通常是使用 springfox-swagger2 和 springfox-swagger-ui 这两个库来实现的。在使用 <code>@EnableWebMvc</code> 注解时，会覆盖掉 SpringBoot 自动配置中的 WebMvcAutoConfiguration，可能导致 <code>Swagger</code> 的默认地址 <code>/swagger-ui.html</code> 失效。因为在 WebMvcAutoConfiguration 类中有一个关于 <code>Swagger</code> 的默认配置项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@ConditionalOnClass(&#123; UiConfiguration.class &#125;)</span><br><span class="line">@EnableConfigurationProperties(SwaggerUiProperties.class)</span><br><span class="line">public class SwaggerUiWebMvcConfiguration &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个类在提供了许多 <code>Swagger</code> 相关的默认配置，包括默认的 UI 界面路径 <code>/swagger-ui.html</code>。但是，当添加 <code>@EnableWebMvc</code> 注解后，SpringMVC 将覆盖掉这个类的配置，进而导致 <code>Swagger</code> 的默认 UI 界面无法使用。</p>
<p>解决这个问题的方法是手动配置 <code>Swagger</code> 相关的 Bean，并指定 Swagger UI 的访问路径和资源文件位置。比如可以在配置类中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@EnableSwagger2</span><br><span class="line">public class SwaggerConfig &#123;</span><br><span class="line">    @Bean</span><br><span class="line">    public Docket api() &#123; </span><br><span class="line">        return new Docket(DocumentationType.SWAGGER_2).select()</span><br><span class="line">          .apis(RequestHandlerSelectors.any())</span><br><span class="line">          .paths(PathSelectors.any())</span><br><span class="line">          .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public WebMvcConfigurerAdapter webMvcConfigurerAdapter() &#123;</span><br><span class="line">        return new WebMvcConfigurerAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void addResourceHandlers(ResourceHandlerRegistry registry) &#123;</span><br><span class="line">                registry.addResourceHandler(&quot;/swagger-ui.html**&quot;)</span><br><span class="line">                        .addResourceLocations(&quot;classpath:/META-INF/resources/swagger-ui.html&quot;);</span><br><span class="line">                registry.addResourceHandler(&quot;/webjars/**&quot;)</span><br><span class="line">                        .addResourceLocations(&quot;classpath:/META-INF/resources/webjars/&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以手动配置 Swagger 相关的 Bean，并指定 Swagger UI 的访问路径和资源文件位置，从而解决 <code>@EnableWebMvc</code> 导致 <code>Swagger</code> 默认地址失效的问题。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>解决 swagger2 默认地址失效</em></strong> 的全部内容了，希望对大家有所帮助！</p>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7176830504996454455">【问题解决】解决如何在 CPU 上加载多 GPU 训练的模型</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注；</p>
<p>👍 创作不易，请多多支持；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a> <a href="https://juejin.cn/column/7143109530753171486" target="_blank" rel="noopener">JAVA</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7221525689856688184" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>掘金·金石计划,后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决如何在CPU上加载多GPU训练的模型</title>
    <url>/7176830504996454455.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong><em>本文正在参加<a href="https://dev.newban.cn/7162096952883019783">「金石计划 . 瓜分6万现金大奖」</a></em></strong></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>有一期的恶意文件检测模型训练好了，因此需要进行测试，关于恶意文件检测的内容，可以回看博主之前写的博文：</p>
<ul>
<li><a href="https://dev.newban.cn/7165831526137987108">【AI】浅析恶意文件静态检测及部分问题解决思路</a></li>
<li><a href="https://dev.newban.cn/7176224054884433957">【AI】恶意文件静态检测模型检验及小结</a></li>
</ul>
<p>因为样本在某台机子上，又恰逢有其他模型在训练，因此 GPU 资源被占满了，不过测试这个模型的话，CPU 也绰绰有余了，当我准备使用 CPU 训练时，却遇到了问题；</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><strong><em>1、<code>model.to(device)</code> 不会影响 <code>torch.load()</code>；</em></strong></p>
<p>我一开始以为只要使用 <code>model.to</code> 就算是使用上 CPU 了；</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py复制代码device = torch.device(&quot;cpu&quot;)</span><br><span class="line">model = ...</span><br><span class="line">model = model.to(device)</span><br><span class="line"></span><br><span class="line">model_savedir_ = &apos;&apos;</span><br><span class="line">if os.path.exists(model_savedir_):</span><br><span class="line">    print(&quot;model load.&quot;)</span><br><span class="line">    state_dict = torch.load(model_savedir_)</span><br><span class="line">    model.load_state_dict(state_dict)</span><br></pre></td></tr></table></figure>

<p>事实证明，我想的太简单了…</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a49df6ca30f6ad11f5e3db1758a52da5860bc103dfc0fbfa84a40ca3be4aca93" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码RuntimeError: CUDA error: out of memory</span><br><span class="line">CUDA kernel errors might be asynchronously reported at some other API call,so the stacktrace below might be incorrect.</span><br><span class="line">For debugging consider passing CUDA_LAUNCH_BLOCKING=1.</span><br></pre></td></tr></table></figure>

<p>这个问题很显而易见，就是 GPU 的内存溢出了，但是按我的思路，用的应该是 CPU 啊，所以我怀疑是 <code>torch.load()</code> 这个函数出了问题，查询了一番资料后，发现是要这样使用的 <code>state_dict = torch.load(model_savedir_, map_location=device)</code>；</p>
<hr>
<p><strong><em>2、GPU 与 CPU 训练时参数名不一致</em></strong></p>
<p>当我以为大功告成，点击运行之时，不料，又报错了：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d4dbefed7c59f9fc9bbc5733d229b612a2dd8cec581f0b4b67e6246ba2796b30" alt="image.png"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码RuntimeError: Error(s) in loading state_dict for ..model..:</span><br><span class="line">	Missing key(s) in state_dict: &quot;fc.weight&quot;, &quot;fc.bias&quot;, &quot;features.0.0.weight&quot;, &quot;features.0.1.weight&quot;, &quot;features.0.1.bias&quot;, &quot;features.0.1.running_mean&quot;, &quot;features.0.1.running_var&quot;, &quot;features.1.conv.0.weight&quot;, &quot;features.1.conv.1.weight&quot;, &quot;features.1.conv.1.bias&quot;, &quot;features.1.conv.1.running_mean&quot;, &quot;features.1.conv.1.running_var&quot;, &quot;features.1.conv.3.weight&quot;, &quot;features.1.conv.4.weight&quot;, &quot;features.1.conv.4.bias&quot;, &quot;features.1.conv.4.running_mean&quot;, &quot;features.1.conv.4.running_var&quot;, &quot;features.1.conv.5.fc.0.weight&quot;, ...</span><br></pre></td></tr></table></figure>

<p>根据理解，就是说找不到参数，因此，我将字典部分内容打印了一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py复制代码for k, v in state_dict.items():</span><br><span class="line">    print(k, v)</span><br><span class="line">    break</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b1bb57abc8c5e210319f18281f76dfc3de45076d22c22d7a2f9e7f884ee911e0" alt="image.png"></p>
<p>发现问题了，在多 GPU 上训练的模型，保存时会在参数名前多加了一个 <code>module.</code> 前缀，因此在用 CPU 进行加载时，需要把这个前缀去掉：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">py复制代码if os.path.exists(model_savedir_):</span><br><span class="line">    print(&quot;model load.&quot;)</span><br><span class="line">    state_dict = torch.load(model_savedir_, map_location=device)</span><br><span class="line">    from collections import OrderedDict</span><br><span class="line">    state_dict_new = OrderedDict()</span><br><span class="line">    for k, v in state_dict.items():</span><br><span class="line">        name = k[7:]  # 去掉 `module.`</span><br><span class="line">        state_dict_new[name] = v</span><br><span class="line">    model.load_state_dict(state_dict_new)</span><br></pre></td></tr></table></figure>

<p>这样就能够在 CPU 上加载多 GPU 训练的模型了！</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>【问题解决】解决如何在 CPU 上加载多 GPU 训练的模型</em></strong> 的全部内容了，希望对大家有所帮助！</p>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7173960546998288391">【问题解决】解决 Docker 二次重启 MySQL 8 遇到的一些问题</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注；</p>
<p>👍 创作不易，请多多支持；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a> <a href="https://juejin.cn/column/7160294356350402590" target="_blank" rel="noopener">AI</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7176830504996454455" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>掘金·金石计划,人工智能,PyTorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux进程fork()系统调用详解</title>
    <url>/7250283546367557692.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>前言：</strong>  本文介绍了进程控制相关的命令与函数，并深入讨论了fork函数的实现机制以及fork函数的一次调用两次返回，最后通过实例演示了如何使用fork函数控制进程的创建。</p>
<hr>
<blockquote>
<h3 id="🏆文章目录"><a href="#🏆文章目录" class="headerlink" title="🏆文章目录"></a>🏆文章目录</h3><ul>
<li><ul>
<li><a href="http://www.cnblogs.com/#1_forkgetpidgetppid_10" target="_blank" rel="noopener">🥇1. fork()、getpid()、getppid()函数介绍</a><ul>
<li><ul>
<li><a href="http://www.cnblogs.com/#11_fork_12" target="_blank" rel="noopener">🥈1.1 fork()函数介绍</a><ul>
<li><a href="http://www.cnblogs.com/#12_getpidgetppid_44" target="_blank" rel="noopener">🥈1.2 getpid()函数与getppid()函数介绍</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/#2_fork_74" target="_blank" rel="noopener">🥇2. fork()工作机制</a></li>
<li><ul>
<li><a href="http://www.cnblogs.com/#21_fork_76" target="_blank" rel="noopener">🥈2.1 fork()的实现机制——一次调用两次返回与进程复制</a><ul>
<li><a href="http://www.cnblogs.com/#22_shell_147" target="_blank" rel="noopener">🥈2.2 shell进程控制命令</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="http://www.cnblogs.com/#3__200" target="_blank" rel="noopener">🥇3. 进程创建的控制</a></li>
<li><ul>
<li><a href="http://www.cnblogs.com/#31__202" target="_blank" rel="noopener">🥈3.1 控制进程创建个数</a><ul>
<li><a href="http://www.cnblogs.com/#32__265" target="_blank" rel="noopener">🥈3.2 进程顺序控制</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bac32d431949da0d952521763f96cd08d685c4dda30861e1e844bcbbda4c97d0" alt="在这里插入图片描述"></p>
<hr>
<h2 id="🥇1-fork-、getpid-、getppid-函数介绍"><a href="#🥇1-fork-、getpid-、getppid-函数介绍" class="headerlink" title="🥇1. fork()、getpid()、getppid()函数介绍"></a>🥇1. fork()、getpid()、getppid()函数介绍</h2><h3 id="🥈1-1-fork-函数介绍"><a href="#🥈1-1-fork-函数介绍" class="headerlink" title="🥈1.1 fork()函数介绍"></a>🥈1.1 fork()函数介绍</h3><p>fork()用于创建一个子进程，我们在shell下执行一个命令其实也是通过fork()实现的，fork()是Linux下最基本的一个系统调用。fork()最大的特点就是一次调用，两次返回，两次返回主要是区分父子进程，因为fork()之后将出现两个进程，所以有两个返回值，父进程返回子进程ID，子进程返回0。</p>
<ul>
<li>包含头文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码pid_t fork(void);</span><br></pre></td></tr></table></figure>

<ul>
<li>函数功能</li>
</ul>
<p>fork() creates a new process by duplicating the calling process. The new process, referred to as the child, the calling process, referred to as the parent. 通过复制的方式创建一个进程，被创建的进程称为子进程，调用进程称为父进程，复制的子进程是从父进程fork()调用后面的语句开始执行的。</p>
<ul>
<li>函数参数</li>
</ul>
<pre><code>+ void</code></pre><ul>
<li>函数返回值</li>
</ul>
<pre><code>+ On success, the PID of the child process is returned in the parent, and 0 is returned in the child.


    - 父进程返回子进程ID
    - 子进程返回0
+ On failure, -1 is returned in the parent, no child process is created, and errno is set appropriately. 失败返回-1并设置errno。</code></pre><h3 id="🥈1-2-getpid-函数与getppid-函数介绍"><a href="#🥈1-2-getpid-函数与getppid-函数介绍" class="headerlink" title="🥈1.2 getpid()函数与getppid()函数介绍"></a>🥈1.2 getpid()函数与getppid()函数介绍</h3><ul>
<li>包含头文件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数原型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码pid_t getpid(void);</span><br><span class="line">pid_t getppid(void);</span><br></pre></td></tr></table></figure>

<ul>
<li>函数功能</li>
</ul>
<pre><code>+ getpid() returns the process ID of the calling process. 获得当前进程的ID。
+ getppid() returns the process ID of the parent of the calling process. 获得当前进程的父进程的ID。</code></pre><ul>
<li>函数参数</li>
</ul>
<p>void</p>
<ul>
<li>函数返回值</li>
</ul>
<pre><code>+ getpid()返回当前进程ID
+ getppid()返回当前进程的父进程ID</code></pre><h2 id="🥇2-fork-工作机制"><a href="#🥇2-fork-工作机制" class="headerlink" title="🥇2. fork()工作机制"></a>🥇2. fork()工作机制</h2><h3 id="🥈2-1-fork-的实现机制——一次调用两次返回与进程复制"><a href="#🥈2-1-fork-的实现机制——一次调用两次返回与进程复制" class="headerlink" title="🥈2.1 fork()的实现机制——一次调用两次返回与进程复制"></a>🥈2.1 fork()的实现机制——一次调用两次返回与进程复制</h3><p>下面通过一个案例来分析fork()是如何创建进程，又是如何返回的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码/************************************************************</span><br><span class="line">  &gt;File Name  : fork_test.c</span><br><span class="line">  &gt;Author     : Mindtechnist</span><br><span class="line">  &gt;Company    : Mindtechnist</span><br><span class="line">  &gt;Create Time: 2022年05月18日 星期三 15时59分29秒</span><br><span class="line">************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	printf(&quot;=== process begin ===\n&quot;);</span><br><span class="line">	pid_t pid = fork();</span><br><span class="line">	if(pid == -1)</span><br><span class="line">	&#123;</span><br><span class="line">		perror(&quot;fork err&quot;);</span><br><span class="line">		return -1;	</span><br><span class="line">	&#125;</span><br><span class="line">	if(pid == 0) /*子进程*/</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i am child: %d, may parent: %d\n&quot;, getpid(), getppid());	</span><br><span class="line">        /*	test2</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;fork process\n&quot;);</span><br><span class="line">            sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">	&#125;</span><br><span class="line">	if(pid &gt; 0)</span><br><span class="line">	&#123;</span><br><span class="line">		printf(&quot;i am call: %d, child: %d, parent: %d\n&quot;, getpid(), pid, getppid());	</span><br><span class="line">        /*	test1</span><br><span class="line">        sleep(1);</span><br><span class="line">        */</span><br><span class="line">        /*	test2</span><br><span class="line">        while(1)</span><br><span class="line">        &#123;</span><br><span class="line">        	sleep(1);</span><br><span class="line">        &#125;</span><br><span class="line">        */</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;=== process end ===\n&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行该程序，我们会发现一个很有意思的现象  </p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fafd376bc74eb2c8ec739f00f878ce077fe5b5ccc50fec7f534874c24edeabdf" alt="在这里插入图片描述"></p>
<p>首先反常的第一点，我们在程序中的打印顺序是先进入子进程(pid == 0)分支，再进入父进程(pid &gt; 0)分支，但实际的打印顺序是先执行了父进程分支的printf()函数，后执行的子进程分支到的printf()函数；第二点是，在执行子进程的printf()函数时，竟然已经回到了shell下，可以看图中高亮标出的位置。下面对着两点详细分析；第三点，子进程打印的父进程ID和父进程自己打印的ID不同。</p>
<p>我们已经知道，fork()系统调用的特点是一次调用两次返回，并且子进程的创建是对父进程的复制，那么是从哪复制开始复制的呢，我们根据程序运行结果分析，程序只打印了一次begin语句，说明不是从头开始复制的，实际上它是从fork()的下一句开始复制的，从fork()开始，后面就成了两个分支。  </p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdb191b64b5c41c162683c5e85f7cac326af6ff4fcfab3cb03711714337712f8" alt="在这里插入图片描述">  </p>
<p>我们看到的运行结果中红色标记的①，实际上是由父进程打印的，②是由子进程打印的，既然不是一个进程打印的，那也就没有先后顺序的问题了。而子进程打印的父进程ID是1，父进程打印的自己的ID是5270，这是因为在子进程结束前，父进程就已经结束了，新建的子进程变成了孤儿进程，所以它会被1号进程收养，所以新建子进程的父进程ID是1，这也是为什么第二个printf()语句是在shell下执行的原因，因为原来的父进程结束了，所以回到了shell进程下，此时子进程还没有结束，它被1号进程接管，继续执行后面的语句，直到结束。</p>
<p>（实际上，这里的3397进程就是我们的shell进程，shell进程是我们自己启动的进程的父进程；而1号进程则是init进程，init进程是Linux下最原始的进程，是所有进程最终的父进程。）</p>
<p>我们可以在父进程中加一个sleep()函数（放开上面代码中test1注释掉的代码即可），让父进程等一下子进程，并看一下效果，这次就好了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e1974e32e5e32093cbe56c5cee535e7e18133e9eaf726f3ce08c632112591074" alt="在这里插入图片描述"></p>
<h3 id="🥈2-2-shell进程控制命令"><a href="#🥈2-2-shell进程控制命令" class="headerlink" title="🥈2.2 shell进程控制命令"></a>🥈2.2 shell进程控制命令</h3><p>下面我们通过shell下的进程控制命令进一步分析上面所讲的fork()实现机制，首先介绍几个命令：</p>
<ul>
<li>ps 查看进程信息，主要用到下面两个参数</li>
</ul>
<pre><code>+ ps aux


![在这里插入图片描述](https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4a0ccdcd9f14231b758652246dec2928e1cf99c20c3ca733ba0bd9909e7c14c7)
+ ps ajx：可以查看父进程ID，追溯进程之间的关系  

![在这里插入图片描述](https://gitee.com/songjianzaina/juejin_p1/raw/master/img/381dc2bb7ef3969a8bf919917a4cfb9a960aeca6b2601e25bf0027c030ef5f63)</code></pre><ul>
<li>kill 给进程发送信号，通过这个命令可以杀死进程，常用的两个参数</li>
</ul>
<pre><code>+ kill -l：查看所有信号；![在这里插入图片描述](https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eba311e7cb46140e255a7918de72da4f03d83a0c846896ffa68cd0c89157bf8f)


+ kill -9 pid：给进程号为pid的进程发送9号信号，杀死进程，实际上相当于 kill -SIGKILL pid，也可以直接通过 kill pid 来杀死pid进程；</code></pre><p>我们再做一个测试，将上面代码中的test2处的注释放开，编译并运行程序，让两个进程一直在while中执行</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ef400deb517f0567299702d88dc27c2a2f38d42a57dc1177e3df4f77094ef5cb" alt="在这里插入图片描述"></p>
<p>开始循环后，我们另起一个shell来查看进程信息，可以通过管道和grep过滤我们需要的进程信息</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dd63f2ea606412c02510b9cd4a5f17b23dae237b81596e58d0464e0912dd4d6b" alt="在这里插入图片描述"></p>
<p>通过ajx追溯进程血缘关系</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e8365205ce3d3a95496c1d3e365fd1d0e31018eb97b2fc81e0607045d665f529" alt="在这里插入图片描述"></p>
<p>可以看到fork()的调用进程5721，它的父进程是3397也就是 bash shell 进程</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d4565da90a72f764700766d53fcd61a996666697b21cfcfebf2528b70bff788b" alt="在这里插入图片描述"></p>
<p>通过kill杀死父进程，可以看到子进程被1号进程接管</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/394cbf0da62afcc2c1924b41ae653584597895a135acdb68951e8f08e78f75e4" alt="在这里插入图片描述"></p>
<p>1号进程就是init进程</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d1eb7c7f2f34ed484084e35796da3b824f3a20bdf00d86aa26ac6362cd8ab859" alt="在这里插入图片描述"></p>
<h2 id="🥇3-进程创建的控制"><a href="#🥇3-进程创建的控制" class="headerlink" title="🥇3. 进程创建的控制"></a>🥇3. 进程创建的控制</h2><h3 id="🥈3-1-控制进程创建个数"><a href="#🥈3-1-控制进程创建个数" class="headerlink" title="🥈3.1 控制进程创建个数"></a>🥈3.1 控制进程创建个数</h3><p>我们通过一个for循环来创建进程</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">markdown复制代码/************************************************************</span><br><span class="line">  &gt;File Name  : mutifork.c</span><br><span class="line">  &gt;Author     : Mindtechnist</span><br><span class="line">  &gt;Company    : Mindtechnist</span><br><span class="line">  &gt;Create Time: 2022年05月18日 星期三 19时33分50秒</span><br><span class="line">************************************************************/</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char* argv[])</span><br><span class="line">&#123;</span><br><span class="line">	int i = 0;</span><br><span class="line">	pid_t pid = 0;</span><br><span class="line">	for(i = 0; i &lt; 5; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		pid = fork();</span><br><span class="line">		if(pid == 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;i am chiled: %d, ppid: %d\n&quot;, getpid(), getppid());</span><br><span class="line">			/*</span><br><span class="line">			break;</span><br><span class="line">			*/</span><br><span class="line">		&#125;	</span><br><span class="line">		if(pid &gt; 0)</span><br><span class="line">		&#123;</span><br><span class="line">			printf(&quot;i am call: %d, child:%d, ppid: %d\n&quot;, getpid(), pid, getppid());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	while(1)</span><br><span class="line">	&#123;</span><br><span class="line">		sleep(1);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，在程序我们期望的是创建5个进程，但是实际运行后出现了一大堆进程，我们可以用wc命令统计一下  </p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1d4055de8e0d5caafb7d0d3932870a825d836b1a82f302fc64500650b01f8828" alt="在这里插入图片描述"></p>
<p>shell命令统计创建的进程个数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">perl复制代码ps aux | grep mutifork | grep -v grep | wc -l</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdb5a95315e28967ece27638438ecbbb7f233728299929413d01f37b2f78cdd6" alt="在这里插入图片描述"></p>
<p>总共有32个进程，我们在程序中只循环了5次，为什么有32个进程呢，下面看一张图</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ce5c96632ec4bc09058c4f2c5254016a1bea60672ed50f508a97a3153f9b16dd" alt="在这里插入图片描述"></p>
<p>每次fork的时候，进程都会一分为二，所以5次循环相当于创建了2的5次方，也就是32个进程。要想避免这种情况，只需要根据返回值判断当前为子进程的时候就退出循环即可，也就是把上面代码中注释掉的break放开即可。</p>
<h3 id="🥈3-2-进程顺序控制"><a href="#🥈3-2-进程顺序控制" class="headerlink" title="🥈3.2 进程顺序控制"></a>🥈3.2 进程顺序控制</h3><p>使用fork()创建的进程都是一样的，在操作系统看来没有区别，先后顺序也是不确定的，我们要想控制进程的退出顺序，需要自己去实现这个逻辑。比如说我们可以依据for循环中i的值来判断哪个进程先创建的，哪个进程后创建的，按照逻辑i小的应该是先创建的，因为C语言就是顺序执行的。因为子进程创建出来就break退出for循环了，所以五个子进程对应的i是0-4，而只有最开始的父进程可以执行到i=5。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码sleep(i); /*不同进程睡眠时间不同，第一个创建的进程</span><br><span class="line">			i的值为0，睡眠最短，最先退出，后面的进</span><br><span class="line">			程对应的i逐渐增大，睡眠时间增加，退出越晚*/</span><br><span class="line">if(i &lt; 5)</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;child: %d, parent: %d\n&quot;, getpid(), getppid());</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;parent: %d\n&quot;, getpid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7250283546367557692?searchId=202404171908050B578BFE9B0EAC21E7B5" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>在kubernetes环境下如何采集日志节点采集Si</title>
    <url>/7347000319983419411.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为稀土掘金技术社区首发签约文章，30天内禁止转载，30天后未获授权禁止转载，侵权必究！</p>
<p>当我们没有使用云原生方案部署应用时采用的日志方案往往是 ELK 技术栈。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/170bd36c33d917fb4370dce4e5092a45c2e7aeacfa50573fe2d0cb0a2bdff112" alt></p>
<p>这套技术方案比较成熟，稳定性也很高，所以几乎成为了当时的标配。</p>
<p>可是随着我们使用 kubernetes 步入云原生的时代后， kubernetes 把以往的操作系统上的许多底层都屏蔽，再由他提供了一些标准接口。</p>
<p>同时在 kubernetes 中的日志来源也比传统虚拟机多，比如可能有容器、kubernetes 自身的事件、日志等。</p>
<p>我们的日志采集方案也得与时俱进，kubernetes 的官方博客有介绍提供一下几种方案：</p>
<h1 id="节点采集"><a href="#节点采集" class="headerlink" title="节点采集"></a>节点采集</h1><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c3fe1c50d49d2f01167a4155107c9b1b27ec81af64dfed100d7d1cdfda1ed2eb" alt></p>
<p>第一种方案是在节点中采集日志，我们知道 kubernetes 是分为 master 调度节点以及 worker 工作节点；我们的应用都是运行在 worker 节点中的。</p>
<blockquote>
<p>在 kubernetes 环境中更推荐使用标准的 stdout/stderr 作为日志输出，这样 kubernetes 更方便做统一处理。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5b2db5eb99963a5b04c2027a27a9562d19202fc0a304e6d9e188875f650d91c1" alt></p>
<p>以我们的 docker 运行时为例，默认情况下我们的标准输入文件会写入到 <code>/var/log</code> 目录中。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0d7896af3481e728995a8704ed2d25a718d66a953c624547347bd955156143b5" alt></p>
<p>如上图所示：我们可以在 kubernetes 的每一个 worker 节点中部署一个 <code>DaemonSet</code> 类型的采集器（filebeat 等），再由他去采集该节点下 <code>/var/log</code> 的日志，最终由他将日志采集后发往日志处理的后端，比如 elasticsearch 等组件中。</p>
<p>这种方案的好处是资源占用较低，往往是有多少个 worker 节点就可以部署多少个采集器。</p>
<p>而且和业务的耦合度低，业务和采集器不管谁进行重启或升级互相都不会产生影响。</p>
<p>但缺点也比较明显，整个节点的日志采集瓶颈都在这个采集器这里了，如果某些 worker 节点的 Pod 数量不均衡，或者是本身日志产生也不平均时就会出现明显的负债不平衡。</p>
<p>而且也无法针对某些日志高峰场景进行调优（毕竟所有的 Pod 都是使用的一个日志采集器）。</p>
<p>所以节点级的日志采集更适用与该 worker 节点负债较低的时候使用，也更容易维护。</p>
<h1 id="Sidecar-代理模式"><a href="#Sidecar-代理模式" class="headerlink" title="Sidecar 代理模式"></a>Sidecar 代理模式</h1><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/20a005a35d418c6fca6357f638ffe03fe16ee36c8c75e5bee2df77634ab51978" alt><br>第二种相对于第一种可以理解为由集中式的日志采集分散到各个应用 Pod 中自行采集。</p>
<p>需要为每一个业务 Pod 挂载一个边车（sidecar）进行日志采集，由于边车和业务 Pod 共享的是一个存储，所以可以很方便的读取到日志。</p>
<p>由于它是和应用挂载在一起的，所以资源占用自然会比节点采集更多，同理耦合度也增加了，采集组件的升级可能还会影响的业务 Pod。</p>
<p>但同样的带来好处就是可以针对单个 Pod 更精细的控制采集方案。</p>
<p>比如对于一些日志写入频繁的应用，可以将 filebeat 的配置提高，甚至还可以将这种高负载的日志单独写入一个 elasticsearch 中，这样可以与普通负载的日志进行资源隔离。</p>
<p>这个方案更适用与集群规模较大的场景，需要做一些精细化配置。</p>
<hr>
<p>我们其实也是采用的也是这个方案，不过具体细节稍有不同。</p>
<p>我们没有直接使用标准输入和输出，原因如下：</p>
<p>日志格式没法统一，导致最终查询的时候无法做一些标准化的限制（比如我们要求每个日志都需要带业务 id、traceId 等，查询时候有这些业务指标就很容易沉淀一些标准的查询语句。）</p>
<p>最终我们还是采用了 Java 的老朋友，logback 配置了自己的日志格式，所有的应用都会根据这个模版进行日志输出。</p>
<p>同时利用日志框架的批量写入、缓冲等特性还更容易进行日志的性能调优。（只使用标准输出时对应用来说是黑盒。）</p>
<p>最终我们的技术方案是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a6e843a03caa2ea6813b09e0e63a83d1cc6ccf26f4f12c58c116e37be3d832c9" alt></p>
<h1 id="直接写入"><a href="#直接写入" class="headerlink" title="直接写入"></a>直接写入</h1><p>还有一种方案是直接写入，这个其实和 kubernetes 本身就没有太多关系了。</p>
<p>由业务自己调用 elasticsearch 或者其他的存储组件的 API 进行写入，这种通常适用于对性能要求较高的场景，略过了中间的采集步骤，直接写入存储端。</p>
<p>这个我在 <a href="https://crossoverjie.top/2023/08/23/ob/VictoriaLogs-Intro/" target="_blank" rel="noopener">VictoriaLogs：一款超低占用的 ElasticSearch 替代方案</a>中介绍过，我需要在 broker 的拦截器中埋点消息信息，从而可以生成一个消息🆔的链路信息。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/17ebd2c95765a002b09f1802053874402b7d19e9f4d22e06440fb0120ca0a92d" alt></p>
<p>因为需要拦截消息的发送、消费的各个阶段，加上并发压力较高，所以对日志的写入性能要求还是蛮高的。</p>
<p>因此就需要在拦截器中直接对写入到日志存储。</p>
<blockquote>
<p>这里考虑到我这里的但一场景，以及对资源的消耗，最终选取了 <code>victoriaLog</code> 这个日志存储。</p>
</blockquote>
<p>而在发送日志的时候也得用了高性能的日志发生框架，这里选取了<a href="https://github.com/aliyun/aliyun-log-java-producer" target="_blank" rel="noopener">aliyun-log-java-producer</a>然后做了一些定制。</p>
<p>这个库支持以下一些功能：</p>
<ul>
<li>高性能：批量发送、多线程等</li>
<li>自动重试</li>
<li>异步非阻塞</li>
<li>资源控制（可以对内存、数量进行控制）</li>
</ul>
<p>因为这是为阿里云日志服务的一个组件，代码里硬编码了只能写入阿里的日志服务。</p>
<p>所以拿来稍加改造后，现在可以支持自定义发送到任意后端，只需要在初始化时自定义实现发送回调接口即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码ProducerConfig producerConfig = new ProducerConfig();</span><br><span class="line">producerConfig.setSenderArgs(new Object[]&#123;vlogUrl, client&#125;);</span><br><span class="line">producerConfig.setSender((batch, args) -&gt; &#123;</span><br><span class="line">    StringBuilder body = new StringBuilder();</span><br><span class="line">    for (String s : batch.getLogItemsString()) &#123;</span><br><span class="line">        body.append(&quot;&#123;\&quot;create\&quot;:&#123;&#125;&#125;&quot;);</span><br><span class="line">        body.append(&quot;\n&quot;);</span><br><span class="line">        body.append(s);</span><br><span class="line">        body.append(&quot;\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    RequestBody requestBody =</span><br><span class="line">            RequestBody.create(MediaType.parse(&quot;application/json&quot;), body.toString());</span><br><span class="line">    Request request =</span><br><span class="line">            new Request.Builder()</span><br><span class="line">                    .url(String.format(&quot;%s/insert/elasticsearch/_bulk&quot;, args[0]))</span><br><span class="line">                    .post(requestBody)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">    OkHttpClient okHttpClient = (OkHttpClient) args[1];</span><br><span class="line">    try (Response response = okHttpClient.newCall(request).execute()) &#123;</span><br><span class="line">        if (response.isSuccessful()) &#123;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            log.error(&quot;Request failed with error code: &quot; + response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; catch (IOException e) &#123;</span><br><span class="line">        log.error(&quot;Send vlogs failed&quot;, e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">logProducer = new LogProducer(producerConfig);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>考虑到这个库只是对阿里云日志服务的一个组件，加上代码已经很久没维护了，所以就没有将这部分代码提交到社区，感兴趣的评论区留言。</p>
</blockquote>
<h1 id="日志安全"><a href="#日志安全" class="headerlink" title="日志安全"></a>日志安全</h1><p>日志是一个非常基础但又很敏感的功能，首先是编码规范上要避免打印一些敏感信息；比如身份证、密码等；同时对日志的访问也要最好权限控制。</p>
<p>在我们内部的研效平台中，对于日志、监控等功能都是和应用权限挂钩的。</p>
<p>简单来说就是关闭了统一查询 ES 的入口，只在应用层级提供查询，类似于：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/32003c66f9651627979b962e8e40659d8d9fda1d59e4cfd3aa69f659e6f6afaf" alt></p>
<blockquote>
<p>图来自于 orbit 产品。</p>
</blockquote>
<h1 id="OpenTelemetry"><a href="#OpenTelemetry" class="headerlink" title="OpenTelemetry"></a>OpenTelemetry</h1><p>当然讲到日志目前自然也逃不过 OpenTelemetry，作为当前云原生可观测性的标准也提供了对应的日志组件。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e3096a5dc352ae8f637e347f8ad07e1c429c3c58626f283213ba9ee54bdc7b0b" alt><br>OpenTelemetry 也定义了结构化的日志格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;&quot;resourceLogs&quot;:[&#123;&quot;resource&quot;:&#123;&quot;attributes&quot;:[&#123;&quot;key&quot;:&quot;resource-attr&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;resource-attr-val-1&quot;&#125;&#125;]&#125;,&quot;scopeLogs&quot;:[&#123;&quot;scope&quot;:&#123;&#125;,&quot;logRecords&quot;:[&#123;&quot;timeUnixNano&quot;:&quot;1581452773000000789&quot;,&quot;severityNumber&quot;:9,&quot;severityText&quot;:&quot;Info&quot;&quot;body&quot;:&#123;&quot;stringValue&quot;:&quot;This is a log message&quot;&#125;,&quot;attributes&quot;:[&#123;&quot;key&quot;:&quot;app&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;server&quot;&#125;&#125;,&#123;&quot;key&quot;:&quot;instance_num&quot;,&quot;value&quot;:&#123;&quot;intValue&quot;:&quot;1&quot;&#125;&#125;],&quot;droppedAttributesCount&quot;:1,&quot;traceId&quot;:&quot;08040201000000000000000000000000&quot;,&quot;spanId&quot;:&quot;0102040800000000&quot;&#125;,&#123;&quot;timeUnixNano&quot;:&quot;1581452773000000789&quot;,&quot;severityNumber&quot;:9,&quot;severityText&quot;:&quot;Info&quot;,&quot;body&quot;:&#123;&quot;stringValue&quot;:&quot;something happened&quot;&#125;,&quot;attributes&quot;:[&#123;&quot;key&quot;:&quot;customer&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;acme&quot;&#125;&#125;,&#123;&quot;key&quot;:&quot;env&quot;,&quot;value&quot;:&#123;&quot;stringValue&quot;:&quot;dev&quot;&#125;&#125;],&quot;droppedAttributesCount&quot;:1,&quot;traceId&quot;:&quot;&quot;,&quot;spanId&quot;:&quot;&quot;&#125;]&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure>

<p>我们可以配置 <code>otel.logs.exporter=otlp (default)</code> 可以将日志输出到 <code>oetl-collector</code> 中，再由他输出到后端存储中。</p>
<p>虽然这样 <code>otel-collectoer</code> 就成为瓶颈了，但我们也可以部署多个副本来降低压力。</p>
<p>同时也可以在应用中指定不同的 <code>endpoint(otel.exporter.otlp.endpoint=http://127.0.0.1:4317)</code> 来区分日志的 collector，与其他类型的 collector 做到资源隔离。</p>
<p>不过目前社区关于日志的实践还比较少，而且由于版本 1.0 版本 release 的时间也不算长，稳定性和之前的 filebeat 相比还得需要时间检验。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>理想情况下，我们需要将可观测性的三个重要组件都关联起来才能更好的排查定位问题。</p>
<p>比如当收到监控系统通过指标变化发出的报警时，可以通过链路追踪定位具体是哪个系统触发的问题。</p>
<p>之后通过 traceID 定位到具体的日志，再通过日志的上下文列出更多日志信息，这样整个链条就可以串联起来，可以极大的提高效率。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/aliyun/aliyun-log-java-producer" target="_blank" rel="noopener">github.com/aliyun/aliy…</a></li>
<li><a href="https://kubernetes.io/docs/concepts/cluster-administration/logging/" target="_blank" rel="noopener">kubernetes.io/docs/concep…</a></li>
<li><a href="https://coding.net/help/docs/orbit/env/logs-event/intro.html" target="_blank" rel="noopener">coding.net/help/docs/o…</a></li>
<li><a href="https://opentelemetry.io/docs/concepts/signals/logs/" target="_blank" rel="noopener">opentelemetry.io/docs/concep…</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7347000319983419411" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,监控</tag>
      </tags>
  </entry>
  <entry>
    <title>不可思议！亿级数据竟然如此轻松同步至ES！</title>
    <url>/7354922285094207540.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-这是一个背景"><a href="#1-这是一个背景" class="headerlink" title="1 这是一个背景"></a>1 这是一个背景</h2><p>最近接了一个需求，要提供一个随意组合多个条件来查询订单数据的功能，看着数据库里过亿的订单量，头发不争气的又脱落了两根代表这个需求不简单</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/86b971f3f5a8659f134c1258e62d4795c78ae38e6dc1f8840500687fcc197a77" alt></p>
<p>脱落的两根头发，不是技术实现上很难，其实技术实现上清晰明了，就是通过数据异构，将数据同步到ES，利用ES的倒排索引、缓存等能力，提供多条件复杂查询的能力，而ES集群我们已经有了</p>
<p>但有些数据，在目前的ES索引中是不存在的，也就是说，我需要将过亿的订单数据从订单数据库重新刷一遍到ES中，而这一顿操作下来得需要一周的时间!</p>
<p>什么？你不信，那咱们来捋一捋</p>
<h2 id="2-捋一捋订单数据同步到ES中的复杂度"><a href="#2-捋一捋订单数据同步到ES中的复杂度" class="headerlink" title="2 捋一捋订单数据同步到ES中的复杂度"></a>2 捋一捋订单数据同步到ES中的复杂度</h2><h3 id="2-1-数据同步ES索引流程"><a href="#2-1-数据同步ES索引流程" class="headerlink" title="2.1 数据同步ES索引流程"></a>2.1 数据同步ES索引流程</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee1aa85681d3382c0239eed86a037459e2531f3358e587991d924ff04eab1960" alt></p>
<p>如上图所示，就是将数据同步到ES索引的过程。</p>
<p>首先需要从订单数据库查询所有的订单数据，然后根据订单数据上保存的用户ID，商品ID等信息从用户服务，商品服务查询相关信息，经过处理与组装后落到ES集群中。</p>
<p>之所以要查询用户信息和商品信息，是因为异构在ES索引中的订单数据，并不会与mysql中的数据一一对应，有很多根据商品类目，用户信息等查询订单信息的诉求存在，因此在这里就需要查询很多的上游服务来组装信息</p>
<h3 id="2-2-来梳理下是否有难点"><a href="#2-2-来梳理下是否有难点" class="headerlink" title="2.2 来梳理下是否有难点?"></a>2.2 来梳理下是否有难点?</h3><ol>
<li>从数据库把上亿的订单数据出来。这个操作不能影响到线上业务，因此查询的订单数据库一般是从库，OK，配置多数据源来读取数据吧，而且上亿的订单一般采用的都是分库分表来存储的，我们是分了16个库，每个库16个表，总共256张表，嘿嘿</li>
<li>上亿的订单数据不能一次性全部读取到内存吧，不然内存冒烟都存不下啊。所以得考虑分页，分页直接limit也不好，随着数据量越大，速度越慢，所以得考虑一个游标，嗯，选一个字段当游标吧，游标最好唯一且递增</li>
<li>从多个服务获取数据，这些数据所在的服务一般都属于公司的其它部门，读取数据的时候也不能影响到人家的服务吧，你这里查询的是嘎嘎猛，一看人家的服务都崩了，这个黑锅就飞来了。所以这里得考虑限流吧，得考虑隔离吧？不说全链路隔离，成本太高，起码关键服务得隔离一下</li>
<li>数据同步一段时间，产品来问，同步多久了啊，大概还有多久能完成啊，数据量大概是多少啊，一脸懵，不知道啊。</li>
<li>如果中途同步失败了，咋处理啊，是不是得重试，咋重试，重试策略是啥？失败有没有报警，能不能及时感知并处理啊？如果同步一段时间中断了咋整啊？有没有记录从哪中断的？能否从中断处继续同步啊，不然从头开始又得N天，哭了</li>
<li>同步了一部分，发现有问题需要暂停一会，咋整？</li>
<li>如果只想同步部分数据不一致的订单数据，可能就2,3个订单，咋整，是不是还得提供按照手动输入订单ID同步ES数据的能力？</li>
<li>同步过程是咋样的？开始时间？结束时间？共耗时多久？操作人是谁？这些统计数据从哪来？</li>
<li>想夜深人静的时候同步数据，这有时候对业务的影响小，定个闹钟晚上起？</li>
<li>现在不单需要同步订单的数据了，还需要同步商品ES集群的数据，这些逻辑还得重新写一遍？</li>
</ol>
<p>啊啊啊啊，想想都头疼啊</p>
<p>所以，一些事情看着简单，其实并没有那么简单</p>
<h2 id="3-神奇的服务"><a href="#3-神奇的服务" class="headerlink" title="3 神奇的服务"></a>3 神奇的服务</h2><p>为了让头发更有归属感，针对上述的难点开发了一款神奇的服务，那就是ECP。<br>它可以将整个流程自动化、可视化的处理，降低数据异构到ES的成本<br>任务界面如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8e31491a488e4e298ba8942ee48a1b1ef2951de35e73c02275047f4dcc12a72e" alt></p>
<h3 id="3-1-ECP的简单运行流程"><a href="#3-1-ECP的简单运行流程" class="headerlink" title="3.1 ECP的简单运行流程"></a>3.1 ECP的简单运行流程</h3><p>简单来说，ECP的作用就是将数据从数据源读取出来，然后推送给ES写服务。<br>因为数据处理的逻辑因不同的业务而异，ES写服务由各个对接方来实现，因此一个简单的流程如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/21d44b864cea1b9d9d2960a9765975d7075e376ab5fcc07f300476186155c2eb" alt></p>
<p>这里面涉及到一些技术细节，比如如何进行多数据源数据读取，数据源配置，sql校验，动态限流、SPI机制、重试策略与故障感知、探活与故障恢复，环境隔离等等。</p>
<p>下面一一介绍下</p>
<h3 id="3-2-多数据源数据读取"><a href="#3-2-多数据源数据读取" class="headerlink" title="3.2 多数据源数据读取"></a>3.2 多数据源数据读取</h3><p>ECP支持目前支持三个数据源数据的读取，分别为ID源，文本源、以及脚本源</p>
<h4 id="3-2-1-ID源"><a href="#3-2-1-ID源" class="headerlink" title="3.2.1 ID源"></a>3.2.1 ID源</h4><p>有个文本框用来输入ID。这种场景适用于小数据的数据同步，比如发现一些数据库和ES的数据不一致了，就简单的刷一下数据</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ae1394f5d0a8321b3178dad68ce14a51833142623d2baca9e50311723ff33360" alt></p>
<h4 id="3-2-2-文件源"><a href="#3-2-2-文件源" class="headerlink" title="3.2.2 文件源"></a>3.2.2 文件源</h4><p>文件源指的是数据源来源于文本文件，适合中等数据的同步。<br>ECP和对象存储进行了对接，用户可以上传文件至对象存储，在任务执行时，ECP会读取对象存储中的文本数据。</p>
<p>这种情况需要注意的是，用户上传的文件有可能会比较大，直接都读取到内存再处理不现实，因此这里采用的是流的方式进行读取，读取一批处理一批，再释放一批，不会造成OOM</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6e4dae85ee864d91185849746c5a44e57aebe134c64672b721542665934de642" alt></p>
<p>简化的处理方式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbscript复制代码</span><br><span class="line"></span><br><span class="line">try (Response response = OK_HTTP_CLIENT.newCall(request).execute()) &#123;</span><br><span class="line">            if (!response.isSuccessful()) &#123;</span><br><span class="line">                throw new IOException(&quot;Unexpected code &quot; + response);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">		// 以流的方式读取文件数据</span><br><span class="line">		InputStream inputStream = response.body().byteStream();</span><br><span class="line">		BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-3-脚本源"><a href="#3-2-3-脚本源" class="headerlink" title="3.2.3 脚本源"></a>3.2.3 脚本源</h4><p>脚本源适用于大数据量的数据同步。</p>
<p>脚本本质上就是SQL和数据源的结合。</p>
<p>用户在ECP中配置数据库的连接信息，然后配置SQL。ECP会执行该SQL，将数据从配置的数据库中读取出来，推送到ES写服务中。</p>
<p>脚本源可以支持上亿数据的读取与推送，如下图为订单库（分库分表）配置的脚本信息：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fb2cf25c1e3f9f5572f7c49017c86d5dea287a53b09e0e09da2d41c87a575700" alt></p>
<h4 id="3-2-4-脚本源大数据读取的实现"><a href="#3-2-4-脚本源大数据读取的实现" class="headerlink" title="3.2.4 脚本源大数据读取的实现"></a>3.2.4 脚本源大数据读取的实现</h4><p>将几亿数据读取到内存中来处理显然不可能，因此采用局部数据的读取与处理才是正道。</p>
<p>在业务中，经常使用的是分页，但分页如果仅是使用limit offset,size，待offset的值比较大时，性能会急剧下降，形成慢SQL，甚至拖累整个数据库的性能。</p>
<p>因此在分页数量比较大时，需要指定一个有索引的字段作为游标，该游标可以提高分页的性能，如在订单表中，若在订单ID是递增的且有设置了索引，SQL就可以这么写：<code>select * from t_order where order_id &gt; xxx order by order_id desc limit 10</code>; 利用order_id值的变化就可以起到分页的效果</p>
<p>这种方式虽好，但让用户选定游标索引无疑增加了使用的门槛，因此ECP没有采用上述分页的形式来读取大数据，而是采用JDBC游标查询的方式，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码				// 建立连接</span><br><span class="line">       conn = DriverManager.getConnection(url, param.getDsUsername(), param.getDsPassword());</span><br><span class="line">       // 创建查询</span><br><span class="line">       stmt = conn.createStatement(java.sql.ResultSet.TYPE_FORWARD_ONLY, java.sql.ResultSet.CONCUR_READ_ONLY);</span><br><span class="line">       stmt.setFetchSize(param.getFetchSize());</span><br></pre></td></tr></table></figure>

<p>游标查询每次读取fetchSize大小的数据量，可以很好的避免读取大数据量导致的OOM问题</p>
<h3 id="3-3-SQL的解析与校验"><a href="#3-3-SQL的解析与校验" class="headerlink" title="3.3 SQL的解析与校验"></a>3.3 SQL的解析与校验</h3><p>用户配置SQL脚本，ECP需要对该SQL脚本进行校验与修改，传统的字符串处理（比如正则）虽然在一定情况下可以满足需求，但是容易出错。<br>因此ECP采用的是Druid的SQL解析工具包，可以将SQL解析成AST语法树，以便对SQL进行各种处理。如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eae4f4ba1b37a3311960391d75a04ab20de0364ae178503f1c62b221f258744b" alt></p>
<p>ECP提供的数据样例查询，会对SQL自动拼接上limit 1<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0b17bb0150afbade03f148f0de2cec6a3613bbacd88131cd8e950d64bfb1dd4f" alt><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a4e278631494707c32b7d87403db443d4bf740e44de5979b64942aa89980c892" alt></p>
<h3 id="3-4-动态限流的实现"><a href="#3-4-动态限流的实现" class="headerlink" title="3.4 动态限流的实现"></a>3.4 动态限流的实现</h3><p>限流分集群限流和单机限流，经过评估，在能简单就简单的原则下，我们采用的是单机限流，限流组件使用的是guava的RateLimiter</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/033425061a740892f1fc0d9f95251f80a3175cb9bc25f713a486939e20f16412" alt></p>
<p>当在页面上修改QPS的值时，会将该值同步到数据库中，有个调度任务会不断地扫描该值的变动，将变动的值同步到RateLimiter组件中</p>
<p>当然，也可以采用数据监听的策略(比如广播MQ)，让变动值同步到RateLimiter更及时，但这种方式还需引入其它组件，复杂度嗷嗷上升，不符合我们简单实现的策略</p>
<p>动态限流的实现流程如下；<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/41baf2c7abf9b96c768884b350762390d0d47650b1197b451610b52e34eb2839" alt></p>
<p>如下图是在不同的时间点修改了限流值后的QPS变化图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3883885a2f61250a1de649889a3012ee73aa3de40799c1c6fd3e4105762bb343" alt></p>
<h3 id="3-5-重试策略与故障感知"><a href="#3-5-重试策略与故障感知" class="headerlink" title="3.5 重试策略与故障感知"></a>3.5 重试策略与故障感知</h3><p>ES中和DB中的数据要尽可能的保证实时一致性，但最终一致性是必须要保证的，所以数据推送、处理失败的时候要进行重试，如何重试？</p>
<p>首先需要了解下失败的类型，制定合适的重试策略，知彼知己，百战不殆嘛</p>
<p>一、网络抖动导致的接口调用超时。<br>在调用微服务RPC接口的时候，由于网络抖动等情况，会导致接口调用超时，但很快就会恢复，通常情况下也就偶尔一次，下一次调用就会正常</p>
<p>二、数据处理逻辑异常。这种情况下，异常没办法自恢复，只能人工介入</p>
<p>三、上游服务异常。如上游服务压力过大导致接口调用失败，这时候就需要我们缓一缓再继续处理，不能一个劲的调用导致上游服务崩溃掉</p>
<p>结合上面的失败类型的特点，斐波那契数列的重试策略就非常适合<br>斐波那契数列的特点是：1，1，2，3，5，8，13，21，34，55，89…</p>
<p>当第一次失败的时候，延时1秒后就重试，如果此时是网络抖动导致的超时，重试就成功了，不影响数据处理的速度<br>若失败的次数越多，重试的间隔时间就会越长，这也会兼顾到上述二、三的失败类型</p>
<p>重试组件使用的是Guava Retry，简单的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码</span><br><span class="line">// 重试组件配置</span><br><span class="line">private final Retryer&lt;Boolean&gt; RETRYER = RetryerBuilder.&lt;Boolean&gt;newBuilder()</span><br><span class="line">            // 对中断类的异常不重试</span><br><span class="line">            .retryIfException(input -&gt; !isPauseException(input))</span><br><span class="line">            // 1,1,2,3,5,8,13,21,33...</span><br><span class="line">            .withWaitStrategy(WaitStrategies.fibonacciWait(1000, 30, TimeUnit.SECONDS))</span><br><span class="line">	          // 重试次数达到一定的次数后，不再重试</span><br><span class="line">            .withStopStrategy(StopStrategies.stopAfterAttempt(MAX_RETRY_TIMES))</span><br><span class="line">            .withRetryListener(new RetryListener() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public &lt;V&gt; void onRetry(Attempt&lt;V&gt; attempt) &#123;</span><br><span class="line">                    if (attempt.hasException()) &#123;</span><br><span class="line">                        log.error(&quot;act=【DataFlushRpcCallRetry】desc=【重试】重试次数=【&#123;&#125;】重试异常=【&#123;&#125;】&quot;, attempt.getAttemptNumber(), attempt.getExceptionCause());</span><br><span class="line">                        // 重试超过阈值进行报警提醒</span><br><span class="line">                        alarmIfExceedThreshold(attempt);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">// 将执行逻辑抽象为Runnable，对外暴露该方法</span><br><span class="line">public void execute(Runnable runnable) &#123;</span><br><span class="line">    innerExecute(runnable,RETRYER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void innerExecute(Runnable runnable, Retryer&lt;Boolean&gt; retryer) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">				retryer.call(() -&gt; &#123;</span><br><span class="line">	       runnable.run();</span><br><span class="line">	       return true;</span><br><span class="line">       &#125;);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">       log.error(&quot;act=【DataFlushRpcCallRetry】desc=【重试异常】error=【&#123;&#125;】&quot;, e);</span><br><span class="line">       throw new IllegalStateException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若重试到一定次数之后依然是失败的话，则会将错误信息发送到报警群。<br>根据推送的信息，可以明确知道错误的类型，重试的次数，以及任务的创建人等等信息，无需查看日志，即可定位大部分的问题。如下图：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0f3337a9b2b4c43a46459884d6805cf3725c557c353910ee6a21888180d903b1" alt></p>
<h3 id="3-6-将数据推送给哪个服务来处理？-SPI机制"><a href="#3-6-将数据推送给哪个服务来处理？-SPI机制" class="headerlink" title="3.6 将数据推送给哪个服务来处理？-SPI机制"></a>3.6 将数据推送给哪个服务来处理？-SPI机制</h3><p>ECP是个通用的服务，因此需要将共性功能收拢在一起做成成品，将非共性的功能抽象一下，交给各个对接方去实现。</p>
<p>从简单实现的角度来看，若有某个服务想要对接ECP，我们在ECP上开发一下，调用该服务的接口，将数据推送给该服务，思路虽清晰明了，但对接及维护成本极高，且没有一个统一的规范，因此不可取，其流程如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/58881c8e0c47dd6615354e65de5f5cf47dc402c68d33d158e1a79a1157707a9b" alt></p>
<p>Java上有个很好的思想可以解决这个问题，那就是SPI。因此由ECP提供一个接口，制定一个规范，具体的ES索引数据的组装逻辑由各个对接方去实现</p>
<p>这样，若有一个新的对接方接入，只要实现接口即可，ECP无需做任何改动<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d2f24dddbbab3953c1b35055dd7aa3af9fd834ca135a35ae378a41f71d728e25" alt></p>
<p>至于服务发现，ECP采用的配置的方式，也就是在新建任务的时候，选择数据推送的消费方服务，如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1410fe2305598099d11f678f41d1db6f2642137fa849ad7ff6a1303ccfc9f853" alt></p>
<p>对于实现方式，得益于公司内部自研的RPC框架，提供了动态指定调用服务的方式，伪代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码Reference&lt;IEsIndexFlushAPI&gt; reference = new Reference&lt;&gt;();</span><br><span class="line">// 设置调用的服务名</span><br><span class="line">reference.setServiceName(serviceName);</span><br><span class="line">// 设置接口名</span><br><span class="line">reference.setInterfaceClass(IEsIndexFlushAPI.class);</span><br><span class="line">// 设置上下文</span><br><span class="line">reference.setApplicationConfig(applicationConfig);</span><br><span class="line">// 获取接口实例</span><br><span class="line">IEsIndexFlushAPI iEsIndexFlushAPI = ES_INDEX_FLUSH_API_MAP.computeIfAbsent(serviceName, s -&gt; reference.refer());</span><br><span class="line">// 接口调用</span><br><span class="line">log.info(&quot;act=【EsIndexFlushApiInvoker】desc=【请求值】serviceName=【&#123;&#125;】dataListSize=【&#123;&#125;】indexNameList=【&#123;&#125;】tag=【&#123;&#125;】&quot;, serviceName,request.getDataList().size(),request.getIndexNameList(),request.getTag() );</span><br><span class="line">EMApiResult&lt;FlushResponse&gt; result = iEsIndexFlushAPI.flush(request);</span><br></pre></td></tr></table></figure>

<h3 id="3-7-环境隔离"><a href="#3-7-环境隔离" class="headerlink" title="3.7 环境隔离"></a>3.7 环境隔离</h3><p>同步数据是个比较重的操作，这个操作不应该影响到线上业务<br>因此，同步数据的服务应当与线上服务隔离开<br>ECP整合了架构组提供的标签路由功能，可以在整个请求链路中调用指定标签的服务，实现环境隔离</p>
<p>ECP标签路由配置图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6e945cf15358568bc07e38c12e0187683e73de327e4b84cec011576ef54c5a3a" alt></p>
<p>如下图，若在ECP上配置任务的标签路由为FLUSH，则在同步任务执行过程中，会自动调用链路中绑定了FLUSH标签的服务分组。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4902dedbc47e92b9b6dfc4ba4291e0589fe621957488e2137fce1f533364e32f" alt></p>
<p>若某些服务没有配置为FLUSH标签的分组，这时就会自动请求该服务的线上正常环境。<br>这样，就可以做到一定程度上的环境隔离<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77cb28ae6ea97f861efd8f0dbb05a3ee550c20e11455ad5466e6ad32308ff68d" alt></p>
<h3 id="3-8-探活与任务故障恢复机制"><a href="#3-8-探活与任务故障恢复机制" class="headerlink" title="3.8 探活与任务故障恢复机制"></a>3.8 探活与任务故障恢复机制</h3><p>在推送数据的过程中，若发生了不可描述的事情导致任务中断，咋整？</p>
<p>到了需求DeadLine，发现任务在某年某月某日进度为1%的时候停了，哭了。</p>
<p>而且工作时间紧，任务重，总不能一定盯着任务，看有没有中断吧？这不适合，也不礼貌。</p>
<p>当然，这种情况在ECP是不会发生的，因为ECP是有“自救包”的。下面聊下ECP的任务探活和中断恢复机制</p>
<p>如下图，在ECP中有探活和任务故障恢复两大组件<br>探活组件负责监控当前任务线程的执行状态，若任务线程正在执行，则对该任务的存活时间进行续期<br>任务故障恢复组件负责扫描当前未完成的任务，若任务上次存活时间大于指定的阈值时，则拉取该任务恢复执行<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c3c18b42e4490426bc8fb41a7934692d7c4a28f79185d6816f552d0d953e5d72" alt></p>
<p>续期的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码    @Scheduled(fixedDelay = ScheduleTimeConstants.KEEP_ALIVE_MILLS)</span><br><span class="line">    public void renewal()&#123;</span><br><span class="line">        futureMap.forEach((taskId,future)-&gt;&#123;</span><br><span class="line">            if (!future.isDone())&#123;</span><br><span class="line">                log.info(&quot;act=【renewal】desc=【任务续期】taskId=【&#123;&#125;】续期时间=【&#123;&#125;】&quot;,taskId, DateUtils.dateToString(new Date(),DateUtils.PATTERN));</span><br><span class="line">                contextService.renewal(taskId);</span><br><span class="line">            &#125;else &#123;</span><br><span class="line">                log.info(&quot;act=【renewal】desc=【任务结束】taskId=【&#123;&#125;】&quot;,taskId);</span><br><span class="line">                futureMap.remove(taskId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>任务故障恢复的伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码    @Scheduled(fixedDelay = ScheduleTimeConstants.RESTART_TASK_MILLS)</span><br><span class="line">    public void restartTask()&#123;</span><br><span class="line"></span><br><span class="line">				 // 1.查询当前未完成的任务</span><br><span class="line">        List&lt;TaskFlushExecuteContextPO&gt; contextPOS = contextService.queryRunningTask();</span><br><span class="line"></span><br><span class="line">        for (TaskFlushExecuteContextPO contextPO : contextPOS) &#123;</span><br><span class="line">            // 2.计算上次存活到当前的时间</span><br><span class="line">            Integer durationMin = calculateTimeSinceLastAlive();</span><br><span class="line"></span><br><span class="line">						// 3.若时间大于指定阈值 则对任务重新拉起</span><br><span class="line">            if (durationMin &gt;= MAX_DURATION_MIN)&#123;</span><br><span class="line">                log.info(&quot;act=【restartTask】desc=【任务重新拉起】taskId=【&#123;&#125;】&quot;,contextPO.getTaskId());</span><br><span class="line">                // 4.更新alive_time进行锁定 防止并发执行</span><br><span class="line">                int i = contextExtMapper.casUpdateAliveTime();</span><br><span class="line">                if (i &gt;0)&#123;</span><br><span class="line">                    // 5.重新拉起任务</span><br><span class="line">                    restart0(contextPO, aliveTime);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-9-平滑迁移的实现"><a href="#3-9-平滑迁移的实现" class="headerlink" title="3.9 平滑迁移的实现"></a>3.9 平滑迁移的实现</h3><p>将数据同步到ES，通常有两种方式：</p>
<ol>
<li>直接把数据同步到原索引上</li>
<li>新建一个索引，利用双写以及切换别名的方式实现流量的平滑迁移。</li>
</ol>
<p>对于新建一个索引的场景，往往是索引Mapping的改变，或者是为了不影响原索引，保证操作可回滚</p>
<p>针对这种场景，ECP分析了历来大家手动操作刷ES索引的步骤，将流程进行抽象，归纳了以下几个步骤，如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f29f695b3d7b2bad18a00541f00e46ab3acf135064823a7b8ec150abd02789f2" alt></p>
<p>ECP提供了平滑迁移组件，其内部整合了Apollo配置中心实现推送能力，其简要的实现流程如下图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b0c6943f2bbba3421c19651996a32fcc703c9e08adcc94adc8f31b402761151a" alt></p>
<h3 id="3-10-优雅的日志记录"><a href="#3-10-优雅的日志记录" class="headerlink" title="3.10 优雅的日志记录"></a>3.10 优雅的日志记录</h3><p>如下图所示展示了该任务操作的日志，原则上日志记录为非核心业务，需要与核心业务代码进行剥离，因此使用注解式流水记录是个很好的选择</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/33d58df5811ea744ea32365bebfd23557c8a9b1d743d95252dbe7a7468dfc862" alt></p>
<p>但注解式流水记录有个问题，就是在很多的场景下，流水里面的值需要动态获取，利用注解可以实现吗?<br>答案是可以的，在上图所示中，任务ID、数据来源都是动态数据，那如何实现的呢？看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码@Flow(subjectIdEp = &quot;#taskPO.id&quot;,subjectType = SubjectTypeEnum.TASK,operateFlowType = OperateFlowTypeEnum.CREATE_TASK,content = &quot;&apos;创建任务，任务ID：&apos; + #taskPO.id &quot;)</span><br><span class="line">    public void saveTaskWithUser(TaskPO taskPO) &#123;</span><br><span class="line">        String name = LoginUserContext.get().getName();</span><br><span class="line">        taskPO.setCreator(name);</span><br><span class="line">        taskPO.setModifier(name);</span><br><span class="line">        taskMapper.insertSelective(taskPO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>subjectIdEp为流水主题ID，#taskPo.id为一个表达式，可用动态获取参数taskPo中的id值，这里利用了springEl表达式的能力</p>
<p>content = “‘创建任务，任务ID：’ + #taskPO.id “ 为流水信息，同样利用了springEL表达式，动态获取请求参数taskPo中的id信息</p>
<p>但有些信息需要一系列的计算才可以获取到，而不是单纯的从对象中取值，这也是可以实现的。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码@Flow(subjectIdEp = &quot;#contextPO.taskId&quot;,</span><br><span class="line">            subjectType = SubjectTypeEnum.TASK,</span><br><span class="line">            operateFlowType = OperateFlowTypeEnum.DATA_FLUSH,</span><br><span class="line">            content = &quot;&apos;【数据同步】异常中断任务恢复执行，中断时间：&apos; + T(com.zhuanzhuan.esmanage.utils.DateUtils).dateToStringSimple(#aliveTime)&quot;)</span><br><span class="line">    @Transactional(rollbackFor = Exception.class,isolation = Isolation.REPEATABLE_READ)</span><br><span class="line">    public void restart0(TaskFlushExecuteContextPO contextPO, Date aliveTime) &#123;</span><br><span class="line">        log.info(&quot;act=【restartTask】desc=【任务重新拉起】taskId=【&#123;&#125;】原aliveTime=【&#123;&#125;】&quot;, contextPO.getTaskId(), aliveTime);</span><br><span class="line">        dsProcessorExecutor.executeAndKeepAliveMonitor(contextPO.getTaskId());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>T(com.zhuanzhuan.esmanage.utils.DateUtils).dateToStringSimple(#aliveTime)</code> 代表执行的是<code>DateUtils.dateToStringSimple</code> 方法，也就是说注解的表达式是可以调用方法的，包括从spring容器中获取对象，调用对象的方法均可。</p>
<p>这种注解式流水的实现原理，就是利用SPEL表达式和Spring Aop的特性，写一个切面，拦截自定义的flow注解即可，伪代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码</span><br><span class="line"></span><br><span class="line">// 定义切面，拦截FLOW注解</span><br><span class="line">@Around(&quot;@annotation(com.zhuanzhuan.esmanage.entity.annotation.Flow)&quot;)</span><br><span class="line">public Object around(ProceedingJoinPoint point) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">    // 调用目标方法</span><br><span class="line">    Object result = null;</span><br><span class="line">    try &#123;</span><br><span class="line">        result = point.proceed();</span><br><span class="line">        recordFlow(point,result);</span><br><span class="line">        return result;</span><br><span class="line">    &#125; catch (Throwable e) &#123;</span><br><span class="line">        recordException(point,e);</span><br><span class="line">        throw e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 流水记录的实现</span><br><span class="line">private void recordFlow(ProceedingJoinPoint point, Object result) &#123;</span><br><span class="line">    // try catch 防止影响主逻辑</span><br><span class="line">    //TODO 看是否需要写在一个事务中，主要评估流水的重要性</span><br><span class="line">    try &#123;</span><br><span class="line">        MethodSignature signature = (MethodSignature) point.getSignature();</span><br><span class="line">        Flow flowAnnotation = getFlowAnnotation(signature);</span><br><span class="line"></span><br><span class="line">        // 组装参数上下文</span><br><span class="line">        EvaluationContext evaluationContext = buildContext(point, signature);</span><br><span class="line"></span><br><span class="line">        evaluationContext.setVariable(&quot;result&quot;,result);</span><br><span class="line"></span><br><span class="line">        // ID表达式</span><br><span class="line">        String subjectIdEp = flowAnnotation.subjectIdEp();</span><br><span class="line"></span><br><span class="line">        // content表达式</span><br><span class="line">        String content = getContent(flowAnnotation, evaluationContext);</span><br><span class="line"></span><br><span class="line">				// SPEL解析表达式</span><br><span class="line">        Expression expression = PARSER.parseExpression(subjectIdEp);</span><br><span class="line">        Integer subjectId = (Integer)expression.getValue(evaluationContext);</span><br><span class="line">        record(flowAnnotation, subjectId, content);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        log.error(&quot;记录操作流水失败&quot;, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h2><p>总得来说，ECP的实现中有很多的技术细节需要考虑，技术难度一般。<br>实际上，在我们大部分的项目中，考验的就是对细节的把控~</p>
<p>ps：感谢ChatGPT对本文名称的大力支持</p>
<hr>
<blockquote>
<p>关于作者</p>
</blockquote>
<p>闫展，转转交易中台研发工程师</p>
<p><code>&gt; 转转研发中心及业界小伙伴们的技术学习交流平台，定期分享一线的实战经验及业界前沿的技术话题。</code></p>
<p><code>&gt; 关注公众号「转转技术」（综合性）、「大转转FE」（专注于FE）、「转转QA」（专注于QA），更多干货实践，欢迎交流分享~</code></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7354922285094207540" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Elasticsearch,后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>从一个JDK21+OpenTelemetry不兼容的问题</title>
    <url>/7356138322367266854.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为稀土掘金技术社区首发签约文章，30天内禁止转载，30天后未获授权禁止转载，侵权必究！</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>前段时间公司领导让我排查一个关于在 jdk21 环境中使用 Spring Boot 配合一个 JDK18 新增的一个 SPI(<code>java.net.spi.InetAddressResolverProvider</code>) 不生效的问题。</p>
<p>但这个不生效的前置条件有点多：</p>
<ul>
<li>JDK 的版本得在 18+</li>
<li>SpringBoot3.x</li>
<li>还在额外再配合使用 <code>-javaagent:opentelemetry-javaagent.jar</code> 使用，也就是 OpenTelemetry 提供的 agent。</li>
</ul>
<p>才会导致自定义的 <code>InetAddressResolverProvider</code> 无法正常工作。</p>
<hr>
<p>在复现这个问题之前先简单介绍下 <code>java.net.spi.InetAddressResolverProvider</code> 这个 SPI；它是在 JDK18 之后才提供的，在这之前我们使用 <code>InetAddress</code> 的内置解析器来解析主机名和 IP 地址，但这个解析器之前是不可以自定义的。</p>
<p>在某些场景下会不太方便，比如我们需要请求 <code>order.service</code> 这个域名时希望可以请求到某一个具体 IP 地址上，我们可以自己配置 host ，或者使用服务发现机制来实现。</p>
<p>但现在通过 <code>InetAddressResolverProvider</code> 就可以定义在请求这个域名的时候返回一个我们预期的 IP 地址。</p>
<p>同时由于它是一个 SPI，所以我们只需要编写一个第三方包，任何项目依赖它之后在发起网络请求时都会按照我们预期的 IP 进行请求。</p>
<h1 id="复现"><a href="#复现" class="headerlink" title="复现"></a>复现</h1><p>要使用它也很简单，主要是两个类：</p>
<ul>
<li><code>InetAddressResolverProvider</code>：这是一个抽象类，我们可以继承它之后重写它的 get 函数返回一个 <code>InetAddressResolver</code> 对象</li>
<li><code>InetAddressResolver</code>：一个接口，主要提供了两个函数；一个用于传入域名返回 IP 地址，另一个反之：传入 IP 地址返回域名。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码</span><br><span class="line">public class MyAddressResolverProvider extends InetAddressResolverProvider &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public InetAddressResolver get(Configuration configuration) &#123;</span><br><span class="line">        return new MyAddressResolver();</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String name() &#123;</span><br><span class="line">        return &quot;MyAddressResolverProvider Internet Address Resolver Provider&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class MyAddressResolver implements InetAddressResolver &#123;</span><br><span class="line"></span><br><span class="line">    public MyAddressResolver() &#123;</span><br><span class="line">        System.out.println(&quot;=====MyAddressResolver&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Stream&lt;InetAddress&gt; lookupByName(String host, LookupPolicy lookupPolicy)</span><br><span class="line">            throws UnknownHostException &#123;</span><br><span class="line">        if (host.equals(&quot;fedora&quot;)) &#123;</span><br><span class="line">            return Stream.of(InetAddress.getByAddress(new byte[] &#123;127, 127, 10, 1&#125;));</span><br><span class="line">        &#125;</span><br><span class="line">        return Stream.of(InetAddress.getByAddress(new byte[] &#123;127, 0, 0, 1&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String lookupByAddress(byte[] addr) &#123;</span><br><span class="line">        System.out.println(&quot;++++++&quot; + addr[0] + &quot; &quot; + addr[1] + &quot; &quot; + addr[2] + &quot; &quot; + addr[3]);</span><br><span class="line">        return  &quot;fedora&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">addresses = InetAddress.getAllByName(&quot;fedora&quot;);</span><br><span class="line">// output: 127 127 10 1</span><br></pre></td></tr></table></figure>

<p>这里我简单实现了一个对域名 fedora 的解析，会直接返回 <code>127.127.10.1</code>。</p>
<p>如果使用 IP 地址进行查询时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码InetAddress byAddress = InetAddress.getByAddress(new byte[]&#123;127, 127, 10, 1&#125;);</span><br><span class="line"></span><br><span class="line">System.out.println(&quot;+++++&quot; + byAddress.getHostName());</span><br><span class="line">// output: fedora</span><br></pre></td></tr></table></figure>

<p>当然要要使得这个 SPI 生效的前提条件是我们需要新建一个文件：<br><code>META-INF/services/java.net.spi.InetAddressResolverProvider</code><br>里面的内容是我们自定义类的全限定名称：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码com.example.demo.MyAddressResolverProvider</span><br></pre></td></tr></table></figure>

<p>这样一个完整的 SPI 就实现完成了。</p>
<hr>
<p>正常情况下我们将应用打包为一个 jar 之后运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>是可以看到输出结果是符合预期的。</p>
<p>一旦我们使用配合上 spring boot 打包之后，也就是加上以下的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;parent&gt;  </span><br><span class="line">  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">  &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;  </span><br><span class="line">  &lt;version&gt;3.2.3&lt;/version&gt;  </span><br><span class="line">  &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;  </span><br><span class="line">&lt;/parent&gt;</span><br><span class="line"></span><br><span class="line">&lt;build&gt;  </span><br><span class="line">  &lt;plugins&gt;  </span><br><span class="line">   &lt;plugin&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  </span><br><span class="line">   &lt;/plugin&gt;  </span><br><span class="line">  &lt;/plugins&gt;  </span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>再次执行其实也没啥问题，也能按照预期输出结果。</p>
<p>但我们加上 OpenTelemetry 的 agent 时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java  -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p>就会发现在执行解析的时候抛出了 <code>java.net.UnknownHostException</code>异常。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/40663931448c0d22892951556772c37f48f811189d1e95210ec96369bbf19b3c" alt><br>从结果来看就是没有进入我们自定义的解析器。</p>
<h1 id="SPI-原理"><a href="#SPI-原理" class="headerlink" title="SPI 原理"></a>SPI 原理</h1><p>在讲排查过程之前还是要先预习下关于 Java SPI 的原理以及应用场景。</p>
<p>以前写过一个 http 框架 <a href="https://github.com/TogetherOS/cicada" target="_blank" rel="noopener">cicada</a>，其中有一个可拔插 IOC 容器的功能：</p>
<blockquote>
<p>就是可以自定义实现自己的 IOC 容器，将自己实现的 IOC 容器打包为一个第三方包加入到依赖中，cicada 框架就会自动使用自定义的 IOC 实现。</p>
</blockquote>
<p>要实现这个功能本质上就是要定义一个接口，然后根据依赖的不同实现创建接口的实例对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public interface CicadaBeanFactory &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Register into bean Factory</span><br><span class="line">     * @param object</span><br><span class="line">     */</span><br><span class="line">    void register(Object object);</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Get bean from bean Factory</span><br><span class="line">     * @param name</span><br><span class="line">     * @return</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    Object getBean(String name) throws Exception;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * get bean by class type</span><br><span class="line">     * @param clazz</span><br><span class="line">     * @param &lt;T&gt;</span><br><span class="line">     * @return bean</span><br><span class="line">     * @throws Exception</span><br><span class="line">     */</span><br><span class="line">    &lt;T&gt; T getBean(Class&lt;T&gt; clazz) throws Exception;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * release all beans</span><br><span class="line">     */</span><br><span class="line">    void releaseBean() ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取具体的示例代码时就只需要使用 JDK 内置的 <code>ServiceLoader</code> 进行加载即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public static CicadaBeanFactory getCicadaBeanFactory() &#123;  </span><br><span class="line">    ServiceLoader&lt;CicadaBeanFactory&gt; cicadaBeanFactories = ServiceLoader.load(CicadaBeanFactory.class);  </span><br><span class="line">    if (cicadaBeanFactories.iterator().hasNext())&#123;  </span><br><span class="line">        return cicadaBeanFactories.iterator().next() ;  </span><br><span class="line">    &#125;  </span><br><span class="line">    return new CicadaDefaultBean();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码也非常的简洁，和刚才提到的 <code>InetAddressResolverProvider</code> 一样我们需要新增一个 <code>META-INF/services/top.crossoverjie.cicada.base.bean.CicadaBeanFactory</code> 文件来配置我们的类名称。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码private boolean hasNextService() &#123;</span><br><span class="line">    if (nextName != null) &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    if (configs == null) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">        	// PREFIX = META-INF/services/</span><br><span class="line">            String fullName = PREFIX + service.getName();</span><br><span class="line">            if (loader == null)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            else</span><br><span class="line">                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; catch (IOException x) &#123;</span><br><span class="line">            fail(service, &quot;Error locating configuration files&quot;, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    while ((pending == null) || !pending.hasNext()) &#123;</span><br><span class="line">        if (!configs.hasMoreElements()) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 ServiceLoader 类中会会去查找 <code>META-INF/services</code> 的文件，然后解析其中的内容从而反射生成对应的接口对象。</p>
<p>这里还有一个关键是通常我们的代码都会打包为一个 JAR 包，类加载器需要加载这个 JAR 包，同时需要在这个 JAR 包里找到我们之前定义的那个 spi 文件，如果这里查不到文件那就认为没有定义 SPI。</p>
<p>这个是本次问题的重点，会在后文分析原因的时候用到。</p>
<h1 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h1><p>因为问题就出现在是否使用 opentelemetry-javaagent.jar 上，所以我需要知道在使用了 agent 之后有什么区别。</p>
<p>从刚才的对 SPI 的原理分析，加上 agent 出现异常，说明理论上就是没有读取到我们配置的文件: <code>java.net.spi.InetAddressResolverProvider</code>。</p>
<p>于是我便开始 debug，在 ServiceLoader 加载 jar 包的时候是可以看到具体使用的是什么 <code>classLoader</code> 。</p>
<p>这是不配置 agent 的时候使用的 classLoader：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37e7eb96c48654de344f8b9df2eab1f9d265dc8f34f2649f0a9ec773aadd049f" alt><br>使用这个 loader 是可以通过文件路径在 jar 包中查找到我们配置的文件。</p>
<p>而配置上 agent 之后使用的 classLoader:<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c192d0901edf4795609628fc8e8c34a41ca93b0800f3857488f93609d64c1f9d" alt><br>却是一个 JarLoader，这样是无法加载到在 springboot 格式下的配置文件的，至于为什么加载不到，那就要提一下 maven 打包后的文件目录和 spring boot 打包后的文件目录的区别了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ced2dbf766da7bebb6afc5e2f8f3d87919bc7defcd7e6282da6b023546c732df" alt><br>这里我截图了同样的一份代码不同的打包方式：<br>上面的是传统 maven，下图是 spring boot；其实主要的区别就是在 pom 中使用了一个构建插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;  </span><br><span class="line">  &lt;plugins&gt;  </span><br><span class="line">   &lt;plugin&gt;  </span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;  </span><br><span class="line">    &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;  </span><br><span class="line">   &lt;/plugin&gt;  </span><br><span class="line">  &lt;/plugins&gt;  </span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>或者使用 <code>spring-boot</code> 命令再次打包的效果也是一样的。</p>
</blockquote>
<p>会发现 spring boot 打包后会多出一层 <code>BOOT-INF</code> 的文件夹，然后会在 <code>MANIFIST.MF</code> 文件中定义 <code>Main-Class</code> 和 <code>Start-Class</code>.</p>
<hr>
<p>通过上面的 debug 其实会发现 JarLoader 只能在加载 maven 打包后的文件，也就是说无法识别 BOOT-INF 这个目录。</p>
<p>正常情况下 spring boot 中会有一个额外的 <code>java.nio.file.spi.FileSystemProvider</code> 实现:<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/00d3e86262088af3b4aac38ce56ddb04a911e57be510de6c53ea0ed0ffc60f85" alt><br>通过这个类的实现可以直接从 JAR 包中加载资源，比如我们自定义的 SPI 资源等。</p>
<p>初步判断使用 <code>opentelemetry-javaagent.jar</code>的 agent 之后，它的类加载器优先于了 spring boot ，从而导致后续的加载失败。</p>
<h2 id="远程-debug"><a href="#远程-debug" class="headerlink" title="远程 debug"></a>远程 debug</h2><p>这里穿插几个 debug 小技巧，其中一个是远程 debug，因为这里我是需要调试 javaagent，正常情况下是无法直接 debug 的。</p>
<p>所以我们可以使用以下命令启动应用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java -agentlib:jdwp=&quot;transport=dt_socket,server=y,suspend=y,address=5000&quot; -javaagent:opentelemetry-javaagent.jar \</span><br><span class="line">      -jar target/demo-0.0.1-SNAPSHOT.jar</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/71100a0db50f579639883c90c7076c7a86d9e5ec9b99b2481f8d332353728f58" alt></p>
<p>然后在 idea 中配置一个 remote 启动。</p>
<blockquote>
<p>注意这里的端口得和命令行中的保持一致。</p>
</blockquote>
<p>当应用启动之后便可以在 idea 中启动这个 remote 了，这样便可以正常 debug 了。</p>
<h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>第二个是条件断点也非常有用，有时候我们需要调试一个公共函数，调用的地方非常多。</p>
<p>而我们只需要关心某一类行为的调用，此时就可以对这个函数中的变量进行判断，当他们满足某些条件时再进入断点，这样可以极大的提高我们的调试效率：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6a98ef517979d3fbb5531ff7058902e9da58060b87f0cc0cd5e2ef4625076569" alt></p>
<p>配置也很简单，只需要在断点上右键就可以编辑条件了。</p>
<h1 id="社区咨询"><a href="#社区咨询" class="headerlink" title="社区咨询"></a>社区咨询</h1><p>虽然我根据现象初步可以猜测下原因，但依然不确定如何调整才能解决这个问题，于是便去社区提了一个 <a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921" target="_blank" rel="noopener">issue</a>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a9c5c62da4e6fff0b04dc44cd70129bc775f3694e48cd672d1b8b5f0912faf03" alt><br>最后在社区大佬的帮助下发现我们需要禁用掉 OpenTelemetry agent 中的一个 resource 就可以了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7b3c09a33dc8f93d256702c1a170b514ebc1d4696cf2eee492fca340436b0b5c" alt><br>这个 resource 是由 agent 触发的，它优先于 spring boot 之前进行 SPI 的加载。<br>目的是为了给 metric 和 trace 新增两个属性：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fbb18e1a3fbe3886101b4cdb01df9c54b8701b34a1ae7d7432e4ff8d2f501a95" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e38390c177f68b8d5512ee4e68a3cb05378edab113721ad12613947e5689c441" alt><br>加载的核心代码在这里，只要禁用掉之后就不会再加载了。</p>
<p>禁用前：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e539943a4351c677f694e36879b0525bb5ad571e67e3cbb2d230b22ed8110047" alt></p>
<p>禁用后：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ab7e1911dd115a331020ebb3b61ac663b5063f7c16a1b054382947a9dc086dfc" alt></p>
<p>当我们禁用掉之后就不会存在这两个属性了，不过我们目前并没有使用这两个属性，所以为了使得 SPI 生效就只有先禁用掉了，后续再看看社区还有没有其他的方案。</p>
<p>想要复现 debug 的可以在这里尝试：<br><a href="https://github.com/crossoverJie/demo" target="_blank" rel="noopener">github.com/crossoverJi…</a></p>
<p>参考连接：</p>
<ul>
<li><a href="https://github.com/TogetherOS/cicada" target="_blank" rel="noopener">github.com/TogetherOS/…</a></li>
<li><a href="https://docs.spring.io/spring-boot/docs/current/maven-plugin/reference/htmlsingle/#packaging.repackage-goal" target="_blank" rel="noopener">docs.spring.io/spring-boot…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/issues/10921" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/instrumentation/resources/library/README.md#host" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7356138322367266854" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决ECharts图表窗口自适应与数据不渲染</title>
    <url>/7354960709010800677.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中使用 <strong>ECharts</strong> 遇到了一些问题，包括图表不会随着窗口大小变化而变化，以及父组件向子组件传值时，ECharts 中的值不会被同步渲染等，因此写本博文进行记录；</p>
<p>博文中的所有代码全部收集在<a href="https://github.com/sid10t/vue-learn_and_upgrade" target="_blank" rel="noopener">博主的 GitHub 仓库</a>中，相关技术栈专栏如下：</p>
<ul>
<li><a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a>;</li>
<li><a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>;</li>
</ul>
<h1 id="快速上手-ECharts"><a href="#快速上手-ECharts" class="headerlink" title="快速上手 ECharts"></a>快速上手 ECharts</h1><p>在分析解决问题前，我们先复现一下情景。根据 <a href="https://echarts.apache.org/handbook/zh/get-started/" target="_blank" rel="noopener">ECharts 的官方文档</a>，我们快速的在 Vue 中构建 ECharts 图表。</p>
<p>首先，根据<a href="https://echarts.apache.org/handbook/zh/get-started/" target="_blank" rel="noopener">官方文档</a>的提示，在下载好的 ECharts 压缩包中提取 <code>dist/echarts.js</code> 放置在自己项目的目录下，并在项目中进行引用，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts 入门示例&lt;/title&gt;</span><br><span class="line">    &lt;script src=&quot;../../vue.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script src=&quot;../../echarts.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/head&gt;</span><br></pre></td></tr></table></figure>

<p>接着，为 ECharts 准备一个 DOM 容器，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;div id=&quot;main&quot; style=&quot;width: 100%; height:400px;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>最后，通过 <a href="https://echarts.apache.org//api.html#echarts.init" target="_blank" rel="noopener"><code>echarts.init</code></a> 方法初始化一个 ECharts 实例并通过 <a href="https://echarts.apache.org//api.html#echartsInstance.setOption" target="_blank" rel="noopener"><code>setOption</code></a> 方法生成一个简单的柱状图，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;script&gt;</span><br><span class="line">    const app = new Vue(&#123;</span><br><span class="line">        el: &apos;#app&apos;,</span><br><span class="line">        data: &#123;</span><br><span class="line">            option: &#123;</span><br><span class="line">                title: &#123;</span><br><span class="line">                    text: &apos;ECharts 入门示例&apos;</span><br><span class="line">                &#125;,</span><br><span class="line">                tooltip: &#123;&#125;,</span><br><span class="line">                legend: &#123;</span><br><span class="line">                    data: [&apos;销量&apos;]</span><br><span class="line">                &#125;,</span><br><span class="line">                xAxis: &#123;</span><br><span class="line">                    data: [&apos;衬衫&apos;, &apos;羊毛衫&apos;, &apos;雪纺衫&apos;, &apos;裤子&apos;, &apos;高跟鞋&apos;, &apos;袜子&apos;]</span><br><span class="line">                &#125;,</span><br><span class="line">                yAxis: &#123;&#125;,</span><br><span class="line">                series: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        name: &apos;销量&apos;,</span><br><span class="line">                        type: &apos;bar&apos;,</span><br><span class="line">                        data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        mounted() &#123;</span><br><span class="line">            this.initChart()</span><br><span class="line">        &#125;,</span><br><span class="line">        methods: &#123;</span><br><span class="line">            initChart() &#123;</span><br><span class="line">                let myChart = echarts.init(document.getElementById(&apos;main&apos;));</span><br><span class="line">                myChart.setOption(this.option);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c1aa8ce0005d8236e800a7c1d1a127de48730c65915b6d4d164729b87be1ceb" alt="n1.png"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html" target="_blank" rel="noopener">【ECharts 入门示例】代码点击此处跳转</a>。</p>
<h1 id="图表自适应"><a href="#图表自适应" class="headerlink" title="图表自适应"></a>图表自适应</h1><p>在上述构建的场景中，图表并不会随着窗口大小的变化而变化，如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c89b66623f04e2e2cf19cde2188f97d489d78a8183b81d1c4a2c2c6094524e71" alt="n2.png"></p>
<p>为了实现图表的窗口自适应功能，我们需要监听窗口的大小变化，并且同时调整图表的大小，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码mounted() &#123;</span><br><span class="line">    this.initChart()</span><br><span class="line">    if (this.autoResize) &#123;</span><br><span class="line">        window.addEventListener(&apos;resize&apos;, this.resizeChart)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br><span class="line">methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    resizeChart() &#123;</span><br><span class="line">        console.log(&apos;chart resize!&apos;)</span><br><span class="line">        this.chart.resize()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，<code>autoResize</code> 表示是否启动自适应功能，<code>window.addEventListener(&#39;resize&#39;, this.resizeChart)</code> 监听窗口的大小变化，如果窗口大小发生改变，则调用 <code>resizeChart()</code> 方法，<code>resizeChart()</code> 方法中使用了 ECharts 自带的调整图表大小的方法 <code>resize()</code>；</p>
<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/817de377d65437d28675219ec4ff46dcc51932a6f6af922a48725c1695c94771" alt="n3.png"></p>
<p>不过眼尖的读者已经发现了，只是缩小了一点窗口的大小，该方法就被调用了85次，这对我们来说是没有必要的，因为我们不需要实时的去调整窗口大小，只需要在一定时间内完成调整即可，因此引入 <a href="https://www.jsdelivr.com/package/npm/lodash" target="_blank" rel="noopener"><code>loadsh</code></a> 的防抖功能，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;script src=&quot;https://cdn.jsdelivr.net/npm/lodash@4.17.21/lodash.min.js&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">    resizeChart: _.debounce(function () &#123;</span><br><span class="line">        console.log(&apos;chart resize!&apos;)</span><br><span class="line">        this.chart.resize()</span><br><span class="line">    &#125;, 100)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6d5d22ad358f6d394fd6f7927e376e57a082f28a1bb22f13dcf139f0b1f530a8" alt="n4.png"></p>
<p>除了使用 <code>loadsh</code> 的防抖功能来节约资源，提高性能之外，还可以在 Vue 实例被销毁之前，取消监控并销毁 ECharts 实例，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码beforeDestroy() &#123;</span><br><span class="line">    if (!this.chart) &#123;</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.autoResize) &#123;</span><br><span class="line">        window.removeEventListener(&apos;resize&apos;, this.resizeChart)</span><br><span class="line">    &#125;</span><br><span class="line">    this.chart.dispose()</span><br><span class="line">    this.chart = null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94.html" target="_blank" rel="noopener">【ECharts 图表自适应】代码点击此处跳转</a>。</p>
<h1 id="数据不渲染"><a href="#数据不渲染" class="headerlink" title="数据不渲染"></a>数据不渲染</h1><p>在前面的内容中，我们成功地开发了一个适用于特定场景的 Echarts 图表组件。为了让这个组件更具普适性和扩展性，我们计划对其进行一些改进和优化。</p>
<p>首先，我们将 <code>div</code> 元素的属性改进成动态绑定的方式，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;div :class=&quot;className&quot; :style=&quot;&#123; height: height, width: width &#125;&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>然后，设置组件的 <code>props</code> 配置，这些 <code>props</code> 允许在父组件中给子组件传递数据，同时也为这些属性提供了默认值以防止属性未被传递时出现错误，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码props: &#123;</span><br><span class="line">  className: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;DataChild&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  width: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;100%&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  height: &#123;</span><br><span class="line">    type: String,</span><br><span class="line">    default: &quot;500px&quot;,</span><br><span class="line">  &#125;,</span><br><span class="line">  autoResize: &#123;</span><br><span class="line">    type: Boolean,</span><br><span class="line">    default: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  series: &#123;</span><br><span class="line">    type: Array,</span><br><span class="line">    default: null,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>在上述代码中，父组件传入不同的 <code>series</code> 数值，可以动态的改变 ECharts 图表。</p>
<p>接着，我们开始构建父组件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">html复制代码&lt;template&gt;</span><br><span class="line">  &lt;data-child :series=&quot;this.series&quot;&gt;&lt;/data-child&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import DataChild from &quot;./DataChild.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;DataParent&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    DataChild,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      series: [</span><br><span class="line">        &#123;</span><br><span class="line">          name: &quot;..&quot;,</span><br><span class="line">          type: &quot;..&quot;,</span><br><span class="line">          data: [],</span><br><span class="line">        &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  created() &#123;</span><br><span class="line">    this.fetchData();</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    fetchData() &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，通过 <code>fetchData()</code> 方法来获取需要渲染数据，这里的话使用 POSTMAN 来模拟后端服务器发送数据。</p>
<p>创建一个模拟服务器，设置 API 接口与响应数据：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/141feab875a64d25f2accb87f9de2886adfe4e08532a36464c553256e5ccd349" alt="p1.png"></p>
<p>对模拟服务器进行相关配置：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7717db9f5cb5af1cc83424ca71455ad453f566d0ef2adaa76c6a32d803c69fae" alt="p2.png"></p>
<p>通过访问 API 接口来获取数据：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37d520443657f4c81dc6a9368002fe2f4086db04dccd7378f3bdecc837304244" alt="p3.png"></p>
<p>同时也能查看到请求日志：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8c0934c21c19a39f4ab3928623f2baad5ee8d79b8e71d42a455591cfe9972c80" alt="p4.png"></p>
<p>在 Vue 中，我们通过 axios 来请求接口，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码fetchData() &#123;</span><br><span class="line">  const url = &quot;&quot;;</span><br><span class="line">  axios</span><br><span class="line">    .get(url + &quot;/test/data&quot;)</span><br><span class="line">    .then((resp) =&gt; &#123;</span><br><span class="line">      this.series[0].data = resp.data.data;</span><br><span class="line">      console.log(this.series);</span><br><span class="line">    &#125;)</span><br><span class="line">    .catch((err) =&gt; &#123;</span><br><span class="line">      console.log(err);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>然而出现了点问题，数据是请求到了，但是 ECharts 图表并没有渲染上：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdfad029876feb145a313c394f7fda86a68558acaa4197e878d84400757fca16" alt="s1.png"></p>
<p>我们在子组件中也打印一下相关数据，确认父组件的数据是否传递到子组件中，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码console.log(&apos;Child Data Before:&apos;, this.series)</span><br><span class="line">this.initChart();</span><br><span class="line">console.log(&apos;Child Data After:&apos;, this.series)</span><br><span class="line"></span><br><span class="line">initChart() &#123;</span><br><span class="line">  ...</span><br><span class="line">  console.log(&apos;Child Data:&apos;, this.series)</span><br><span class="line">  this.chart.setOption(this.option);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>子组件也确实获取到了数据，那为什么图表不渲染数据呢？</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a2d73d82b9d1e84106d6cec98d3e4f78c0c84da6932c0b3977c2fa149fe4bd6f" alt="s2.png"></p>
<p>这是因为，当父组件需要通过异步 AJAX 请求获取数据来设置子组件的 <code>props</code> 属性时，可能会遇到子组件渲染速度快于 AJAX 请求返回的情况。这种情况下，父组件在 <code>created</code> 或 <code>mounted</code> 生命周期钩子函数执行时，子组件可能已经开始渲染，但是尚未接收到通过 AJAX 请求获得的数据，因此只有默认的 <code>props</code> 值会被子组件使用。</p>
<p>可以通过在父子组件中打点来得知程序的运行情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// parent</span><br><span class="line">created() &#123;</span><br><span class="line">  console.log(&quot;Parent Created Before&quot;);</span><br><span class="line">  this.fetchData();</span><br><span class="line">  console.log(&quot;Parent Created After&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">fetchData() &#123;</span><br><span class="line">  axios</span><br><span class="line">    ...</span><br><span class="line">    .then((resp) =&gt; &#123;</span><br><span class="line">      ...</span><br><span class="line">      console.log(&quot;Parent Fetch Data&quot;);</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">// child</span><br><span class="line">created() &#123;</span><br><span class="line">  console.log(&quot;Child Created&quot;);</span><br><span class="line">&#125;,</span><br><span class="line">mounted() &#123;</span><br><span class="line">  console.log(&quot;Child Mounted Before&quot;);</span><br><span class="line">  this.initChart();</span><br><span class="line">  console.log(&quot;Child Mounted After&quot;);</span><br><span class="line">  ...</span><br><span class="line">&#125;,</span><br><span class="line">initChart() &#123;</span><br><span class="line">  ...</span><br><span class="line">  console.log(&apos;Child Init Data&apos;)</span><br><span class="line">  ...</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b5eea0f3332fb46eb08c85aeed988f2ced228921992014a129adb8f205320493" alt="s3.png"></p>
<p>通过上述的运行结果可知，正如我们所预料的那样，由于父组件的 <code>fetchData()</code> 方法使用了异步请求，因此程序会一直执行下去，并不会因为没有获取到数据而阻塞，当子组件完成图表渲染 <code>initChart()</code> 后，父组件才请求到数据，<strong>因此才造成了子组件图表中的数据不渲染问题</strong>，子组件图表渲染时使用的数据是 <code>props</code> 中的默认值，即空数组。</p>
<p>那如何解决这个问题呢？其实很简单，我们只要监听对应的属性即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码watch: &#123;</span><br><span class="line">  option: &#123;</span><br><span class="line">    handler(newVal, oldVal) &#123;</span><br><span class="line">      if (this.chart) &#123;</span><br><span class="line">        if (newVal) &#123;</span><br><span class="line">          this.chart.setOption(newVal);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          this.chart.setOption(oldVal);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        this.initChart();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: true,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>上述代码之所以监听的是 <code>option</code> 而不是 <code>series</code>，是因为在初始化图表时已经进行了赋值 <code>this.option.series = this.series;</code>，<code>series</code> 本身是 <code>option</code> 的属性，通过 <code>deep: true</code> 也可以监听到 <code>series</code> 发生变化，同时监听 <code>option</code> 还能监听到其他属性。</p>
<p>运行结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d9f850ffa6e58fad52aa3e001b1e6179bd9e8a03b6b4dfc0fff93ef092c0b1fc" alt="s4.png"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/data-rendered/src/components" target="_blank" rel="noopener">【ECharts 数据不渲染】代码点击此处跳转</a>。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>解决 ECharts 图表窗口自适应与数据不渲染问题</em></strong> 的所有内容了，希望本篇博文对大家有所帮助！欢迎大家持续关注我的博客，一起分享学习和成长的乐趣！✨</p>
<p>代码：</p>
<ul>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B.html" target="_blank" rel="noopener">ECharts 入门示例</a>；</li>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/%E5%9B%BE%E8%A1%A8%E8%87%AA%E9%80%82%E5%BA%94.html" target="_blank" rel="noopener">ECharts 图表自适应</a>；</li>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/echarts/data-rendered/src/components" target="_blank" rel="noopener">ECharts 数据不渲染</a>；</li>
</ul>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7221525689856688184">解决 swagger2 默认地址失效</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注，创作不易，请多多支持；</p>
<p>👍 公众号：<strong>sidiot的技术驿站</strong>；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a>；<a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>；<a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7354960709010800677" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>前端,Vue.js,架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Redisstream用做消息队列完美吗?1基础知</title>
    <url>/7357301805569687563.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis Stream 是 Redis 5.0 版本中引入的一种新的数据结构，它用于实现简单但功能强大的消息传递模式。</p>
<p>这篇文章，我们聊聊 Redis Stream 基本用法 ，以及如何在 SpringBoot 项目中应用 Redis Stream 。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2455fe8b4155656ae7cc88bc6b1289ee10d09cf39b53065640e2ee8e0c7e62d5" alt></p>
<h1 id="1-基础知识"><a href="#1-基础知识" class="headerlink" title="1 基础知识"></a>1 基础知识</h1><p>Redis Stream 的结构如下图所示，它是一个消息链表，将所有加入的消息都串起来，每个消息都有一个唯一的 ID 和对应的内容。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4776bf4b53f713c0c722d4c852bf6c05864235aecba83fd841cb8a24ca2b5225" alt></p>
<p>每个 Redis Stream 都有唯一的名称 ，对应唯一的 Redis Key 。</p>
<p>同一个 Stream 可以挂载多个<strong>消费组 ConsumerGroup</strong> , 消费组不能自动创建，需要<strong>使用 XGROUP CREATE 命令创建</strong>。</p>
<p>每个消费组会有个<strong>游标 last_delivered_id</strong>，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动 ，标识当前消费组消费到哪条消息了。</p>
<p>消费组 ConsumerGroup 同样可以挂载多个消费者 Consumer , 每个 Consumer 并行的读取消息，任意一个消费者读取了消息都会使游标 last_delivered_id 往前移动。</p>
<p>消费者内部有一个属性 <strong>pending_ids</strong> ， 记录了当前消费者读取但没有回复 ACK 的消息 ID 列表 。</p>
<h1 id="2-核心命令"><a href="#2-核心命令" class="headerlink" title="2 核心命令"></a>2 核心命令</h1><h2 id="01-XADD-向-Stream-末尾添加消息"><a href="#01-XADD-向-Stream-末尾添加消息" class="headerlink" title="01 XADD 向 Stream 末尾添加消息"></a>01 XADD 向 Stream 末尾添加消息</h2><p>使用 XADD 向队列添加消息，如果指定的队列不存在，则创建一个队列。基础语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码XADD key ID field value [field value ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key</strong> ：队列名称，如果不存在就创建</li>
<li><strong>ID</strong> ：消息 id，我们使用 * 表示由 redis 生成，可以自定义，但是要自己保证递增性。</li>
<li><strong>field value</strong> ： 记录。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XADD mystream * name1 value1 name2 value2</span><br><span class="line">&quot;1712473185388-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XLEN mystream</span><br><span class="line">(integer) 1</span><br><span class="line">127.0.0.1:6379&gt; XADD mystream * name2 value2 name3 value3</span><br><span class="line">&quot;1712473231761-0&quot;</span><br></pre></td></tr></table></figure>

<p>消息 ID 使用 * 表示由 redis 生成，同时也可以自定义，但是自定义时要保证递增性。</p>
<blockquote>
<p>消息 ID 的格式： 毫秒级时间戳 + 序号 , 例如：1712473185388-5 , 它表示当前消息在毫秒时间戳 1712473185388 产生 ，并且该毫秒内产生到了第5条消息。</p>
</blockquote>
<p>在添加队列消息时，也<strong>可以指定队列的长度</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XADD mystream MAXLEN 100 * name value1 age 30</span><br><span class="line">&quot;1713082205042-0&quot;</span><br></pre></td></tr></table></figure>

<p>使用 XADD 命令向 <code>mystream</code> 的 stream 中添加了一条消息，并且指定了最大长度为 100。消息的 ID 由 Redis 自动生成，消息包含两个字段 <code>name</code> 和 <code>age</code>，分别对应的值是 <code>value1</code> 和 <code>30</code>。</p>
<h2 id="02-XRANGE-获取消息列表"><a href="#02-XRANGE-获取消息列表" class="headerlink" title="02 XRANGE 获取消息列表"></a>02 XRANGE 获取消息列表</h2><p>使用 XRANGE 获取消息列表，会自动过滤已经删除的消息。语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码XRANGE key start end [COUNT count]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>key</strong> ：队列名</li>
<li><strong>start</strong> ：开始值， <strong>-</strong> 表示最小值</li>
<li><strong>end</strong> ：结束值， <strong>+</strong> 表示最大值</li>
<li><strong>count</strong> ：数量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XRANGE mystream - + COUNT 2</span><br><span class="line">1) 1) &quot;1712473185388-0&quot;</span><br><span class="line">   2) 1) &quot;name1&quot;</span><br><span class="line">      2) &quot;value1&quot;</span><br><span class="line">      3) &quot;name2&quot;</span><br><span class="line">      4) &quot;value2&quot;</span><br><span class="line">2) 1) &quot;1712473231761-0&quot;</span><br><span class="line">   2) 1) &quot;name2&quot;</span><br><span class="line">      2) &quot;value2&quot;</span><br><span class="line">      3) &quot;name3&quot;</span><br><span class="line">      4) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>我们得到两条消息，第一层是消息 ID ，第二层是消息内容 ，消息内容是 Hash 数据结构 。</p>
<h2 id="03-XREAD-以阻塞-非阻塞方式获取消息列表"><a href="#03-XREAD-以阻塞-非阻塞方式获取消息列表" class="headerlink" title="03 XREAD 以阻塞/非阻塞方式获取消息列表"></a>03 XREAD 以阻塞/非阻塞方式获取消息列表</h2><p>使用 XREAD 以阻塞或非阻塞方式获取消息列表 ，语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] id [id ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>count</strong> ：数量</li>
<li><strong>milliseconds</strong> ：可选，阻塞毫秒数，没有设置就是非阻塞模式</li>
<li><strong>key</strong> ：队列名</li>
<li><strong>id</strong> ：消息 ID</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XREAD streams mystream 0-0</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1712473185388-0&quot;</span><br><span class="line">         2) 1) &quot;name1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">            3) &quot;name2&quot;</span><br><span class="line">            4) &quot;value2&quot;</span><br><span class="line">      2) 1) &quot;1712473231761-0&quot;</span><br><span class="line">         2) 1) &quot;name2&quot;</span><br><span class="line">            2) &quot;value2&quot;</span><br><span class="line">            3) &quot;name3&quot;</span><br><span class="line">            4) &quot;value3&quot;</span><br></pre></td></tr></table></figure>

<p>XRED 读消息时分为<strong>阻塞</strong>和<strong>非阻塞</strong>模式，使用 <strong>BLOCK</strong> 选项可以表示阻塞模式，需要设置阻塞时长。非阻塞模式下，读取完毕（即使没有任何消息）立即返回，而在阻塞模式下，若读取不到内容，则阻塞等待。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XREAD block 1000 streams mystream $</span><br><span class="line">(nil)</span><br><span class="line">(1.07s)</span><br></pre></td></tr></table></figure>

<p>使用 Block 模式，配合 $ 作为 ID ，表示读取最新的消息，若没有消息，命令阻塞！等待过程中，其他客户端向队列追加消息，则会立即读取到。</p>
<p>因此，典型的队列就是 XADD 配合 XREAD Block 完成。XADD 负责生成消息，XREAD 负责消费消息。</p>
<h2 id="04-XGROUP-CREATE-创建消费者组"><a href="#04-XGROUP-CREATE-创建消费者组" class="headerlink" title="04 XGROUP CREATE 创建消费者组"></a>04 XGROUP CREATE 创建消费者组</h2><p>使用 XGROUP CREATE 创建消费者组，分两种情况：</p>
<ul>
<li>从头开始消费:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码XGROUP CREATE mystream consumer-group-name 0-0</span><br></pre></td></tr></table></figure>

<ul>
<li>从尾部开始消费:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码XGROUP CREATE mystream consumer-group-name $</span><br></pre></td></tr></table></figure>

<p>执行效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XGROUP CREATE mystream mygroup 0-0</span><br><span class="line">OK</span><br></pre></td></tr></table></figure>

<h2 id="05-XREADGROUP-GROUP-读取消费组中的消息"><a href="#05-XREADGROUP-GROUP-读取消费组中的消息" class="headerlink" title="05 XREADGROUP GROUP 读取消费组中的消息"></a>05 XREADGROUP GROUP 读取消费组中的消息</h2><p>使用 XREADGROUP GROUP 读取消费组中的消息，语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码XREADGROUP GROUP group consumer [COUNT count] [BLOCK milliseconds] [NOACK] STREAMS key [key ...] ID [ID ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><strong>group</strong> ：消费组名</li>
<li><strong>consumer</strong> ：消费者名。</li>
<li><strong>count</strong> ： 读取数量。</li>
<li><strong>milliseconds</strong> ： 阻塞毫秒数。</li>
<li><strong>key</strong> ： 队列名。</li>
<li><strong>ID</strong> ： 消息 ID。</li>
</ul>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt;  XREADGROUP group mygroup consumerA count 1 streams mystream &gt;</span><br><span class="line">1) 1) &quot;mystream&quot;</span><br><span class="line">   2) 1) 1) &quot;1712473185388-0&quot;</span><br><span class="line">         2) 1) &quot;name1&quot;</span><br><span class="line">            2) &quot;value1&quot;</span><br><span class="line">            3) &quot;name2&quot;</span><br><span class="line">            4) &quot;value2&quot;</span><br></pre></td></tr></table></figure>

<p>消费者组 <code>mygroup</code> 中的消费者 <code>consumerA</code> ，从 名为 <code>mystream</code> 的 Stream 中读取消息。</p>
<ul>
<li><code>COUNT 1</code> 表示一次最多读取一条消息</li>
<li><code>&gt;</code> 表示消息的起始位置是当前可用消息的 ID，即从当前未读取的最早消息开始读取。</li>
</ul>
<h2 id="06-XACK-消息消费确认"><a href="#06-XACK-消息消费确认" class="headerlink" title="06 XACK 消息消费确认"></a>06 XACK 消息消费确认</h2><p>接收到消息之后，我们要手动确认一下（ack），语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码xack key group-key ID [ID ...]</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XACK mystream mygroup 1713089061658-0</span><br><span class="line">(integer) 1</span><br></pre></td></tr></table></figure>

<p>消费确认增加了消息的可靠性，一般在业务处理完成之后，需要执行 ack 确认消息已经被消费完成，整个流程的执行如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/07ee8b4f0ad2f007285ed2a2b0fe62b803809e6f8c2eca35fb5690a53b3e0a28" alt></p>
<p>我们可以使用 xpending 命令查看<strong>消费者未确认的消息ID</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; xpending mystream mygroup</span><br><span class="line">1) (integer) 1</span><br><span class="line">2) &quot;1713091227595-0&quot;</span><br><span class="line">3) &quot;1713091227595-0&quot;</span><br><span class="line">4) 1) 1) &quot;consumerA&quot;</span><br><span class="line">      2) &quot;1&quot;</span><br></pre></td></tr></table></figure>

<h2 id="07-XTRIM-限制-Stream-长度"><a href="#07-XTRIM-限制-Stream-长度" class="headerlink" title="07 XTRIM 限制 Stream 长度"></a>07 XTRIM 限制 Stream 长度</h2><p>我们使用 XTRIM 对流进行修剪，限制长度， 语法格式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码127.0.0.1:6379&gt; XADD mystream * field1 A field2 B field3 C field4 D</span><br><span class="line">&quot;1712535017402-0&quot;</span><br><span class="line">127.0.0.1:6379&gt; XTRIM mystream MAXLEN 2</span><br><span class="line">(integer) 4</span><br><span class="line">127.0.0.1:6379&gt; XRANGE mystream - +</span><br><span class="line">1) 1) &quot;1712498239430-0&quot;</span><br><span class="line">   2) 1) &quot;name&quot;</span><br><span class="line">      2) &quot;zhangyogn&quot;</span><br><span class="line">2) 1) &quot;1712535017402-0&quot;</span><br><span class="line">   2) 1) &quot;field1&quot;</span><br><span class="line">      2) &quot;A&quot;</span><br><span class="line">      3) &quot;field2&quot;</span><br><span class="line">      4) &quot;B&quot;</span><br><span class="line">      5) &quot;field3&quot;</span><br><span class="line">      6) &quot;C&quot;</span><br><span class="line">      7) &quot;field4&quot;</span><br><span class="line">      8) &quot;D&quot;</span><br></pre></td></tr></table></figure>

<h1 id="3-SpringBoot-Redis-Stream-实战"><a href="#3-SpringBoot-Redis-Stream-实战" class="headerlink" title="3 SpringBoot Redis Stream 实战"></a>3 SpringBoot Redis Stream 实战</h1><p><strong>1、添加 SpringBoot Redis 依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2、yaml 文件配置</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/301bf51f03671472c93d10ab46791914ee1757087a47579ce850ca3471b4c8ac" alt></p>
<p><strong>3、RedisTemplate 配置</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3bba11fd415f2adc5f770f9c6ff51279646c748b564af5b6e38eb9485d77a48b" alt></p>
<p><strong>4、定义stream监听器</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/34b2912b1b7f8ae95f8c04366864c5b15b7afc9b88c227542cbb18e1ef60ff5b" alt></p>
<p><strong>5、定义streamcontainer 并启动</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8e15539a8d63714a1977ae33c56bde339ef0a2692e24b6b207e43615e3340ac2" alt></p>
<p><strong>6、发送消息</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/32edf7403232acc07aa0e5ce32a101ac5b8a93a00b2e6094887187b23bd2e454" alt></p>
<p>执行完成之后，消费者就可以打印如下日志：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/174bca8cfe61c29ab45cd7cf40787e02fd4793f4b30e0d9223185d3c5b3da68f" alt></p>
<p>演示代码地址：</p>
<blockquote>
<p><a href="https://github.com/makemyownlife/courage-cache-demo" target="_blank" rel="noopener">github.com/makemyownli…</a></p>
</blockquote>
<h1 id="4-Redis-stream-用做消息队列完美吗"><a href="#4-Redis-stream-用做消息队列完美吗" class="headerlink" title="4 Redis stream 用做消息队列完美吗"></a>4 Redis stream 用做消息队列完美吗</h1><p>笔者认为 Redis stream 用于消息队列最大的进步在于：<strong>实现了发布订阅模型</strong>。</p>
<p>发布订阅模型具有如下特点：</p>
<ul>
<li><strong>消费独立</strong></li>
</ul>
<p>相比队列模型的匿名消费方式，发布订阅模型中消费方都会具备的身份，一般叫做订阅组（订阅关系），不同订阅组之间相互独立不会相互影响。</p>
<ul>
<li><strong>一对多通信</strong></li>
</ul>
<p>基于独立身份的设计，同一个主题内的消息可以被多个订阅组处理，每个订阅组都可以拿到全量消息。因此发布订阅模型可以实现一对多通信。</p>
<p>细品 Redis stream 的设计，我们发现它和 Kafka 非常相似，比如说消费者组，消费进度偏移量等。</p>
<p>我们曾经诟病 Redis List 数据结构用做队列时，因为消费时没有 Ack 机制，应用异常挂掉导致消息偶发丢失的情况，Redis Stream 已经完美的解决了。</p>
<p>因为消费者内部有一个属性 <strong>pending_ids</strong> ， 记录了当前消费者读取但没有回复 ACK 的消息 ID 列表 。当消费者重新上线，这些消息可以重新被消费。</p>
<p>但 Redis stream 用做消息队列完美吗 ？</p>
<p><strong>这个真没有！</strong> 。</p>
<p>1、Redis 本身定位是<strong>内存数据库</strong>，它的设计之初都是为缓存准备的，<strong>并不具备消息堆积的能力</strong>。而专业消息队列一个非常重要的功能是<strong>数据中转枢纽</strong>，Redis 的定位很难满足，所以使用起来要非常小心。</p>
<p>2、Redis 的高可用方案可能丢失消息（AOF 持久化 和 主从复制都是异步 ），而专业消息队列可以针对不同的场景选择不同的高可用策略。</p>
<p>所以，笔者认为 Redis 非常适合轻量级消息队列解决方案，轻量级意味着：数据量可控 + 业务模型简单 。</p>
<hr>
<p>参考文章：</p>
<blockquote>
<p><a href="https://redis.io/docs/data-types/streams/" target="_blank" rel="noopener">redis.io/docs/data-t…</a></p>
<p><a href="https://www.runoob.com/redis/redis-stream.html" target="_blank" rel="noopener">www.runoob.com/redis/redis…</a></p>
<p><a href="https://pdai.tech/md/db/nosql-redis/db-redis-data-type-stream.html" target="_blank" rel="noopener">pdai.tech/md/db/nosql…</a></p>
</blockquote>
<hr>
<p>如果我的文章对你有所帮助，还请帮忙<strong>点赞、在看、转发</strong>一下，你的支持会激励我输出更高质量的文章，非常感谢！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357301805569687563" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式锁实战</title>
    <url>/7354929072957702144.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>柯苏远写于2024年4月7日 20点10分</p>
<p>公司的主要业务线是国外电商，之前是在客户下订单，以及厂商对客户订单进行打包发货等关键节点都会给客户发送对应邮件。</p>
<p>可是由于邮件没有短信那么及时，方便，为了提高客户的体验和下单率准备在整个系统接入短信。</p>
<p>所以这里就涉及到要和国外通讯商对接短信发送的接口。</p>
<p>这里主要是两个接口：一个是获取token接口，一个是发送短信接口。<strong>获取token的接口一个小时之内只能获取5次，一次获取到的token有效期是一个小时。</strong></p>
<h2 id="简单-token-缓存设计"><a href="#简单-token-缓存设计" class="headerlink" title="简单 token 缓存设计"></a>简单 token 缓存设计</h2><p>根据背景描述，显而易见的是，token必须要缓存起来，因为一个小时就只能获取5次，所以必须尽量重复使用，以下是我的设想的接口调用情况：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/931970573cab39f90b6378091c2a504b9396ff33cbc309f4a2d36b2a1b66994f" alt="获取token-进阶.jpg"></p>
<p>从直观感受上来讲，确实是可以了，我们通常的设计一般情况下都不会考虑多线程并发的情况。</p>
<p><strong>但是！！！ 我们的业务项目是电商欸，肯定会存在并发的可能。</strong></p>
<p><strong>所以我将方案给我老大看了之后，我老大一眼就看出我没有考虑并发问题，要我重新去设计。</strong></p>
<h2 id="并发-token-缓存设计"><a href="#并发-token-缓存设计" class="headerlink" title="并发 token 缓存设计"></a>并发 token 缓存设计</h2><p>由于上一版的核心就是没考虑并发，如果此时100个线程同时去缓存获取并且同时没获取到，再然后同时去调用了短信的api，那么这个api一分钟5次的限制一下子就到了峰值。</p>
<p>考虑到并发点，我引入了分布式锁，对之前方案做了更新，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b62bd491d872553145744ace1b24f3ae4e0fbba03a13b09f8eb84056c448616d" alt="获取token流程-私人版.jpg"></p>
<p>整个流程图看起来复杂了很多，其实和上面方案比较起来主要就两点：</p>
<ol>
<li>在调用api之前加了分布式锁，在取得token之后，释放分布式锁。</li>
<li>如果在一个线程持有分布式锁的情况，其它线程进来没获取锁，就让它们冷处理，类似一个while循环操作，然后睡眠200毫秒，循环15次去缓存里取。如果15次都没有从缓存里取到token对象，那么就要进行去抢夺分布式锁，如果抢夺成功那么执行调用api流程，如果失败，那么再去缓存看看，有的话直接返回token对象，没有的话再去抢夺分布式锁。</li>
</ol>
<h2 id="具体实现-amp-当前问题"><a href="#具体实现-amp-当前问题" class="headerlink" title="具体实现 &amp; 当前问题"></a>具体实现 &amp; 当前问题</h2><p>具体实现分布式锁：</p>
<ul>
<li>在项目里用的是redisTemplate，有一个setIfAbsent，然后再结合expire(<strong>项目里是10s</strong>)，用这两个命令来获取分布式锁。</li>
<li>释放的时候直接就是delete。</li>
</ul>
<p>其实这种实现方式是不严谨的，有如下缺点：</p>
<ul>
<li>setIfAbsent和expire：这两个不是原子命令，如果setIfAbsent成功，由于某种原因expire没有成功，那么就会造成死锁，这个分布式锁会得不到释放。</li>
<li>expire 这里设置的过期时间是10s，但是如果我业务执行时间大于10s呢？分布式锁就失效了，那还搞个毛线？其它线程也进我的临界区了，线程不安全了。</li>
<li>delete是直接删除的，没有考虑某种未知错误造成删除失败的原因。这个其实是小问题，即使删除失败也有超时的保证。</li>
</ul>
<p><strong>这三个目前存在的问题和老大聊了，老大说确实是有这问题，然后后面研究一下redisson，然后完善一下这个分布式锁，后面等手头活少点去研究一下。</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>api token 缓存设计</li>
<li>多线程下 api token 缓存设计</li>
<li>分布式锁的实现 &amp; 目前存在的问题</li>
<li>后续目标：研究redisson实现分布式锁。</li>
</ol>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7354929072957702144#comment" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>详解MySQL自定义函数</title>
    <url>/7357390581302493195.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>在实际开发过程中。业务是复杂多变的；在大多数情况下我们都会将这些复杂多变的东西放到代码里面去处理，但是你知道吗，MySQL本身也是支持我们去自定义函数处理这些内容的。</p>
<p>在本文中，我们将一起学习一下自定义函数。</p>
</blockquote>
<h2 id="一-自定义函数的概念"><a href="#一-自定义函数的概念" class="headerlink" title="一. 自定义函数的概念"></a>一. 自定义函数的概念</h2><h3 id="1-1-什么是MySQL自定义函数"><a href="#1-1-什么是MySQL自定义函数" class="headerlink" title="1.1 什么是MySQL自定义函数"></a>1.1 什么是MySQL自定义函数</h3><p>MySQL自定义函数是用户根据自己的需求和逻辑编写的特定功能的函数。它们是在MySQL数据库中创建的，可以根据用户定义的输入参数执行特定的操作，并返回一个结果。</p>
<h3 id="1-2-存储过程和自定义函数的区别"><a href="#1-2-存储过程和自定义函数的区别" class="headerlink" title="1.2 存储过程和自定义函数的区别"></a>1.2 存储过程和自定义函数的区别</h3><ul>
<li>存储过程（Stored Procedure）是一组预编译的SQL语句，它们一起执行一系列操作。存储过程通常用于执行一些复杂的业务逻辑或批处理操作。它们可以接受输入参数，并且可以返回多个结果集。存储过程通常用于执行数据操作，如插入、更新和删除数据。</li>
<li>自定义函数（Function）是一个具有特定功能的代码块，接受输入参数并返回一个值。函数可以在SQL查询中使用，作为表达式的一部分。它们通常用于计算和转换数据，而不像存储过程那样执行复杂的操作。函数可以返回一个标量值（如整数、字符串等），也可以返回一个表。</li>
</ul>
<h3 id="1-3-自定义函数与内置函数的关系"><a href="#1-3-自定义函数与内置函数的关系" class="headerlink" title="1.3 自定义函数与内置函数的关系"></a>1.3 自定义函数与内置函数的关系</h3><ul>
<li>自定义函数是由用户编写的，用于满足特定需求的函数。</li>
<li>内置函数是MySQL提供的已经实现的函数，用于执行常见的操作，如数学计算、字符串处理等。内置函数是MySQL自身提供的一组功能强大的函数库，可以直接在查询中使用。</li>
<li>用户可以在自定义函数中调用内置函数，以扩展其功能或组合使用。因此，自定义函数可以使用内置函数来完成更复杂的任务。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1437ba600563d31873006268b9fed1be50b5a0dbd582400043b5154c7e442df8" alt="image.png"></p>
<h2 id="二-自定义函数的类型"><a href="#二-自定义函数的类型" class="headerlink" title="二. 自定义函数的类型"></a>二. 自定义函数的类型</h2><p>自定义函数的类型根据使用场景和函数返回的结果类型和形式来进行分类，大概可以分为以下三类：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/731eabb01ed2d8e6968a856717ca8750096674257ecd6a2b74cb2b1f6db785cd" alt="518B7944-C304-4343-9F5F-C138D5D0E35C.png"></p>
<ol>
<li><strong>标量函数（Scalar Function）</strong> ：这种函数接收一组输入参数，并返回一个单一的标量值，如整数、字符串、日期等。标量函数经常用于计算和转换数据，例如计算年龄、字符串拼接、日期格式化等。</li>
<li><strong>聚合函数（Aggregate Function）</strong> ：聚合函数接收一组输入值，并对它们进行聚合计算，返回一个单一的结果。常见的聚合函数包括<code>SUM</code>（求和）、<code>AVG</code>（平均值）、<code>COUNT</code>（计数）、<code>MAX</code>（最大值）<code>和MIN</code>（最小值）。聚合函数通常与<code>GROUP BY</code>子句一起使用。</li>
<li><strong>表值函数（Table-Valued Function）</strong> ：表值函数返回一个结果集，可以像表一样进行查询和操作。它可以作为查询的数据源，与普通的表一起使用。表值函数可以返回单个结果集或多个结果集。常见的表值函数包括行生成函数（<code>ROW GENERATO</code>R）和表返回函数（<code>TABLE-RETURNING</code>）。这三种类型是从什么维度划分的</li>
</ol>
<blockquote>
<p>注意：千万不要把存储过程和自定义函数混为一谈，虽然都是写一堆sql代码，但是无论是语法和使用姿势，他们都不是一个东西。</p>
</blockquote>
<h2 id="三-创建自定义函数的步骤"><a href="#三-创建自定义函数的步骤" class="headerlink" title="三. 创建自定义函数的步骤"></a>三. 创建自定义函数的步骤</h2><h3 id="3-1-创建自定义函数步骤"><a href="#3-1-创建自定义函数步骤" class="headerlink" title="3.1 创建自定义函数步骤"></a>3.1 创建自定义函数步骤</h3><p>创建自定义函数的步骤可以分为以下步骤：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/36625bf89003dea3391cf5f6f8b40f27eec9752bb72c8cb8bf9b87686689370e" alt="image.png"></p>
<ol>
<li><strong>确定函数需求</strong>：明确函数的功能、输入参数和返回值类型。</li>
<li><strong>编写函数代码</strong>：使用MySQL支持的编程语言（如SQL）编写函数的逻辑代码。可以使用控制结构、变量、内置函数等来实现所需的功能。</li>
<li><strong>创建函数</strong>：使用CREATE FUNCTION语句创建函数并将函数代码添加到数据库中。</li>
<li><strong>设置参数和返回值</strong>：根据函数需求，设置函数的输入参数和返回值类型。</li>
<li><strong>测试函数</strong>：使用适当的测试数据和参数调用函数，确保函数能够正确运行并返回预期的结果。</li>
</ol>
<h3 id="3-2-创建自定义函数的语法"><a href="#3-2-创建自定义函数的语法" class="headerlink" title="3.2 创建自定义函数的语法"></a>3.2 创建自定义函数的语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码CREATE FUNCTION function_name ([parameter_list])</span><br><span class="line">    RETURNS return_type</span><br><span class="line">    [characteristics]</span><br><span class="line">    BEGIN</span><br><span class="line">        -- 函数逻辑代码</span><br><span class="line">        RETURN expression;</span><br><span class="line">    END;</span><br></pre></td></tr></table></figure>

<ul>
<li>上面大写的内容都是语法固定值</li>
<li><code>function_name</code>是函数的名称，可以根据实际需求进行命名</li>
<li><code>parameter_list</code>是函数的输入参数列表，可以包含零个或多个参数。每个参数由名称、数据类型和其他属性组成</li>
<li><code>characteristics</code>是可选项，用于定义函数的属性，如语言、安全性、SQL数据访问等</li>
<li><code>BEGIN</code>和<code>END</code>之间是函数的逻辑代码，用于实现所需的功能</li>
<li><code>return_type</code>是函数的返回值类型，表示函数返回的结果的数据类型</li>
<li><code>RETURN</code>语句用于指定函数的返回值，可以使用表达式来计算返回值</li>
</ul>
<h3 id="3-3-自定义函数示例"><a href="#3-3-自定义函数示例" class="headerlink" title="3.3 自定义函数示例"></a>3.3 自定义函数示例</h3><p><strong>用户故事</strong>：作为一个电商平台，我有自己的会员体系，现在我希望根据我的会员体系来计算不同的积分</p>
<p><strong>需求</strong>：根据用户的购买行为给予积分奖励，不同等级的用户可能会有不同的积分回报率。普通用户，按5%计算积分；银牌用户，按10%计算积分；金牌用户，按15%计算积分</p>
<ul>
<li>自定义函数实现：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码CREATE FUNCTION CalculateRewardPoints(price DECIMAL(10,2), user_level INT)</span><br><span class="line">RETURNS INT</span><br><span class="line">BEGIN</span><br><span class="line">    DECLARE points INT;</span><br><span class="line">    IF user_level = 1 THEN</span><br><span class="line">        SET points = FLOOR(price * 0.05); -- 普通用户，按5%计算积分</span><br><span class="line">    ELSEIF user_level = 2 THEN</span><br><span class="line">        SET points = FLOOR(price * 0.1); -- 银牌用户，按10%计算积分</span><br><span class="line">    ELSEIF user_level = 3 THEN</span><br><span class="line">        SET points = FLOOR(price * 0.15); -- 金牌用户，按15%计算积分</span><br><span class="line">    END IF;</span><br><span class="line">    RETURN points;</span><br><span class="line">END</span><br></pre></td></tr></table></figure>

<ul>
<li>使用方法：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码select CalculateRewardPoints(109, 1) as score;</span><br><span class="line">-- 运行结果：5</span><br><span class="line">select CalculateRewardPoints(109, 2) as score;</span><br><span class="line">-- 运行结果：10</span><br><span class="line">select CalculateRewardPoints(109, 3) as score;</span><br><span class="line">-- 运行结果：16</span><br></pre></td></tr></table></figure>

<h2 id="四-自定义函数的使用场景"><a href="#四-自定义函数的使用场景" class="headerlink" title="四. 自定义函数的使用场景"></a>四. 自定义函数的使用场景</h2><p>MySQL自定义函数具有广泛的使用场景，以下是几个常见的使用场景</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/73d646eb27261a4c2ed8c91957d8e864b146f905fb9fc047fe37072c8eb4f3fe" alt="image.png"></p>
<p>通过自定义函数，可以提高数据库的灵活性、可读性和可维护性，使数据库应用更加强大和高效。</p>
<h2 id="五-自定义函数的性能考虑"><a href="#五-自定义函数的性能考虑" class="headerlink" title="五. 自定义函数的性能考虑"></a>五. 自定义函数的性能考虑</h2><h3 id="5-1-自定义函数对数据库性能的潜在影响"><a href="#5-1-自定义函数对数据库性能的潜在影响" class="headerlink" title="5.1 自定义函数对数据库性能的潜在影响"></a>5.1 自定义函数对数据库性能的潜在影响</h3><p>自定义函数对数据库性能可能产生潜在影响，主要体现在以下几个方面：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3ac61e14d9b9e00be99f4fe3cf029af67501e3e7ebbca48f9396591fd1629fe2" alt="image.png"></p>
<ol>
<li><strong>函数调用开销</strong>：每次调用函数都需要进行函数的解析、编译和执行，这会增加一定的开销。如果函数在大量的查询中频繁调用，可能会导致性能下降。</li>
<li><strong>函数执行时间</strong>：函数内部的逻辑代码执行时间可能会对性能产生影响。如果函数的逻辑复杂或处理大量数据的计算，可能会导致函数执行时间较长，从而影响查询的整体性能。</li>
<li><strong>函数与查询优化器</strong>：自定义函数的使用可能会限制查询优化器的优化能力。查询优化器在选择执行计划时，可能无法准确估计函数的执行成本，从而导致选择不够优化的执行计划。</li>
</ol>
<h3 id="5-2-优化自定义函数性能的方向"><a href="#5-2-优化自定义函数性能的方向" class="headerlink" title="5.2 优化自定义函数性能的方向"></a>5.2 优化自定义函数性能的方向</h3><p>为了优化自定义函数的性能，可以从以下入手：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/70450c65a671aba13fad4e90a3c49789257c7160c040992cb0c6c99c82cbc7aa" alt="image.png"></p>
<ol>
<li><strong>减少函数调用次数</strong>：尽量减少函数的调用次数，特别是在大规模数据查询中。可以通过优化查询语句或重构函数逻辑，减少函数的使用频率。</li>
<li><strong>避免在WHERE子句中使用函数</strong>：在WHERE子句中使用函数可能会导致无法使用索引，影响查询性能。尽量避免将函数应用于WHERE子句中的列，以充分利用索引优化查询。</li>
<li><strong>使用内置函数替代自定义函数</strong>：MySQL提供了许多内置函数，这些函数经过优化和性能测试，通常比自定义函数具有更好的性能。如果有适用的内置函数可用，优先选择使用内置函数。</li>
<li><strong>考虑使用存储过程或触发器</strong>：对于复杂的业务逻辑，可以考虑使用存储过程或触发器来代替自定义函数。存储过程和触发器可以与数据库紧密集成，执行效率较高。</li>
<li><strong>使用函数结果缓存</strong>：如果函数的计算结果在短时间内保持不变，可以考虑使用缓存来存储函数的结果，避免重复计算。可以使用MySQL的缓存机制或自定义缓存表来实现。</li>
<li><strong>定期优化数据库结构和查询</strong>：通过定期的数据库结构优化和查询优化，可以提高整体性能。包括创建适当的索引、合理划分数据表、优化查询语句等。</li>
</ol>
<blockquote>
<p>这里要说一个特别特别重要的：</p>
<p>1、函数使用要综合考虑，不能滥用；</p>
<p>2、使用了函数一定要做性能测试，不要觉得自己写的就牛逼轰轰的</p>
</blockquote>
<h2 id="六-自定义函数的维护"><a href="#六-自定义函数的维护" class="headerlink" title="六. 自定义函数的维护"></a>六. 自定义函数的维护</h2><p>现在的大部分开发，都有一个习惯，开发任务上线就Over了，没有持续打磨自己的功能，也没有有效的维护自己的项目，在自定义函数的时候，实际也是需要维护的；管理和维护自定义函数是确保其正常运行和性能的重要方面。</p>
<p>以下是管理和维护自定义函数的方法和技巧：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a770b6712f5d1a897d058b4e7b8d84230a0266d806ed13c13f7bdc8d51d292ff" alt="image.png"></p>
<ol>
<li><strong>备份自定义函数</strong>：定期备份数据库，包括自定义函数的定义和相关数据。这样可以在需要时还原函数或迁移至其他环境。</li>
<li><strong>版本控制</strong>：使用版本控制系统（如Git）对自定义函数的代码进行管理。这样可以跟踪和管理函数的修改历史，并方便团队合作和回滚操作。</li>
<li><strong>文档和注释</strong>：为自定义函数编写清晰的文档和注释，描述函数的用途、参数、返回值以及实现逻辑。这样可以方便其他开发人员理解和使用函数，并在维护时提供参考。</li>
<li><strong>监控函数性能</strong>：使用MySQL的性能监控工具（如EXPLAIN和SHOW PROFILE）来监视自定义函数的性能表现。通过分析查询执行计划和性能统计信息，可以发现潜在的性能瓶颈和优化机会。</li>
<li><strong>定期优化和重构</strong>：根据实际需求和性能问题，定期对自定义函数进行优化和重构。优化包括改进函数逻辑、使用更高效的算法、减少函数调用次数等，以提高函数的性能和可维护性。</li>
<li><strong>测试和验证</strong>：在对自定义函数进行更改或更新之前，进行充分的测试和验证。使用适当的测试数据和参数调用函数，确保函数在各种情况下都能返回正确的结果。</li>
<li><strong>错误处理和日志记录</strong>：在自定义函数中实现适当的错误处理机制，并在需要时记录错误日志。这样可以帮助诊断和解决函数中的问题，并及时修复潜在的错误。</li>
</ol>
<h2 id="七-总结"><a href="#七-总结" class="headerlink" title="七. 总结"></a>七. 总结</h2><p>自定义函数在MySQL数据库中提供了强大的扩展能力，使得开发者能够根据具体的业务需求来创建特定的功能。这些函数可以直接在数据库层面处理数据，减少了应用程序与数据库之间的数据传输，提高了数据处理的效率和性能。</p>
<p>自定义函数在电商平台、金融分析、数据报告等多个领域都有着广泛的应用。例如，在电商平台中，可以根据用户的购买行为和会员等级计算积分；在金融分析中，可以用于计算投资组合的风险指标；在数据报告中，可以用于生成动态的数据汇总和图表。</p>
<p>当然尽管自定义函数带来了许多优势，但不合理的使用也可能引发一些问题，如性能下降、代码可读性降低等。因此，合理使用自定义函数至关重要。</p>
<blockquote>
<p>希望本文对您有所帮助。如果有任何错误或建议，请随时指正和提出。</p>
<p>同时，如果您觉得这篇文章有价值，请考虑点赞和收藏。这将激励我进一步改进和创作更多有用的内容。</p>
<p>感谢您的支持和理解！</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357390581302493195" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,MySQL,SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAIchemy异步DBManager封装-01入门理</title>
    <url>/7357703852726911016.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>SQLAlchemy 是一个强大的 Python SQL 工具包和对象关系映射（ORM）系统，是业内比较流行的ORM，设计非常优雅。随着其2.0版本的发布，SQLAlchemy 引入了原生的异步支持，这极大地增强了其在处理高并发和异步I/O场景下的能力。通过结合像greenlet、gevent这样的协程库，SQLAlchemy 使得异步数据库操作成为可能，从而提高了应用程序的性能和响应速度。</p>
<p>这里我将基于SQLAlchemy的异步支持，封装一些常用的增删改查（CRUD）操作到 <a href="https://github.com/HuiDBK/py-tools" target="_blank" rel="noopener">github.com/HuiDBK/py-t…</a> 中，以便在项目开发中更加便捷地使用。</p>
<p>Github: <a href="https://github.com/sqlalchemy/sqlalchemy" target="_blank" rel="noopener">github.com/sqlalchemy/…</a></p>
<p>2.0文档：<a href="https://docs.sqlalchemy.org/en/20/index.html" target="_blank" rel="noopener">docs.sqlalchemy.org/en/20/index…</a></p>
</blockquote>
<h1 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h1><p>封装前，先简单介绍下如何使用 SQLAIchemy。</p>
<p>具体细节可以参考官网文档：<a href="https://docs.sqlalchemy.org/en/20/orm/quickstart.html" target="_blank" rel="noopener">docs.sqlalchemy.org/en/20/orm/q…</a></p>
<h2 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip install sqlalchemy[asyncio]==2.0.20</span><br><span class="line">pip install aiomysql==0.2.0</span><br></pre></td></tr></table></figure>

<p>这里安装了 sqlalchemy 2.0版本，以及 aiomysql 异步数据库驱动，进行演示。</p>
<h2 id="创建异步数据库引擎"><a href="#创建异步数据库引擎" class="headerlink" title="创建异步数据库引擎"></a><strong>创建异步数据库引擎</strong></h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy.ext.asyncio import create_async_engine  </span><br><span class="line"></span><br><span class="line"># db_uri = &quot;&#123;protocol&#125;://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;&quot;</span><br><span class="line"></span><br><span class="line">db_engine = create_async_engine(&quot;mysql+aiomysql://root:123456@127.0.0.1:3306/demo&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="声明数据库表映射模型"><a href="#声明数据库表映射模型" class="headerlink" title="声明数据库表映射模型"></a>声明数据库表映射模型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from sqlalchemy import String</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseOrmTable(DeclarativeBase):</span><br><span class="line">    &quot;&quot;&quot;SQLAlchemy Base ORM Model&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __abstract__ = True</span><br><span class="line"></span><br><span class="line">    id: Mapped[int] = mapped_column(primary_key=True, autoincrement=True, comment=&quot;主键ID&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserTable(BaseOrmTable):</span><br><span class="line">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    username: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户昵称&quot;)</span><br><span class="line">    password: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户密码&quot;)</span><br><span class="line">    phone: Mapped[str] = mapped_column(String(11), default=&quot;&quot;, comment=&quot;手机号&quot;)</span><br><span class="line">    email: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;邮箱&quot;)</span><br><span class="line">    avatar: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;头像&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="简单db操作"><a href="#简单db操作" class="headerlink" title="简单db操作"></a>简单db操作</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"># db_uri = &quot;&#123;protocol&#125;://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;&quot;</span><br><span class="line"></span><br><span class="line">db_engine = create_async_engine(&quot;mysql+aiomysql://root:123456@127.0.0.1:3306/hui-demo&quot;)</span><br><span class="line"></span><br><span class="line">Session = async_sessionmaker(db_engine)</span><br><span class="line"></span><br><span class="line">async def create_tables():</span><br><span class="line">    # 根据映射创建库表</span><br><span class="line">    async with db_engine.begin() as conn:</span><br><span class="line">        await conn.run_sync(BaseOrmTable.metadata.create_all)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    await create_tables()</span><br><span class="line"></span><br><span class="line">    async with Session.begin() as session:</span><br><span class="line">        # 添加用户</span><br><span class="line">        new_user = UserTable(username=&apos;hui&apos;, email=&apos;huidbk@163.com&apos;)</span><br><span class="line">        session.add(new_user)</span><br><span class="line">        await session.flush()   # 刷新table 对象属性，获取新增的id</span><br><span class="line">        print(new_user.id)</span><br><span class="line">        print(&quot;add user&quot;, new_user.__dict__)</span><br><span class="line"></span><br><span class="line">        # 获取用户</span><br><span class="line">        user = await session.get(UserTable, new_user.id)</span><br><span class="line">        print(&quot;get user&quot;, user.__dict__)</span><br><span class="line"></span><br><span class="line">        # 更新用户</span><br><span class="line">        user.email = &apos;hui@163.com&apos;</span><br><span class="line">        await session.merge(user)</span><br><span class="line">        print(&quot;updated user&quot;, user.__dict__)</span><br><span class="line"></span><br><span class="line">        # 删除用户</span><br><span class="line">        await session.delete(user)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 运行主函数</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<h1 id="常用DB操作封装"><a href="#常用DB操作封装" class="headerlink" title="常用DB操作封装"></a>常用DB操作封装</h1><h2 id="SQLAlchemyManager"><a href="#SQLAlchemyManager" class="headerlink" title="SQLAlchemyManager"></a>SQLAlchemyManager</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SQLAlchemyManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_URL_TEMPLATE = &quot;&#123;protocol&#125;://&#123;user&#125;:&#123;password&#125;@&#123;host&#125;:&#123;port&#125;/&#123;db&#125;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(</span><br><span class="line">            self,</span><br><span class="line">            host: str = &quot;localhost&quot;,</span><br><span class="line">            port: int = 3306,</span><br><span class="line">            user: str = &quot;&quot;,</span><br><span class="line">            password: str = &quot;&quot;,</span><br><span class="line">            db_name: str = &quot;&quot;,</span><br><span class="line">            pool_size: int = 30,</span><br><span class="line">            pool_pre_ping: bool = True,</span><br><span class="line">            pool_recycle: int = 600,</span><br><span class="line">            log: Union[logging.Logger] = None,</span><br><span class="line">    ):</span><br><span class="line">        self.host = host</span><br><span class="line">        self.port = port</span><br><span class="line">        self.user = user</span><br><span class="line">        self.password = password</span><br><span class="line">        self.db_name = db_name</span><br><span class="line">        self.pool_size = pool_size</span><br><span class="line">        self.pool_pre_ping = pool_pre_ping</span><br><span class="line">        self.pool_recycle = pool_recycle</span><br><span class="line">        self.log = log or logger</span><br><span class="line"></span><br><span class="line">        self.db_engine: AsyncEngine = None</span><br><span class="line">        self.async_session_maker: async_sessionmaker = None</span><br><span class="line"></span><br><span class="line">    def get_db_url(self, protocol: str = &quot;mysql+aiomysql&quot;):</span><br><span class="line">        db_url = self.DB_URL_TEMPLATE.format(</span><br><span class="line">            protocol=protocol, user=self.user, password=self.password, host=self.host, port=self.port, db=self.db_name</span><br><span class="line">        )</span><br><span class="line">        return db_url</span><br><span class="line">     </span><br><span class="line">    def init_db_engine(self, protocol: str):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化db引擎</span><br><span class="line">        Args:</span><br><span class="line">            protocol: 驱动协议类型</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            self.db_engine</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        db_url = self.get_db_url(protocol=protocol)</span><br><span class="line">        self.log.info(f&quot;init_db_engine =&gt; &#123;db_url&#125;&quot;)</span><br><span class="line">        self.db_engine = create_async_engine(</span><br><span class="line">            url=db_url, pool_size=self.pool_size, pool_pre_ping=self.pool_pre_ping, pool_recycle=self.pool_recycle</span><br><span class="line">        )</span><br><span class="line">        self.async_session_maker = async_sessionmaker(bind=self.db_engine, expire_on_commit=False)</span><br><span class="line">        return self.db_engine</span><br><span class="line">        </span><br><span class="line">    def init_mysql_engine(self, protocol: str = &quot;mysql+aiomysql&quot;):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        初始化mysql引擎</span><br><span class="line">        Args:</span><br><span class="line">            protocol: 驱动协议类型</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            self.db_engine</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        return self.init_db_engine(protocol=protocol)</span><br></pre></td></tr></table></figure>

<p>SQLAlchemyManager 主要封装一些数据库账户配置信息、连接池信息。</p>
<p><strong>pool_size（连接池大小）：</strong> 指定连接池中允许保持的最大连接数。当应用程序需要访问数据库时，连接池会维护一定数量的数据库连接，以便快速地响应请求。通常情况下，pool_size 的值应该根据应用程序的并发访问量和数据库的性能来进行调整。</p>
<p><strong>pool_pre_ping（预检查连接）：</strong> 指定是否在数据库连接被使用前对连接进行预检查。预检查可以确保连接处于活动状态，并且可以自动重新连接到数据库服务器，以防止连接由于长时间空闲而失效。启用预检查可以提高应用程序对数据库的可靠性和稳定性。</p>
<p><strong>pool_recycle（连接回收时间）：</strong> 指定数据库连接在被重新使用之前的最大空闲时间。当连接空闲时间超过 pool_recycle 设置的值时，连接将被关闭并重新创建，以防止连接长时间处于空闲状态而导致的连接问题。pool_recycle 的值通常设置为一个较小的时间间隔，以确保连接能够及时地得到回收和重建，从而提高连接的健壮性和性能。</p>
<p><code>init_db_engine</code> 方法则是初始化数据库引擎，内部根据数据库配置信息</p>
<ul>
<li>构造异步的数据库引擎 <strong>db_engine</strong></li>
<li>维护一个 <strong>async_session_maker</strong> 数据库会话工厂</li>
</ul>
<h2 id="BaseORMTable-映射库表封装"><a href="#BaseORMTable-映射库表封装" class="headerlink" title="BaseORMTable 映射库表封装"></a>BaseORMTable 映射库表封装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from datetime import datetime</span><br><span class="line">from sqlalchemy import func</span><br><span class="line">from sqlalchemy.ext.asyncio import AsyncAttrs</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseOrmTable(AsyncAttrs, DeclarativeBase):</span><br><span class="line">    &quot;&quot;&quot;SQLAlchemy Base ORM Model&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __abstract__ = True</span><br><span class="line"></span><br><span class="line">    id: Mapped[int] = mapped_column(primary_key=True, comment=&quot;主键ID&quot;)</span><br><span class="line">    </span><br><span class="line">    def __repr__(self):</span><br><span class="line">        return str(self.to_dict())</span><br><span class="line"></span><br><span class="line">    def to_dict(self, alias_dict: dict = None, exclude_none=True) -&gt; dict:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        数据库模型转成字典</span><br><span class="line">        Args:</span><br><span class="line">            alias_dict: 字段别名字典 eg: &#123;&quot;id&quot;: &quot;user_id&quot;&#125;, 把id名称替换成 user_id</span><br><span class="line">            exclude_none: 默认排查None值</span><br><span class="line">        Returns: dict</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        alias_dict = alias_dict or &#123;&#125;</span><br><span class="line">        if exclude_none:</span><br><span class="line">            return &#123;</span><br><span class="line">                alias_dict.get(c.name, c.name): getattr(self, c.name)</span><br><span class="line">                for c in self.__table__.columns if getattr(self, c.name) is not None</span><br><span class="line">            &#125;</span><br><span class="line">        else:</span><br><span class="line">            return &#123;</span><br><span class="line">                alias_dict.get(c.name, c.name): getattr(self, c.name, None)</span><br><span class="line">                for c in self.__table__.columns</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class TimestampColumns(AsyncAttrs, DeclarativeBase):</span><br><span class="line">    &quot;&quot;&quot;时间戳相关列&quot;&quot;&quot;</span><br><span class="line">    __abstract__ = True</span><br><span class="line"></span><br><span class="line">    created_at: Mapped[datetime] = mapped_column(default=datetime.now, comment=&quot;创建时间&quot;)</span><br><span class="line"></span><br><span class="line">    updated_at: Mapped[datetime] = mapped_column(default=datetime.now, onupdate=datetime.now, comment=&quot;更新时间&quot;)</span><br><span class="line"></span><br><span class="line">    deleted_at: Mapped[datetime] = mapped_column(nullable=True, comment=&quot;删除时间&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class BaseOrmTableWithTS(BaseOrmTable, TimestampColumns):</span><br><span class="line">    __abstract__ = True</span><br></pre></td></tr></table></figure>

<p>创建一些基础的 ORM 类，以便后续的映射类可以继承并且共享一些公有属性和方法。</p>
<ol>
<li><code>BaseOrmTable</code> 类:</li>
</ol>
<pre><code>1. 定义了一个基础的 ORM 模型类，继承了 `AsyncAttrs` 和 `DeclarativeBase`。这样做使得 `BaseOrmTable` 类具有了异步属性访问的能力，为异步编程提供便利，特别是在异步环境中访问具有延迟加载或者异步加载特性的属性。
2. 提供了一个 `to_dict` 方法，用于将数据库模型转换为字典。它支持通过参数 `alias_dict` 指定字段别名，并且可以选择是否排除值为 None 的属性。</code></pre><ol start="2">
<li><code>TimestampColumns</code> 类:</li>
</ol>
<pre><code>1. 定义了一个包含时间戳相关列的抽象基类。这些列通常在很多数据库表中都会有，用于记录数据的创建时间、更新时间和删除时间。
2. 这些列被设置为默认值，比如 `created_at` 和 `updated_at` 默认使用 `datetime.now` 函数来自动记录当前时间，`deleted_at` 则允许为空，用于标记数据的删除时间（可用作于逻辑删除）</code></pre><ol start="3">
<li><code>BaseOrmTableWithTS</code> 类:</li>
</ol>
<pre><code>1. 继承了 `BaseOrmTable` 和 `TimestampColumns`，实际上是一个组合类，集成了基础的 ORM 功能和时间戳相关的列。
2. 这个类进一步封装了 `BaseOrmTable` 和 `TimestampColumns`，使得后续的映射类只需要继承这个类，就能够拥有基础的 ORM 功能和时间戳相关的列。</code></pre><p>通过这种封装，你可以在后续的数据库映射类中更加专注于业务逻辑的实现，而不需要重复编写基础的 ORM 功能和时间戳相关的列，提高了代码的重用性和可维护性。</p>
<h2 id="DBManager-数据库通用操作封装"><a href="#DBManager-数据库通用操作封装" class="headerlink" title="DBManager 数据库通用操作封装"></a>DBManager 数据库通用操作封装</h2><h3 id="前置封装说明"><a href="#前置封装说明" class="headerlink" title="前置封装说明"></a>前置封装说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import Any, List, Type, TypeVar, Union</span><br><span class="line">from py_tools.connections.db.mysql import BaseOrmTable</span><br><span class="line">from py_tools.meta_cls import SingletonMetaCls</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"># 泛指 BaseOrmTable 所有子类实例对象类型   </span><br><span class="line">T_BaseOrmTable = TypeVar(&quot;T_BaseOrmTable&quot;, bound=BaseOrmTable)</span><br><span class="line">T_Hints = TypeVar(&quot;T_Hints&quot;)  # 用于修复被装饰的函数参数提示，让IDE有类型提示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def with_session(method) -&gt; T_Hints:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    兼容事务会话</span><br><span class="line">    Args:</span><br><span class="line">        method: orm 的 crud</span><br><span class="line"></span><br><span class="line">    Notes:</span><br><span class="line">        方法中没有带事务连接则，则构造</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    @functools.wraps(method)</span><br><span class="line">    async def wrapper(db_manager, *args, **kwargs):</span><br><span class="line">        session = kwargs.get(&quot;session&quot;) or None</span><br><span class="line">        if session:</span><br><span class="line">            return await method(db_manager, *args, **kwargs)</span><br><span class="line">        else:</span><br><span class="line">            async with db_manager.transaction() as session:</span><br><span class="line">                kwargs[&quot;session&quot;] = session</span><br><span class="line">                return await method(db_manager, *args, **kwargs)</span><br><span class="line"></span><br><span class="line">    return wrapper</span><br></pre></td></tr></table></figure>

<p>这里我提供了一个 <strong>with_session</strong> 装饰器，用于在需要数据库会话（事务）的数据库操作方法中自动开启事务，由于 sqlaichemy 官方推荐每个数据库操作都手动开启事务会话（自动提交），装饰器的设计没有时则构造，有则共享，这样不但可以减少冗余 <strong>async with db_manager.transaction() as session</strong> 的代码，也可以兼容多个操作共享同一个 session 有问题时进行事务回滚。</p>
<p>由于给方法加了通用的装饰器导致一些版本的IDE无法识别方法真实的签名，使用时会出现不知道方法的入参是什么，对于开发者来说是极其不方便的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a1896230aace0636723f3562595c0e657c60cb0d26038b648b334f435662a0e1" alt></p>
<p>使用 typing 的 TypeVar 自定义类型来构造一个通用的泛型来当作函数返回的类型，进而修复。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from typing import TypeVar</span><br><span class="line">T_Hints = TypeVar(&quot;T_Hints&quot;)  # 用于修复被装饰的函数参数提示，让IDE有类型提示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def with_session(method) -&gt; T_Hints:</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8514e25ac87eda48a1b8e34edad9ff6d6080ecf9aa13037ffbc3619ac05cf82a" alt></p>
<p>这里PyCharm 2023.2.4 版本升级到 2024.1 就有提示了，IDE修复了，可以不用 T_Hints 了。</p>
<p>一些旧版本构造 sqlaichemy 的库表对象时也会出现不知道类对象属性入参提示，升级到最新版本都解决了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from contextlib import asynccontextmanager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class DBManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_CLIENT: SQLAlchemyManager = None</span><br><span class="line">    orm_table: Type[BaseOrmTable] = None</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    def init_db_client(cls, db_client: SQLAlchemyManager):</span><br><span class="line">        cls.DB_CLIENT = db_client</span><br><span class="line">        return cls.DB_CLIENT</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    @asynccontextmanager</span><br><span class="line">    async def transaction(cls):</span><br><span class="line">        &quot;&quot;&quot;事务上下文管理器&quot;&quot;&quot;</span><br><span class="line">        async with cls.DB_CLIENT.async_session_maker.begin() as session:</span><br><span class="line">            yield session</span><br><span class="line"></span><br><span class="line">    @classmethod</span><br><span class="line">    @asynccontextmanager</span><br><span class="line">    async def connection(cls) -&gt; AsyncIterator[AsyncConnection]:</span><br><span class="line">        &quot;&quot;&quot;数据库引擎连接上下文管理器&quot;&quot;&quot;</span><br><span class="line">        async with cls.DB_CLIENT.db_engine.begin() as conn:</span><br><span class="line">            yield conn</span><br></pre></td></tr></table></figure>

<ul>
<li>init_db_client 方法用于初始化数据库客户端（引擎）。</li>
<li>transaction 则是简单的通过 contextlib 中 asynccontextmanager 封装一个异步的上下文管理器方便简洁的开启一个数据库会话（事务）进行数据库相关操作。</li>
<li>connection 数据库引擎连接上下文管理器。</li>
<li>orm_table 是具体继承 DBManager 的子类进行指定的，用于操作具体的库表（orm_table）。</li>
<li>DBManager 通过 SingletonMetaCls 元类实现单例模式。具体单例模式可以了解 <a href="https://dev.newban.cn/7272006755265380367">juejin.cn/post/727200…</a> 这篇文章有详细的介绍。</li>
</ul>
<h3 id="DB添加操作封装"><a href="#DB添加操作封装" class="headerlink" title="DB添加操作封装"></a>DB添加操作封装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line">class DBManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_CLIENT: SQLAlchemyManager = None</span><br><span class="line">    orm_table: Type[BaseOrmTable] = None</span><br><span class="line"></span><br><span class="line">    @with_session</span><br><span class="line">    async def bulk_add(</span><br><span class="line">            self,</span><br><span class="line">            table_objs: List[Union[T_BaseOrmTable, dict]],</span><br><span class="line">            *,</span><br><span class="line">            orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">            flush: bool = False,</span><br><span class="line">            session: AsyncSession = None</span><br><span class="line">    ) -&gt; List[T_BaseOrmTable]:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        批量插入</span><br><span class="line">        Args:</span><br><span class="line">            table_objs: orm映射类实例列表</span><br><span class="line">                eg.[UserTable(username=&quot;hui&quot;, age=18), ...] or [&#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;, ...]</span><br><span class="line">            orm_table: orm表映射类</span><br><span class="line">            flush: 刷新对象状态，默认不刷新</span><br><span class="line">            session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            成功插入的对象列表</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        orm_table = orm_table or self.orm_table</span><br><span class="line">        if all(isinstance(table_obj, dict) for table_obj in table_objs):</span><br><span class="line">            # 字典列表转成orm映射类实例列表处理</span><br><span class="line">            table_objs = [orm_table(**table_obj) for table_obj in table_objs]</span><br><span class="line">    </span><br><span class="line">        session.add_all(table_objs)</span><br><span class="line">        if flush:</span><br><span class="line">            await session.flush(table_objs)</span><br><span class="line">    </span><br><span class="line">        return table_objs</span><br><span class="line">    </span><br><span class="line">    @with_session</span><br><span class="line">    async def add(</span><br><span class="line">            self,</span><br><span class="line">            table_obj: [T_BaseOrmTable, dict],</span><br><span class="line">            *,</span><br><span class="line">            orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">            session: AsyncSession = None</span><br><span class="line">     ) -&gt; int:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        插入一条数据</span><br><span class="line">        Args:</span><br><span class="line">            table_obj: orm映射类实例对象, eg. UserTable(username=&quot;hui&quot;, age=18) or &#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">            orm_table: orm表映射类</span><br><span class="line">            session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">        Returns: 新增的id</span><br><span class="line">            table_obj.id</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        orm_table = orm_table or self.orm_table</span><br><span class="line">        if isinstance(table_obj, dict):</span><br><span class="line">            table_obj = orm_table(**table_obj)</span><br><span class="line">            </span><br><span class="line">        session.add(table_obj)</span><br><span class="line">        await session.flush(objects=[table_obj])  # 刷新对象状态，获取新增的id</span><br><span class="line">        return table_obj.id</span><br></pre></td></tr></table></figure>

<p>这里就是用 session.add 与 add_all 方法封装了数据库添加、批量添加的操作，封装的点主要在于除了 orm_table 实例对象入参还支持字典入参，内部还是转换成库表映射类实例来操作，最后通过 session.flush 方法，单个添加返回新增的主键id，批量添加则是返回实例对象列表。</p>
<p>设计的方法中有一个 * 号是参数的分隔符，它的作用是将其前面的参数声明为位置参数，而将 * 后面的参数声明为关键字参数，* 号后面的参数入参只能使用关键字形式的入参，我在很多的开源库中都看到了这样的设计，可以把一些函数语义连贯、常用必传的参数设置为位置参数，其他的则是关键字参数。这样可以明确参数的作用、提高函数的可读性、防止参数错误等。</p>
<p>具体看下使用案例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import asyncio</span><br><span class="line"></span><br><span class="line">from sqlalchemy import String</span><br><span class="line">from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker</span><br><span class="line">from sqlalchemy.orm import DeclarativeBase, Mapped, mapped_column</span><br><span class="line"></span><br><span class="line">from py_tools.connections.db.mysql import BaseOrmTableWithTS, BaseOrmTable, DBManager, SQLAlchemyManager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserTable(BaseOrmTableWithTS):</span><br><span class="line">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    username: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户昵称&quot;)</span><br><span class="line">    password: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户密码&quot;)</span><br><span class="line">    phone: Mapped[str] = mapped_column(String(11), default=&quot;&quot;, comment=&quot;手机号&quot;)</span><br><span class="line">    email: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;邮箱&quot;)</span><br><span class="line">    avatar: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;头像&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def create_tables():</span><br><span class="line">    # 根据映射创建库表（异步）</span><br><span class="line">    # async with db_engine.begin() as conn:</span><br><span class="line">    #    await conn.run_sync(BaseOrmTable.metadata.create_all)</span><br><span class="line">    </span><br><span class="line">    async with DBManager.connection() as conn:</span><br><span class="line">        await conn.run_sync(BaseOrmTable.metadata.create_all)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def init_orm_manager():</span><br><span class="line">    db_client = SQLAlchemyManager(</span><br><span class="line">        host=&quot;127.0.0.1&quot;,</span><br><span class="line">        port=3306,</span><br><span class="line">        user=&quot;root&quot;,</span><br><span class="line">        password=&quot;123456&quot;,</span><br><span class="line">        db_name=&quot;hui-demo&quot;,</span><br><span class="line">    )</span><br><span class="line">    db_client.init_mysql_engine()</span><br><span class="line">    DBManager().init_db_client(db_client)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def manager_crud():</span><br><span class="line">    user = &#123;&quot;username&quot;: &quot;hui&quot;, &quot;email&quot;: &quot;huidbk.163.com&quot;&#125;</span><br><span class="line">    user_id = await DBManager().add(table_obj=user, orm_table=UserTable)</span><br><span class="line">    print(&quot;user_id&quot;, user_id)</span><br><span class="line"></span><br><span class="line">    users = [</span><br><span class="line">        &#123;&quot;username&quot;: &quot;zack&quot;, &quot;email&quot;: &quot;zack.163.com&quot;&#125;,</span><br><span class="line">        &#123;&quot;username&quot;: &quot;wang&quot;, &quot;email&quot;: &quot;wang.163.com&quot;&#125;</span><br><span class="line">    ]</span><br><span class="line">    add_users = await DBManager().bulk_add(table_objs=users, orm_table=UserTable)</span><br><span class="line">    add_user_ids = [user.id for user in add_users]</span><br><span class="line">    print(&quot;add_user_ids&quot;, add_user_ids)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def main():</span><br><span class="line">    await create_tables()</span><br><span class="line"></span><br><span class="line">    # await normal_crud()</span><br><span class="line"></span><br><span class="line">    await init_orm_manager()</span><br><span class="line"></span><br><span class="line">    await manager_crud()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    # 运行主函数</span><br><span class="line">    asyncio.run(main())</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a077f583e2a48a0e4e6db698dfd1d53fe7ec47de05dc69c24a37afaac6ea120c" alt></p>
<p>在程序启动时初始化好DBManager 的 DB_CLIENT 就可以直接使用封装的方法，主要就是 DB_CLIENT 作为类属性，后面DBManager 实例与子类实例对象都可以共享这个数据库引擎。但我这里还是不推荐上面的写法，DBManager 是一些通用的DB操作，而具体一些业务操作还是单独封装一些DB业务Manager类来进行会比较好，更利于扩展维护与复用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class UserManager(DBManager):</span><br><span class="line">    orm_table = UserTable</span><br><span class="line"></span><br><span class="line">    async def get_name_by_email(self, email):</span><br><span class="line">        username = await self.query_one(cols=[&quot;username&quot;], conds=[self.orm_table.email == email], flat=True)</span><br><span class="line">        return username</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">async def manager_crud():</span><br><span class="line"></span><br><span class="line">    # demo 2 （推荐）</span><br><span class="line">    user = UserTable(username=&quot;hui-test01&quot;, email=&quot;hui-test01.163.com&quot;)</span><br><span class="line">    user_id = await UserManager().add(table_obj=user)</span><br><span class="line">    print(&quot;user_id&quot;, user_id)</span><br><span class="line"></span><br><span class="line">    users = [</span><br><span class="line">        UserTable(username=&quot;hui-test02&quot;, email=&quot;hui-test02.163.com&quot;),</span><br><span class="line">        UserTable(username=&quot;hui-test03&quot;, email=&quot;hui-test03.163.com&quot;),</span><br><span class="line">    ]</span><br><span class="line">    add_users = await UserManager().bulk_add(table_objs=users)</span><br><span class="line">    add_user_ids = [user.id for user in add_users]</span><br><span class="line">    print(&quot;add_user_ids&quot;, add_user_ids)</span><br><span class="line">    </span><br><span class="line">    username = await UserManager().get_name_by_email(email=&quot;huidbk.163.com&quot;)</span><br><span class="line">    print(&quot;username&quot;, username)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">user_id 4</span><br><span class="line">add_user_ids [5, 6]</span><br><span class="line">username hui</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee698e1969ca8f266b2fcb2bacdd01697f3d61738867b9d5f70d41e113721239" alt></p>
<p>这里 <strong>UserManager</strong> 单独封装的 <strong>get_name_by_email</strong> 的方法就是业务中常用查询操作通过邮件获取用户名称，这里就是举一个简单的例子，具体DB业务具体封装而不是全部写在逻辑层，这样别人要用的时候就不用重新组织条件参数、上下文，而是简单传递业务参数进行复用获取数据。</p>
<p>UserManager 调用 add、bulk_add 等方法时也不用像 DBManager 指定 orm_table 参数，使用起来更简洁。具体是因为 UserManager 类指定了 类属性 orm_table = UserTable，再封装时有一句 <strong>orm_table = orm_table or self.orm_table</strong> 意思就是优先选择入参的orm_table，没有则是 self.orm_table （具体实例对象的orm_table）。这样写也体现出 封装、继承的灵活性。</p>
<p>这里也引出了另一个封装方法 <strong>query_one</strong> 查询单条数据。由于介绍了一些Demo如果把所有的封装方法混合到一起篇幅就太长，故而我准备分成三篇进行分别介绍，这样也更好阅读。</p>
<ol>
<li><a href="https://dev.newban.cn/7357703852726911016">SQLAIchemy 异步DBManager封装-01入门理解</a></li>
<li><a href="https://dev.newban.cn/7357957809072619554">SQLAIchemy 异步DBManager封装-02熟悉掌握</a></li>
<li><a href="https://dev.newban.cn/7358352353295106088">SQLAIchemy 异步DBManager封装-03得心应手</a></li>
</ol>
<h1 id="Github源代码"><a href="#Github源代码" class="headerlink" title="Github源代码"></a>Github源代码</h1><p>源代码已上传到了Github，里面也有具体的使用Demo，欢迎大家一起体验、贡献。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357703852726911016" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring配置类解析与Bean扫描过程源码分析一、注册C</title>
    <url>/7357917500964012042.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[TOC]</p>
<h1 id="一、注册ConfigurationClassPostProcessor"><a href="#一、注册ConfigurationClassPostProcessor" class="headerlink" title="一、注册ConfigurationClassPostProcessor"></a>一、注册ConfigurationClassPostProcessor</h1><p>Spring启动之前，构造AnnotatedBeanDefinitionReader（主要作用添加一些基础的PostProcessor，同时可以通过reader进行BeanDefinition的注册），同时对BeanFactory进行设置和添加PostProcessor（后置处理器）。</p>
<p>此时，会向BeanFactory中添加<code>ConfigurationClassPostProcessor</code>对应的BeanDefinition。</p>
<p><code>ConfigurationClassPostProcessor</code>实现了<code>BeanDefinitionRegistryPostProcessor</code>接口，并实现了<code>postProcessBeanDefinitionRegistry</code>和<code>postProcessBeanFactory</code>方法。</p>
<p>当Spring容器调用invokeBeanFactoryPostProcessors方法时，就会执行<code>ConfigurationClassPostProcessor</code>的<code>BeanDefinitionRegistryPostProcessor</code>方法与<code>postProcessBeanFactory</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor,</span><br><span class="line">		PriorityOrdered, ResourceLoaderAware, ApplicationStartupAware, BeanClassLoaderAware, EnvironmentAware &#123;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanDefinitionRegistry(BeanDefinitionRegistry registry) &#123;</span><br><span class="line">		int registryId = System.identityHashCode(registry);</span><br><span class="line">		if (this.registriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;postProcessBeanDefinitionRegistry already called on this post-processor against &quot; + registry);</span><br><span class="line">		&#125;</span><br><span class="line">		if (this.factoriesPostProcessed.contains(registryId)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;postProcessBeanFactory already called on this post-processor against &quot; + registry);</span><br><span class="line">		&#125;</span><br><span class="line">		this.registriesPostProcessed.add(registryId);</span><br><span class="line"></span><br><span class="line">		processConfigBeanDefinitions(registry);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">		int factoryId = System.identityHashCode(beanFactory);</span><br><span class="line">		if (this.factoriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">			throw new IllegalStateException(</span><br><span class="line">					&quot;postProcessBeanFactory already called on this post-processor against &quot; + beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line">		this.factoriesPostProcessed.add(factoryId);</span><br><span class="line">		if (!this.registriesPostProcessed.contains(factoryId)) &#123;</span><br><span class="line">			// BeanDefinitionRegistryPostProcessor hook apparently not supported...</span><br><span class="line">			// Simply call processConfigurationClasses lazily at this point then.</span><br><span class="line">			processConfigBeanDefinitions((BeanDefinitionRegistry) beanFactory);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		enhanceConfigurationClasses(beanFactory);</span><br><span class="line">		beanFactory.addBeanPostProcessor(new ImportAwareBeanPostProcessor(beanFactory));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="二、postProcessBeanDefinitionRegistry方法"><a href="#二、postProcessBeanDefinitionRegistry方法" class="headerlink" title="二、postProcessBeanDefinitionRegistry方法"></a>二、postProcessBeanDefinitionRegistry方法</h1><h2 id="1、processConfigBeanDefinitions方法"><a href="#1、processConfigBeanDefinitions方法" class="headerlink" title="1、processConfigBeanDefinitions方法"></a>1、processConfigBeanDefinitions方法</h2><p>该方法调用了<code>ConfigurationClassUtils.checkConfigurationClassCandidate</code>方法，判断一个类是否是配置类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码// org.springframework.context.annotation.ConfigurationClassUtils#checkConfigurationClassCandidate</span><br><span class="line">public static boolean checkConfigurationClassCandidate(</span><br><span class="line">		BeanDefinition beanDef, MetadataReaderFactory metadataReaderFactory) &#123;</span><br><span class="line"></span><br><span class="line">	String className = beanDef.getBeanClassName();</span><br><span class="line">	if (className == null || beanDef.getFactoryMethodName() != null) &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	AnnotationMetadata metadata;</span><br><span class="line">	if (beanDef instanceof AnnotatedBeanDefinition &amp;&amp;</span><br><span class="line">			className.equals(((AnnotatedBeanDefinition) beanDef).getMetadata().getClassName())) &#123;</span><br><span class="line">		// Can reuse the pre-parsed metadata from the given BeanDefinition...</span><br><span class="line">		metadata = ((AnnotatedBeanDefinition) beanDef).getMetadata();</span><br><span class="line">	&#125;</span><br><span class="line">	else if (beanDef instanceof AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) beanDef).hasBeanClass()) &#123;</span><br><span class="line">		// Check already loaded Class if present...</span><br><span class="line">		// since we possibly can&apos;t even load the class file for this Class.</span><br><span class="line">		Class&lt;?&gt; beanClass = ((AbstractBeanDefinition) beanDef).getBeanClass();</span><br><span class="line">		if (BeanFactoryPostProcessor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				BeanPostProcessor.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				AopInfrastructureBean.class.isAssignableFrom(beanClass) ||</span><br><span class="line">				EventListenerFactory.class.isAssignableFrom(beanClass)) &#123;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">		metadata = AnnotationMetadata.introspect(beanClass);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			MetadataReader metadataReader = metadataReaderFactory.getMetadataReader(className);</span><br><span class="line">			metadata = metadataReader.getAnnotationMetadata();</span><br><span class="line">		&#125;</span><br><span class="line">		catch (IOException ex) &#123;</span><br><span class="line">			if (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(&quot;Could not find class file for introspecting configuration annotations: &quot; +</span><br><span class="line">						className, ex);</span><br><span class="line">			&#125;</span><br><span class="line">			return false;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Map&lt;String, Object&gt; config = metadata.getAnnotationAttributes(Configuration.class.getName());</span><br><span class="line">	if (config != null &amp;&amp; !Boolean.FALSE.equals(config.get(&quot;proxyBeanMethods&quot;))) &#123;</span><br><span class="line">		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_FULL);</span><br><span class="line">	&#125;</span><br><span class="line">	else if (config != null || isConfigurationCandidate(metadata)) &#123;</span><br><span class="line">		beanDef.setAttribute(CONFIGURATION_CLASS_ATTRIBUTE, CONFIGURATION_CLASS_LITE);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		return false;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// It&apos;s a full or lite configuration candidate... Let&apos;s determine the order value, if any.</span><br><span class="line">	Integer order = getOrder(metadata);</span><br><span class="line">	if (order != null) &#123;</span><br><span class="line">		beanDef.setAttribute(ORDER_ATTRIBUTE, order);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring认为，包含@Component、@ComponentScan、@Import、@ImportResource、@Bean方法的类，属于轻配置类。<br>而加了@Configuration的类属于full配置类。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/989ad853210c248013854c33f0c9bf160b61166cabcdec19ddb8cacf03685e5f" alt="在这里插入图片描述"></p>
<h2 id="2、流程梳理"><a href="#2、流程梳理" class="headerlink" title="2、流程梳理"></a>2、流程梳理</h2><p>1、在启动Spring时，需要传入一个AppConfig.class给ApplicationContext，ApplicationContext会根据AppConfig类封装为一个BeanDefinition，这种BeanDefinition我们把它称为配置类BeanDefinition。</p>
<p>2、ConfigurationClassPostProcessor中会把配置类BeanDefinition取出来</p>
<p>3、构造一个ConfigurationClassParser用来解析配置类BeanDefinition，并且会生成一个配置类对象ConfigurationClass</p>
<p>4、如果配置类上存在@Component注解，那么解析配置类中的内部类（这里有递归，如果内部类也是配置类的话）</p>
<p>5、如果配置类上存在@PropertySource注解，那么则解析该注解，并得到PropertySource对象，并添加到environment中去</p>
<p>6、如果配置类上存在@ComponentScan注解，那么则解析该注解，进行扫描，扫描得到一系列的BeanDefinition对象，然后判断这些BeanDefinition是不是也是配置类BeanDefinition（只要存在@Component注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，（也有递归），并且会生成对应的ConfigurationClass</p>
<p>7、如果配置类上存在@Import注解，那么则判断Import的类的类型：<br>如果是ImportSelector，那么调用执行selectImports方法得到类名，然后在把这个类当做配置类进行解析**（也是递归）**<br>如果是ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的importBeanDefinitionRegistrars属性中。</p>
<p>8、如果配置类上存在@ImportResource注解，那么则把导入进来的资源路径存在配置类对象中的importedResources属性中。</p>
<p>9、如果配置类中存在@Bean的方法，那么则把这些方法封装为BeanMethod对象，并添加到配置类对象中的beanMethods属性中。</p>
<p>10、如果配置类实现了某些接口，则看这些接口内是否定义了@Bean的默认方法</p>
<p>11、如果配置类有父类，则把父类当做配置类进行解析</p>
<p>12、AppConfig这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用reader来进一步解析ConfigurationClass<br>如果ConfigurationClass是通过@Import注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上@Scope,@Lazy等注解信息，并注册BeanDefinition<br>如果ConfigurationClass中存在一些BeanMethod，也就是定义了一些@Bean，那么则解析这些@Bean，并生成对应的BeanDefinition，并注册<br>如果ConfigurationClass中导入了一些资源文件，比如xx.xml，那么则解析这些xx.xml文件，得到并注册BeanDefinition<br>如果ConfigurationClass中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的registerBeanDefinitions进行BeanDefinition的注册</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e22f346d35a4a87f9ad9b3ec9d304c049fa7ffcb5d4ec8761411b7e3953bbffc" alt="在这里插入图片描述"><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c5205ac788d613cee53f69c6abb061da4b6a5bddb97cd036eb8223b7bfd35b3" alt="在这里插入图片描述"></p>
<h2 id="3、postProcessBeanFactory方法"><a href="#3、postProcessBeanFactory方法" class="headerlink" title="3、postProcessBeanFactory方法"></a>3、postProcessBeanFactory方法</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码// org.springframework.context.annotation.ConfigurationClassPostProcessor#enhanceConfigurationClasses</span><br><span class="line">public void enhanceConfigurationClasses(ConfigurableListableBeanFactory beanFactory) &#123;</span><br><span class="line">	StartupStep enhanceConfigClasses = this.applicationStartup.start(&quot;spring.context.config-classes.enhance&quot;);</span><br><span class="line">	Map&lt;String, AbstractBeanDefinition&gt; configBeanDefs = new LinkedHashMap&lt;&gt;();</span><br><span class="line">	for (String beanName : beanFactory.getBeanDefinitionNames()) &#123;</span><br><span class="line">		BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);</span><br><span class="line">		Object configClassAttr = beanDef.getAttribute(ConfigurationClassUtils.CONFIGURATION_CLASS_ATTRIBUTE);</span><br><span class="line">		AnnotationMetadata annotationMetadata = null;</span><br><span class="line">		MethodMetadata methodMetadata = null;</span><br><span class="line">		if (beanDef instanceof AnnotatedBeanDefinition) &#123;</span><br><span class="line">			AnnotatedBeanDefinition annotatedBeanDefinition = (AnnotatedBeanDefinition) beanDef;</span><br><span class="line">			annotationMetadata = annotatedBeanDefinition.getMetadata();</span><br><span class="line">			methodMetadata = annotatedBeanDefinition.getFactoryMethodMetadata();</span><br><span class="line">		&#125;</span><br><span class="line">		if ((configClassAttr != null || methodMetadata != null) &amp;&amp; beanDef instanceof AbstractBeanDefinition) &#123;</span><br><span class="line">			// Configuration class (full or lite) or a configuration-derived @Bean method</span><br><span class="line">			// -&gt; eagerly resolve bean class at this point, unless it&apos;s a &apos;lite&apos; configuration</span><br><span class="line">			// or component class without @Bean methods.</span><br><span class="line">			AbstractBeanDefinition abd = (AbstractBeanDefinition) beanDef;</span><br><span class="line">			if (!abd.hasBeanClass()) &#123;</span><br><span class="line">				boolean liteConfigurationCandidateWithoutBeanMethods =</span><br><span class="line">						(ConfigurationClassUtils.CONFIGURATION_CLASS_LITE.equals(configClassAttr) &amp;&amp;</span><br><span class="line">							annotationMetadata != null &amp;&amp; !ConfigurationClassUtils.hasBeanMethods(annotationMetadata));</span><br><span class="line">				if (!liteConfigurationCandidateWithoutBeanMethods) &#123;</span><br><span class="line">					try &#123;</span><br><span class="line">						abd.resolveBeanClass(this.beanClassLoader);</span><br><span class="line">					&#125;</span><br><span class="line">					catch (Throwable ex) &#123;</span><br><span class="line">						throw new IllegalStateException(</span><br><span class="line">								&quot;Cannot load configuration class: &quot; + beanDef.getBeanClassName(), ex);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		if (ConfigurationClassUtils.CONFIGURATION_CLASS_FULL.equals(configClassAttr)) &#123;</span><br><span class="line">			if (!(beanDef instanceof AbstractBeanDefinition)) &#123;</span><br><span class="line">				throw new BeanDefinitionStoreException(&quot;Cannot enhance @Configuration bean definition &apos;&quot; +</span><br><span class="line">						beanName + &quot;&apos; since it is not stored in an AbstractBeanDefinition subclass&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			else if (logger.isInfoEnabled() &amp;&amp; beanFactory.containsSingleton(beanName)) &#123;</span><br><span class="line">				logger.info(&quot;Cannot enhance @Configuration bean definition &apos;&quot; + beanName +</span><br><span class="line">						&quot;&apos; since its singleton instance has been created too early. The typical cause &quot; +</span><br><span class="line">						&quot;is a non-static @Bean method with a BeanDefinitionRegistryPostProcessor &quot; +</span><br><span class="line">						&quot;return type: Consider declaring such methods as &apos;static&apos;.&quot;);</span><br><span class="line">			&#125;</span><br><span class="line">			configBeanDefs.put(beanName, (AbstractBeanDefinition) beanDef);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (configBeanDefs.isEmpty() || NativeDetector.inNativeImage()) &#123;</span><br><span class="line">		// nothing to enhance -&gt; return immediately</span><br><span class="line">		enhanceConfigClasses.end();</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// 代理</span><br><span class="line">	ConfigurationClassEnhancer enhancer = new ConfigurationClassEnhancer();</span><br><span class="line">	for (Map.Entry&lt;String, AbstractBeanDefinition&gt; entry : configBeanDefs.entrySet()) &#123;</span><br><span class="line">		AbstractBeanDefinition beanDef = entry.getValue();</span><br><span class="line">		// If a @Configuration class gets proxied, always proxy the target class</span><br><span class="line">		beanDef.setAttribute(AutoProxyUtils.PRESERVE_TARGET_CLASS_ATTRIBUTE, Boolean.TRUE);</span><br><span class="line">		// Set enhanced subclass of the user-specified bean class</span><br><span class="line">		Class&lt;?&gt; configClass = beanDef.getBeanClass();</span><br><span class="line">		Class&lt;?&gt; enhancedClass = enhancer.enhance(configClass, this.beanClassLoader);</span><br><span class="line">		if (configClass != enhancedClass) &#123;</span><br><span class="line">			if (logger.isTraceEnabled()) &#123;</span><br><span class="line">				logger.trace(String.format(&quot;Replacing bean definition &apos;%s&apos; existing class &apos;%s&apos; with &quot; +</span><br><span class="line">						&quot;enhanced class &apos;%s&apos;&quot;, entry.getKey(), configClass.getName(), enhancedClass.getName()));</span><br><span class="line">			&#125;</span><br><span class="line">			beanDef.setBeanClass(enhancedClass);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	enhanceConfigClasses.tag(&quot;classCount&quot;, () -&gt; String.valueOf(configBeanDefs.keySet().size())).end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>配置类，如果是full的配置类，会生成一个代理类。</p>
<p>我们看<code>enhancer.enhance</code>生成的代理对象：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0ee5d5f5b43ff380d3df48b5ab9a42dc60edd4155d4636243afe9c0950b89fe6" alt="在这里插入图片描述"><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7034dcf7d77fed6fabd787aabf14a07ff35138708151a744e6798fdc9157beb2" alt="在这里插入图片描述"><br>我们看一下BeanMethodInterceptor的代理方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码// org.springframework.context.annotation.ConfigurationClassEnhancer.BeanMethodInterceptor#intercept</span><br><span class="line">@Override</span><br><span class="line">@Nullable</span><br><span class="line">public Object intercept(Object enhancedConfigInstance, Method beanMethod, Object[] beanMethodArgs,</span><br><span class="line">			MethodProxy cglibMethodProxy) throws Throwable &#123;</span><br><span class="line"></span><br><span class="line">	ConfigurableBeanFactory beanFactory = getBeanFactory(enhancedConfigInstance);</span><br><span class="line">	String beanName = BeanAnnotationHelper.determineBeanNameFor(beanMethod);</span><br><span class="line"></span><br><span class="line">	// Determine whether this bean is a scoped-proxy</span><br><span class="line">	if (BeanAnnotationHelper.isScopedProxy(beanMethod)) &#123;</span><br><span class="line">		String scopedBeanName = ScopedProxyCreator.getTargetBeanName(beanName);</span><br><span class="line">		if (beanFactory.isCurrentlyInCreation(scopedBeanName)) &#123;</span><br><span class="line">			beanName = scopedBeanName;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// To handle the case of an inter-bean method reference, we must explicitly check the</span><br><span class="line">	// container for already cached instances.</span><br><span class="line"></span><br><span class="line">	// First, check to see if the requested bean is a FactoryBean. If so, create a subclass</span><br><span class="line">	// proxy that intercepts calls to getObject() and returns any cached bean instance.</span><br><span class="line">	// This ensures that the semantics of calling a FactoryBean from within @Bean methods</span><br><span class="line">	// is the same as that of referring to a FactoryBean within XML. See SPR-6602.</span><br><span class="line">	if (factoryContainsBean(beanFactory, BeanFactory.FACTORY_BEAN_PREFIX + beanName) &amp;&amp;</span><br><span class="line">			factoryContainsBean(beanFactory, beanName)) &#123;</span><br><span class="line">		Object factoryBean = beanFactory.getBean(BeanFactory.FACTORY_BEAN_PREFIX + beanName);</span><br><span class="line">		if (factoryBean instanceof ScopedProxyFactoryBean) &#123;</span><br><span class="line">			// Scoped proxy factory beans are a special case and should not be further proxied</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			// It is a candidate FactoryBean - go ahead with enhancement</span><br><span class="line">			return enhanceFactoryBean(factoryBean, beanMethod.getReturnType(), beanFactory, beanName);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	// 代理类执行某个方法的时候，会判断正在执行的方法是不是正在创建Bean的方法</span><br><span class="line">	if (isCurrentlyInvokedFactoryMethod(beanMethod)) &#123;</span><br><span class="line">		// The factory is calling the bean method in order to instantiate and register the bean</span><br><span class="line">		// (i.e. via a getBean() call) -&gt; invoke the super implementation of the method to actually</span><br><span class="line">		// create the bean instance.</span><br><span class="line">		if (logger.isInfoEnabled() &amp;&amp;</span><br><span class="line">				BeanFactoryPostProcessor.class.isAssignableFrom(beanMethod.getReturnType())) &#123;</span><br><span class="line">			logger.info(String.format(&quot;@Bean method %s.%s is non-static and returns an object &quot; +</span><br><span class="line">							&quot;assignable to Spring&apos;s BeanFactoryPostProcessor interface. This will &quot; +</span><br><span class="line">							&quot;result in a failure to process annotations such as @Autowired, &quot; +</span><br><span class="line">							&quot;@Resource and @PostConstruct within the method&apos;s declaring &quot; +</span><br><span class="line">							&quot;@Configuration class. Add the &apos;static&apos; modifier to this method to avoid &quot; +</span><br><span class="line">							&quot;these container lifecycle issues; see @Bean javadoc for complete details.&quot;,</span><br><span class="line">					beanMethod.getDeclaringClass().getSimpleName(), beanMethod.getName()));</span><br><span class="line">		&#125;</span><br><span class="line">		// 直接执行该方法</span><br><span class="line">		return cglibMethodProxy.invokeSuper(enhancedConfigInstance, beanMethodArgs);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return resolveBeanReference(beanMethod, beanMethodArgs, beanFactory, beanName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就意味着，同一个代理配置类中调用@Bean的方法，相当于获取了同一个Bean。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/27f2cfb42202cd0d5deea476fbc02702a79c148f76ee3f4dfdf0d3354309f5a8" alt="在这里插入图片描述"></p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>JFR：<br><a href="https://zhuanlan.zhihu.com/p/122247741" target="_blank" rel="noopener">zhuanlan.zhihu.com/p/122247741</a></p>
<p>@LookUp注解</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357917500964012042" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>深入探索垃圾收集</title>
    <url>/7357917500963373066.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p><em>垃圾收集是应对应用程序内存管理挑战的主要方式之一，本文介绍了业界主流的垃圾收集算法（以Java为主），比较了不同算法的优劣、适用场景，对于研发团队选择适合业务场景的垃圾收集算法提供了很好的参考。原文: <a href="https://itnext.io/in-depth-exploration-of-garbage-collector-gc-828fcef9fe5d" target="_blank" rel="noopener">In-depth Exploration of Garbage Collector (GC)</a></em></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4dd5cda7cb94438d96365d04c0ec82173adad4c1c0861bb5604321bf8bf9bf47" alt="垃圾收集周期概览"></p>
<h4 id="导言"><a href="#导言" class="headerlink" title="导言"></a>导言</h4><p>在 C 或 C++ 等传统编程语言中，由开发人员负责为对象或数据结构显式分配、释放内存。</p>
<p>但是手动管理内存容易出错，导致内存泄漏（分配的内存未释放）或野指针（指针引用已被释放的内存）等错误，而这些问题会造成软件不稳定或不安全。</p>
<p>垃圾回收通过自动化内存管理过程来应对这些挑战。垃圾回收器不需要开发人员手动分配和释放内存，而是自动识别和回收程序无法再访问或引用的内存。</p>
<p>垃圾回收算法的复杂程度和实现方式各不相同，不同编程语言和运行环境可能会使用不同的垃圾回收策略。</p>
<p>虽然垃圾回收有很多好处，如自动内存管理、防止与内存相关的错误，但也会给 CPU 和内存使用造成额外开销。</p>
<p>本文旨在探讨不同垃圾收集算法，研究其内部工作原理、优点和局限性。</p>
<p>从而有助于我们选择合适的算法和配置，使我们能够更高效的编写代码。</p>
<h4 id="历史背景"><a href="#历史背景" class="headerlink" title="历史背景"></a>历史背景</h4><h5 id="程序运行内存"><a href="#程序运行内存" class="headerlink" title="程序运行内存"></a>程序运行内存</h5><p>运行中程序的典型内存布局如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6865f871acca789bf2c30372e5318a8da4876e0183e4023de2f65d3d9b6db86c" alt="违反内存安全。如何避免内存问题？| 作者：Héla Ben Khalfallah | Better Programming"></p>
<p>在程序运行期间，<strong>静态内存（Static memory）</strong> 用于存储全局变量或使用static关键字声明的变量。</p>
<p><strong>栈（Stack）</strong> 是计算机程序临时存放数据的指定内存区域，是一个连续内存块，在函数调用期间存储数据，并在函数结束后清除。</p>
<p>栈内存遵循<strong>后进先出（LIFO，Last-In-First-Out）</strong> 原则，即最新放入栈的条目将被最先移除。</p>
<p>在函数调用时，程序会生成一个称为<strong>栈帧（Stack Frame）</strong> 的新元素，然后将其推入该特定函数调用的栈中。</p>
<p>栈帧包括：</p>
<ul>
<li>函数局部变量。</li>
<li>传递给函数的参数。</li>
<li>返回地址，指示程序在函数结束后继续执行的位置。</li>
<li>附加元素，如前一帧的基本指针。</li>
</ul>
<p>函数执行完毕后，其<strong>栈帧</strong>将被移除，控制权将转回到帧内指示的返回地址。</p>
<p>请记住，<strong>栈</strong>内存的容量是有限的，一旦用完，就会发生<strong>栈溢出（Stack Overflow）</strong>，导致程序失败。因此，<strong>栈</strong>并不适合存储大量数据。</p>
<p>此外，<strong>栈</strong>不允许内存块在分配后调整大小。例如，如果我们为<strong>栈</strong>上的数组分配的内存太少，就无法像动态分配内存那样调整其大小。</p>
<p>这些因素促成了堆内存的发明。</p>
<p><strong>堆（Heap）</strong> 是指定用于动态内存分配的计算机内存区域。与<strong>栈</strong>内存自动管理不同，<strong>堆</strong>内存需要手动管理，通过 <code>malloc</code> 等方法分配内存，用 <code>free</code> 等方法释放内存。</p>
<p><strong>堆</strong>上的对象是通过<strong>引用（references）</strong> 访问的，引用是指向这些对象的<strong>指针（pointers）</strong>。对象在<strong>堆</strong>空间中实例化，而<strong>栈</strong>内存则保存对象的引用：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f82fbbc00f9cf3d3738e7c2a6a192abf355437ec97d5afecbf6c5eda1db674cc" alt="准备深入学习 Java 内存管理：垃圾回收器 - CodersTea"></p>
<p><strong>堆</strong>常用于以下场景：</p>
<ul>
<li>数据结构（如数组或对象）所需的内存只有在运行时才能确定（动态分配）。</li>
<li>数据的保留时间必须超过单次函数调用的持续时间。</li>
<li>将来有可能需要调整所分配内存的大小。</li>
</ul>
<p>本文后续内容的重点将放在<strong>堆</strong>内存的管理上。</p>
<h5 id="垃圾收集器的出现"><a href="#垃圾收集器的出现" class="headerlink" title="垃圾收集器的出现"></a>垃圾收集器的出现</h5><p>堆对象占用的内存可以通过显式删除分配（使用 C 的 <code>free</code> 或 C++ 的 <code>delete</code> 等操作）进行<strong>手动</strong>回收，也可以由运行时系统通过<a href="https://en.wikipedia.org/wiki/Reference_counting" target="_blank" rel="noopener">引用计数</a>或<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)" target="_blank" rel="noopener">垃圾回收</a>实现<strong>自动</strong>回收。</p>
<p>手动内存管理可能会导致两种主要的编程错误：</p>
<p>🔴第一种情况是在内存引用仍然存在的情况下过早释放内存，造成所谓的<a href="https://en.wikipedia.org/wiki/Dangling_pointer" target="_blank" rel="noopener">野指针</a>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/19351473bcde8554a9788f011c6d14f2382a81e0ce64db94eb06b5f46579eb0b" alt="什么是悬空指针，在 c 语言中如何使用？— Quora"></p>
<p>🔴 第二种情况是可能无法释放程序不再需要的对象，造成<a href="https://en.wikipedia.org/wiki/Memory_leak" target="_blank" rel="noopener">内存泄漏</a>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b741926caccf9dbd6e9dbfa2e158dc6698fa3c8ca82a7931a395d26b0d3f1374" alt="内存泄露 - 通过 Kotlin 掌握高性能(oreilly.com)"></p>
<p>在并发编程中，这些问题变得更加复杂，因为多个线程可能会同时引用同一个对象。</p>
<p>因此，有必要对各种方法进行评估和重组，从而打造自动内存管理。</p>
<p>简单来说，自动内存管理可以看作是对手动内存管理的重构：</p>
<p>☑️ 内存管理集中在垃圾回收器这一单一工具中，由<strong>运行时控制</strong>（通常由虚拟机控制）。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b143de45fba2a658f5ee25ec48f3b1b9b6cc9c74e4a52e0b8b61ada7546f6cc6" alt="Java 垃圾回收基础 (oracle.com)"></p>
<p>☑️ 垃圾收集器的内存管理方法简化了手动释放内存的过程，使代码更易于阅读和维护。</p>
<p>☑️ 内存调试和分析变得更加高效。</p>
<p>☑️ 垃圾收集器和自动内存管理算法的升级变得可扩展、通用和高效。</p>
<p>垃圾回收器里有什么秘密？接下来我们将进一步探讨！</p>
<h4 id="垃圾收集器概述"><a href="#垃圾收集器概述" class="headerlink" title="垃圾收集器概述"></a>垃圾收集器概述</h4><p>垃圾收集器（GC）是一个定期触发的后台程序，能自动释放不再使用的对象所占用的内存，从而使内存满足应用程序的未来需求。</p>
<p>GC 如何识别未使用的对象？</p>
<p>垃圾收集器（GC）通过定位那些不再被运行程序的任何部分引用的对象来识别未使用的对象。如果一个对象没有任何活跃引用，就会被认为是死对象，可以被收集，从而释放内存。</p>
<p>堆不仅可以被局部变量引用，也可以被全局变量和静态变量、线程栈（被线程的执行栈引用的对象）和常量池（存储程序使用的常量值）引用。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/983fad1e7fbede26b4a8d49be2bfcd25ba0a249085a0b5b514625937a4bfb43b" alt="Java 中的垃圾回收 (2) (javacodegeeks.com)"></p>
<p>任何持有<strong>堆</strong>对象但不在<strong>堆</strong>中的指针（引用）都可以称为<strong>根（root）</strong>，垃圾回收利用这些<strong>根</strong>来确定对象是否有效。如果某个对象可以被任意一个<strong>根</strong>直接访问或临时访问，那么就不会被视为垃圾对象。如果无法访问，则视为垃圾，需要进行收集。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5fbfc71221bf6f914ecd88ff67987e263f61348731c91d4e0d48f5e031121ff3" alt="垃圾收集方法 - Hyperskill"></p>
<p>托管内存系统由在堆中运行的突变器（mutator）和垃圾回收器组成：</p>
<ul>
<li><strong>突变器</strong>是修改堆对象的程序（应用程序）。</li>
<li><strong>突变器</strong>通过分配器<strong>申请</strong>堆内存，而<strong>收集器</strong>则负责<strong>回收</strong>堆内存。</li>
<li>内存<strong>分配器</strong>和垃圾回收器合作管理堆内存空间。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e4ce9687f3cf2db664492e859e24ac80835520dc2b4cdffa7b800cb96a7329f5" alt="编写内存分配器 - Dmitry Soshnikov"></p>
<p>垃圾回收器的基本特征包括：</p>
<ul>
<li>最短的整体执行时间（吞吐量）。</li>
<li>优化空间使用（内存开销）。</li>
<li>停顿时间最少（尤其是实时任务）。</li>
<li>改进突变器的定位。</li>
<li>可扩展性。</li>
</ul>
<p>垃圾收集器所使用的各种算法在方法、优化和利弊方面各不相同，因此上述特性也会受到影响。</p>
<p>在接下来的章节中，我们将研究不同的算法，以确定它们的优势、局限性和在现实世界中的潜在用途。</p>
<p>开始！</p>
<h4 id="Mark-Sweep"><a href="#Mark-Sweep" class="headerlink" title="Mark-Sweep"></a>Mark-Sweep</h4><h5 id="工作原理和算法"><a href="#工作原理和算法" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p>Mark-Sweep 原始算法是由<a href="https://groups.seas.harvard.edu/courses/cs252/2016fa/16.pdf" target="_blank" rel="noopener">约翰-麦卡锡（John McCarthy）于 1960 年为 Lisp 引入</a>，基于某种STW（stop-the-world）机制。当程序请求内存但没有可用内存时，程序会被停止，并执行一次完整的垃圾回收以释放空间。</p>
<p>Mark-Sweep GC 的运行可概括为以下几个阶段：</p>
<p>1️⃣第一步是提取并准备根列表。根可能是局部变量、全局变量、静态变量或线程栈中引用的变量。</p>
<p>2️⃣ 确定所有根节点后，就进入<strong>标记阶段（mark phase）</strong>。标记阶段需要对根节点进行<a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">深度优先搜索（DFS）</a>遍历，目的是将根节点可到达的所有节点标记为活跃节点。</p>
<blockquote>
<p>许多垃圾收集算法在收集程序的核心部分都采用了<strong>跟踪例程(tracing routine)</strong>，<strong>该例程会标记每一个可以从初始根集到达的对象</strong>。跟踪例程通常会执行<strong>图遍历</strong>，使用标记栈，其中包含一组已访问过但其子对象尚未扫描的对象。跟踪流程会反复从标记栈中取出对象，标记其子对象，并将之前未标记的每个子对象插入标记栈。从标记栈中插入和移除对象的顺序决定了跟踪顺序。<strong>最常见的跟踪顺序是后进先出标记栈的 DFS（深度优先搜索）和作为先进先出队列工作的标记栈的 BFS（广度优先搜索）</strong>。</p>
<p>– <a href="https://web.archive.org/web/20170809123435id_/http://www.cs.technion.ac.il/~erez/Papers/dsa-ismm-15.pdf" target="_blank" rel="noopener">数据结构感知垃圾回收器</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7dd82b6d39701cdff63eb8c1c552bdc7a66b1710663ed76680687e68f37c3ba5" alt="COSC 340：软件工程导论 (utk.edu)"></p>
<p>3️⃣ 未标记的节点是垃圾节点，因此在<strong>清扫阶段（sweep phase）</strong>，GC 会遍历所有对象并释放未标记的对象。此外还会重置已标记的对象，为下一循环做好准备。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d28de7414d40b2eaa31e3c1534e59b1bfd91e5b2e553dd9ef11410f17221de59" alt="COSC 340：软件工程导论 (utk.edu)"></p>
<p>基本 Mark-Sweep 算法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码//Marking</span><br><span class="line">Add each object referenced by the root set to Unscanned and set its reached-bit to 1;</span><br><span class="line">while(Unscanned != empty set)&#123;</span><br><span class="line">     remove some object o from Unscanned;</span><br><span class="line">     for(each object o&apos; referenced in o)&#123;</span><br><span class="line">         if(o&apos; is unreached; i.e, reached-bit is 0)&#123;</span><br><span class="line">              set the reached-bit of o&apos; to 1;</span><br><span class="line">            place o&apos; in Unscanned;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Sweeping</span><br><span class="line">Free = empty set;</span><br><span class="line">for(each chunk of memory o in heap)&#123;</span><br><span class="line">    if(o is unreached, i.e, its reached-bit is 0) add o to Free;</span><br><span class="line">    else set reached-bit of o to 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Mark-Sweep GC 有一个优点：由于对象在 GC 期间不会移动，因此无需更新其指针。不过，也有几个缺点：</p>
<ul>
<li>由于在不扫描整个堆的情况下很难找到无法到达的对象，因此其扫描阶段的成本很高。</li>
<li>垃圾回收过程中必须停止执行程序，从而导致严重的性能问题。</li>
<li>堆中未使用内存的累积会导致内存碎片，使其无法用于新对象。</li>
</ul>
<p>显然，Mark-Sweep GC 不适合实时系统。</p>
<p>我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例"><a href="#真实用例" class="headerlink" title="真实用例"></a>真实用例</h5><p>该算法的原始版本可以在这些应用中找到：</p>
<p>1️⃣ uLisp：</p>
<blockquote>
<p>uLisp 中使用的垃圾回收器类型称为标记和扫描。首先，<code>markobject()</code> 会标记所有仍可访问的对象。然后，<code>sweep()</code> 基于未标记的对象建立一个新的 freelist，并删除已标记对象的标记。</p>
<p>– <a href="http://www.ulisp.com/show?1BD3" target="_blank" rel="noopener">uLisp — Garbage collection</a></p>
</blockquote>
<p>2️⃣ Ruby 的早期版本：</p>
<blockquote>
<p>Ruby 的第一个版本已经有了基于标记扫描（M&amp;S，Mark and Sweep）算法的 GC。M&amp;S 是最简单的 GC 算法之一，包括两个阶段：(1) 标记：遍历所有存活对象并标记。(2) 清扫：对未标记的未使用对象执行垃圾收集。</p>
<p>虽然 M&amp;S 算法简单且运行良好，但也存在一些问题。最重要的问题是”吞吐量 “和”暂停时间”。由于 GC 的开销，Ruby 程序的 GC 速度会减慢。换句话说，低吞吐量会增加应用程序的总执行时间。每次 GC 都会停止 Ruby 应用程序的运行。停顿时间过长会影响交互式网络应用的用户体验。Ruby 2.1 引入了分代垃圾回收（generational garbage collection），以解决”吞吐量”问题。</p>
<p>– <a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">Ruby 2.2 中的增量式垃圾回收 | Heroku</a></p>
</blockquote>
<p>此外，还可以找到原始算法的改进版本：</p>
<p>1️⃣增量式标记扫描算法（Incremental Mark-Sweep algorithm）：</p>
<p>➖ Ruby 2.2：</p>
<blockquote>
<p>增量式垃圾回收算法将垃圾回收执行过程拆分为多个细粒度过程，并将垃圾回收过程和 Ruby 进程交错处理。增量式垃圾回收会在一段时间内发起许多次较短的暂停，而不是一次长时间的暂停。总暂停时间是一样的（或者由于使用增量 GC，开销甚至更长一些），但每个单独的暂停时间要短得多，从而使得性能更加稳定。</p>
<p>– <a href="https://blog.heroku.com/incremental-gc" target="_blank" rel="noopener">Ruby 2.2 中的增量式垃圾回收 | Heroku</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37d2c0268040c26172ae2af24d2fc6c4788e50b65852df453f4f97d868d5dd4e" alt="STW：Stop the world与增量式标记"></p>
<p>➖ OCaml：</p>
<blockquote>
<p>大堆通常比小堆大很多，可以扩展到千兆字节大小。垃圾收集算法分几个阶段运行[…]<strong>标记和清扫阶段在堆的片段上增量运行，以避免长时间暂停应用程序</strong>，并在每个片段之前进行快速的小堆收集。只有压缩阶段会一次性触及所有内存，不过这是相对罕见的操作。</p>
<p>– <a href="https://dev.realworldocaml.org/garbage-collector.html" target="_blank" rel="noopener">了解垃圾回收器 - 真实的 OCaml 世界</a></p>
</blockquote>
<p>➖ Mozilla SpiderMonkey:</p>
<blockquote>
<p>SpiderMonkey 的垃圾回收（GC）采用增量标记模式、 分代回收和压缩。大部分 GC 工作在辅助线程上执行。</p>
<p>– <a href="https://udn.realityripple.com/docs/Mozilla/Projects/SpiderMonkey/Internals/Garbage_collection" target="_blank" rel="noopener">垃圾回收（realityripple.com）</a></p>
</blockquote>
<p>2️⃣ 并发标记扫描（CMS，Concurrent Mark-Sweep）算法：</p>
<blockquote>
<p>并发标记扫描（CMS）收集器是专为那些希望缩短垃圾收集暂停时间的应用程序而设计的，这些应用程序可以在应用程序运行时与垃圾收集器共享处理器资源。</p>
<p>– <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/cms.html" target="_blank" rel="noopener">并发标记扫描（CMS）收集器（oracle.com）</a></p>
</blockquote>
<blockquote>
<p>并发标记扫描收集器（或并发收集器、CMS）是 Oracle HotSpot Java 虚拟机（JVM）中的标记扫描垃圾收集器，自 1.4.1 版起可用，在第 9 版中被弃用，在第 14 版中被移除，因此从 Java 15 开始就不再可用了。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Concurrent_mark_sweep_collector" target="_blank" rel="noopener">并发标记清扫收集器 - 维基百科</a></p>
</blockquote>
<p>顺便提一下，Java 已用 <a href="https://bugs.openjdk.org/browse/JDK-8229049?page=com.atlassian.jira.plugin.system.issuetabpanels%3Achangehistory-tabpanel" target="_blank" rel="noopener">Z 垃圾收集器 (ZGC) 和 Shenandoah 收集器</a>取代了并发标记扫描(CMS)，我们将在接下来的章节中介绍。</p>
<h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><h5 id="工作原理和算法-1"><a href="#工作原理和算法-1" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://www.cs.cornell.edu/courses/cs312/2003fa/lectures/sec24.htm" target="_blank" rel="noopener">复制垃圾回收(Copying Garbage Collection)</a>的原理是将堆分成两个大小相等的半空间：<strong>源空间(from-space)</strong> 和<strong>目标空间(to-space)</strong> ：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/105f8079355448bc07ebabf0913379533e7457d82543c140537e348cdb0ce636" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>1️⃣ 内存在源空间中分配，而目标空间为空。</p>
<p>2️⃣ 当源空间已满时，源空间中所有可访问的对象都会被复制到目标空间，指向它们的指针也会相应更新。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ed0f1edd23384fa3eb9501d2e0d5ed33986e6a5065fc65ee3dd52efacc6ad125" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>⛔ 在复制对象之前，有必要验证该对象以前是否被复制过。如果已经复制，则不应再次复制该对象，而应使用现有副本。在复制完源空间对象后，可以通过在该对象中放置一个”转发指针”来进行验证。</p>
<p>3️⃣ 最后，两个空间的角色互换，程序继续运行。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/861a42a9754c26462bb5115978317f25ba00ab2c76a5d9267f098415fcc38730" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>✔️ 在复制垃圾回收器中，内存分配在源空间中线性进行，无需空闲列表或搜索空闲块。只需用一个指针标记源空间中已分配区域和空闲区域的边界即可。</p>
<p>✔️ 此外，复制垃圾回收器中的分配非常快，几乎与栈分配一样快。</p>
<p>原始复制垃圾回收算法执行的是可达图（reachable graph）的<a href="https://en.wikipedia.org/wiki/Depth-first_search" target="_blank" rel="noopener">深度优先遍历</a>，在递归执行时可能会导致<a href="https://en.wikipedia.org/wiki/Stack_overflow" target="_blank" rel="noopener">栈溢出</a>。</p>
<p>相比之下，Cheney的复制垃圾回收算法是一种高效的技术，它对可达图进行<a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noopener">广度优先遍历</a>，只需要一个指针作为附加状态：</p>
<p>✳️ 在任何广度优先遍历中，都有必要跟踪已被访问但其子节点尚未被探索的节点集。</p>
<blockquote>
<p>需要额外内存（通常是<a href="https://en.wikipedia.org/wiki/Queue_(data_structure)" target="_blank" rel="noopener">队列</a>）来跟踪已访问但尚未探索的子节点。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Breadth-first_search" target="_blank" rel="noopener">广度优先搜索 - 维基百科</a></p>
</blockquote>
<p>✳️ Cheney算法从根本上使用目标空间来存储这组节点，并用一个名为 <code>scan</code> 的指针来表示。</p>
<p>✳️ 这个指针将目标空间分为两部分：一部分是已访问过的子节点，另一部分是尚未访问过的子节点。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7f460dc3be3e253bf7f9b475df9922ca8b5f389c7ff75044155bc453f653ba81" alt="acc14_09_memory-management (epfl.ch)"></p>
<p>➕ 使用复制垃圾回收代替标记和扫描的优势在于消除外部碎片、快速分配和避免死对象遍历。</p>
<p>➕ 切尼算法的一个主要特点是，它从不接触任何需要释放的对象，只遵循从活跃对象到活跃对象的指针。</p>
<p>➖ 但缺点是需要消耗两倍的虚拟内存，必须准确识别指针，复制成本可能很高。</p>
<p>Github上有<a href="https://gist.github.com/DEADB17/3fc90d569fb6f7466441" target="_blank" rel="noopener">实现Cheney算法的伪代码</a>。</p>
<p>让我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例-1"><a href="#真实用例-1" class="headerlink" title="真实用例"></a>真实用例</h5><p>1️⃣ Ocaml：</p>
<blockquote>
<p>为了对小堆进行垃圾回收，OCaml 会使用复制收集（copying collection）将小堆中的所有活跃块移动到大堆中。这需要的工作量与小堆中的活跃块数量成正比，而根据世代假设，小堆中的活跃块数量通常较少。一般来说，垃圾回收器会在运行过程中STW（即停止程序运行），这就是为什么必须快速完成，以便让应用程序以最小的代价恢复运行。</p>
<p>– <a href="https://dev.realworldocaml.org/garbage-collector.html" target="_blank" rel="noopener">了解垃圾回收器 - 真实世界 OCaml</a></p>
</blockquote>
<p>2️⃣ LISP：</p>
<blockquote>
<p>Fenichel 和 Yochelson 描述了在使用虚拟内存的 LISP 系统中，性能是如何随着时间的推移而下降的。他们的解决方案–复制垃圾回收（经 Cheney 进一步修改）–在现代 LISP 系统中被广泛采用，但其性能受到了限制，因为需要扫描可能很大的根集，并在每次垃圾回收时将通过计算维护的所有结构从一个区域移动到另一个区域。</p>
<p>– <a href="https://apps.dtic.mil/sti/tr/pdf/ADA290169.pdf" target="_blank" rel="noopener">通用计算机上 LISP 系统的终身垃圾收集器。(dtic.mil)</a></p>
</blockquote>
<p>3️⃣ Chicken (Scheme实现):</p>
<blockquote>
<p>所使用的设计是一种复制垃圾收集器，最初由 C. J. Cheney 设计，它将所有活跃对象复制到堆中。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Chicken_(Scheme_implementation)" target="_blank" rel="noopener">Chicken (Scheme implementation) — Wikipedia</a></p>
</blockquote>
<p>我们对复制垃圾回收领域的探索到此结束，现在让我们进入一种新的算法！</p>
<h4 id="标记-压缩-Mark-Compact"><a href="#标记-压缩-Mark-Compact" class="headerlink" title="标记-压缩(Mark-Compact)"></a>标记-压缩(Mark-Compact)</h4><h5 id="工作原理和算法-2"><a href="#工作原理和算法-2" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><blockquote>
<p><strong>标记-压缩算法可以看作是标记-扫描算法和Cheney复制算法的结合</strong>。首先，对可达对象进行标记，然后通过压缩步骤将可达（标记）对象移至堆区域的起始位置。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Mark%E2%80%93compact_algorithm" target="_blank" rel="noopener">标记-压缩算法 - 维基百科</a></p>
</blockquote>
<p>Mark-Compact 算法在运行过程中会经历不同阶段：</p>
<p>1️⃣ 从<strong>标记阶段</strong>开始，在这一阶段识别实时数据。</p>
<p>2️⃣ 接下来，通过重新定位对象和更新所有已移动对象的实时引用的指针值来<strong>压缩</strong>实时数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ae9ddf236ede04170027f695ffb9b7422b4663e6286acf11fd5b74f92d54d039" alt="COSC 340：软件工程导论 (utk.edu)"></p>
<p>压缩的方法有很多种，既可以保留原来的顺序，也可以不考虑。以下是几种不同的方法：</p>
<p>1️⃣ <strong>任意（Arbitrary）</strong>：不保持逻辑或空间顺序。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5f177a57a06ecc97aaa9a1d8d8e47fef7b2daf0af61ac0db570645639cdba6d7" alt="02-压缩(technion.ac.il)"></p>
<p>2️⃣ <strong>线性化（Linearizing）</strong>：移动物体，然后根据逻辑关系排序，即把相互指向的物体移动到相邻位置。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fb6a82e227b6fbae57d250f120580beb1d10a113d44c5c05383f4967043509b7" alt="02-压缩(technion.ac.il)"></p>
<p>3️⃣ <strong>滑动（Sliding）</strong>：保持原来的分配顺序。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/202d75771763d2ca503961d9ed7d7e59922a74737fcd176918e80cc25818a818" alt="02-压缩(technion.ac.il)"></p>
<p>让我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例-2"><a href="#真实用例-2" class="headerlink" title="真实用例"></a>真实用例</h5><p>有五种著名的压缩算法：</p>
<ul>
<li>双指算法（Two-finger algorithm，桑德斯 - 1974 年）：由于性能问题，实际中并没有使用。</li>
<li><a href="https://www.softwarepreservation.org/projects/LISP/lisp2/TM-3417_500_00_LISP2_GC_Spec.pdf" target="_blank" rel="noopener">Lisp 2 算法</a>。</li>
<li><a href="https://tugawa.github.io/publication/ismm2021-preprint.pdf" target="_blank" rel="noopener">Jonkers 的线程算法</a>（1979 年）。</li>
<li>SUN 的并行算法（<a href="https://www.usenix.org/legacy/events/jvm01/full_papers/flood/flood.pdf" target="_blank" rel="noopener">Flood-Detlefs-Shavit-Zhang - 2001</a>）。</li>
<li>IBM 的并行算法（<a href="https://research.ibm.com/haifa/Workshops/compiler2004/papers/GCforcompiler.pdf" target="_blank" rel="noopener">Abuaiadh-Ossia-Petrank-Silbershtein - 2004</a>）。</li>
<li>The Compressor (<a href="https://csaws.cs.technion.ac.il/~erez/Papers/compressor-pldi.pdf" target="_blank" rel="noopener">Kermany-Petrank — 2006</a>)。</li>
</ul>
<p>算法可分为以下几类：</p>
<ul>
<li><strong>单处理器压缩（Uni-processor compaction）</strong> 包括双指、Lisp2 和 Jonkers线程。</li>
<li><strong>并行编译（Parallel compaction）</strong> 包括 Sun 的编译、IBM 的编译和 Compressor（并行、并发、延迟……）。</li>
</ul>
<p>下面的表格总结了单处理器压缩算法的特点：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fd553acb21d4c905bf53db56c8e266a60092dd695b7493bda38ce6f954c7cdf7" alt="02-压缩(technion.ac.il)"></p>
<p>该表比较了 Jonkers 的线程算法、仅限于单线程的 IBM 并行压缩算法和完全并行的 IBM 并行压缩算法的性能（时间单位为毫秒）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/60f52d63f369ed223636292054f746e79dff48717b15abeca32eea454d71e97a" alt="02-压缩(technion.ac.il)"></p>
<p>即使仅限于单线程，IBM 的并行编译算法仍能保持高效，提供显著的速度提升和高质量的编译。</p>
<p>让我们使用更先进的算法！</p>
<h4 id="分代"><a href="#分代" class="headerlink" title="分代"></a>分代</h4><h5 id="工作原理和算法-3"><a href="#工作原理和算法-3" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p>分代垃圾收集是指根据对象的年龄将其分成若干代，并优先收集年轻代，而不是较老的一代。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/70901426ecdb58e192e9d944b1e77f2e41f525ac297e741bae5580ac78c8725a" alt="垃圾收集 (grinnell.edu)"></p>
<p>1️⃣ <strong>年轻代（The Young Generation）</strong> 是分配和老化所有新对象的地方。</p>
<p>2️⃣ 当年轻代填满时，会引发一次小规模垃圾收集，被死对象填满的年轻代很快就会被收集起来。</p>
<p>🚩 所有小规模垃圾回收都是STW事件。</p>
<p>3️⃣ 根据<strong>晋升政策（Promotion Policy）</strong>，幸存对象被晋升为<strong>老年代（Old Generation）</strong>。</p>
<p>4️⃣ 老年代用于存储存活时间较长的对象。通常情况下，会为年轻代对象设置阈值，当达到该年龄时，该对象就会被转移到老年代。</p>
<p>5️⃣ 当老年代内存已满时，将进行一次<strong>大回收</strong>，回收该代和所有年轻代的内存。</p>
<p>6️⃣ 此外，还为年轻代对象设置了阈值，当达到该阈值（即对象被复制的次数）时，对象就会被移到老年代。</p>
<p>🚩 大型垃圾回收也是STW事件。</p>
<p>✔️ 大部分分代收集器<strong>通过复制来管理年轻代</strong>：原始复制收集器、并行复制收集器或并行清理收集器。</p>
<p>✔️ 可以通过 <strong>Mark-Sweep</strong> 算法、<strong>并发收集器</strong>或<strong>增量收集器</strong>来管理旧世代。</p>
<p>回顾一下优缺点：</p>
<p>➕ 分代 GC 往往能减少 GC 暂停时间，因为大部分时间只收集最年轻的一代，也是最小的一代。</p>
<p>➕ 在复制 GC 时，分代还能避免重复复制长寿命对象。</p>
<p>➖ 在此方案中，由于实时对象可以处于不同的代际空间，因此出现了代间指针（例如，从上一代指向下一代的指针）的问题。</p>
<p>➖ 由于老年代的回收不如年轻代频繁，所以老对象有可能会阻止回收死去的年轻对象。这个问题被称为<a href="https://www.memorymanagement.org/glossary/n.html" target="_blank" rel="noopener">裙带关系问题(Nepotism)</a>。</p>
<p>让我们看看这种算法到底是如何实现和使用的。</p>
<h5 id="真实用例-3"><a href="#真实用例-3" class="headerlink" title="真实用例"></a>真实用例</h5><p>1️⃣ Python：</p>
<blockquote>
<p>标准 CPython 垃圾回收器有两个组成部分，即引用计数回收器和分代垃圾回收器（称为 gc 模块）。</p>
<p>– <a href="https://rushter.com/blog/python-garbage-collector/" target="_blank" rel="noopener">Python 中的垃圾回收：你需要知道的事情 | Artem Golubin (rushter.com)</a></p>
</blockquote>
<blockquote>
<p>为了限制每次垃圾回收所需时间，默认构建的 GC 实现使用了一种流行的优化方法：世代。这个概念背后的主要思想是假设大多数对象的生命周期都很短，因此可以在创建后很快被回收。事实证明，这与许多 Python 程序的实际情况非常接近，因为许多临时对象的创建和销毁都非常快。为了利用这一事实，所有容器对象都被划分为三个空间/世代。每个新对象都从第一代（第 0 代）开始。前一种算法只对某一代的对象执行，如果一个对象在其一代的回收中存活下来，就会被转移到下一代（第 1 代），那里回收频率会更低。如果同一对象在新一代（第 1 代）的另一轮 GC 中存活下来，将被转移到最后一代（第 2 代），在那里回收的次数最少。</p>
<p>– <a href="https://devguide.python.org/internals/garbage-collector/index.html#optimization-generations" target="_blank" rel="noopener">垃圾收集器设计（python.org）</a></p>
</blockquote>
<p>2️⃣ Ruby：</p>
<blockquote>
<p>回到问题的关键：从 Ruby 2.1 开始，Ruby 引入了利用弱代际假设的分代 GC，将更频繁的垃圾回收工作集中在年轻、较新的对象上。Ruby 的垃圾回收器实际上有两种不同类型的垃圾回收：大 GC 和小 GC。小 GC 的频率更高，主要针对年轻对象。(大 GC 发生的频率较低，主要处理所有对象。小 GC 比大 GC 更快，因为查看的对象更少。</p>
<p>– <a href="https://jemma.dev/blog/gc-generational" target="_blank" rel="noopener">Ruby 垃圾回收深度剖析：分代垃圾回收 | Jemma Issroff</a></p>
</blockquote>
<p>3️⃣ V8 的垃圾回收：</p>
<blockquote>
<p>V8 使用分代垃圾收集器，将 Javascript 堆分成小的年轻代和大的老年代，前者用于分配新对象，后者用于长期存活的对象。由于大多数对象生命周期较短，因此这种分代策略使垃圾收集器可以在较小的年轻代中执行定期、短暂的垃圾收集（称为清扫），而无需跟踪老年代中的对象。年轻代使用半空间（复制）分配策略，新对象最初分配到年轻代的活跃半空间中。一旦半空间满了，清扫操作就会把活跃对象移到另一个半空间。已经移动过一次的对象会被提升到老年代，并被视为长寿对象。一旦活跃对象被移动，就会激活新的半空间，旧半空间中剩余的死对象就会被丢弃。老年垃圾收集器使用标记-扫描收集器（分多个小步骤增量标记活跃对象），并进行了多项优化，以改善延迟和内存消耗。</p>
<p>– <a href="https://v8.dev/blog/free-garbage-collection" target="_blank" rel="noopener">免费获取垃圾回收 - V8</a></p>
</blockquote>
<p>4️⃣ Java 序列收集器：</p>
<blockquote>
<p>串行 GC 是最简单的 Java GC 算法，是单核 32 位机器上的默认收集器。[…]串行收集器是一种分代垃圾收集器，年轻代使用疏散收集器（也称为标记复制收集器），老年代使用标记-清扫-压缩（MSC）收集器。年轻代的收集器称为Serial，而老年代的收集器称为Serial（MSC）。不过，对于大多数现代服务端应用来说，串行收集器并不实用。[…]并行收集器是具有两个或两个以上 CPU 的 64 位机器上的默认垃圾收集器（最高到 Java 8）。与串行收集器类似，都是分代收集器，但使用多线程来执行垃圾收集。并行收集器使用多个线程同时收集年轻代和老年代。并行收集器使用名为 ParallelScavenge 的标记复制收集器收集年轻代，使用名为 ParallelOld 的标记-清扫-压缩收集器收集老年代，这与串行收集器类似，主要区别在于并行收集器中使用了多个线程。</p>
<p>– <a href="https://abiasforaction.net/understanding-jvm-garbage-collection-part-6-serial-and-parallel-collector/#:~:text=The%20serial%20collector%20is%20a,is%20called%20Serial%20(MSC)." target="_blank" rel="noopener">了解 JVM 垃圾收集 - 第 6 部分（串行和并行收集器）</a></p>
</blockquote>
<blockquote>
<p>年轻代由伊甸园（eden）和两个幸存者空间（survivor spaces）组成。大多数对象最初都分配在 eden 中。其中一个幸存者空间在任何时候都是空的，是 eden 中所有活跃对象的目的地，另一个幸存者空间则是下一次复制集合的目的地。对象以这种方式在活跃空间之间复制，直到年龄足够长（复制到老年代）。</p>
<p>– <a href="https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/generations.html" target="_blank" rel="noopener">世代（oracle.com）</a></p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/97691f660b7ad6fd1a7a0112e52312f15c73a7a370ca017f023fd12e000610b7" alt="世代（oracle.com）"></p>
<p>各种各样的算法和思考让我着迷。让我们在接下来的章节中进一步了解更现代、更复杂的 GC！</p>
<h4 id="垃圾优先（G1-Garbage-first）"><a href="#垃圾优先（G1-Garbage-first）" class="headerlink" title="垃圾优先（G1,Garbage-first）"></a>垃圾优先（G1,Garbage-first）</h4><h5 id="工作原理和算法-4"><a href="#工作原理和算法-4" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-E9CB81BC-92E5-489E-8A2E-760691A41CDF" target="_blank" rel="noopener">垃圾优先（G1）</a>是 Sun Microsystems 推出的一种垃圾收集算法，用于 Java 虚拟机（JVM）。</p>
<p>是一个分代、分区、增量、并行、并发为主、stop-the-world 和疏散（压缩）的垃圾收集器。</p>
<p>🔵 分区垃圾收集器将堆划分为多个区域，每个区域大小相等：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/991f0415aa8622bd298547ccdb407a05bc08732697b9f2c59ad84d03368ae7de" alt="垃圾优先（G1）垃圾收集器（oracle.com）"></p>
<p>🔵 每个区域都由不同部分组成：</p>
<ul>
<li><strong>空间（Space）</strong>：根据堆的最大大小，为每个区分配的空间从 1MB 到 32MB 不等。</li>
<li><strong>活跃（Alive）</strong>：区域内仍然活跃的部分对象。</li>
<li><strong>垃圾（Garbage）</strong>：区域内某些不再需要的对象，可归类为垃圾。</li>
<li><strong>RSet（Remembered Set）</strong>：一种元数据，可帮助跟踪哪些对象是有效的，哪些不再需要。该数据有助于 JVM 在任何给定时间内计算区域内有效对象的百分比（Liveness % = Live Size / Region Size）。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2a9c7f64034b937333bcd68a30282d39e37016887491e7cf61ce2469b626f2b3" alt="G1 GC - 性能工程入门 | Dhaval Shah (dhaval-shah.com)"></p>
<p>🔵 <strong>伊甸园（Eden）</strong>、<strong>幸存者（Survivor）</strong> 和<strong>旧（Old）</strong> 区不需要像旧版垃圾收集器（逻辑区域集）那样连续：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dfdbf2c43b19278a2a0b17f2b1c8ae222a7d4b008ed416da995961400c68523a" alt="G1 GC - 性能工程学入门 | Dhaval Shah (dhaval-shah.com)"></p>
<p>🔵 伊甸园区（”E”）和幸存者区（”S”）属于年轻代。</p>
<p>🔵 应用程序总是专门在伊甸园区分配对象，但大对象（跨越多个区的对象）除外，这些对象直接分配给老年代。</p>
<p>🔵 G1收集器在两个阶段之间交替运行：年轻（young-only）阶段和空间回收（space-reclamation）阶段。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/32198b8f5e321d29a876bc9f061cebe7df673b511e907f752d9d7c2e3acb5b39" alt="垃圾优先（G1）垃圾收集器（oracle.com）"></p>
<p>1️⃣ Young-only GC 负责将对象从伊甸园提升到幸存者区，或将幸存者区提升到老年区。Young-only事件被视为STW事件。</p>
<p>2️⃣ G1 收集器执行以下阶段，作为Young-only GC 的一部分：</p>
<ul>
<li><strong>初始标记（Initial Mark）</strong>：启动标记过程，同时进行常规的只收集年轻对象的工作。并发标记会确定旧一代区域中的所有实时对象（不是STW事件）。</li>
<li><strong>标记（Remark）</strong>：通过执行全局引用处理和类卸载，最终完成标记。回收完全清空的区域并清理内部数据结构（这是STW事件）。</li>
<li><strong>清理（Cleanup）</strong>：确定是否需要进行空间回收混合收集（这是STW事件）。</li>
</ul>
<p>3️⃣ 空间回收阶段涉及多个混合收集，不仅针对年轻代区域，还从选定的老年代区域回收活跃对象。</p>
<p>4️⃣ 当 G1 得出结论，进一步回收老年代区域不会产生大量空闲空间来证明所做努力的合理性时，空间回收阶段结束。</p>
<p>5️⃣ 空间回收后，收集周期重新开始，进入另一个Young-only阶段。</p>
<p>6️⃣ 如果应用程序在收集有效性信息时内存耗尽，G1 将执行就地停止的全堆压缩（Full GC）作为预防措施，与其他收集器类似。</p>
<p>🔵 根据我们所看到的，以下是使用 G1 的一些优缺点：</p>
<p>➕ 优点：</p>
<ul>
<li>可预测的暂停时间</li>
<li>基于区域的收集</li>
<li>自适应大小</li>
<li>压缩</li>
<li>软实时性能</li>
</ul>
<p>➖ 缺点：</p>
<ul>
<li>初始标记暂停</li>
<li>增加了 CPU 开销</li>
<li>与其他收集器相比，成熟度较低</li>
<li>堆碎片</li>
<li>配置复杂</li>
</ul>
<p>总之，垃圾优先（G1）具有可预测的暂停时间和有效的内存管理等显著优势。不过，并不是每个应用程序的理想选择，通常需要进行细致调整才能获得最佳性能。</p>
<blockquote>
<p>垃圾优先（G1）收集器是一种服务器风格的垃圾收集器，适用于具有大内存的多处理器机器，能高概率的实现垃圾收集（GC）暂停时间目标，同时实现高吞吐量。</p>
<p>– <a href="https://www.oracle.com/technetwork/tutorials/tutorials-1876574.html#:~:text=The%20Garbage%2DFirst%20(G1),probability%2C%20while%20achieving%20high%20throughput." target="_blank" rel="noopener">G1 垃圾收集器入门 (oracle.com)</a></p>
</blockquote>
<h5 id="真实用例-4"><a href="#真实用例-4" class="headerlink" title="真实用例"></a>真实用例</h5><p>垃圾优先（G1）算法是为 Java 虚拟机（JVM）创建的，通常用于在 JVM 上运行的编程语言，主要是 Java。任何使用 JVM 垃圾收集功能的 Java 应用程序都有可能通过 G1 垃圾收集器得到改进。</p>
<p>值得注意的是，G1 并不局限于 Java 语言本身，而是 JVM 运行时环境。其他可在 JVM 上运行的语言，如 Kotlin、Scala、Groovy 和 Clojure，在 JVM 上运行时也可以使用 G1 垃圾收集器。</p>
<p>接下来，我们将深入探讨另一种现代垃圾回收器的工作原理：Z！</p>
<h4 id="Z"><a href="#Z" class="headerlink" title="Z"></a>Z</h4><h5 id="工作原理和算法-5"><a href="#工作原理和算法-5" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p>Z 垃圾收集器（ZGC）是一种高性能的垃圾收集器，专门用于处理大型内存堆，如太字节级的内存堆。</p>
<p>ZGC 分为两类：<a href="https://openjdk.org/jeps/333" target="_blank" rel="noopener">非分代 ZGC</a> 和<a href="https://openjdk.org/jeps/439" target="_blank" rel="noopener">分代 ZGC</a>。非分代 ZGC 自 Java 15 开始在生产中使用，而分代 ZGC 是 Java 21 的一部分。</p>
<p>有一份关于<a href="https://openjdk.org/jeps/8326667" target="_blank" rel="noopener">在未来版本中废弃非分代 ZGC 的草案</a>：</p>
<blockquote>
<p>弃用非分代 ZGC，以便在未来版本中将其删除。将分代 ZGC 改为默认 ZGC 模式，并废弃 <code>ZGenerational</code> 标志。</p>
<p>– <a href="https://openjdk.org/jeps/8326667" target="_blank" rel="noopener">JEP 草案：废弃非世代 ZGC（openjdk.org）</a></p>
</blockquote>
<p>ZGC 可同时管理几乎所有垃圾回收进程：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cf27aeb867ad4dc7adbb639df53d211473b5ce6a6c34ee21a0d16a87040d5745" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p>ZGC 运行周期包括 3 个阶段。每个阶段都以一个”安全点(safe-point)”同步点开始，包括暂停所有应用线程，又称 STW。除这 3 个阶段外，所有操作都与应用程序的其他部分同步进行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4b59d80515604305f623223cf4329299c2163fe71540fd0cf84290065eab6b57" alt="Z 垃圾收集器 - 简介 (openjdk.org)"></p>
<p>停顿总是低于毫秒：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0bad6dd87bcfef3b990b51856e44de6cdd46eb49300df5ab27dfc2214cbccacc" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2a3a2220877c750600af01bff0989f577109fa847cb12c0123b9403f0d2e12ab" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p>1️⃣ 第一阶段：周期开始时有一个同步暂停 (STW1)，允许：</p>
<ul>
<li>线程确定要使用的正确”颜色”（<strong>彩色指针，colored pointers</strong>）。</li>
<li>创建内存页（<strong>ZPages</strong>）。</li>
<li>确保所有”GC 根”都有效（颜色正确），必要时进行更正（<strong>加载屏障，Load Barriers</strong>）</li>
</ul>
<p>Mark/Remap 的后续并发阶段包括遍历对象图，以确定候选收集对象。</p>
<p>2️⃣ 第二阶段：STW2 暂停标志着标记阶段的结束。并行处理可识别需要压缩的内存区域。</p>
<p>3️⃣ 第三阶段：在 STW3 中再次识别出正确的颜色后，同时移动对象以压缩内存，从而完成循环。</p>
<p>让我们深入了解一下各种关键词的细节：</p>
<p>✳️ <strong>ZPages</strong>：ZGC 将堆内存分割成称为 ZPage 的区域，分为小、中、大三种：</p>
<ul>
<li>小（2 MiB - 对象大小不超过 256 KiB）。</li>
<li>中（32 MiB - 对象大小不超过 4MiB）。</li>
<li>大（4 MiB 以上 - 对象大小 &gt; 4 MiB）。</li>
</ul>
<p>中小页可以容纳多个对象，而大页只能容纳一个对象。这种限制有助于防止大型对象的移动，因为移动大型对象需要复制大量内存，可能会导致严重的延迟。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a94c9e8e1d9c14bc9e2fe39066dac82343c886967353e66eeaa24bcbd36e6aa8" alt="深入了解 ZGC 的架构 - Dev.java"></p>
<p>✳️ <strong>压缩和重定位</strong>：堆对象会不断压缩，以解决内存逐步碎片化的问题，并保证新对象的快速分配。</p>
<p>在生命周期中，可压缩页在第二阶段被识别（标记）（通常是对象最少的页），然后驻留在这些页上的所有对象在第三阶段被重定位。一旦页上没有任何对象，就可以回收其内存。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4f721c5392fcde11927ae2fa1efa242bd49a1ec3b996747822952dfdea741c6f" alt="深入了解 ZGC 的架构 - Dev.java"></p>
<p>为了同时执行重定位操作，ZGC 维护<strong>路由表</strong>。这些表存储在堆外，并为快速读取进行了优化，但会增加内存成本。</p>
<p>✳️ <strong>彩色指针</strong>：我们的目标是在指针中存储对象生命周期的相关信息，这是允许同时执行多种操作的关键。</p>
<p>4 比特专门用于存储元数据：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7d65ac2f275673cd09b23ce62f1a9dcf055e74f9ca39a244348f41c5946363fb" alt="Z 垃圾收集器 - 简介 (openjdk.org)"></p>
<p>指针的”颜色”由标记 0 (<strong>M0</strong>)、标记 1 (<strong>M1</strong>) 和重映射 (<strong>R</strong>) 这三个元比特的状态决定：</p>
<ul>
<li>M0 和 M1 用于标记要收集的对象。</li>
<li>重映射表示引用已被重定位。</li>
</ul>
<p>🚩 这三个比特中只有一个比特的值为 1。因此，得到了三种颜色：M0 (100)、M1 (010) 和 R (001)。</p>
<p>一种颜色要么是”好”的，要么是”坏”的，这是由生命周期阶段决定的：</p>
<ul>
<li>新实例化的对象会被标上正确的颜色。</li>
<li>ZGC 周期以短暂的STW（STW 1）开始，在此期间，通过交替改变 M0 和 M1 位的值来确定正确的颜色。因此，如果在一个周期中 M0 是正确的颜色，那么在下一个周期中 M1 将是正确的颜色。</li>
<li>在下一个并发阶段，即并发标记/重映射（Concurrent Mark/Remap）阶段，如果垃圾回收器遇到着色不正确的指针，会将指针更新为正确的地址，并分配适当的颜色。</li>
<li>在周期的最后一个同步点（STW 3），R 为正确的颜色。</li>
</ul>
<p>✳️ <strong>堆多重映射（Heap Multi-Mapping）</strong>：多内存映射允许多个虚拟地址指向同一个物理地址。因此，虚拟地址仅因元数据不同而不同的两个指针会指向相同的物理地址。</p>
<p>ZGC 需要这种技术，因为 ZGC 可以在应用程序运行时移动对象在堆内存中的物理位置。通过多重映射，对象的物理位置会映射到虚拟内存中的三个视图，分别对应指针的每种潜在”颜色”：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/efced130d14f231729429acb2fd3300cab407c67479d0e1f050c0101f39515ff" alt="Z 垃圾收集器 - 简介 (openjdk.org)"></p>
<p>这样，加载屏障就能识别自上一个同步点以来被重定位的对象。</p>
<p>✳️ <strong>加载屏障（Load barriers）</strong>：是 JIT 编译器在策略点注入的小段代码，特别是在从堆中加载对象引用时。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/71ee531ed4fc96240f30c63ab5801ec458ff91c14c1de247ee27c40f532b4402" alt="ZGC - 下一代低延迟垃圾回收器（openjdk.org）"></p>
<p>因为有了加载屏障，对象才可以随时移动，而不会更新指向它的指针。加载屏障会拦截对指针的读取，并对其进行纠正。这就确保了在 GC 和应用程序线程同时运行时，指针在任何时候被加载时都能指向正确的对象。</p>
<blockquote>
<p>在计算机术语中，内存屏障（memory barrier）也称为内存围栏（membar）、内存栅栏（memory fence）或栅栏指令（fence instruction），是一种屏障指令，能使中央处理器（CPU）或编译器对在屏障指令前后发出的内存操作执行顺序约束。通常意味着，在屏障指令之前发起的操作，能够保证在屏障指令之后的操作之前完成。</p>
<p>– <a href="https://en.wikipedia.org/wiki/Memory_barrier" target="_blank" rel="noopener">内存屏障 - 维基百科</a></p>
</blockquote>
<h5 id="真实用例-5"><a href="#真实用例-5" class="headerlink" title="真实用例"></a>真实用例</h5><p>Z 垃圾收集器（ZGC）主要用于在 Java 虚拟机（JVM）上运行的 Java 应用程序。因此，任何编译成 Java 字节码并在 JVM 上运行的编程语言都有可能使用 ZGC，这类语言中最主要的就是 Java 本身。</p>
<p>不过值得注意的是，除了 Java 之外，其他语言也可以在 JVM 上运行，包括 Kotlin、Scala、Groovy、Clojure 和 JRuby 等。只要这些语言利用 JVM 执行，就能受益于 ZGC 提供的功能和优化（如果进行了配置）。</p>
<p>总之，虽然 ZGC 由于与 JVM 集成而主要与 Java 有关，但也可用于其他基于 JVM 的语言。</p>
<p>让我们保持节奏，进入下一个算法！</p>
<h4 id="Shenandoah"><a href="#Shenandoah" class="headerlink" title="Shenandoah"></a>Shenandoah</h4><h5 id="工作原理和算法-6"><a href="#工作原理和算法-6" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://wiki.openjdk.org/display/shenandoah/Main" target="_blank" rel="noopener">Shenandoah</a> 主要由 Red Hat 开发，从 Java 12 开始作为 OpenJDK 的实验功能提供，得到了社区的积极开发和支持。</p>
<p>✔️ 虽然 Shenandoah 和 ZGC 都优先考虑通过<strong>并发垃圾收集</strong>来尽量减少暂停时间，但 Shenandoah 的设计是完全并发的，旨在完全避免 STW 暂停。ZGC 虽然采用了高度并发的方法，但在垃圾收集的某些阶段仍会出现短暂的 STW 停顿。</p>
<p>✔️ 虽然 Shenandoah 和 ZGC 都使用分段方法来管理堆，但分段粒度不同。Shenandoah 使用较大的区域，而 ZGC 使用较小的 ZPage。</p>
<p>✔️ Shenandoah 分几个阶段运行，包括初始标识、同步标识、同步驱逐（同步复制实时对象）和同步清理：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e65924caf291c1a694d2e5be015c27bc8d68b93d83e780d52dafbe812337e5f4" alt></p>
<p>✔️ Shenandoah 主要采用了并发驱逐，而 ZGC 则综合利用了并发标记、驱逐（重定位活跃对象）和压缩（尽量减少碎片）等技术。</p>
<p>✔️ 虽然 Shenandoah 和 ZGC 都使用专门的指针技术来保持垃圾回收过程中的一致性，但采用了不同的机制–Shenandoah 使用 <strong>Brooks</strong> 指针，而 ZGC 使用 <strong>Colored</strong> 指针。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9a4e36088e8204345558874e14855e1bfbdb1d01b2522675265768a406bd5ebc" alt="JVM 中的实验性垃圾回收器 | Baeldung"></p>
<blockquote>
<p>Shenandoah 会<strong>在对象布局中增加一个字</strong>，这就是间接指针，允许 Shenandoah 在不更新所有引用的情况下移动对象，也被称为 Brooks 指针。</p>
<p>– <a href="https://www.baeldung.com/jvm-experimental-garbage-collectors" target="_blank" rel="noopener">JVM 中的实验性垃圾回收器 | Baeldung</a></p>
</blockquote>
<p>✔️ Shenandoah 和 ZGC 都依靠加载屏障来确保垃圾回收过程中的内存一致性和正确性。加载屏障会拦截应用程序线程对对象引用的读取，确保观察到堆的一致视图，即使在并发垃圾回收操作的情况下也是如此。</p>
<p>💡 对那些优先考虑超低延迟和完全并发操作的用户来说，Shenandoah 是最佳选择，尤其是对于大规模堆内存和动态工作负载。相反，ZGC 则是经过验证、低延迟、兼容性强且易于配置的垃圾回收器的理想选择。</p>
<h5 id="真实用例-6"><a href="#真实用例-6" class="headerlink" title="真实用例"></a>真实用例</h5><p>Shenandoah 垃圾收集器（GC）主要用于在 Java 虚拟机（JVM）上运行的 Java 应用程序。因此，任何编译成 Java 字节代码并在 JVM 上运行的编程语言都有可能使用 Shenandoah GC，其中最主要的就是 Java 本身。</p>
<p>不过，值得注意的是，除了 Java 之外，其他语言也可以在 JVM 上运行，包括 Kotlin、Scala、Groovy、Clojure 和 JRuby 等。只要这些语言利用 JVM 执行，就能受益于 Shenandoah GC 提供的功能和优化（如果配置了这样的功能和优化）。</p>
<p>总之，虽然 Shenandoah GC 由于与 JVM 集成而主要与 Java 有关，但也可用于其他基于 JVM 的语言。</p>
<p>我们已经接近尾声，只需要介绍最后一个 GC，就可以进行比较了。开始吧！</p>
<h4 id="Epsilon"><a href="#Epsilon" class="headerlink" title="Epsilon"></a>Epsilon</h4><h5 id="工作原理和算法-7"><a href="#工作原理和算法-7" class="headerlink" title="工作原理和算法"></a>工作原理和算法</h5><p><a href="https://blogs.oracle.com/javamagazine/post/epsilon-the-jdks-do-nothing-garbage-collector" target="_blank" rel="noopener">Epsilon GC</a> 是 Java 11 中引入的一种特殊垃圾收集器，是一项试验性功能。传统垃圾收集器通过识别和收集未使用的对象来回收内存，而 Epsilon GC 与之不同，它根本不执行任何垃圾收集。相反，它允许 Java 虚拟机（JVM）在不收集垃圾的情况下分配内存！</p>
<p>以下是有关 Epsilon GC 的一些要点：</p>
<p>✔️ 无垃圾回收：Epsilon GC 不执行任何垃圾回收。它根据需要分配内存，但从不回收。这使它适用于不需要考虑垃圾回收开销的情况，如短期应用程序或手动管理内存的应用程序。</p>
<p>✔️ 用于性能测试：Epsilon GC 主要用于性能测试和基准测试。通过消除垃圾回收的开销，开发人员可以完全专注于应用程序性能，而不受垃圾回收暂停的干扰。</p>
<p>✔️ 不适合生产环境：Epsilon GC 不适用于生产环境，在生产环境中，内存管理和垃圾回收对应用程序的稳定性和性能至关重要。它仅用于测试和实验目的。</p>
<p>⛔ Epsilon GC 通过完全消除垃圾回收开销，为性能测试和实验提供了独特的选择。不过，它并不打算用于生产，其适用性有限，具体取决于应用程序的具体要求。</p>
<h5 id="真实用例-7"><a href="#真实用例-7" class="headerlink" title="真实用例"></a>真实用例</h5><p>Epsilon GC 是专为 Java 虚拟机（JVM）设计的垃圾收集器，因此与 Java 之外的任何编程语言都没有直接关联。任何在支持 Epsilon GC 的 JVM 上运行的 Java 应用程序都有可能使用。</p>
<p>是时候总结一下了！</p>
<h4 id="垃圾收集器算法比较"><a href="#垃圾收集器算法比较" class="headerlink" title="垃圾收集器算法比较"></a>垃圾收集器算法比较</h4><p>比较垃圾回收算法需要评估各种因素，如暂停时间、吞吐量、可扩展性、内存开销以及对特定应用场景的适用性。</p>
<p>1️⃣ 串行或单线程垃圾收集器：</p>
<ul>
<li>暂停时间：通常暂停时间较长，因为它会在垃圾回收期间停止所有应用线程。</li>
<li>吞吐量：与并发垃圾收集器相比，吞吐量一般较低。</li>
<li>可扩展性：堆大小较大或多线程应用时可能无法很好扩展。</li>
<li>内存开销：与其他收集器相比，内存开销通常较低。</li>
<li>适用性：适用于中小型应用或对暂停时间要求不高的应用。</li>
</ul>
<p>2️⃣ 并行垃圾收集器：</p>
<ul>
<li>暂停时间：与串行收集器相比，暂停时间更短，因为使用多个线程进行垃圾收集。</li>
<li>吞吐量：由于并行性，吞吐量比串行收集器高。</li>
<li>可扩展性：使用多核处理器和更大的堆大小时，可扩展性更好。</li>
<li>内存开销：由于增加了线程，内存开销通常比串行收集器高。</li>
<li>适用性：适用于吞吐量重要但暂停时间不重要的中型应用。</li>
</ul>
<p>3️⃣ Concurrent Mark-Sweep (CMS) 垃圾收集器：</p>
<ul>
<li>暂停时间：旨在通过与应用程序线程同时执行大部分垃圾收集工作，最大限度减少暂停时间。</li>
<li>吞吐量：吞吐量适中，但可能存在碎片问题。</li>
<li>可扩展性：在堆规模非常大或高度多线程的应用中可能无法很好的扩展。</li>
<li>内存开销：内存开销适中</li>
<li>适用性：适合堆的规模中等，以及对延迟要求敏感的应用。</li>
</ul>
<p>4️⃣ 垃圾优先（G1）垃圾收集器：</p>
<ul>
<li>暂停时间：旨在通过将堆划分为多个区域，并以增量方式执行垃圾回收，从而提供低暂停时间行为。</li>
<li>吞吐量对于大多数应用，尤其是具有大型堆的应用，吞吐量良好。</li>
<li>可扩展性：可基于多核处理器和大型堆实现良好扩展。</li>
<li>内存开销：由于基于区域的管理，内存开销适中。</li>
<li>适用性：适用于暂停时间短、吞吐量大的大规模应用。</li>
</ul>
<p>5️⃣ Z 垃圾收集器（ZGC）：</p>
<ul>
<li>暂停时间：旨在提供超低延迟性能，暂停时间通常低于 10 毫秒，即使在大型堆上也是如此。</li>
<li>吞吐量：为大多数应用提供良好的吞吐量，同时优先考虑低暂停时间。</li>
<li>可扩展性：高度可扩展性，支持超大堆大小和多线程应用。</li>
<li>内存开销：使用 ZPages 和其他技术，内存开销适中。</li>
<li>适用性：适用于有严格延迟要求和大规模堆的应用。</li>
</ul>
<p>6️⃣ Shenandoah垃圾收集器：</p>
<ul>
<li>暂停时间：目标是通过并发垃圾收集实现超低延迟，即使在大型堆上也能最大限度减少暂停时间。</li>
<li>吞吐量：提供良好的吞吐量，同时优先考虑低暂停时间。</li>
<li>可扩展性：高度可扩展性，支持超大堆和多线程应用。</li>
<li>内存开销：使用基于区域的管理，内存开销适中。</li>
<li>适用性：适用于有严格延迟要求和大规模堆的应用程序，尤其是具有动态内存分配模式的应用程序。</li>
</ul>
<p>总之，垃圾收集算法的选择取决于应用需求、堆大小、延迟敏感性和可用硬件资源等因素。必须仔细评估这些因素，为特定用例选择最合适的垃圾收集器。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>了解垃圾回收算法对于理解编程语言和运行时环境中如何进行内存管理至关重要，因为编程语言和运行时环境会自动执行这项任务。</p>
<p>这些算法在方法、优化和利弊方面各不相同，影响到暂停时间、吞吐量、内存开销和可扩展性等因素。</p>
<p>虽然垃圾回收提供了自动内存管理功能，并简化了开发人员分配和释放内存的过程，但也带来了权衡和挑战，在设计和实施软件系统时必须深思熟虑。</p>
<p>最后，将垃圾收集归类为”绿色技术”取决于多个因素，如其对资源利用、能源消耗、系统效率和整体环境可持续性的影响。虽然垃圾收集技术可以提高资源利用效率，并可能减少电子垃圾，但必须根据具体的使用情况和系统设置来评估其对环境的影响。</p>
<p>相信这次垃圾收集之旅一定会给你带来启发。</p>
<hr>
<blockquote>
<p>你好，我是俞凡，在Motorola做过研发，现在在Mavenir做技术工作，对通信、网络、后端架构、云原生、DevOps、CICD、区块链、AI等技术始终保持着浓厚的兴趣，平时喜欢阅读、思考，相信持续学习、终身成长，欢迎一起交流学习。为了方便大家以后能第一时间看到文章，请朋友们关注公众号”DeepNoMind”，并设个星标吧，如果能一键三连(转发、点赞、在看)，则能给我带来更多的支持和动力，激励我持续写下去，和大家共同成长进步！</p>
</blockquote>
<p>本文由<a href="https://mdnice.com/?platform=2" target="_blank" rel="noopener">mdnice</a>多平台发布</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357917500963373066" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Fastify+TS实现基础IM服务（四）@fastify/</title>
    <url>/7357909187953623081.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本文主要内容均为@fastifywebsocket入门内容，这部分可以直接去看NPM上的<a href="https://www.npmjs.com/package/@fastify/websocket" target="_blank" rel="noopener">@fastify/websocket</a> #readme</p>
<p>不同的是本文的代码示例都是TS的，如果已经有了这部分基础可以直接跳到改造js+ws聊天室代码部分</p>
</blockquote>
<p>Fastify 的 WebSocket 支持，基于 ws@8 构建。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm i @fastify/websocket</span><br><span class="line"># 或者</span><br><span class="line">yarn add @fastify/websocket</span><br></pre></td></tr></table></figure>

<p>如果你是 TypeScript 用户，这个包内置了自己的 TypeScript 类型，但你还需要安装 ws 包的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm i @types/ws -D</span><br><span class="line"># 或者</span><br><span class="line">yarn add -D @types/ws</span><br></pre></td></tr></table></figure>

<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>注册这个插件后，你可以选择 WS 服务器响应哪些路由。这可以通过在 fastify 的 <code>.get</code> 路由上添加 <code>websocket: true</code> 属性到 <code>routeOptions</code> 来实现。在这种情况下，两个参数将被传递给处理程序，socket 连接和 fastify 请求对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket);</span><br><span class="line"></span><br><span class="line">app.register(async function (fastify) &#123;</span><br><span class="line">  fastify.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      // message.toString() === &apos;hi from client&apos;</span><br><span class="line">      connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(&#123; port: 3000 &#125;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在这种情况下，它将在每个未注册的路由上响应一个 404 错误，关闭传入的升级连接请求。</p>
<p>然而，你仍然可以定义一个通配符路由，它将被用作默认处理程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket, &#123;</span><br><span class="line">  options: &#123; maxPayload: 1048576 &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.register(async function (fastify) &#123;</span><br><span class="line">  fastify.get(&apos;/*&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      // message.toString() === &apos;hi from client&apos;</span><br><span class="line">      connection.socket.send(&apos;hi from wildcard route&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fastify.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      // message.toString() === &apos;hi from client&apos;</span><br><span class="line">      connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(&#123; port: 3000 &#125;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="附加事件处理程序"><a href="#附加事件处理程序" class="headerlink" title="附加事件处理程序"></a>附加事件处理程序</h3><p>重要的是，WebSocket 路由处理程序在处理程序执行期间同步附加事件处理程序，以避免意外丢弃消息。如果你想在你的 WebSocket 处理程序中进行任何异步工作，比如认证用户或从数据存储加载数据，请确保在触发这个异步工作之前附加任何 on(‘message’) 处理程序。否则，消息可能会在这个异步工作进行时到达，如果没有处理程序监听这个数据，它将被默默丢弃。</p>
<p>下面是一个例子，展示了如何在仍然访问异步资源的同时同步附加消息处理程序。我们将一个异步事情的 promise 存储在一个局部变量中，同步附加消息处理程序，然后使消息处理程序本身异步，以获取异步数据并进行一些处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码app.get(&apos;/*&apos;, &#123; websocket: true &#125;, (connection, request) =&gt; &#123;</span><br><span class="line">  const sessionPromise = request.getSession(); // 示例异步会话获取器，同步调用以返回一个 promise</span><br><span class="line"></span><br><span class="line">  connection.socket.on(&apos;message&apos;, async (message) =&gt; &#123;</span><br><span class="line">    const session = await sessionPromise;</span><br><span class="line">    // 使用消息和会话做一些事情</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="使用钩子"><a href="#使用钩子" class="headerlink" title="使用钩子"></a>使用钩子</h3><p>使用 @fastify/websocket 注册的路由遵循 Fastify 插件封装上下文，因此将运行已注册的任何钩子。这意味着你可能用于认证或错误处理的普通 HTTP 处理程序的相同路由钩子也适用于 websocket 处理程序。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码app.addHook(&apos;preValidation&apos;, async (request, reply) =&gt; &#123;</span><br><span class="line">  // 检查请求是否已认证</span><br><span class="line">  if (!request.isAuthenticated()) &#123;</span><br><span class="line">    await reply.code(401).send(&quot;未认证&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">  // 仅为认证的传入请求打开连接</span><br><span class="line">  connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="自定义错误处理程序"><a href="#自定义错误处理程序" class="headerlink" title="自定义错误处理程序"></a>自定义错误处理程序</h3><p>你可以选择性地提供一个自定义 <code>errorHandler</code>，它将用于处理已建立的 websocket 连接的任何清理工作。如果在建立连接后你的 websocket 路由处理程序抛出任何错误，将调用 <code>errorHandler</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket, &#123;</span><br><span class="line">  errorHandler: function (error, connection, req, reply) &#123;</span><br><span class="line">    // 做些事情</span><br><span class="line">    // 销毁/关闭连接</span><br><span class="line">    connection.socket.terminate();</span><br><span class="line">  &#125;,</span><br><span class="line">  options: &#123;</span><br><span class="line">    maxPayload: 1048576, // 我们将允许的最大消息大小设置为 1 MiB（1024 字节 * 1024 字节）</span><br><span class="line">    verifyClient: function (info, next) &#123;</span><br><span class="line">      if (info.req.headers[&apos;x-fastify-header&apos;] !== &apos;fastify is awesome !&apos;) &#123;</span><br><span class="line">        return next(false); // 连接不被允许</span><br><span class="line">      &#125;</span><br><span class="line">      next(true); // 连接被允许</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">  connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">    // message.toString() === &apos;hi from client&apos;</span><br><span class="line">    connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(&#123; port: 3000 &#125;, err =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err);</span><br><span class="line">    process.exit(1);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="自定义-preClose-钩子"><a href="#自定义-preClose-钩子" class="headerlink" title="自定义 preClose 钩子"></a>自定义 preClose 钩子</h3><p>默认情况下，当服务器关闭时，所有 ws 连接都将关闭。如果你希望修改这种行为，你可以传递你自己的 preClose 函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import fastify from &apos;fastify&apos;;</span><br><span class="line">import fastifyWebsocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const app = fastify();</span><br><span class="line"></span><br><span class="line">app.register(fastifyWebsocket, &#123;</span><br><span class="line">  preClose: (done) =&gt; &#123; // 注意：也可以使用 async 风格，不使用 done-callback</span><br><span class="line">    const server = this.websocketServer;</span><br><span class="line"></span><br><span class="line">    for (const socket of server.clients) &#123;</span><br><span class="line">      socket.close(1001, &apos;WS 服务器以自定义方式离线，发送代码 + 消息&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    server.close(done);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>测试 ws 处理程序可能相当棘手，幸运的是 fastify-websocket 为 fastify 实例装饰了 injectWS。它允许轻松测试 websocket 端点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import Fastify from &apos;fastify&apos;;</span><br><span class="line">import FastifyWebSocket from &apos;@fastify/websocket&apos;;</span><br><span class="line">import ws from &apos;ws&apos;;</span><br><span class="line"></span><br><span class="line">const app = Fastify();</span><br><span class="line">await app.register(FastifyWebSocket);</span><br><span class="line"></span><br><span class="line">app.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection, req) =&gt; &#123;</span><br><span class="line">  const stream = ws.createWebSocketStream(connection.socket, &#123; /* 选项 */ &#125;);</span><br><span class="line">  stream.setEncoding(&apos;utf8&apos;);</span><br><span class="line">  stream.write(&apos;hello client&apos;);</span><br><span class="line">  </span><br><span class="line">  stream.on(&apos;data&apos;, function (data) &#123;</span><br><span class="line">    // 确保设置了数据处理程序或以其他方式读取所有传入的数据，否则流背压将导致底层 WebSocket 对象被暂停。</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">await app.listen(&#123; port: 3000 &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="App-js"><a href="#App-js" class="headerlink" title="App.js"></a>App.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import Fastify from &apos;fastify&apos;;</span><br><span class="line">import FastifyWebSocket from &apos;@fastify/websocket&apos;;</span><br><span class="line"></span><br><span class="line">const App = Fastify();</span><br><span class="line"></span><br><span class="line">App.register(FastifyWebSocket);</span><br><span class="line"></span><br><span class="line">App.register(async function(fastify) &#123;</span><br><span class="line">  fastify.addHook(&apos;preValidation&apos;, async (request, reply) =&gt; &#123;</span><br><span class="line">    if (request.headers[&apos;api-key&apos;] !== &apos;some-random-key&apos;) &#123;</span><br><span class="line">      return reply.code(401).send();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  fastify.get(&apos;/&apos;, &#123; websocket: true &#125;, (connection) =&gt; &#123;</span><br><span class="line">    connection.socket.on(&apos;message&apos;, message =&gt; &#123;</span><br><span class="line">      connection.socket.send(&apos;hi from server&apos;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure>

<h3 id="App-test-js"><a href="#App-test-js" class="headerlink" title="App.test.js"></a>App.test.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import &#123; test &#125; from &apos;tap&apos;;</span><br><span class="line">import Fastify from &apos;fastify&apos;;</span><br><span class="line">import App from &apos;./app&apos;;</span><br><span class="line"></span><br><span class="line">test(&apos;connect to /&apos;, async (t) =&gt; &#123;</span><br><span class="line">  t.plan(1);</span><br><span class="line"></span><br><span class="line">  const fastify = Fastify();</span><br><span class="line">  fastify.register(App);</span><br><span class="line">  t.teardown(fastify.close.bind(fastify));</span><br><span class="line"></span><br><span class="line">  const ws = await fastify.injectWS(&apos;/&apos;, &#123;headers: &#123; &quot;api-key&quot; : &quot;some-random-key&quot; &#125;&#125;);</span><br><span class="line">  let resolve;</span><br><span class="line">  const promise = new Promise(r =&gt; &#123; resolve = r; &#125;);</span><br><span class="line"></span><br><span class="line">  ws.on(&apos;message&apos;, (data) =&gt; &#123;</span><br><span class="line">    resolve(data.toString());</span><br><span class="line">  &#125;);</span><br><span class="line">  ws.send(&apos;hi from client&apos;);</span><br><span class="line"></span><br><span class="line">  t.assert(await promise, &apos;hi from server&apos;);</span><br><span class="line">  // 记得最后关闭 ws</span><br><span class="line">  ws.terminate();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="注意！！！"><a href="#注意！！！" class="headerlink" title="注意！！！"></a>注意！！！</h3><ul>
<li>测试结束时需要手动关闭 Websocket。</li>
<li>需要等待 fastify.ready() 以确保 fastify 已被装饰。</li>
<li>如果你需要处理服务器响应，需要在发送消息之前注册事件监听器。</li>
</ul>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><p>@fastify/websocket 接受以下 ws 的选项：</p>
<ul>
<li>host - 绑定服务器的主机名。</li>
<li>port - 绑定服务器的端口。</li>
<li>backlog - 等待连接的队列的最大长度。</li>
<li>server - 一个预创建的 Node.js HTTP/S 服务器。</li>
<li>verifyClient - 用于验证传入连接的函数。</li>
<li>handleProtocols - 用于处理 WebSocket 子协议的函数。</li>
<li>clientTracking - 指定是否跟踪客户端。</li>
<li>perMessageDeflate - 启用/禁用 permessage-deflate。</li>
<li>maxPayload - 允许的最大消息大小（以字节为单位）。</li>
</ul>
<p>有关更多信息，你可以查看 ws 选项文档。</p>
<p>注意：默认情况下，如果你不提供 server 选项，@fastify/websocket 将把你的 websocket 服务器实例绑定到作用域内的 fastify 实例。</p>
<p>注意：ws 的 path 选项不应提供，因为路由由 fastify 自身处理</p>
<p>注意：ws 的 noServer 选项不应提供，因为 @fastify/websocket 的目的是在 fastify 服务器上监听。如果你想要一个自定义服务器，你可以使用 server 选项，如果你想要更多控制，你可以直接使用 ws 库</p>
<p>ws 不允许你将 objectMode 或 writableObjectMode 设置为 true</p>
<h3 id="完整的-TypeScript-示例"><a href="#完整的-TypeScript-示例" class="headerlink" title="完整的 TypeScript 示例"></a>完整的 TypeScript 示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码/* eslint-disable @typescript-eslint/no-unused-vars */</span><br><span class="line">import Fastify from &apos;fastify&apos;</span><br><span class="line">import FastifyWebsocket, &#123; WebSocket &#125; from &apos;@fastify/websocket&apos;</span><br><span class="line">import &#123; FastifyRequest, FastifyReply &#125; from &apos;fastify&apos;</span><br><span class="line"></span><br><span class="line">// 创建 Fastify 实例</span><br><span class="line">const app = Fastify()</span><br><span class="line"></span><br><span class="line">// 注册 @fastify/websocket 插件</span><br><span class="line">app.register(FastifyWebsocket, &#123;</span><br><span class="line">  options: &#123;</span><br><span class="line">    maxPayload: 1048576, // 设置允许的最大消息大小为 1MB</span><br><span class="line">    verifyClient: (info, done) =&gt; &#123;</span><br><span class="line">      // 示例：客户端验证逻辑</span><br><span class="line">      if (info.req.headers[&apos;x-fastify-header&apos;] === &apos;fastifyrocks&apos;) &#123;</span><br><span class="line">        done(true) // 验证通过</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        done(false) // 验证失败，连接被拒绝</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    clientTracking: true, // 启用客户端跟踪</span><br><span class="line">    perMessageDeflate: true // 启用 permessage-deflate 压缩</span><br><span class="line">  &#125;,</span><br><span class="line">  errorHandler: (error, connection, _req, _reply) =&gt; &#123;</span><br><span class="line">    // 错误处理逻辑</span><br><span class="line">    console.error(&apos;WebSocket 错误:&apos;, error)</span><br><span class="line">    connection.terminate() // 终止连接</span><br><span class="line">  &#125;,</span><br><span class="line">  preClose: (done) =&gt; &#123;</span><br><span class="line">    // 服务器关闭前的清理逻辑</span><br><span class="line">    console.log(&apos;正在关闭 WebSocket 连接&apos;)</span><br><span class="line">    done() // 完成清理操作</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 添加认证钩子</span><br><span class="line">app.addHook(</span><br><span class="line">  &apos;preValidation&apos;,</span><br><span class="line">  async (request: FastifyRequest, _reply: FastifyReply) =&gt; &#123;</span><br><span class="line">    if (!request.headers[&apos;authorization&apos;]) &#123;</span><br><span class="line">      throw new Error(&apos;未授权&apos;) // 抛出未授权错误</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 定义 WebSocket 路由</span><br><span class="line">app.get(</span><br><span class="line">  &apos;/ws&apos;,</span><br><span class="line">  &#123; websocket: true &#125;,</span><br><span class="line">  (connection: WebSocket, _req: FastifyRequest) =&gt; &#123;</span><br><span class="line">    connection.on(&apos;message&apos;, (message) =&gt; &#123;</span><br><span class="line">      console.log(&apos;收到消息:&apos;, message.toString())</span><br><span class="line">      connection.send(&apos;消息已接收&apos;) // 向客户端发送响应</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    connection.on(&apos;close&apos;, () =&gt; &#123;</span><br><span class="line">      console.log(&apos;WebSocket 已关闭&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 启动服务器</span><br><span class="line">app.listen(&#123; port: 3000 &#125;, (err, address) =&gt; &#123;</span><br><span class="line">  if (err) &#123;</span><br><span class="line">    app.log.error(err)</span><br><span class="line">    process.exit(1) // 遇到错误，退出程序</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(`服务器正在监听地址 $&#123;address&#125;`)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="关键点解释"><a href="#关键点解释" class="headerlink" title="关键点解释"></a>关键点解释</h3><ul>
<li><strong>注册插件</strong>：通过 <code>app.register(FastifyWebsocket, {...})</code> 注册 <code>@fastify/websocket</code> 插件，并传递配置选项。</li>
<li><strong>选项配置</strong>：<code>options</code> 对象中包含了 <code>ws</code> 库的配置选项，如 <code>maxPayload</code>, <code>verifyClient</code>, <code>clientTracking</code>, 和 <code>perMessageDeflate</code>。</li>
</ul>
<pre><code>+ **`maxPayload`**：定义了 WebSocket 消息的最大大小（以字节为单位）。这是一个重要的安全特性，用于防止恶意用户通过发送大量数据来尝试耗尽服务器资源。
+ **`verifyClient`**：这是一个函数，用于在 WebSocket 握手阶段验证连接客户端。它接收两个参数：`info` 和 `done`。`info` 对象包含了请求相关的信息，如请求头和请求源等，而 `done` 是一个回调函数，用于基于验证结果接受或拒绝请求。这个验证步骤是实现自定义认证逻辑的理想场所。
+ **`clientTracking`**：当设置为 `true` 时，WebSocket 服务器将会跟踪连接到服务器的客户端。这使得服务器能够保持对所有活动 WebSocket 连接的引用，便于管理这些连接，如广播消息。
+ **`perMessageDeflate`**：这个选项启用了 permessage-deflate 压缩，可以减少通过 WebSocket 发送的数据的大小。这对于减少带宽使用和提高传输效率非常有用，特别是在发送大量数据时。除了这些选项，`@fastify/websocket` 插件还提供了其他几个重要的配置点：


+ **`errorHandler`**：这是一个函数，用于处理 WebSocket 连接过程中的任何错误。这允许开发者自定义错误处理逻辑，例如记录错误或关闭出现问题的连接。
+ **`preClose`**：这是一个函数，在服务器即将关闭前调用，允许进行清理工作，如优雅地关闭 WebSocket 连接。</code></pre><ul>
<li><strong>错误处理</strong>：<code>errorHandler</code> 函数用于处理 WebSocket 连接过程中的错误。</li>
<li><strong>认证钩子</strong>：<code>preValidation</code> 钩子用于在建立 WebSocket 连接之前进行认证检查。</li>
<li><strong>WebSocket 路由</strong>：通过 <code>app.get(&#39;/ws&#39;, {websocket: true}, handler)</code> 定义 WebSocket 路由。在路由处理函数中，可以使用 <code>connection.socket</code> 来发送和接收消息。</li>
<li><strong>启动服务器</strong>：通过 <code>app.listen({ port: 3000 }, callback)</code> 启动服务器。</li>
</ul>
<p>这个示例展示了如何在 Fastify 应用中使用 TypeScript 来集成和配置 WebSocket 功能，包括如何处理客户端消息、执行认证和错误处理。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357909187953623081" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>WebSocket,Node.js,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SkyWalking为所有的API接口增加tag背景胡</title>
    <url>/7357917741909262351.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="背景胡扯"><a href="#背景胡扯" class="headerlink" title="背景胡扯"></a>背景胡扯</h1><p>线上接口报错，接着被 SkyWalking 抓到，然后 SkyWalking 触发告警，最后老板@你，让你辛苦一下，在明早上班前把这个bug 改了，并告诉你你是全公司的希望。谁说不是呢？为公司业务保驾护航，我辈责无旁贷。</p>
<p>既然告警都触发了，咱就来看看怎么个事。嘿嘿小样，这下还能让你跑了。（实际上还真的有可能跑了，说多了都是泪）</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/312fc5e5d205931dbafd80c4c17a30de078fea560c0c55eec1db0e9725ac1db1" alt="image.png"></p>
<p>我打开 SkyWalking UI 一看，报错服务说要和我试试，我说可以。我一说他啪的一下一个显眼的红色报错直冲我面门，我鼠标一点，当时就全部防住了。防出去以后自然是传统功夫以点到为止，鼠标放在了报错上，没点他。我笑一下，准备收拳。</p>
<p>因为这时间，按传统功夫的点到为止他已经输了，如果我点下去，就直接把他错误堆栈打印出来了，我就鼠标放在错误上没点他。</p>
<p>我收鼠标的时间不打了，他突然袭击抛出上下文，我大意了啊，没有闪。他的上下文给我眼晃了一下，我当时流眼泪了，捂着眼，我说婷婷。上下文怎么没有用户标识。然后两分钟以后就好了，完犊子日志里面也没有。</p>
<p>看来是有备而来，这个服务不讲武德，来骗来偷袭我这个老码农。这好吗？这不好。</p>
<p>总之，就是缺少一些上下文数据，例如用户ID，设备ID这类的数据，我们给补上就行了，给老码农一个闪避buff。</p>
<h1 id="上菜：附加上下文"><a href="#上菜：附加上下文" class="headerlink" title="上菜：附加上下文"></a>上菜：附加上下文</h1><p>看一下官网的文档，怎么样能够给接口添加上下文数据</p>
<p><a href="https://skywalking.apache.org/docs/skywalking-java/v9.2.0/en/setup/service-agent/java-agent/application-toolkit-dependency/" target="_blank" rel="noopener">the toolkit, such as using maven or gradle | Apache SkyWalking</a></p>
<p>别忘了第一步先引入依赖，依赖版本和你使用的 <code>java-agent</code> 版本保持一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">      &lt;groupId&gt;org.apache.skywalking&lt;/groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;apm-toolkit-trace&lt;/artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;skywalking.version&#125;&lt;/version&gt;</span><br><span class="line">   &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>然后才是第二部附加上下文 <code>tag</code>，我总结了三种方式：</p>
<p>第一种是最直接的，直接调用 <code>ActiveSpan.tag(&quot;my_tag&quot;, &quot;my_value&quot;)</code> 操作接口。特点就是直接到不能再直接了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@GetMapping(&quot;/xxx&quot;)</span><br><span class="line">public Result&lt;User&gt; query() &#123;  </span><br><span class="line">    ActiveSpan.tag(&quot;my_key&quot;, &quot;my_value&quot;);  </span><br><span class="line">    // 其他代码。。。 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二种是简单的，在接口方法上打上注解 <code>@Trace</code> 和 <code>@Tag</code>。特点是简单到不能再简单了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Trace</span><br><span class="line">@Tag(key = &quot;tag1&quot;, value = &quot;arg[0]&quot;)</span><br><span class="line">@Tag(key = &quot;tag2&quot;, value = &quot;arg[1]&quot;)</span><br><span class="line">@Tag(key = &quot;username&quot;, value = &quot;returnedObj.username&quot;)</span><br><span class="line">@Tag(key = &quot;age&quot;, value = &quot;returnedObj.age&quot;)</span><br><span class="line">public User methodYouWantToTrace(String param1, String param2) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第三种是相对优雅的，在拦截器上使用API统一操作。特点是无侵入。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码</span><br><span class="line"> public class SkyWalkingTraceContextInterceptor implements HandlerInterceptor &#123;  </span><br><span class="line">    @Override  </span><br><span class="line">    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;  </span><br><span class="line">		// 这里太简单粗暴了，别抄哈。只是提供一种思路</span><br><span class="line">        String token = request.getHeader(TokenParserConfig.HEADER_TOKEN_KEY);  </span><br><span class="line">        if (StringUtils.isNotBlank(token)) &#123;  </span><br><span class="line">            ActiveSpan.tag(&quot;biz.token&quot;, token);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要能够根据 <code>tag</code> 来进行搜索，不要漏掉最后这一步。在配置文件中增加我们的 <code>tag key</code>，或者直接修改环境变量 <code>SW_SEARCHABLE_TAG_KEYS</code> 也行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yml复制代码searchableTracesTags: $&#123;SW_SEARCHABLE_TAG_KEYS:http.method,http.status_code,rpc.status_code,db.type,db.instance,mq.queue,mq.topic,mq.broker,mq.payload,biz.token&#125;</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357917741909262351" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAIchemy异步DBManager封装-02熟悉掌</title>
    <url>/7357957809072619554.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h1><blockquote>
<p>在上一篇文章中 <a href="https://dev.newban.cn/7357703852726911016">SQLAIchemy 异步DBManager封装-01入门理解</a> 我们深入讨论了SQLAlchemy异步DBManager整体的封装结构与思路。详细地介绍了如何封装添加和批量添加的操作方法，并通过实际示例进行了演示。SQL 全称是结构化查询语言，无疑查询是最复杂的部分。因此，在这篇文章中，我将详细介绍如何封装通用的数据库查询方法，并通过具体的示例来讲解这一过程，使得这一复杂的任务变得更为简单。</p>
</blockquote>
<h1 id="二、通用查询封装"><a href="#二、通用查询封装" class="headerlink" title="二、通用查询封装"></a>二、通用查询封装</h1><h2 id="指定主键id查询"><a href="#指定主键id查询" class="headerlink" title="指定主键id查询"></a>指定主键id查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class DBManager(metaclass=SingletonMetaCls):</span><br><span class="line">    DB_CLIENT: SQLAlchemyManager = None</span><br><span class="line">    orm_table: Type[BaseOrmTable] = None</span><br><span class="line">    </span><br><span class="line">    @with_session</span><br><span class="line">    async def query_by_id(</span><br><span class="line">            self,</span><br><span class="line">            pk_id: int,</span><br><span class="line">            *,</span><br><span class="line">            orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">            session: AsyncSession = None,</span><br><span class="line">    ) -&gt; Union[T_BaseOrmTable, None]:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        根据主键id查询</span><br><span class="line">        Args:</span><br><span class="line">            pk_id: 主键id</span><br><span class="line">            orm_table: orm表映射类</span><br><span class="line">            session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">        Returns:</span><br><span class="line">            orm映射类的实例对象</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        orm_table = orm_table or self.orm_table</span><br><span class="line">        ret = await session.get(orm_table, pk_id)</span><br><span class="line">        return ret</span><br></pre></td></tr></table></figure>

<p>这个封装很简单，直接看demo吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class UserTable(BaseOrmTableWithTS):</span><br><span class="line">    &quot;&quot;&quot;用户表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user&quot;</span><br><span class="line">    username: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户昵称&quot;)</span><br><span class="line">    age: Mapped[int] = mapped_column(default=0, comment=&quot;年龄&quot;)</span><br><span class="line">    password: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;用户密码&quot;)</span><br><span class="line">    phone: Mapped[str] = mapped_column(String(11), default=&quot;&quot;, comment=&quot;手机号&quot;)</span><br><span class="line">    email: Mapped[str] = mapped_column(String(30), default=&quot;&quot;, comment=&quot;邮箱&quot;)</span><br><span class="line">    avatar: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;头像&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class UserManager(DBManager):</span><br><span class="line">    orm_table = UserTable</span><br><span class="line"></span><br><span class="line">    async def get_name_by_email(self, email):</span><br><span class="line">        username = await self.query_one(cols=[&quot;username&quot;], conds=[self.orm_table.email == email], flat=True)</span><br><span class="line">        return username</span><br><span class="line">        </span><br><span class="line">async def query_demo():</span><br><span class="line">    user = await UserManager().query_by_id(pk_id=1)</span><br><span class="line">    print(&quot;user&quot;, user)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; out</span><br><span class="line">user &#123;&apos;id&apos;: 1, &apos;username&apos;: &apos;hui&apos;, &apos;age&apos;: 18, &apos;password&apos;: &apos;&apos;, &apos;phone&apos;: &apos;&apos;, &apos;email&apos;: &apos;huidbk.163.com&apos;, &apos;avatar&apos;: &apos;&apos;, &apos;created_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43), &apos;updated_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询单条"><a href="#查询单条" class="headerlink" title="查询单条"></a>查询单条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@with_session</span><br><span class="line">async def _query(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: BaseOrmTable = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        limit: int = None,</span><br><span class="line">        offset: int = 0,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">) -&gt; Result[Any]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    通用查询</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表, 默认id升序</span><br><span class="line">        limit: 限制数量大小</span><br><span class="line">        offset: 偏移量</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 查询结果集</span><br><span class="line">        cursor_result</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cols = cols or []</span><br><span class="line">    cols = [column(col_obj) if isinstance(col_obj, str) else col_obj for col_obj in cols]  # 兼容字符串列表</span><br><span class="line"></span><br><span class="line">    conditions = conds or []</span><br><span class="line">    orders = orders or [column(&quot;id&quot;)]</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line"></span><br><span class="line">    # 构造查询</span><br><span class="line">    if cols:</span><br><span class="line">        # 查询指定列</span><br><span class="line">        query_sql = select(*cols).select_from(orm_table).where(*conditions).order_by(*orders)</span><br><span class="line">    else:</span><br><span class="line">        # 查询全部字段</span><br><span class="line">        query_sql = select(orm_table).where(*conditions).order_by(*orders)</span><br><span class="line"></span><br><span class="line">    if limit:</span><br><span class="line">        query_sql = query_sql.limit(limit).offset(offset)</span><br><span class="line"></span><br><span class="line">    # 执行查询</span><br><span class="line">    cursor_result = await session.execute(query_sql)</span><br><span class="line">    return cursor_result</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def query_one(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        flat: bool = False,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">) -&gt; Union[dict, T_BaseOrmTable, Any]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    查询单行</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表</span><br><span class="line">        flat: 单字段时扁平化处理</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Examples:</span><br><span class="line">        # 指定列名</span><br><span class="line">        ret = await UserManager().query_one(cols=[&quot;username&quot;, &quot;age&quot;], conds=[UserTable.id == 1])</span><br><span class="line">        sql =&gt; select username, age from user where id=1</span><br><span class="line">        ret =&gt; &#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line"></span><br><span class="line">        # 指定列名，单字段扁平化处理</span><br><span class="line">        ret = await UserManager().query_one(cols=[&quot;username&quot;], conds=[UserTable.id == 1])</span><br><span class="line">        sql =&gt; select username from user where id=1</span><br><span class="line">        ret =&gt; &#123;&quot;username&quot;: &quot;hui&quot;&#125; =&gt; &quot;hui&quot;</span><br><span class="line"></span><br><span class="line">        # 计算总数</span><br><span class="line">        ret = await UserManager().query_one(cols=[func.count()], flat=True)</span><br><span class="line">        sql =&gt; select count(*) as count from user</span><br><span class="line">        ret =&gt; &#123;&quot;count&quot;: 10&#125; =&gt; 10</span><br><span class="line"></span><br><span class="line">        # 不指定列名，查询全部字段, 返回表实例对象</span><br><span class="line">        ret = await UserManager().query_one(conds=[UserTable.id == 1])</span><br><span class="line">        sql =&gt; select id, username, age from user where id=1</span><br><span class="line">        ret =&gt; UserTable(id=1, username=&quot;hui&quot;, age=18)</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        Union[dict, BaseOrmTable(), Any(flat=True)]</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cursor_result = await self._query(cols=cols, orm_table=orm_table, conds=conds, orders=orders, session=session)</span><br><span class="line">    if cols:</span><br><span class="line">        if flat and len(cols) == 1:</span><br><span class="line">            # 单行单字段查询: 直接返回字段结果</span><br><span class="line">            # eg: select count(*) as count from user 从 &#123;&quot;count&quot;: 100&#125; =&gt; 100</span><br><span class="line">            # eg: select username from user where id=1 从 &#123;&quot;username&quot;: &quot;hui&quot;&#125; =&gt; &quot;hui&quot;</span><br><span class="line">            return cursor_result.scalar_one()</span><br><span class="line"></span><br><span class="line">        # eg: select username, age from user where id=1 =&gt; &#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;</span><br><span class="line">        return cursor_result.mappings().one() or &#123;&#125;</span><br><span class="line">    else:</span><br><span class="line">        # 未指定列名查询默认全部字段，返回的是表实例对象 BaseOrmTable()</span><br><span class="line">        # eg: select id, username, age from user where id=1 =&gt; UserTable(id=1, username=&quot;hui&quot;, age=18)</span><br><span class="line">        return cursor_result.scalar_one()</span><br></pre></td></tr></table></figure>

<p>查询无疑就只有两种结果单条、多条结果数据。这里统一封装一个 <strong>_query</strong> 通用查询方法，以供内部使用。</p>
<ul>
<li>支持指定查询的列（cols）</li>
<li>条件查询（conds）</li>
<li>排序（orders）</li>
<li>分页（limit、offset）</li>
</ul>
<p>主要封装就是利用 sqlaichemy 提供的 select 语法进行组织sql，通过 column 兼容列名字段字符串列表。query_one 方法，如果指定了 cols 返回字典格式，不指定则是库表映射类实例对象，一开始封装的时候我想统一出参都是返回 库表映射类实例对象 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码query_ret = cursor_result.mappings().one() or &#123;&#125;</span><br><span class="line">return orm_table(**query_ret)</span><br></pre></td></tr></table></figure>

<p>如果是 <strong>id as user_id</strong> 取别名查询会导致映射不上，但可以查询时不指定别名，<code>orm_table_obj.to_dict(alias_dict={&quot;id&quot;: &quot;user_id&quot;})</code> 时进行别名转换，还有一些flat 扁平化、统计数量的时候都不能使用 <code>orm_table(**query_ret)</code> 故而不好统一，再实际web场景中，出参还是要转成dict、json格式化进行响应，故而进行保留。看看具体使用效果</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1709450dae091eba6911a0b100ec5baa1d0609740daf7fa69ce1a0e67b786145" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from sqlalchemy import String, func, label</span><br><span class="line"></span><br><span class="line">async def query_demo():</span><br><span class="line">    ret = await UserManager().query_one(cols=[&quot;username&quot;, &quot;age&quot;], conds=[UserTable.id == 1])</span><br><span class="line">    print(&quot;指定列名 ret&quot;, ret)</span><br><span class="line">    </span><br><span class="line">    ret = await UserManager().query_one(</span><br><span class="line">        cols=[UserTable.username, label(&quot;user_age&quot;, UserTable.age)], conds=[UserTable.id == 1]</span><br><span class="line">    )</span><br><span class="line">    print(&quot;取别名 ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserManager().query_one(cols=[&quot;username&quot;], conds=[UserTable.id == 1], flat=True)</span><br><span class="line">    print(&quot;指定列名，单字段扁平化处理&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserManager().query_one(cols=[func.count()], flat=True)</span><br><span class="line">    print(&quot;计算总数&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserManager().query_one(conds=[UserTable.id == 1])</span><br><span class="line">    print(&quot;不指定列名，查询全部字段, 返回表实例对象&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码指定列名 ret &#123;&apos;username&apos;: &apos;hui&apos;, &apos;age&apos;: 18&#125;</span><br><span class="line"></span><br><span class="line">取别名 ret &#123;&apos;username&apos;: &apos;hui&apos;, &apos;user_age&apos;: 18&#125;</span><br><span class="line"></span><br><span class="line">指定列名，单字段扁平化处理 hui</span><br><span class="line"></span><br><span class="line">计算总数 6</span><br><span class="line"></span><br><span class="line">不指定列名，查询全部字段, 返回表实例对象 &#123;&apos;username&apos;: &apos;hui&apos;, &apos;age&apos;: 18, &apos;password&apos;: &apos;&apos;, &apos;phone&apos;: &apos;&apos;, &apos;email&apos;: &apos;huidbk.163.com&apos;, &apos;avatar&apos;: &apos;&apos;, &apos;id&apos;: 1, &apos;created_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43), &apos;updated_at&apos;: datetime.datetime(2024, 4, 15, 1, 0, 43)&#125;</span><br></pre></td></tr></table></figure>

<h2 id="查询多条"><a href="#查询多条" class="headerlink" title="查询多条"></a>查询多条</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@with_session</span><br><span class="line">async def query_all(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: BaseOrmTable = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        flat: bool = False,</span><br><span class="line">        limit: int = None,</span><br><span class="line">        offset: int = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">) -&gt; Union[List[dict], List[T_BaseOrmTable], Any]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    查询多行</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表</span><br><span class="line">        flat: 单字段时扁平化处理</span><br><span class="line">        limit: 限制数量大小</span><br><span class="line">        offset: 偏移量</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    cursor_result = await self._query(</span><br><span class="line">        cols=cols, orm_table=orm_table, conds=conds, orders=orders, limit=limit, offset=offset, session=session</span><br><span class="line">    )</span><br><span class="line">    if cols:</span><br><span class="line">        if flat and len(cols) == 1:</span><br><span class="line">            # 扁平化处理</span><br><span class="line">            # eg: select id from user 从 [&#123;&quot;id&quot;: 1&#125;, &#123;&quot;id&quot;: 2&#125;, &#123;&quot;id&quot;: 3&#125;] =&gt; [1, 2, 3]</span><br><span class="line">            return cursor_result.scalars().all()</span><br><span class="line"></span><br><span class="line">        # eg: select username, age from user =&gt; [&#123;&quot;username&quot;: &quot;hui&quot;, &quot;age&quot;: 18&#125;, [&#123;&quot;username&quot;: &quot;dbk&quot;, &quot;age&quot;: 18&#125;]]</span><br><span class="line">        return cursor_result.mappings().all() or []</span><br><span class="line">    else:</span><br><span class="line">        # 未指定列名查询默认全部字段，返回的是表实例对象 [BaseOrmTable()]</span><br><span class="line">        # eg: select id, username, age from user</span><br><span class="line">        # [User(id=1, username=&quot;hui&quot;, age=18), User(id=2, username=&quot;dbk&quot;, age=18)</span><br><span class="line">        return cursor_result.scalars().all()</span><br></pre></td></tr></table></figure>

<p>查询多条与query_one一致内部调用 <strong>_query()</strong> 获取查询结果集，最后通过 <code>cursor_result.mappings().all()</code>、<code>cursor_result.scalars().all()</code> 获取列表数据，同样支持单字段扁平化处理，还支持分页处理。具体看如下例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from sqlalchemy import String, func, label, or_</span><br><span class="line"></span><br><span class="line">ret = await UserManager().query_all()</span><br><span class="line">user_ids = [user.id for user in ret]</span><br><span class="line">print(&quot;查询全部&quot;, user_ids)</span><br><span class="line"></span><br><span class="line">user_ids = await UserManager().query_all(cols=[UserTable.id], flat=True)</span><br><span class="line">print(&quot;查询全部的用户id（扁平化处理）&quot;, user_ids)</span><br><span class="line"></span><br><span class="line">ret = await UserManager().query_all(</span><br><span class="line">    cols=[UserTable.username],</span><br><span class="line">    conds=[</span><br><span class="line">        UserTable.id &gt; 1,</span><br><span class="line">        or_(UserTable.age &lt; 20, UserTable.email == &quot;huidbk.163.com&quot;)</span><br><span class="line">    ],</span><br><span class="line">    orders=[UserTable.id],</span><br><span class="line">    flat=True</span><br><span class="line">)</span><br><span class="line"># sql =&gt; select username from user where user.id &gt; 1 and (age &lt; 20 or email=&apos;huidbk.163.com&apos;) order by id</span><br><span class="line">print(&quot;条件查询&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码查询全部 [1, 2, 3, 4, 5, 6]</span><br><span class="line">查询全部的用户id（扁平化处理） [1, 2, 3, 4, 5, 6]</span><br><span class="line">条件查询 [&apos;zack&apos;]</span><br></pre></td></tr></table></figure>

<p>单字段扁平化处理，可以节省获取查询数据后再进行扁平化处理的一步操作。看看下面没有扁平化处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码user_infos = await UserManager().query_all(cols=[UserTable.id])</span><br><span class="line">user_ids = [user_info.get(&quot;id&quot;) for user_info in user_infos]</span><br><span class="line">print(&quot;查询全部的用户id&quot;, user_ids)</span><br><span class="line"></span><br><span class="line">ret = await UserManager().query_one(cols=[func.count()])</span><br><span class="line">count = ret.get(&quot;count&quot;) or 0</span><br><span class="line">print(&quot;计算总数&quot;, count)</span><br></pre></td></tr></table></figure>

<p>上面的获取某业务的所有id，计算总数等，直接获取扁平化的结果，有时还是比较实用。</p>
<h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码async def list_page(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        cols: list = None,</span><br><span class="line">        orm_table: BaseOrmTable = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orders: list = None,</span><br><span class="line">        curr_page: int = 1,</span><br><span class="line">        page_size: int = 20,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    单表通用分页查询</span><br><span class="line">    Args:</span><br><span class="line">        cols: 查询的列表字段</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        conds: 查询的条件列表</span><br><span class="line">        orders: 排序列表</span><br><span class="line">        curr_page: 页码</span><br><span class="line">        page_size: 每页数量</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: </span><br><span class="line">        total_count, data_list</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    conds = conds or []</span><br><span class="line">    orders = orders or [column(&quot;id&quot;)]</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line"></span><br><span class="line">    limit = page_size</span><br><span class="line">    offset = (curr_page - 1) * page_size</span><br><span class="line">    total_count, data_list = await asyncio.gather(</span><br><span class="line">        self.query_one(</span><br><span class="line">            cols=[func.count()], orm_table=orm_table, conds=conds, orders=orders, flat=True, session=session</span><br><span class="line">        ),</span><br><span class="line">        self.query_all(</span><br><span class="line">            cols=cols, orm_table=orm_table, conds=conds, orders=orders, limit=limit, offset=offset, session=session</span><br><span class="line">        ),</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    return total_count, data_list</span><br></pre></td></tr></table></figure>

<p>这里分页查询就用 query_one 查询总数，query_all 分页查询，curr_page 当前页与 page_size 每页大小计算数据偏移量 offset，然后通过 <strong>asyncio.gather</strong> 并发执行获取结果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码total_count, data_list = await UserManager().list_page(</span><br><span class="line">    cols=[UserTable.id, UserTable.username, UserTable.age],</span><br><span class="line">    conds=[UserTable.id &gt; 1],</span><br><span class="line">    curr_page=2,</span><br><span class="line">    page_size=3,</span><br><span class="line">    orders=[desc(UserTable.age)]</span><br><span class="line">)</span><br><span class="line">print(&quot;分页查询 total_count&quot;, total_count)</span><br><span class="line">print(&quot;分页查询 data_list&quot;, data_list)</span><br></pre></td></tr></table></figure>

<p>分页查询结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码分页查询 total_count 5</span><br><span class="line">分页查询 data_list [&#123;&apos;id&apos;: 3, &apos;username&apos;: &apos;wang&apos;, &apos;age&apos;: 20&#125;, &#123;&apos;id&apos;: 2, &apos;username&apos;: &apos;zack&apos;, &apos;age&apos;: 19&#125;]</span><br></pre></td></tr></table></figure>

<p>这里的分页查询没有使用 with_session 装饰器，由于 asyncio.gather 并发操作原因不能共享数据库会话 session，需要单独的 session，不然会报如下错误。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c9ec291c6d8167598c5d56adefc76df207d9fcabf40a14e37ee4c7cf3cd2932" alt></p>
<blockquote>
<p>sqlalchemy.exc.InvalidRequestError：无法在上下文管理器内的已关闭事务上进行操作。 请先完成上下文管理器，然后再发出进一步的命令。</p>
</blockquote>
<h1 id="三、封装说明"><a href="#三、封装说明" class="headerlink" title="三、封装说明"></a>三、封装说明</h1><p>SQL 的话还是查询用的多，查询也复杂，这里的话只封装了一些通用的查询操作，有一些分组查询、连表查询等我都没有封装，我认为这些操作还是写原生sql更直观一些，用ORM进行组装这些操作会感觉语法很别扭不简洁。如何执行原始sql，请看下一篇。<a href="https://dev.newban.cn/7358352353295106088">SQLAIchemy 异步DBManager封装-03得心应手</a></p>
<h1 id="四、Github源代码"><a href="#四、Github源代码" class="headerlink" title="四、Github源代码"></a>四、Github源代码</h1><p>源代码已上传到了Github，里面也有具体的使用Demo，欢迎大家一起体验、贡献。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357957809072619554" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>DDD落地指南-架构师眼中的餐厅1、领域设计2、架构设计</title>
    <url>/7357957599844122624.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在去年、我整理了一篇名为《<a href="http://sd.jd.com/article/2312" target="_blank" rel="noopener">如何做架构设计？</a>》的文章，主要探讨了架构设计的目标和过程，然而、那是一篇概括性的文章，用于启发思路，并不是具体的实践指南，因此、我一直期望给出具体参考案例。</p>
<p>我几乎忘了这件事，如今回顾、我发现并没有合适的案例可供参考，现有的案例要么不完整、要么是与业务耦合的特定场景，要么无法支撑研发落地。所以我决定从实际生活中出发，虚拟一个案例场景，以便能够系统性的阐述这个问题。</p>
<p>﻿</p>
<p>正文开始</p>
<hr>
<p>﻿</p>
<p>本案例侧重于DDD的实践，从实际业务场景推导软件架构，将业务元素映射为系统元素，让系统本身成为最好的业务文档。在本案例中，我们选择餐厅作为业务场景，但不在意餐厅实现细节，而是以餐厅为主线故事，系统性的阐述DDD落地方法。希望读者能够从中吸取精华，去其糟粕，全文较长、耐心读完、必有收获。</p>
<hr>
<p>﻿</p>
<h1 id="1、领域设计"><a href="#1、领域设计" class="headerlink" title="1、领域设计"></a>1、领域设计</h1><p>领域设计的核心是业务驱动的分而治之，旨在缩小软件系统与真实业务的差异，从而减少差异带来的问题。</p>
<p>当业务与系统之间存在差异时，我们无法将业务逻辑和程序逻辑对应起来，从而分不清区域，也分不清职责，因此会觉得混乱。就像你平时不会将枕头和被子放在厨房或卫生间一样，你的床上不会放着大米白面，否则你想睡觉是一件很复杂的事情，软件系统也是如此。</p>
<p>所以、首先要把业务分析清楚，然后设计与业务模型对应的软件模型，这就是DDD的核心思想。</p>
<p>﻿</p>
<h2 id="1-1-宏观流程"><a href="#1-1-宏观流程" class="headerlink" title="1.1 宏观流程"></a>1.1 宏观流程</h2><p>假如我要设计一个餐厅，由于分而治之的需要，我会首先从宏观流程去分析，可以帮我们迅速找到重要的区域（这是功能相关性的初步划分）。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dad69a636c144ff45114faa8026d8439e0127ae2c25689605dda61b09fe5fd95" alt></p>
<p>﻿﻿</p>
<p>因此会得到几个明确的行为区域，我将餐厅划分为“菜品域”，“订单域”，“厨房域”，“用餐域”，这是宏观级别的领域划分，后续应该针对每个区域单独分析。</p>
<p>产出物是：宏观流程和参与角色</p>
<p>﻿</p>
<h2 id="1-2-统一语言"><a href="#1-2-统一语言" class="headerlink" title="1.2 统一语言"></a>1.2 统一语言</h2><p>语言贯穿于整个开发过程，从需求分析到设计、从设计到编码，因此好的语言非常重要，好的语言体现了清晰的业务概念。</p>
<p>在这个阶段，我们需要通过梳理，找到业务中都有哪些实体与行为，对其做一些归纳。我们的核心问题是“谁”通过什么“行为”影响了“谁”，其中的三个要素分别是“角色”、“行为”、“实体”，因此我的建议是先找到 “角色”、“行为”、“实体”，并对他们归类，我常常关注角色以及具体身份、行为以及包含的重要步骤、实体以及具体实例。</p>
<p><strong>角色</strong>：是施事主语、是名词，是主动发起行为的一类实体。</p>
<p><strong>行为</strong>：是动词、是做了什么事情，是行为本身。</p>
<p><strong>实体</strong>：是名词，是除“角色”之外的其他实体。</p>
<p>推荐使用脑图画出来，我认为归纳后的脑图有助于我们识别根本要素，有利于抽象。</p>
<p>产出物是：名词、概念定义、相关脑图。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3a1614f7e2c0ee3a66f2db19ed192bce04f42dde6019c4fa930e1835c1df5092" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="1-3-用例分析"><a href="#1-3-用例分析" class="headerlink" title="1.3 用例分析"></a>1.3 用例分析</h2><p>在这一步、我们使用相对宏观的分析，不需要进入用例的细节分析，主要的目的是掌握角色与行为之间的关系，理清谁在做什么，角色的职责目的是什么，用于指导领域划分以及领域服务设计。</p>
<p>产出物：用例图</p>
<p><strong>以做菜为例，如图</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/51ac3fc0da0ed091a670723bf99b41d78b9fe7c0e7ab9df8b0510704cf941d45" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="1-4-领域划分"><a href="#1-4-领域划分" class="headerlink" title="1.4 领域划分"></a>1.4 领域划分</h2><p>我们在分析宏观流程时，划分了几个行为区域，那是宏观级别的。在那基础之上，我们需要拉进某个区域的视角，再结合之前的用例分析，按照“功能相关性”、“角色相关性”进一步划分领域。我们不仅要知道谁做了什么，还需要知道谁“在哪”做了什么。</p>
<p><strong>功能相关性</strong>：也称为业务相关性，业务是由一套用例组成的，一套用例之间是符合高内聚原则的，一套用例构成了一个问题空间，也就构成了一个领域，所以“功能相关性”是划分领域的黄金标准。例如与做菜相关的用例都应该归属于厨房，所以我们确认了厨房域，这也是很自然的事。在这一步，通过划分领域、梳理领域与用例之间的关系。</p>
<p><strong>角色相关性：</strong> 角色相关性不可以作为首要参考因素，在特殊情况下用于划分子域，某个区域涉及多个角色参与，可以按照角色的分工，拆分为多个子域，从而满足不同角色的个性化需要。例如厨房的采购人员负责买菜、刀工负责切菜、大厨负责烹饪。我们就会考虑将厨房划分为“采购子域”、“加工子域”、“烹饪子域”。通常来说，子域不具备独立的问题空间，不会作为独立的领域存在。</p>
<p>划分领域的核心原则是保证领域的自治性（最小完备和自我履行），谨慎使用“实体相关性”划分领域，否则有可能将一个功能打散在多个领域上，违反了自治性原则，如果按照功能相关性划分，更容易实现领域的自治性，并且有助于将功能需要的实体聚合在一起。</p>
<p>产出物：领域、子域、领域与用例的关系</p>
<p><strong>以厨房域为例，如图</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/636f22fea81a57bd9bf193e29442074fdb03d32f3e978f95eaf8e40266f559c3" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<p>在复杂业务时，可以使用事件风暴方法辅助分析，并输出上述产出物。</p>
<p>﻿</p>
<h2 id="1-5-领域服务"><a href="#1-5-领域服务" class="headerlink" title="1.5 领域服务"></a>1.5 领域服务</h2><p>什么是领域服务？一个领域可以有几个领域服务？ 我们如何划分领域服务？标准是什么？</p>
<p>我认为一个领域不只有一个领域服务，我们不应该按照实体划分，也不应该按照聚合划分，也不该按照功能相关性划分。</p>
<p>领域服务用于实现用例功能，我认为应该使用角色划分领域服务。在用例图中，不同的角色发起不一样的用例，不同的领域服务提供不一样的用例，只有这样、才能确保领域服务是用例图的映射，也才能真正体现业务含义。领域服务是面向角色的，在一个领域中、每个角色对应一个领域服务。另外、同一个用例的逻辑差异是与角色的身份有关的，角色的身份对应了服务的泛化，角色的用例对应了服务的方法。对于此观点、我们在后续功能设计的部分也有体现。</p>
<p>例如：厨房域（厨师服务、刀工服务、采购员服务），菜品域（客户服务、管理者服务）。</p>
<p>产出物：领域服务类图</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d05be2480c52c89ce4292386cb88df4b38faaa01ce847e22c46fa8781abadc07" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="1-6-领域建模"><a href="#1-6-领域建模" class="headerlink" title="1.6 领域建模"></a>1.6 领域建模</h2><p>我们思考一下，到底什么才是领域驱动设计？ 例如“厨房域”被称为“菜域”，“厨师”的“做菜”功能被称为“菜服务”的“做菜”功能，也例如“菜品域”有个“菜品服务”，“菜品服务”提供了“增、删、改、查”的功能。我们往往以最核心的实体为中心，误以为业务就是在操作数据，丢掉了业务本质含义，逐渐也就走歪了。</p>
<p>不要学传统的数据模型驱动设计，实体模型驱动设计与前者的本质是一样的，是换汤不换药的，这不是技术问题，而是过度集中在实体上以至于忘记其他元素。我们必须把精力放在业务本身，防止领域驱动设计变成领域模型驱动设计。我们不应该优先思考领域模型，不应该以领域模型命名一切，不应该让领域模型决定业务的实现方式。厨房不只有菜，也有服务员和厨师，我们使用合适的语言对应合适的元素，以确保软件元素是真实业务的映射。例如“厨师在厨房做菜”，这句话中的所有元素都要在系统中得以保留，丢了一个也不行，更何况只剩下菜了。</p>
<p>所以、我们先做领域划分，再做领域服务设计，最后做领域建模，这个顺序很重要，可以避免我们错误的以领域建模为中心。先有用例才有领域，先有领域才为领域建模，实体是为了实现一组用例存在的。而一组用例不一定依赖实体。</p>
<p>回到正题、我们在这一步的重点还是菜的问题，我们分析实体与领域之间关系（领域聚合），实体与实体的关系（OO聚合）。其中OO关系影响了功能的扩展性，需要我们特别关注。实体因一套用例而聚合在一起，我推荐做法是将领域的用例放在一起分析，找到他们的共同性，充分考虑变化，使用兼容性更好的模型解决问题。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/979aeab943606c29a7fca1875e5d7552d9a854b8683e0b4aeb2ca599bfdc4b21" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<p><strong>组合、聚合</strong></p>
<p>聚合（aggregation）：聚合关系是一种弱的关系，整体和部分可以相互独立。</p>
<p>组合（composition）：组合关系是一种强的整体和部分的关系，整体和部分具有相同的生命周期。</p>
<p>可以使用如下案例，既能表达领域聚合，又能表达OO聚合的关系。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9d7a0a9e6d4d885a43ae8179ccb5320463eb1a7223a6c602bb416d0ab96e466b" alt></p>
<p>﻿﻿</p>
<p>产出物：聚合、实体、值对象、实体的属性</p>
<p>﻿</p>
<h2 id="1-7-领域上下游"><a href="#1-7-领域上下游" class="headerlink" title="1.7 领域上下游"></a>1.7 领域上下游</h2><p>领域上下游关系，不是领域的依赖关系，依赖关系指的是能力的依赖，是共用了某些能力。领域上下游关系，也不是调用关系，调用关系是与用例相关的，不是用于描述领域处境的。</p>
<p>领域上下游关系指的是影响力的关系，上游影响下游，影响力分为“逻辑影响”和“数据影响”，一般说来我们更应该关注“数据影响”，因为上下游的逻辑影响也是靠数据传递的，所以领域上下游关系是一种数据流向的限制，是业务发生的顺序限制，用于规定该领域所使用的数据，是下游领域依赖上游领域“准备就绪”的体现。合理的上下游限制，有助于减少领域之间的不必要依赖和重复的计算。</p>
<p>领域上下游是与场景相关的，并不是一成不变的，不同场景的情况下，存在不同的上下游关系，各场景应该独立说明。</p>
<p>产出物：各场景的上下游说明</p>
<p>﻿</p>
<p><strong>例：在【菜品管理】场景下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e09eeffb9d7e9119dd062848ac5e0c9cbcd2e69f82342f51708979a4afb55fbb" alt></p>
<p>﻿</p>
<p>如果厨房的某些食材不足了，或者某个厨师休假了，就会影响到菜品的展示，从而影响到客户的订单。</p>
<p>﻿</p>
<p><strong>例：在【客户消费】场景下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3976b2b629ba96be28ec2ff6b1e897289f194c77386aa7243e3c4c760396ce12" alt></p>
<p>﻿﻿</p>
<p>客户的订单、影响厨房生产的菜，从而影响刀工的行为，也影响到了采购。</p>
<p>﻿</p>
<p><strong>请对比下面两个图，用于理解领域的上下游</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f6abdca63824a3424cde317d8dcf7d928677089ad29e5acf057bf0d928a56268" alt></p>
<p>﻿﻿</p>
<p>实际上，厨师不应该依赖采购人员的采购功能，也不依赖刀工的切菜功能，他只是依赖“初加工食材”而已，而“初加工食材”就是被处理好的数据，厨师在做饭时，“初加工食材”就已经被处理好了，上面的图例只是为了说明一个关于领域上下游的问题，这是业务<strong>发生顺序</strong>以及<strong>数据来源</strong>的问题。</p>
<p>我们常常使用领域事件串联业务流程，在使用领域事件时，不止要关注点对点的解耦，更应该使业务流程符合领域上下游限定，让各个领域独立运行。</p>
<p>顺序发生优于嵌套发生，数据依赖优于功能依赖。</p>
<p>﻿</p>
<h1 id="2、架构设计"><a href="#2、架构设计" class="headerlink" title="2、架构设计"></a>2、架构设计</h1><p>架构设计是为了解决软件系统复杂度带来的问题，找到系统中的元素并搞清楚他们之间关系。</p>
<p>架构的目标是用于管理复杂性、易变性和不确定性，以确保在长期的系统演化过程中，一部分架构的变化不会对其它部分产生不必要的负面影响。这样做可以确保业务和研发效率的敏捷，让应用的易变部分能够频繁地变化，对应用的其它部分的影响尽可能地小。</p>
<p>架构设计三原则：合适原则、简单原则、演化原则</p>
<h2 id="2-1-分层架构"><a href="#2-1-分层架构" class="headerlink" title="2.1 分层架构"></a>2.1 分层架构</h2><p>我们需要按照 接口层、领域层（领域用例层、领域模型层）、依赖层、基础层 构建架构模型。</p>
<p><strong>接口层</strong>：为外部提供服务的入口，是适配层的北向网关。不实现任何业务逻辑，也不处理事务，是跨领域的，是流程编排层，是门面服务。</p>
<p><strong>领域用例层：</strong> 是领域服务层，是领域用例的实现层、隶属于某个领域、是业务逻辑层，是事务层，业务逻辑应该在这层完整体现，不要分散到其他层级。</p>
<p><strong>领域模型层：</strong> 是领域模型（实体、值对象、聚合）的所在位置，专注于领域模型自身的能力，不包含业务功能，可以处理事务，是原子化的能力，是领域对象的自我实现 <em>。</em></p>
<p><strong>依赖层</strong>： 是连接外部服务的出口，是适配层的南向网关。包括仓储，端点、RPC等，主要作用是领域和外部解耦，是跨领域的。</p>
<p><strong>基础层：</strong> 与业务无关的，与领域无关的，通用的技术能力，技术组件等。</p>
<p>﻿</p>
<h2 id="2-2-架构映射"><a href="#2-2-架构映射" class="headerlink" title="2.2 架构映射"></a>2.2 架构映射</h2><p>架构的视角，从大到小依次是：系统-&gt;应用（微服务）-&gt;模块（包）-&gt;子模块 这样的从大到小的层级。</p>
<p><strong>业务领域映射</strong>：我们将划分好的领域，按照对应的视角映射为对应的元素，领域模型映射到架构模型时，应该是视角对等的，如果餐厅是系统、那么厨房就是应用，如果餐厅是应用、那么厨房就是模块。也应该是层级匹配的，将用例的实现映射到用例层，将领域模型的实现映射到领域模型层。也应该是名称一致的，将领域名映射为应用名或包名，将实体名映射为实体类名，将角色名映射为领域服务类名，将角色身份名映射为服务类的子类名，将用例名映射为服务类的方法名。</p>
<p><strong>技术和抽象问题</strong>：有时候、业务领域分析不能体现那些共性的技术问题，所以需要适当结合技术视角，可能需要对领域模型微调。同时、我们需要找到共同需要的基础能力，例如“水”、“电”、“煤气”等等，将这些作为额外的考虑因素，要做到业务问题与技术问题解耦，不要将技术问题和业务逻辑揉成一团。</p>
<p>领域设计，类似餐厅设计师，他设计餐厅有几个区域，区域的用途是什么。</p>
<p>架构设计，类似建筑设计师，他设计如何走水电煤气、如何施工等。</p>
<p>产出物：分层架构图</p>
<p>﻿</p>
<p><strong>以厨房为视角，其架构如下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/966a1ae235eef34a3e984d09e3fb04f923a8bd148e1f979c2f59f6c3c62815af" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<p><strong>以餐厅为视角，其架构如下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ba3c0b20ee2212d3166c41277447f3edfbe144488c72efc9b939aa4b3b58a10a" alt></p>
<p>﻿﻿</p>
<p>分层架构图，体现逻辑上的层级分布，而不是代表组件的具体含义，组件是应用还是模块、需要结合实际情况而定。</p>
<p>﻿</p>
<h2 id="2-3-必要的约束"><a href="#2-3-必要的约束" class="headerlink" title="2.3 必要的约束"></a>2.3 必要的约束</h2><p>1、分层架构越往下层就越是稳定的：下层是被上层依赖的，下层不可以反向依赖上层（扩展点除外）。因为分层架构的核心原则是将容易变化的逻辑上浮，将共性的、原子化的、通用的逻辑下沉，被依赖的下层应该是稳定的，这要求上层承接更多业务变化。下层离开上层应该是可以独立存在的，例如在接口层定义的DTO不可以在下层被使用，但领域层定义的实体可以被上层使用。</p>
<p>2、在使用充血模型时，应该符合面向对象编程原则：不要随意的将一些能力都充到领域实体模型中。以“菜”为例，重量和规格是“菜”的自身的属性，激发味蕾是“菜”的能力，“菜”可以维护自身的持久化状态。但是、请注意、“菜”不可以“炒菜”，因为“炒菜”的时候，“菜”还没有出现呢，“菜”不是自己的上帝，“菜”需要被做出来，所以“菜”被做出来之前是没有“菜”的，这是个时间上的概念，不要错把“炒菜”的能力放在“菜”的身上。“炒菜”用到的“水+电+气+食材+调料+厨具”不应该是“菜”的属性范围，这些元素都在“厨房”的范围中，不要让领域的模型包含不属于自身的元素，领域的实体模型只是领域的一部分，只用于实现通用的模型能力。</p>
<p>3、接口层和依赖层是与领域无关的：他们是与技术相关的层级，不属于任何领域，这两层不能包含业务逻辑。有时候我们可以把接口层拆为两层（接口层、应用层），但是我不建议这样做，我们没有必要把很轻的一层再次拆分。我们也可以把依赖层拆分为两个（领域模型依赖、其他依赖），我非常建议这样做，因为领域模型依赖的资源不会被其他领域使用，拆开之后可以有效限制领域模型的依赖，</p>
<p>4、领域层是与环境无关的：无论某个领域是应用还是模块，都应该是完整的。应该具备独立的用例层和独立的模型层，即使多个领域在同一个应用当中，也要按照他们是分别独立去看待，无论某个领域是应用还是模块，领域对外部的交互，不可以绕过依赖层和接口层。</p>
<p>5、领域应该自治性的：把一个领域拆分为子域、子子域….. 无限拆分，子域就不完整了。或者没有按照功能相关性拆分，也可能破坏领域的完整性，不完整的领域不符合自治性原则。所以、不完整的领域不会单独存在，所以、当一个领域的内部子域不具备独立性时，子域之间不必严格解耦，不需要通过依赖层访问本领域的其他子域，他们之间可以直接调用。</p>
<p>6、领域用例层和领域模型层是两个层级：领域用例层指的就是领域服务层，不建议将领域服务与领域模型放在同一层，这可能会导致逻辑的分散（一部分在领域服务层、一部分在领域模型层）。如果将业务逻辑写在领域模型中，会导致业务逻辑进一步下沉，业务逻辑的不确定性太大，是不适合下沉的，是违反分层架构原则的。领域模型对应的是实体、领域服务对应的是用例，分开就是更有效的限制措施。</p>
<p>7、领域用例层只能承接符合自身领域的用例：我们划分出领域的目的，就是为了区分每个领域的职责所在，因此他们必须严格按照职责办事，我们在之前已明确了用例和领域之间的关系，需要严格遵守。 如果出现跨领域的编排，请在接口层串联。如果依赖其他领域的功能，请把被依赖的功能逻辑放在其他领域中。</p>
<p>8、领域模型层遵循最小依赖原则：只可以依赖必要的资源，必要资源指的是领域模型实现自身能力需要的资源，不包括实现业务逻辑依赖的资源。例如领域模型需要依赖DB完成持久化，可以依赖数据访问资源，但不应该依赖其他领域资源、不可以依赖RPC资源等。 最好的做法就是将领域模型依赖的资源单独拿出来，并且与领域模型放在一起。保持领域模型层的独立性，在多个领域应用共享领域模型时，方便使用共享内核的设计模式。</p>
<p>﻿</p>
<h2 id="2-4-微服务划分"><a href="#2-4-微服务划分" class="headerlink" title="2.4 微服务划分"></a>2.4 微服务划分</h2><p>服务划分以领域划分为参考，主要看我们要拆分到什么粒度，不建议将几个领域放在同一个服务中，不建议把一个完整的领域拆分为几个不完整的微服务。</p>
<p>产出物：微服务</p>
<p>﻿</p>
<p>例如餐厅：是有必要拆分的，餐厅的“菜品域”，“订单域”，“厨房域”有独立的问题空间，是具备自治性的。</p>
<p>例如厨房：是没有必要拆分的，厨师与刀工的耦合非常高，他们都在做饭，分开之后是不完整的，分开就是没有必要的。</p>
<p>﻿</p>
<p>所以餐厅被拆分为：<strong>厨房、菜品、订单</strong>，三个微服务。基于此、我们单独拿出<strong>餐厅门面服务</strong>作为接口层应用，再单独拿出<strong>餐厅基础服务</strong>作为水电煤气的应用。</p>
<p>一般情况下，依赖层不会作为单独的服务提供，会被以组件的形式嵌入到其他服务中。</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/49ae85e1b195a812f56555e88bff5ad92e0cf49e9c090b2d108a4e8080e38540" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h1 id="3、功能设计（用例实现）"><a href="#3、功能设计（用例实现）" class="headerlink" title="3、功能设计（用例实现）"></a>3、功能设计（用例实现）</h1><p>如果说领域设计是餐厅的设计师、架构设计是餐厅的建筑师、那么功能设计就是餐厅的厨师。</p>
<p>任何设计都要落地到功能设计，如果厨师不守规则，偏偏要去洗手间洗菜，最后的结果依然是一团乱，最终会导致前面的所有设计泡汤。</p>
<p>功能设计是实现 “面向扩展开放、面向修改关闭” 的途径，</p>
<p>功能设计是为研发提供的落地支撑。</p>
<p>﻿</p>
<h2 id="3-1-功能的概念"><a href="#3-1-功能的概念" class="headerlink" title="3.1 功能的概念"></a>3.1 功能的概念</h2><p>功能迭代时，功能会发生一些变化，所以他的含义是可能变化的，所以我们需要再次审视功能的概念，及时加以调整。</p>
<p>例如、我们实现了一个“做蛋炒饭”的功能，后来又实现了一个“做辣椒炒蛋”的功能，那么我们应该将功能升级为“炒菜”，甚至是“制作菜品”等。</p>
<p>结合相关功能，系统性思考和抽象，明确功能的概念，是功能设计的前提。</p>
<p>产出物：更新语言库，更新脑图</p>
<p>﻿</p>
<h2 id="3-2-用例的位置"><a href="#3-2-用例的位置" class="headerlink" title="3.2 用例的位置"></a>3.2 用例的位置</h2><p>我们在1.3用例分析章节，明确了用例与角色的关系，在1.4领域划分章节，明确了用例与领域的关系。</p>
<p>然而一个新功能的加入，我们仍然要再次评估，以确保他处于正确的位置。按照之前的做法,根据功能相关性确认用例的领域，根据角色相关性确认用例的领域服务。</p>
<p>产出物：更新用例图</p>
<p>﻿</p>
<h2 id="3-3-事件风暴"><a href="#3-3-事件风暴" class="headerlink" title="3.3 事件风暴"></a>3.3 事件风暴</h2><p>事件风暴常用于梳理业务流程，适用于解构跨领域的复杂业务，感兴趣的朋友可以去自行学习。</p>
<p>但是、对于领域内的单功能，稍有复杂的时候，我们可以采取简化版事件风暴的方法，从而获得如下信息：</p>
<p>将功能拆分为多个子功能（步骤）。（在后续使用）</p>
<p>步骤对应的角色+角色身份。（在后续的3.6章节落地）</p>
<p>步骤的串联流程+领域事件。（在后续的3.6章节落地）</p>
<p>步骤依赖的实体。（在后续的3.7章节落地）</p>
<p>产出物：事件风暴模型</p>
<p>﻿</p>
<h2 id="3-4-用例分析"><a href="#3-4-用例分析" class="headerlink" title="3.4 用例分析"></a>3.4 用例分析</h2><p>我们暂且收回思路，首先要关注共性和差异问题，以实现功能复用或扩展。</p>
<ul>
<li>确认用例的泛化+差异点，实现功能的扩展。</li>
<li>寻找共同包含的步骤，实现逻辑的复用。</li>
</ul>
<p>产出物：用例分析图</p>
<p>﻿</p>
<p><strong>例：制作菜品（做大拌菜、做铁锅炖、做炒鸡蛋、做蒸米饭、做炒米饭）</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6524cc86f573441d9e72ac1b9b34f22d9d1fe24c33c3181a02c4a8ed1abd9a69" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="3-5-用例实现类（领域服务类）结构图"><a href="#3-5-用例实现类（领域服务类）结构图" class="headerlink" title="3.5 用例实现类（领域服务类）结构图"></a>3.5 用例实现类（领域服务类）结构图</h2><p>首要关注点是领域服务类的结构问题，结构决定了扩展，我们需要先达到“面相修改关闭，面相扩展开放”的目的。</p>
<p>领域服务的类结构图是用例图的映射，服务类结构图反向映射了角色的身份，进一步反向印证了上文的观点。</p>
<p>出物：用例层的类结构图</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/05a7a9bd08aee82f11528e059da6d42f939d3b0345ba41e569536a646362ad41" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="3-6-用例流程图"><a href="#3-6-用例流程图" class="headerlink" title="3.6 用例流程图"></a>3.6 用例流程图</h2><p>我们接回思路，更进一步，将事件风暴模型落实到代码层面。</p>
<p>我们将步骤分配到实现类中、步骤就是该类的一个方法，进一步明确由哪个类和方法来实现该步骤，从而就规定了步骤所在的领域服务。再将步骤和领域事件串联起来，规定了业务实现流程。</p>
<p>在确认步骤所在位置的时候，根据角色身份相关性定位步骤的具体实现类。</p>
<p>推荐使用泳道图表达上述内容，泳道的纵向组件是领域服务类，领域服务承接了所有子功能，流程图也需要体现所有的步骤，这是用例层的横向交互。</p>
<p>程序流程就是业务流程的映射，步骤分布体现了角色身份的差异。</p>
<p>产出物：用例流程图</p>
<p>﻿</p>
<p><strong>以炒鸡蛋为例，其用例流程图如下</strong></p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c39fe5d87e2f598d66fa1c61e796cbdff8b1e4f166c0e8d356914ffebf9efdb0" alt></p>
<p>﻿﻿</p>
<p>﻿</p>
<h2 id="3-7-活动图（时序图）"><a href="#3-7-活动图（时序图）" class="headerlink" title="3.7 活动图（时序图）"></a>3.7 活动图（时序图）</h2><p>进一步将事件风暴模型落实到代码层面，我们使用时序图，体现依赖和调用关系，规定了步骤与领域实体模型的关系，说明该步骤影响了谁。</p>
<p>时序图体现了领域服务内部的纵向交互，为了简便、我们可以收起领域服务类（用例层）的泳道。</p>
<p>产出物：时序图、活动图</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ffe3961bf4f225fe7319a7deba2624bfc49f3625105f3576258cbabf183835d" alt></p>
<p>﻿﻿</p>
<hr>
<p>﻿</p>
<p>在本篇文章中，通过三大步骤阐述了映射办法，让软件系统成为真实业务的说明书，软件系统似乎在对我们说“谁？在哪？做了什么事？影响了谁？是怎么做的？有什么差异？”。例如我们画的圈成为了应用名或包名，圈中的领域模型图成为了实体类+数据模型，圈中的用例图成为了领域服务和方法，功能流程成为了程序调用链，功能步骤成为了方法，领域服务类结构反向体现了角色身份，也体现了不同身份的差异…… 系统就是业务、业务就是系统、两者可以相互映射。</p>
<p>DDD的概念有很多，到底什么是DDD？是思想吗？是方法论吗？每个人都有自己的理解。在我看来、DDD是一套系统化的办法，无法用几句话说清楚，故而以此分享DDD的落地模式。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357957599844122624" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.jsVS.Net：国外网友也吵起来了！</title>
    <url>/7358295139457761317.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>近日有人在 Hacker News 上询问了有关 Node.js 和 .Net Core（2024）生态系统，此前在 2016 年也有过同样问题的讨论。引发激烈讨论，有喜欢 Node.js 的、有喜欢 .Net 的，还有 Go 和 Java。</p>
<p>下面摘选几个不同角度的热点评论：</p>
<h2 id="评论1：“两者都可以，但我更倾向于-Net”"><a href="#评论1：“两者都可以，但我更倾向于-Net”" class="headerlink" title="评论1：“两者都可以，但我更倾向于 .Net”"></a>评论1：“两者都可以，但我更倾向于 .Net”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a1405b03646da5c152d6cacd34a6410c12cf52c3e7ee8aeea38e435796076dfe" alt></p>
<p>网友 “Atotalnoob”：</p>
<blockquote>
<p>两者都可以。这真的取决于你的使用情况。在我看来，对于 .NET，开发体验要好得多，但它也更昂贵，通常需要 Windows（是的，Linux 上也完全可以使用 .NET）。微软在从头到尾构建更好、更简单的工具方面投入了大量资源。如果你是 Azure 店铺，部署将非常容易。</p>
<p>我还没有看最新的基准测试结果，但我曾经看过的时候，C# 在性能、多线程等方面是一个明显的赢家。Node.js 在任何方面都不慢，但也不是不慢。</p>
<p>Node.js 擅长开发速度和像 Next.js 或其他 SSG 中的 BFF 模式。.NET 将引导你进入更好的设计模式，以便未来更易于维护。在 Node.js 周围还有更多需要注意的地方，这主要是由于 JavaScript 的怪异性。</p>
<p>如果你同时使用 Node.js 后端和前端，那会非常不错。这是一种语言，如果你使用 TypeScript，你可以共享类型！</p>
<p>总的来说，两者都有取舍。当你在它们之间做出选择时，我更关心的是你的团队构成、技能组合和项目类型。</p>
<p>如果你逼我做选择，我会选择 .NET。”</p>
</blockquote>
<p>上面有一点是认同的，Node.js 服务端同前端是一种语言，因为大家都是用 JavaScript，学习成本总归是要低些的，有些通用的模块是可以共享的，例如，使用 TS 后，类型就可以共享啊！</p>
<h2 id="评论2-“Node-js-生产力方面无与伦比”"><a href="#评论2-“Node-js-生产力方面无与伦比”" class="headerlink" title="评论2: “Node.js 生产力方面无与伦比”"></a>评论2: “Node.js 生产力方面无与伦比”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bbed384f91a43f324df5141785d3383b4ee61c53e7eb279a514b38bb340418c2" alt></p>
<p>网友 @dzonga：</p>
<blockquote>
<p>.NET Core 相当不错。如果我没记错的话，它们甚至采用了与 Express 类似的 API。</p>
<p>是的，它也很快。比 Node 还要快。有类型等。但是 C# 是一种复杂的语言。而且它不断添加新特性。在 .NET 世界中有很棒的工具等。</p>
<p>但是你知道为什么 JavaScript / Node.js 会出色吗？JS 是一种简单的语言。当然，像 Clojure 这样的 Lisp 也很简单。但只有一种语言接近 JavaScript 的简洁性 – Go 语言。</p>
<p>但是 Go 语言像 JavaScript 一样灵活吗？</p>
<p>在 JavaScript 领域可能唯一不太好的是工具。但就服务器端的东西来说，比如处理 JSON / 转换 JSON，这正是信息类应用所需的 – 也就是我们大多数人工作的应用的大部分内容。Node.js 在生产力方面是无与伦比的。</p>
<p>所以，是的，Node.js 能够用 20% 的工作获得 80% 的结果。</p>
</blockquote>
<h2 id="评论3：“选择-JS-开发，因为不想与-Windows-人才打交道！”"><a href="#评论3：“选择-JS-开发，因为不想与-Windows-人才打交道！”" class="headerlink" title="评论3：“选择 JS 开发，因为不想与 Windows 人才打交道！”"></a>评论3：“选择 JS 开发，因为不想与 Windows 人才打交道！”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1daf0f27d79f0338906ae8717edd8d6393a5f4192a4231361b52d8ec15a50b7f" alt></p>
<blockquote>
<p>我知道你不是在询问技能背后的人格，但我宁愿选择一个 JS 开发，而不是一个 .NET 开发（即使（也许特别是）.NET Core 可以在 Linux 上运行），我甚至会更换整个技术栈，以避免与 Windows 人才打交道。基于 Microsoft 的生态系统中的 ClickOps 思维令人震惊。</p>
</blockquote>
<p>这哥们不知道与 Windows 有啥恩怨，以至于选择选择 JS 开发的原因是不想与 Windows 人才打交道 😂</p>
<h2 id="评论4：“我选择-go”"><a href="#评论4：“我选择-go”" class="headerlink" title="评论4：“我选择 go”"></a>评论4：“我选择 go”</h2><p>最后有一个由 @moomoo11 评论到 “正确的答案是 Go”</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d6f70ede0f59a59d80ea964427a0264fdcf165912c9773a14bb19937119c7325" alt></p>
<p>网友 @kcartlidge 回复到</p>
<blockquote>
<p>我使用 Go、Node 和 C#（还有当前的 Python、Ruby 和 PHP），正确答案是没有正确答案。</p>
<p>你能做到的最接近的就是使用你已经了解的知识。</p>
<p>如果你已经得出结论你已经了解的知识无法完成工作，那么理论上你已经掌握了缺失功能的知识，这让你能够根据特定的使用情况进行正确的技术评估。</p>
</blockquote>
<p>就好像有人说，我总是首先考虑 Go，还有人说 Go 是一个更糟糕的选择！正确上面 @kcartlidge 回复的，这里可能真的没有正确答案！</p>
<h2 id="评论5-“赚钱还得是我-PHP”"><a href="#评论5-“赚钱还得是我-PHP”" class="headerlink" title="评论5: “赚钱还得是我 PHP”"></a>评论5: “赚钱还得是我 PHP”</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee29ab3ed777540b3bd7fa01f202c66a0dbb08530bdda6921691d96e6182a5eb" alt></p>
<p>这种讨论怎能没有我 PHP？网友 @delfinom 回复到：</p>
<blockquote>
<p>你要使用最适合你应用程序的工具。这就是任何语言争论的答案。</p>
<p>这就是人们即使只运行 PHP，也能赚取数百万利润的方式。</p>
</blockquote>
<p>前段时间知乎上有个 “<a href="https://www.zhihu.com/question/634587715" target="_blank" rel="noopener">2024年nodejs凉了吗？凉到什么程度了？</a>”，既然能有这么热烈的讨论，至少还没凉透吧，正常使用吧！没什么问题的。引用一句话：“世上只有两种编程语言：一种被人骂，一种没人用”。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://news.ycombinator.com/item?id=40014102" target="_blank" rel="noopener">news.ycombinator.com/item?id=400…</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358295139457761317" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>前端,Node.js,.NET</tag>
      </tags>
  </entry>
  <entry>
    <title>一文讲透可升级合约，并通过hardhat+openzeppe</title>
    <url>/7357988193340653609.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>在我们进行合约开发时有一个痛点是，升级部署到链上后不能再更改，但如果了解<code>Solidity</code>比较深的小伙伴就知道，<code>Solidity</code>有个<code>delegate</code>方法，可以实现通过代理合约调用逻辑合约，我们的数据存储在代理合约中，执行的逻辑在逻辑合约中，我们想要升级合约时只需要部署新的逻辑合约即可。具体执行逻辑如下图：</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bd32e1d667e410a36723a9644b3beca6b073266ac1d1be2f3eaff20dfdab9d98" alt="image.png"></p>
<h3 id="一、简单可升级合约"><a href="#一、简单可升级合约" class="headerlink" title="一、简单可升级合约"></a>一、简单可升级合约</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">// wtf.academy</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">// 简单的可升级合约，管理员可以通过升级函数更改逻辑合约地址，从而改变合约的逻辑。</span><br><span class="line">// 教学演示用，不要用在生产环境</span><br><span class="line">contract SimpleUpgrade &#123;</span><br><span class="line">    address public implementation; // 逻辑合约地址</span><br><span class="line">    address public admin; // admin地址</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化admin和逻辑合约地址</span><br><span class="line">    constructor(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback函数，将调用委托给逻辑合约</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧逻辑合约</span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;old&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新逻辑合约</span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器：0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;new&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码中包含了<code>3</code>个合约：</p>
<ul>
<li><code>SimpleUpgrade</code>: 代理合约</li>
<li><code>Logic1</code>: 旧逻辑合约</li>
<li><code>Logic2</code>: 新逻辑合约</li>
</ul>
<h4 id="1-代理合约SimpleUpgrade"><a href="#1-代理合约SimpleUpgrade" class="headerlink" title="1. 代理合约SimpleUpgrade"></a>1. 代理合约<code>SimpleUpgrade</code></h4><p>代理合约包含<code>3</code>个变量:</p>
<ul>
<li><code>implementation</code>: 逻辑合约地址</li>
<li><code>admin</code>: 合约管理员地址</li>
<li><code>words</code>: 字符串，通过调用逻辑合约函数来改变</li>
</ul>
<p>也包含了<code>3</code>个函数:</p>
<ul>
<li>构造函数: 初始化<code>admin</code>和<code>implementation</code>地址</li>
<li><code>fallback</code>函数: 委托函数，会将函数调用委托给逻辑合约执行，需要通过函数选择器<code>calldata</code>来调用</li>
<li><code>upgrade</code>函数: 升级函数，只能由<code>admin</code>调用，改变逻辑合约地址</li>
</ul>
<h4 id="2-旧逻辑合约"><a href="#2-旧逻辑合约" class="headerlink" title="2. 旧逻辑合约"></a>2. 旧逻辑合约</h4><p>旧逻辑合约中变量和代理合约保持一致（防止函数执行时插槽错误），通过代理合约调用时改变的状态变量是代理合约中的，有一个函数<code>foo</code>，将代理合约中的<code>words</code>值改为<code>old</code>。</p>
<h4 id="3-新逻辑合约"><a href="#3-新逻辑合约" class="headerlink" title="3. 新逻辑合约"></a>3. 新逻辑合约</h4><p>和旧逻辑合约逻辑一直，<code>foo</code>将代理合约中的<code>words</code>改为<code>new</code>。</p>
<h4 id="4-部署测试"><a href="#4-部署测试" class="headerlink" title="4. 部署测试"></a>4. 部署测试</h4><ol>
<li>在<code>Remix</code>中首先部署<code>旧逻辑合约(Logic1)</code>和<code>新逻辑合约(Logic2)</code></li>
<li>再部署<code>代理合约(SimpleUpgrade)</code>，构造函数中填入<code>旧逻辑合约(Logic1)</code>的地址</li>
<li>都部署好后可以通过<code>代理合约</code>去调用<code>旧逻辑合约</code>的<code>foo</code>函数，需要通过低级调用的方式填入函数签名在<code>calldata</code>中，这里填入<code>c2985578</code></li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7481e9d9c234ff123203cd156969d20b6fb743e1b832c2b3169cd94e0c56829b" alt="image-3.png"></p>
<p>函数签名可以通过<code>https://abi.hashex.org/</code>，来生成</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d077fadb445e31b25a3bcc5314d56fe61ef4537bc21e83feb941b71630d63925" alt="image-2.png"></p>
<ol start="4">
<li>此时查看<code>代理合约</code>中的<code>words</code>就被改成了<code>old</code></li>
<li>再调用代理合约的<code>upgrade</code>函数，填入<code>新逻辑合约</code>地址，实现逻辑合约的升级</li>
<li>最后再次通过低级调用的方式填入函数签名在<code>calldata</code>中调用新逻辑合约的<code>foo</code>函数，就可以看到代理合约中的<code>words</code>改变为了<code>new</code></li>
</ol>
<p>到此，我们就完成了可升级合约的开发和部署，但可升级合约还有可能产生选择器冲突问题。</p>
<h3 id="二、透明代理和通用可升级代理-UUPS"><a href="#二、透明代理和通用可升级代理-UUPS" class="headerlink" title="二、透明代理和通用可升级代理(UUPS)"></a>二、透明代理和通用可升级代理(UUPS)</h3><p>大家可以看到我们上面填的两个<code>foo</code>函数的函数签名其实是<code>foo</code>哈希后取的前 4 个字节，4 个字节这个范围其实很少，两个不同的函数很有可能造成<code>hash</code>的前 4 个字节一样，这就造成了选择器冲突。</p>
<p>如果选择器冲突出现在同一个合约中，那么合约是无法编译成功的，但是可升级合约会部署两个合约，比如代理合约的升级函数和逻辑合约中其中一个函数有选择器冲突，那么管理人在调用逻辑合约中的函数就可能将代理合约升级成黑洞合约，有严重的安全问题。</p>
<p>解决的方法一般有两种：</p>
<ul>
<li>透明代理</li>
<li>通用可升级代理</li>
</ul>
<h4 id="1-透明代理"><a href="#1-透明代理" class="headerlink" title="1. 透明代理"></a>1. 透明代理</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">// wtf.academy</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">// 透明可升级合约的教学代码，不要用于生产。</span><br><span class="line">contract TransparentProxy &#123;</span><br><span class="line">    address implementation; // logic合约地址</span><br><span class="line">    address admin; // 管理员</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化admin和逻辑合约地址</span><br><span class="line">    constructor(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback函数，将调用委托给逻辑合约</span><br><span class="line">    // 不能被admin调用，避免选择器冲突引发意外</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        require(msg.sender != admin);</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        if (msg.sender != admin) revert();</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 旧逻辑合约</span><br><span class="line">contract Logic1 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;old&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新逻辑合约</span><br><span class="line">contract Logic2 &#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器：0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;new&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透明代理是通过限制管理员的权限，管理员只能调用代理合约中的升级函数，不能调用逻辑合约中函数，其他用户只能调用逻辑合约中的函数不能调用代理合约的升级函数来解决选择器冲突问题。</p>
<h4 id="2-通用可升级代理-UUPS"><a href="#2-通用可升级代理-UUPS" class="headerlink" title="2. 通用可升级代理(UUPS)"></a>2. 通用可升级代理(UUPS)</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">// wtf.academy</span><br><span class="line">pragma solidity ^0.8.4;</span><br><span class="line"></span><br><span class="line">contract UUPSProxy &#123;</span><br><span class="line">    address public implementation; // 逻辑合约地址</span><br><span class="line">    address public admin; // admin地址</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 构造函数，初始化admin和逻辑合约地址</span><br><span class="line">    constructor(address _implementation)&#123;</span><br><span class="line">        admin = msg.sender;</span><br><span class="line">        implementation = _implementation;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // fallback函数，将调用委托给逻辑合约</span><br><span class="line">    fallback() external payable &#123;</span><br><span class="line">        (bool success, bytes memory data) = implementation.delegatecall(msg.data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UUPS逻辑合约（升级函数写在逻辑合约内）</span><br><span class="line">contract UUPS1&#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;old&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span><br><span class="line">    // UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 新的UUPS逻辑合约</span><br><span class="line">contract UUPS2&#123;</span><br><span class="line">    // 状态变量和proxy合约一致，防止插槽冲突</span><br><span class="line">    address public implementation;</span><br><span class="line">    address public admin;</span><br><span class="line">    string public words; // 字符串，可以通过逻辑合约的函数改变</span><br><span class="line"></span><br><span class="line">    // 改变proxy中状态变量，选择器： 0xc2985578</span><br><span class="line">    function foo() public&#123;</span><br><span class="line">        words = &quot;new&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 升级函数，改变逻辑合约地址，只能由admin调用。选择器：0x0900f010</span><br><span class="line">    // UUPS中，逻辑函数中必须包含升级函数，不然就不能再升级了。</span><br><span class="line">    function upgrade(address newImplementation) external &#123;</span><br><span class="line">        require(msg.sender == admin);</span><br><span class="line">        implementation = newImplementation;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用可升级代理(UUPS)是通过把升级函数也放在逻辑合约中，代理合约只存储状态变量和调用逻辑合约中的所有函数(升级函数和其他逻辑函数)来解决选择器冲突问题，因为通过代理合约来调用逻辑合约的升级函数时，改变的也是代理合约中存储的逻辑合约的地址，这样我们其实升级也是没有任何问题的。</p>
<h3 id="三、使用Hardhat-OpenZeppelin开发生产环境的可升级合约"><a href="#三、使用Hardhat-OpenZeppelin开发生产环境的可升级合约" class="headerlink" title="三、使用Hardhat+OpenZeppelin开发生产环境的可升级合约"></a>三、使用<code>Hardhat</code>+<code>OpenZeppelin</code>开发生产环境的可升级合约</h3><p>用上面的办法开发的可升级合约，虽然可以实现可升级功能，但对于一些安全问题没有很好的处理，所以我们一般在实际项目开发中会使用如<code>Hardhat</code>、<code>OpenZeppelin</code>等工具来开发可升级合约。</p>
<h4 id="1-初始化一个Hardhat项目"><a href="#1-初始化一个Hardhat项目" class="headerlink" title="1. 初始化一个Hardhat项目"></a>1. 初始化一个<code>Hardhat</code>项目</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm init</span><br><span class="line">npm install --save-dev hardhat</span><br><span class="line">npx hardhat init</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码$ npx hardhat init</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">888    888                      888 888               888</span><br><span class="line">8888888888  8888b.  888d888 .d88888 88888b.   8888b.  888888</span><br><span class="line">888    888     &quot;88b 888P&quot;  d88&quot; 888 888 &quot;88b     &quot;88b 888</span><br><span class="line">888    888 .d888888 888    888  888 888  888 .d888888 888</span><br><span class="line">888    888 888  888 888    Y88b 888 888  888 888  888 Y88b.</span><br><span class="line">888    888 &quot;Y888888 888     &quot;Y88888 888  888 &quot;Y888888  &quot;Y888</span><br><span class="line"></span><br><span class="line">👷 Welcome to Hardhat v2.22.2 👷‍</span><br><span class="line"></span><br><span class="line">? What do you want to do? …</span><br><span class="line">&gt; Create a JavaScript project</span><br><span class="line">  Create a TypeScript project</span><br><span class="line">  Create a TypeScript project (with Viem)</span><br><span class="line">  Create an empty hardhat.config.js</span><br><span class="line">  Quit</span><br></pre></td></tr></table></figure>

<h4 id="2-安装OpenZeppelin可升级合约的hardhat插件依赖和合约依赖"><a href="#2-安装OpenZeppelin可升级合约的hardhat插件依赖和合约依赖" class="headerlink" title="2. 安装OpenZeppelin可升级合约的hardhat插件依赖和合约依赖"></a>2. 安装<code>OpenZeppelin</code>可升级合约的<code>hardhat</code>插件依赖和合约依赖</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npm install --save-dev @openzeppelin/hardhat-upgrades</span><br><span class="line">npm install --save-dev @openzeppelin/contracts-upgradeable</span><br></pre></td></tr></table></figure>

<h4 id="3-合约编写"><a href="#3-合约编写" class="headerlink" title="3. 合约编写"></a>3. 合约编写</h4><p><code>contracts/Box.sol</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solidity复制代码// contracts/Box.sol</span><br><span class="line">// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract Box is Initializable &#123;</span><br><span class="line">    uint256 private _value;</span><br><span class="line"></span><br><span class="line">    function initialize(uint256 value) public initializer &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Emitted when the stored value changes</span><br><span class="line">    event ValueChanged(uint256 value);</span><br><span class="line"></span><br><span class="line">    // Stores a new value in the contract</span><br><span class="line">    function store(uint256 value) public &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">        emit ValueChanged(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reads the last stored value</span><br><span class="line">    function retrieve() public view returns (uint256) &#123;</span><br><span class="line">        return _value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>合约很简单，就是存储了一个<code>_value</code>值，并通过<code>store</code>来修改这个值，并通过<code>retrieve</code>来读取这个值。</p>
<p>其中有个很关键的<code>initialize</code>函数，这是合约的初始化函数，在以前我们写构造函数是通过<code>constructor</code>，但在<code>OpenZeppelin</code>可升级合约中需要使用<code>initialize</code>函数。并通过继承<code>Initializable</code>合约，并在<code>initialize</code>函数上添加<code>initializer</code>函数修饰器来确保这个初始化函数只能执行一次。</p>
<h4 id="4-部署合约"><a href="#4-部署合约" class="headerlink" title="4. 部署合约"></a>4. 部署合约</h4><p><code>script/deploy.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码const &#123; ethers, upgrades &#125; = require(&quot;hardhat&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  const Box = await ethers.getContractFactory(&quot;Box&quot;);</span><br><span class="line">  console.log(&quot;Deploying Box...&quot;);</span><br><span class="line">  const box = await upgrades.deployProxy(Box, [70]);</span><br><span class="line">  console.log(&quot;Box deployed to:&quot;, box.target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<p>其中<code>deployProxy</code>的第二参数为初始化函数需要的参数，通过数组的形式传进去，然后通过运行下面命令来部署，<code>--network</code>为我自己添加的本地<code>ganache</code>网络，也可以改成其他网络或者不写，不写会部署到<code>hardhat</code>的本地测试网络。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat run script/deploy.js --network ganache</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ca8ba6c93c8270a74522eefd2127b3973de64a2d8199f2b0fe0837cc16dba2cb" alt="image-4.png"></p>
<h4 id="5-可以通过hardhat提供的console来测试"><a href="#5-可以通过hardhat提供的console来测试" class="headerlink" title="5. 可以通过hardhat提供的console来测试"></a>5. 可以通过<code>hardhat</code>提供的<code>console</code>来测试</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat console --network ganache</span><br><span class="line">Welcome to Node.js v12.22.1.</span><br><span class="line">Type &quot;.help&quot; for more information.</span><br><span class="line">&gt; const Box = await ethers.getContractFactory(&apos;Box&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const box = await Box.attach(&apos;0xC707173c04105676B7AbadEA745A1cc04f3A5b3A&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; (await box.retrieve()).toString();</span><br><span class="line">&apos;70&apos;</span><br></pre></td></tr></table></figure>

<p>其中<code>Box.attach</code>函数需要填入我们上面部署好的<code>Box</code>合约地址。</p>
<h4 id="6-编写新的BoxV2合约"><a href="#6-编写新的BoxV2合约" class="headerlink" title="6. 编写新的BoxV2合约"></a>6. 编写新的<code>BoxV2</code>合约</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">solidity复制代码// SPDX-License-Identifier: MIT</span><br><span class="line">pragma solidity ^0.8.0;</span><br><span class="line"></span><br><span class="line">import &quot;@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol&quot;;</span><br><span class="line"></span><br><span class="line">contract BoxV2 is Initializable &#123;</span><br><span class="line">    uint256 private _value;</span><br><span class="line"></span><br><span class="line">    function initialize(uint256 value) public initializer &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Emitted when the stored value changes</span><br><span class="line">    event ValueChanged(uint256 value);</span><br><span class="line"></span><br><span class="line">    // Stores a new value in the contract</span><br><span class="line">    function store(uint256 value) public &#123;</span><br><span class="line">        _value = value;</span><br><span class="line">        emit ValueChanged(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Reads the last stored value</span><br><span class="line">    function retrieve() public view returns (uint256) &#123;</span><br><span class="line">        return _value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Increments the stored value by 1</span><br><span class="line">    function increment() public &#123;</span><br><span class="line">        _value = _value + 1;</span><br><span class="line">        emit ValueChanged(_value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>BoxV2</code>合约中我们新增了一个<code>increment</code>函数，用来增加<code>_value</code>的值。</p>
<h4 id="7-编写升级脚本"><a href="#7-编写升级脚本" class="headerlink" title="7. 编写升级脚本"></a>7. 编写升级脚本</h4><p><code>script/upgrade.js</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码const &#123; ethers, upgrades &#125; = require(&quot;hardhat&quot;);</span><br><span class="line"></span><br><span class="line">async function main() &#123;</span><br><span class="line">  const BoxV2 = await ethers.getContractFactory(&quot;BoxV2&quot;);</span><br><span class="line">  console.log(&quot;Upgrading Box...&quot;);</span><br><span class="line">  await upgrades.upgradeProxy(</span><br><span class="line">    &quot;0xC707173c04105676B7AbadEA745A1cc04f3A5b3A&quot;,</span><br><span class="line">    BoxV2</span><br><span class="line">  );</span><br><span class="line">  console.log(&quot;Box upgraded&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure>

<p>其中<code>upgradeProxy</code>函数需要填入我们上面部署好的<code>Box</code>合约地址，并在命令行执行下面命令来升级</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat run .\scripts\upgrade.js --network ganache</span><br></pre></td></tr></table></figure>

<p>最后在通过<code>hardhat</code>的<code>console</code>来测试发现就多了一个<code>increment</code>函数了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码npx hardhat console --network ganache</span><br><span class="line">Welcome to Node.js v12.22.1.</span><br><span class="line">Type &quot;.help&quot; for more information.</span><br><span class="line">&gt; const BoxV2 = await ethers.getContractFactory(&apos;BoxV2&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; const box = await BoxV2.attach(&apos;0xC707173c04105676B7AbadEA745A1cc04f3A5b3A&apos;);</span><br><span class="line">undefined</span><br><span class="line">&gt; await box.increment();</span><br><span class="line">...</span><br><span class="line">&gt; (await box.retrieve()).toString();</span><br><span class="line">&apos;71&apos;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>至此我们就通过<code>Hardhat</code>和<code>OpenZeppelin</code>来实现了一个生产环境可用的可升级合约，大家开发自己的可升级合约时就可以参考这个形式开发即可。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7357988193340653609" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>web3,区块链,智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Debezium在Spring应用程序中监听M</title>
    <url>/7358295139457957925.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>要在 Spring 应用程序中监听 MySQL 的 binlog（二进制日志），您可以使用开源库 Debezium。Debezium 提供了一个 Kafka Connect 插件，用于捕获 MySQL、PostgreSQL、MongoDB 等数据库的数据变更事件。</p>
<p>以下是使用 Debezium 在 Spring 应用程序中监听 MySQL binlog 的步骤：</p>
<ol>
<li>在 <code>pom.xml</code> 文件中添加 Debezium 的依赖项：</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.debezium&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;debezium-connector-mysql&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.8.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置 Debezium</li>
</ol>
<hr>
<p>在 application.yml 文件中添加以下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码debezium:</span><br><span class="line">  connector:</span><br><span class="line">    name: my-connector</span><br><span class="line">    connector.class: io.debezium.connector.mysql.MySqlConnector</span><br><span class="line">    tasks.max: 1</span><br><span class="line">    database.hostname: localhost</span><br><span class="line">    database.port: 3306</span><br><span class="line">    database.user: root</span><br><span class="line">    database.password: root</span><br><span class="line">    database.server.id: 184054</span><br><span class="line">    database.server.name: my-server</span><br><span class="line">    database.history.kafka.bootstrap.servers: localhost:9092</span><br><span class="line">    database.history.kafka.topic: dbhistory.my-server</span><br><span class="line">    database.include.list: mydatabase</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建一个配置类 <code>BinlogListenerConfiguration</code>用于设置 Debezium 的配置并启动嵌入式引擎：</li>
</ol>
<hr>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dart复制代码import io.debezium.config.Configuration;</span><br><span class="line">import io.debezium.embedded.EmbeddedEngine;</span><br><span class="line">import io.debezium.engine.ChangeEvent;</span><br><span class="line">import io.debezium.engine.DebeziumEngine;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import java.util.concurrent.Executor;</span><br><span class="line">import java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line"> public class BinlogListenerConfiguration &#123;</span><br><span class="line">        @Bean</span><br><span class="line">        public DebeziumEngine&lt;ChangeEvent&lt;Object, Object&gt;&gt; debeziumEngine() &#123;</span><br><span class="line">            // Debezium 配置</span><br><span class="line">            Configuration config = Configuration.create()</span><br><span class="line">                    .with(&quot;connector.class&quot;, &quot;io.debezium.connector.mysql.MySqlConnector&quot;)</span><br><span class="line">                    .with(&quot;offset.storage&quot;, &quot;org.apache.kafka.connect.storage.MemoryOffsetBackingStore&quot;)</span><br><span class="line">                    .with(&quot;offset.flush.interval.ms&quot;, 60000)</span><br><span class="line">                    .with(&quot;name&quot;, &quot;mysql-connector&quot;)</span><br><span class="line">                    .with(&quot;database.hostname&quot;, &quot;localhost&quot;)</span><br><span class="line">                    .with(&quot;database.port&quot;, 3306)</span><br><span class="line">                    .with(&quot;database.user&quot;, &quot;your_database_user&quot;)</span><br><span class="line">                    .with(&quot;database.password&quot;, &quot;your_database_password&quot;)</span><br><span class="line">                    .with(&quot;database.server.id&quot;, 1)</span><br><span class="line">                    .with(&quot;database.server.name&quot;, &quot;your_database_server_name&quot;)</span><br><span class="line">                    .with(&quot;database.whitelist&quot;, &quot;your_database_name&quot;)</span><br><span class="line">                    .with(&quot;database.history&quot;, &quot;io.debezium.relational.history.MemoryDatabaseHistory&quot;)</span><br><span class="line">                    .build();</span><br><span class="line">            // 创建 Debezium 引擎</span><br><span class="line">            DebeziumEngine&lt;ChangeEvent&lt;Object, Object&gt;&gt; engine = DebeziumEngine.create(ChangeEvent.class)</span><br><span class="line">                    .using(config)</span><br><span class="line">                    .notifying(record -&gt; &#123;</span><br><span class="line">                        System.out.println(&quot;Received change event: &quot; + record);</span><br><span class="line">                    &#125;).build();</span><br><span class="line">            // 使用单独的线程启动 Debezium 引擎</span><br><span class="line">            Executor executor = Executors.newSingleThreadExecutor();</span><br><span class="line">            executor.execute(engine);</span><br><span class="line">            return engine;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在这个配置类中，我们首先创建了一个 Debezium 配置对象，其中包含了连接到 MySQL 数据库所需的所有信息。然后，我们创建了一个 Debezium 引擎，该引擎在接收到 binlog 事件时调用指定的通知函数。最后，我们使用一个单独的线程启动 Debezium 引擎。</p>
<ol start="4">
<li>现在，每当数据库发生更改时，您的 Spring 应用程序都会接收到 binlog 事件。</li>
</ol>
<hr>
<p>在上面的示例中，我们只是简单地将接收到的事件打印到控制台。您可以根据需要修改通知函数以处理这些事件，例如将它们发送到消息队列、更新缓存等。</p>
<p>请注意，Debezium 仅支持 InnoDB 存储引擎。确保您的 MySQL 数据库使用 InnoDB 存储引擎。此外，确保已启用 binlog，并将 <code>binlog_format</code> 设置为 <code>ROW</code>。要了解有关 Debezium 的更多信息，如何配置过滤器等，请访问官方文档：<a href="https://debezium.io/documentation/reference/connectors/mysql.html%E3%80%82" target="_blank" rel="noopener">debezium.io/documentati…</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358295139457957925" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>MySQL,Debezium,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：循</title>
    <url>/7358302760150564876.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：循环引用与代理解决方案</strong></p>
<p>在 TypeScript 中，构建大型应用程序或框架时，可能会遇到循环引用的问题。循环引用通常发生在两个或多个模块或类相互依赖，形成一个闭环的情况。这可能导致代码难以维护，甚至在某些情况下引发运行时错误。本文将解释什么是循环引用，并通过一个 <code>UserService</code> 和 <code>OrderService</code> 的例子来说明问题，然后展示如何通过代理（Proxy）和接口（Interface）来解决循环引用。</p>
<p><strong>什么是循环引用？</strong></p>
<p>循环引用是指两个或多个对象或模块相互引用对方，形成一个闭环。在 TypeScript 中，当两个类相互导入对方时，就可能发生循环引用。例如，类 A 依赖于类 B 的实例，而类 B 又依赖于类 A 的实例，这就形成了一个循环引用。</p>
<p><strong>UserService 和 OrderService 循环引用示例</strong></p>
<p>考虑一个简单的电商应用，其中 <code>UserService</code> 负责处理用户相关的操作，<code>OrderService</code> 负责处理订单相关的操作。这两个服务在逻辑上可能需要互相调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// user-service.ts</span><br><span class="line">import &#123; OrderService &#125; from &apos;./order-service&apos;;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">  constructor(private orderService: OrderService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // ... UserService 的其他方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// order-service.ts</span><br><span class="line">import &#123; UserService &#125; from &apos;./user-service&apos;;</span><br><span class="line"></span><br><span class="line">export class OrderService &#123;</span><br><span class="line">  constructor(private userService: UserService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  // ... OrderService 的其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，<code>UserService</code> 和 <code>OrderService</code> 都通过构造函数注入的方式依赖于对方，这直接导致了循环引用。当 TypeScript 编译器尝试编译这些文件时，会抛出一个错误，因为两个类都相互依赖，导致无法解析依赖关系。</p>
<p><strong>使用 TypeScript 的 Proxy 解决循环引用</strong></p>
<p>在 TypeScript 中，你可以使用 ES6 的 <code>Proxy</code> 对象来动态地处理对象，包括解决循环引用问题。虽然 <code>Proxy</code> 本身不直接解决循环引用的问题，但你可以用它来实现一种延迟初始化或懒加载的策略，避免在初始化时直接创建循环依赖。</p>
<p>为了解决这个问题，我们可以对 <code>UserService</code> 和 <code>OrderService</code> 的构造函数进行重构，使其接受工厂函数而不是直接实例，这样我们就可以延迟创建实例，直到真正需要的时候。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// user-service.ts</span><br><span class="line">import &#123; IOrderService &#125; from &apos;./IOrderService&apos;;</span><br><span class="line"></span><br><span class="line">export class UserService &#123;</span><br><span class="line">  private orderService: IOrderService;</span><br><span class="line"></span><br><span class="line">  constructor(getOrderService: () =&gt; IOrderService) &#123;</span><br><span class="line">    this.orderService = getOrderService();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ... UserService 的其他方法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// order-service.ts</span><br><span class="line">import &#123; IUserService &#125; from &apos;./IUserService&apos;;</span><br><span class="line"></span><br><span class="line">export class OrderService &#123;</span><br><span class="line">  private userService: IUserService;</span><br><span class="line"></span><br><span class="line">  constructor(getUserService: () =&gt; IUserService) &#123;</span><br><span class="line">    this.userService = getUserService();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // ... OrderService 的其他方法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们定义接口，并使用 <code>Proxy</code> 来实现延迟初始化的逻辑。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// IUserService.ts</span><br><span class="line">export interface IUserService &#123;</span><br><span class="line">  // ... UserService 的方法声明</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IOrderService.ts</span><br><span class="line">export interface IOrderService &#123;</span><br><span class="line">  // ... OrderService 的方法声明</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// index.ts 或者你的应用启动文件</span><br><span class="line">import &#123; UserService &#125; from &apos;./user-service&apos;;</span><br><span class="line">import &#123; OrderService &#125; from &apos;./order-service&apos;;</span><br><span class="line">import &#123; IUserService &#125; from &apos;./IUserService&apos;;</span><br><span class="line">import &#123; IOrderService &#125; from &apos;./IOrderService&apos;;</span><br><span class="line"></span><br><span class="line">const getUserService = () =&gt; &#123;</span><br><span class="line">  return new UserService(getOrderService);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const getOrderService = () =&gt; &#123;</span><br><span class="line">  return new OrderService(getUserService);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userServiceProxy = new Proxy(getUserService, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    return Reflect.apply(target, thisArg, argumentsList);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const orderServiceProxy = new Proxy(getOrderService, &#123;</span><br><span class="line">  apply(target, thisArg, argumentsList) &#123;</span><br><span class="line">    return Reflect.apply(target, thisArg, argumentsList);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const userService: IUserService = userServiceProxy();</span><br><span class="line">const orderService: IOrderService = orderServiceProxy();</span><br><span class="line"></span><br><span class="line">// 现在你可以使用 userService 和 orderService，它们之间不会有循环引用的问题</span><br></pre></td></tr></table></figure>

<p>在这个解决方案中，<code>getUserService</code> 和 <code>getOrderService</code> 是工厂函数，它们返回 <code>UserService</code> 和 <code>OrderService</code> 的实例。通过使用 <code>Proxy</code>，我们确保在第一次调用这些工厂函数时，它们会相互调用对方来创建实例，但不会立即形成循环引用，因为实际的创建操作被推迟到了第一次调用代理对象的 <code>apply</code> 陷阱时。</p>
<p>请注意，这种方法仍然需要小心处理，确保逻辑上 <code>UserService</code> 和 <code>OrderService</code> 的使用不会造成逻辑上的死循环。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358302760150564876" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>一个简单的用户弹窗竟然也可以这么复杂</title>
    <url>/7358306245348851738.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，我是小趴菜，最近有一个需求，就是之后有新功能上线，那么用户在登录以后需要给个弹窗，主要是为了提醒用户，平台新增了这么一个功能，当然用户弹了一次之后，后续就不用再弹了</p>
<p>当然后续有新功能上线依然是需要弹的，需求就是这样，其实也蛮简单的对不对？？？</p>
<p>接下来我们就一步一步的来设计一下，该如何实现这个功能</p>
<h2 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h2><p>做什么需求都是需要把流程搞明白的，不然后面麻烦就大了，</p>
<ul>
<li>1：用户登录，判断这个用户对应的这个新功能对应的弹窗是否有弹过</li>
<li>2：如果有弹过，就返回给前端一个状态值，就不需要弹了，比如 {“功能ID”:1,”是否弹过”:1}</li>
<li>3：如果没有弹过，那么返回前端一个{“功能ID”:1,”是否弹过”:0}</li>
<li>4：前端拿到这个json数据，判断是否弹过，然后再根据新功能的ID来弹出对应的弹框就行了</li>
</ul>
<h2 id="数据库存储方案"><a href="#数据库存储方案" class="headerlink" title="数据库存储方案"></a>数据库存储方案</h2><p>首先我们会想到，在数据库建一张新功能的表，然后再建一张用户与新功能之间的关联关系表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码新功能表：obility</span><br><span class="line">id：新功能的主键</span><br><span class="line">obility_name：新功能的名称</span><br><span class="line">obility_desc：新功能的描述</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用户与新功能的关联关系表:obility_user</span><br><span class="line">id：主键</span><br><span class="line">user_id：用户ID</span><br><span class="line">obility_id：新功能的id</span><br><span class="line">is_open：是否弹过 0:没有，1：弹过了</span><br></pre></td></tr></table></figure>

<p>那么判断的流程是这样的</p>
<ul>
<li>1：拿到这个登录的用户的user_id</li>
<li>2：去数据库查ubility_user表，找到这个用户所有的is_open=0的记录</li>
<li>3：如果查询不为空，那么这些就是这次用户需要弹的弹窗</li>
</ul>
<p>现在用户登录进来，首先拿到这个登录用户的ID，然后去obility_user表中查询出这个用户有哪些新功能的弹窗没有弹出来过</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码select * from obility_user where user_id = 1 and is_open = 0;</span><br></pre></td></tr></table></figure>

<p>我们拿到这个用户所有没有弹过的新功能，然后进行拼接一起返回给前端就行了，好了，这个功能其实到这也就实现的差不多了</p>
<p>但是这种方案会不会存在什么弊端呢？？？</p>
<h4 id="弊端一：数据量问题"><a href="#弊端一：数据量问题" class="headerlink" title="弊端一：数据量问题"></a>弊端一：数据量问题</h4><p>其实在用户量小，并且你的新功能确定不会很多的时候，这种方式确实是可以实现的，因为数据量不是很大，后续加个索引查询也没什么问题</p>
<p>如果现在你的用户量很大，比如说有1000万，这时候加一个新功能，那么你这张obility_user表就会有1000万的数据，那如果有10个新功能，那就是1亿的数据，这时候单表肯定满足不了我们的业务了，所以你会采用分表来做，这时候的就要引入分库分表的中间件了，总的来说实现太复杂了</p>
<h4 id="弊端二：数据同步问题"><a href="#弊端二：数据同步问题" class="headerlink" title="弊端二：数据同步问题"></a>弊端二：数据同步问题</h4><p>而且这种方案其实还有一个弊端，就是我们查询的时候，这个时候这个新功能与用户的关联关系记录是已经存在表内的，也就是说我们在发布一个新功能的时候就要把所有用户跟这个新功能的关联关系都要同步到obility_user这张表中，不然用户登录的时候是查不到，那么也就不会有弹窗了</p>
<p>所以你还要保证这个新功能与所有用户的关联关系记录都成功保存到obility_user这张表中，当然少量的数据丢失也没什么影响，那这时候你是不是还要再做个数据同步的功能？？</p>
<p>还有数据同步是需要时间的，如果你有几千万的数据，对吧，所有记录维护好需要10分钟时间，这时候有个用户登录进来了，但是这个新功能与这个用户的关联关系还没保存到数据库中，这时候就不会弹这个弹窗，然后这个用户发现有这个新功能就使用了，后续用户再登录的时候，这时候这个新功能与这个用户的关联关系保存到数据库了，这时候就会弹出这个弹窗，对于用户来说就有点体验不好了</p>
<h2 id="数据库存储方案-优化"><a href="#数据库存储方案-优化" class="headerlink" title="数据库存储方案-优化"></a>数据库存储方案-优化</h2><p>之前的方案中我们发现要实现起来太麻烦了，比如数据量大需要分库分表，还要做数据同步，还有数据延迟的问题</p>
<p>之前查询的是ubility_user表，然后拿到这个用户所有 is_open这个字段等于0的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码select * from obility_user where user_id = 1 and is_open = 0;</span><br></pre></td></tr></table></figure>

<p>这时候我们换种查询流程</p>
<ul>
<li>1：获取登录用户的user_id</li>
<li>2：还是去查ubility_user这张表，查询出这个用户与哪些新功能已经存在关联记录了</li>
<li>3：与ubility表做对比，判断这个用户还有哪些新功能不存在这个关联记录的</li>
<li>4：那么不存在关联记录的这些新功能就是这次用户要弹的弹窗了</li>
<li>5：用户弹窗之后，在ubility_user表插入这几条关联关系的记录</li>
</ul>
<p>相比于之前的方案，这时候我们发布一个新功能就不需要提前做好用户与新功能的关联关系了，我们把这个流程放到登录的时候判断了，那么也就不会存在数据延迟的问题了</p>
<p>而且这个方案可以在一定程度上减少我们ubility_user这张表的数据量，试想一下，系统里面有100万的用户，难道这100万的用户真的都是真实用户吗？难道就没有一些所谓的僵尸用户？？？</p>
<p>其实这个所谓的僵尸用户是不会登录我们系统的，这些用户不登陆，那么ubility_user这张表就不会存他们的关联关系了</p>
<p>但是依然没有解决数据量的问题，即使除了那些僵尸用户，真实用户还是有很多，后续你的新功能多了，ubility_user这张表的数据量还是有很多，还是避免不了要分表</p>
<h2 id="使用redis来存储"><a href="#使用redis来存储" class="headerlink" title="使用redis来存储"></a>使用redis来存储</h2><p>仔细想想，其实我们只需要知道用户在登录的时候这个新功能的弹窗有没有弹出来过，无非就是弹过，没弹过两种，那么redis中的bitmap数据类型就很符合我们的业务了，我们一个新功能就建立一个新的bitmap,KEY呢就是这个新任务的ID，每个用户对应着一个bit位，如果这个用户对应的这个任务上的值是0,那么就没有弹过，弹窗之后把这个对应的用户的值改成1就可以了</p>
<p>这样后续即使有多个新任务也就是多几个bitmap而已，我们也不需要使用数据库来存储，也不用考虑后续数据量多了还要分库分表了，简单多了</p>
<p>而且即使redis有些时候丢了一点数据也无所谓，大不了就再弹一次嘛，对于用户来说其实影响也不大的</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358306245348851738" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：依</title>
    <url>/7358310951478804491.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：依赖注入</strong></p>
<p>在构建 Web 框架时，依赖注入（Dependency Injection, DI）是一个非常重要的概念。它允许我们在不改变类代码的情况下，将类的依赖从外部注入到类中，从而提高了代码的可测试性和可维护性。本文将介绍依赖注入的基本概念，并通过一个具体的例子，展示如何在 TypeScript 中实现依赖注入。</p>
<p><strong>什么是依赖注入？</strong></p>
<p>依赖注入是一种设计模式，它的核心思想是将一个对象所依赖的其他对象以参数的形式传入，而不是在对象内部通过 new 关键字来创建。这样做的好处是，可以轻松地替换依赖对象，使得代码更加灵活和可测试。</p>
<p><strong>UserController 中注入 UserService 的例子</strong></p>
<p>假设我们有一个 <code>IUserService</code> 接口和一个实现了该接口的 <code>UserService</code> 类，以及一个需要依赖 <code>UserService</code> 的 <code>UserController</code> 类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码// IUserService.ts</span><br><span class="line">interface IUserService &#123;</span><br><span class="line">  getUserById(id: number): Promise&lt;User&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserService.ts</span><br><span class="line">class UserService implements IUserService &#123;</span><br><span class="line">  async getUserById(id: number): Promise&lt;User&gt; &#123;</span><br><span class="line">    // 模拟从数据库获取用户信息的操作</span><br><span class="line">    return &#123; id, name: `User $&#123;id&#125;` &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// IUserController.ts</span><br><span class="line">interface IUserController &#123;</span><br><span class="line">  getUser(id: number): Promise&lt;User&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// UserController.ts</span><br><span class="line">class UserController implements IUserController &#123;</span><br><span class="line">  constructor(private readonly userService: IUserService) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  async getUser(id: number): Promise&lt;User&gt; &#123;</span><br><span class="line">    return this.userService.getUserById(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们需要使用 IoC 容器来管理服务的注册和获取。同时，我们将使用 TypeScript 的反射 API 来动态获取 <code>UserController</code> 构造函数的参数类型，并从 IoC 容器中获取对应参数的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码// index.ts</span><br><span class="line">import &apos;reflect-metadata&apos;;</span><br><span class="line"></span><br><span class="line">function constructController&lt;T&gt;(ControllerClass: new (...args: any[]) =&gt; T, iocContainer: typeof IoCContainer): T &#123;</span><br><span class="line">  // 获取 ControllerClass 的构造函数参数类型</span><br><span class="line">  const constructorTypes = Reflect.getMetadata(&apos;design:paramtypes&apos;, ControllerClass);</span><br><span class="line"></span><br><span class="line">  // 假设服务名称与接口名相同（以 I 开头）</span><br><span class="line">  const dependencies = constructorTypes.map(type =&gt; &#123;</span><br><span class="line">    const serviceName = type.name.replace(/^I/, &apos;&apos;); // 去掉接口名前的 I</span><br><span class="line">    return iocContainer.resolve(serviceName);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 使用 Reflect.construct 创建 Controller 实例</span><br><span class="line">  return Reflect.construct(ControllerClass, dependencies) as T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Reflect.getMetadata(‘design:paramtypes’, ControllerClass) 这行代码的作用是获取 ControllerClass 构造函数的参数类型信息。这里 ‘design:paramtypes’ 是一个特殊的元数据键，它对应的是 TypeScript 编译器在编译时自动添加的关于构造函数参数类型的元数据。</p>
<p>当你使用 TypeScript 定义一个类，并且这个类的构造函数带有参数时，TypeScript 编译器会生成一些额外的元数据来记录这些参数的类型。这些元数据在编译后的 JavaScript 代码中是不可见的，但是可以通过反射 API 在运行时访问。</p>
<p>通过 Reflect.getMetadata(‘design:paramtypes’, ControllerClass)，你可以得到一个数组，数组中的每个元素代表 ControllerClass 构造函数的一个参数的类型。这些类型通常是构造函数的函数对象本身（对于类类型），而不是字符串或其他表示形式。</p>
<p>这在你想要动态创建类的实例，并且需要知道构造函数的参数类型以便正确传递依赖时特别有用。通过获取这些类型信息，你可以从 IoC 容器中查找相应的实例，并传递给构造函数。</p>
<p>需要注意的是，为了使用 Reflect.getMetadata 和相关的反射 API，你需要在项目中包含 reflect-metadata 这个库，并且需要在 TypeScript 的配置文件中（通常是 tsconfig.json）启用发射元数据（emitDecoratorMetadata 和 experimentalDecorators）的选项。</p>
<p>现在，我们需要在 IoC 容器中注册 <code>UserService</code>，并使用 <code>constructController</code> 函数来创建 <code>UserController</code> 的实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码// app.ts</span><br><span class="line">import &#123; IoCContainer &#125; from &apos;./IoCContainer&apos;;</span><br><span class="line">import &#123; IUserController, UserController &#125; from &apos;./UserController&apos;;</span><br><span class="line">import &#123; UserService &#125; from &apos;./UserService&apos;;</span><br><span class="line">import &#123; constructController &#125; from &apos;./utils&apos;;</span><br><span class="line"></span><br><span class="line">// 注册 UserService 到 IoC 容器</span><br><span class="line">IoCContainer.register(&apos;UserService&apos;, new UserService());</span><br><span class="line"></span><br><span class="line">// 创建 UserController 实例并注入 UserService</span><br><span class="line">const userController: IUserController = constructController(UserController, IoCContainer);</span><br><span class="line"></span><br><span class="line">// 现在可以使用 userController 实例进行操作了</span><br><span class="line">userController.getUser(1).then(user =&gt; &#123;</span><br><span class="line">  console.log(user);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，<code>UserController</code> 构造函数中的 <code>IUserService</code> 类型参数通过反射被获取，然后从 IoC 容器中获取了对应的 <code>UserService</code> 实例，并将其作为参数传递给 <code>Reflect.construct</code> 来创建 <code>UserController</code> 的实例。</p>
<p>通过这种方式，我们可以轻松地替换 <code>UserService</code> 的实现，只需在 IoC 容器中注册新的服务即可，而无需修改 <code>UserController</code> 的代码。这就是依赖注入带来的好处之一，它使得代码更加灵活和可维护。</p>
<p>结合文件扫描和动态导入，我们可以轻松实现自动扫描项目代码中所有的控制器文件并自动注入相关依赖项。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951478804491" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：路</title>
    <url>/7358310951478837259.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：路由映射</strong></p>
<p>在构建自己的 Web 框架时，使用装饰器来定义路由是一种非常优雅且强大的方法。通过装饰器，我们可以在控制器类上指定基础路径，并为每个方法定义具体的路由。接着，我们利用 TypeScript 的反射能力，解析这些装饰器提供的路由信息，并将其映射到 Web 服务器上。</p>
<p>在本篇文章中，我们将展示如何使用 <code>@Controller</code>、<code>@Get</code> 和 <code>@Post</code> 装饰器来定义路由，并通过反射机制将这些路由映射到 hyper-express Web 服务器上。</p>
<p><strong>一、定义装饰器</strong></p>
<p>首先，我们需要定义 <code>@Controller</code>、<code>@Get</code> 和 <code>@Post</code> 装饰器。<code>@Controller</code> 用于标记控制器类，并为其提供一个基础路径。<code>@Get</code> 和 <code>@Post</code> 分别用于标记处理 GET 和 POST 请求的方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码function Controller(basePath: string) &#123;</span><br><span class="line">  return function (target: Function) &#123;</span><br><span class="line">    Reflect.defineMetadata(&apos;basePath&apos;, basePath, target);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Get(path: string) &#123;</span><br><span class="line">  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">    const basePath = Reflect.getMetadata(&apos;basePath&apos;, target.constructor);</span><br><span class="line">    const fullPath = `$&#123;basePath&#125;$&#123;path&#125;`;</span><br><span class="line">    Reflect.defineMetadata(&apos;route:get&apos;, fullPath, target, propertyKey);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function Post(path: string) &#123;</span><br><span class="line">  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) &#123;</span><br><span class="line">    const basePath = Reflect.getMetadata(&apos;basePath&apos;, target.constructor);</span><br><span class="line">    const fullPath = `$&#123;basePath&#125;$&#123;path&#125;`;</span><br><span class="line">    Reflect.defineMetadata(&apos;route:post&apos;, fullPath, target, propertyKey);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>二、创建控制器类</strong></p>
<p>接下来，我们创建一个控制器类，并使用上面定义的装饰器来定义路由。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码@Controller(&apos;/api&apos;)</span><br><span class="line">class MyController &#123;</span><br><span class="line">  @Get(&apos;/hello&apos;)</span><br><span class="line">  public async getHello(req: any, res: any) &#123;</span><br><span class="line">    res.end(&apos;Hello from /api/hello&apos;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @Post(&apos;/submit&apos;)</span><br><span class="line">  public async postSubmit(req: any, res: any) &#123;</span><br><span class="line">    res.end(&apos;Data submitted to /api/submit&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>MyController</code> 类被 <code>@Controller</code> 装饰器标记，并指定了基础路径 <code>/api</code>。<code>getHello</code> 方法被 <code>@Get</code> 装饰器标记，并指定了路由路径 <code>/hello</code>，因此它的完整路径是 <code>/api/hello</code>。同样地，<code>postSubmit</code> 方法被 <code>@Post</code> 装饰器标记，并指定了路由路径 <code>/submit</code>，完整路径为 <code>/api/submit</code>。</p>
<p><strong>三、解析并映射路由</strong></p>
<p>现在，我们需要编写代码来解析控制器类上的路由信息，并将其映射到 hyper-express Web 服务器上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码import &#123; createServer &#125; from &apos;hyper-express&apos;;</span><br><span class="line"></span><br><span class="line">const app = createServer();</span><br><span class="line"></span><br><span class="line">function mapRoutes(controller: any) &#123;</span><br><span class="line">  const basePath = Reflect.getMetadata(&apos;basePath&apos;, controller);</span><br><span class="line"></span><br><span class="line">  const methods = Object.getOwnPropertyNames(controller.prototype).filter(methodName =&gt; methodName !== &apos;constructor&apos;);</span><br><span class="line"></span><br><span class="line">  methods.forEach(methodName =&gt; &#123;</span><br><span class="line">    const getPath = Reflect.getMetadata(&apos;route:get&apos;, controller.prototype, methodName);</span><br><span class="line">    const postPath = Reflect.getMetadata(&apos;route:post&apos;, controller.prototype, methodName);</span><br><span class="line"></span><br><span class="line">    if (getPath) &#123;</span><br><span class="line">      app.get(getPath, controller.prototype[methodName].bind(controller));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (postPath) &#123;</span><br><span class="line">      app.post(postPath, controller.prototype[methodName].bind(controller));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 假设 MyController 已经定义并可用</span><br><span class="line">mapRoutes(MyController);</span><br><span class="line"></span><br><span class="line">app.listen(3000, () =&gt; &#123;</span><br><span class="line">  console.log(&apos;Server started on port 3000&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在上面的代码中，<code>mapRoutes</code> 函数遍历控制器类原型上的所有方法，并检查是否存在 <code>@Get</code> 或 <code>@Post</code> 装饰器定义的路由路径。如果存在，则使用 <code>app.get</code> 或 <code>app.post</code> 方法将方法映射到相应的路由上。注意，我们使用 <code>bind(controller)</code> 来确保方法中的 <code>this</code> 指向控制器实例。</p>
<p><strong>四、总结</strong></p>
<p>结合前文的文件扫描和自动导入，我们可以轻松的将项目中约定或配置的路径下的控制器文件映射到 Web 服务器的路由系统，并且可以使用 IoC 容器实现依赖注入。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951478837259" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>使用TypeScript从零搭建自己的Web框架：代</title>
    <url>/7358310951478820875.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>使用 TypeScript 从零搭建自己的 Web 框架：代理（Proxy）</strong></p>
<p>在深入探索 IoC（控制反转）和依赖注入（Dependency Injection, DI）的细节之前，理解 TypeScript 的一些高级特性是非常有必要的。代理（Proxy）就是其中一个强大的工具，它允许我们创建对象的代理，并在对象被访问时定义一些自定义行为。</p>
<p><strong>TypeScript 中的代理（Proxy）</strong></p>
<p>在 TypeScript 中，<code>Proxy</code> 是一个用于创建对象代理的内置对象。代理可以拦截对目标对象的各种操作，如属性访问、赋值、枚举、函数调用等，并在这些操作发生时执行自定义逻辑。</p>
<p><strong>Proxy 的基本语法</strong></p>
<p>要使用 <code>Proxy</code>，我们需要提供两个参数给 <code>Proxy</code> 构造函数：目标对象（target）和处理器对象（handler）。处理器对象定义了一系列陷阱函数（trap functions），这些函数会在代理对象上执行相应操作时被调用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码let target = &#123;&#125;;</span><br><span class="line">let handler = &#123;</span><br><span class="line">  get(target, property, receiver) &#123;</span><br><span class="line">    console.log(`get $&#123;property&#125;`);</span><br><span class="line">    return Reflect.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let proxy = new Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">proxy.foo; // 输出: &quot;get foo&quot;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们创建了一个代理对象 <code>proxy</code>，它会在访问属性 <code>foo</code> 时输出一条日志。<code>handler</code> 对象中的 <code>get</code> 函数是一个陷阱函数，它会在 <code>proxy.foo</code> 被访问时调用。</p>
<p><strong>使用 Proxy 实现属性访问的拦截</strong></p>
<p>下面是一个更具体的例子，展示了如何使用 <code>Proxy</code> 来拦截对象的属性访问，并在访问特定属性时返回模拟数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typescript复制代码interface User &#123;</span><br><span class="line">  id: number;</span><br><span class="line">  name: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const users: User[] = []; // 假设这是从数据库获取的用户列表</span><br><span class="line"></span><br><span class="line">const userHandler = &#123;</span><br><span class="line">  get(target: any, propKey: string, receiver: any) &#123;</span><br><span class="line">    if (propKey === &apos;findById&apos;) &#123;</span><br><span class="line">      return function (id: number) &#123;</span><br><span class="line">        const user = users.find(user =&gt; user.id === id);</span><br><span class="line">        return user || null;</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return Reflect.get(...arguments);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const userProxy = new Proxy(&#123;&#125;, userHandler);</span><br><span class="line"></span><br><span class="line">// 使用代理对象上的方法查找用户</span><br><span class="line">const userById = userProxy.findById(1);</span><br><span class="line">console.log(userById); // 输出匹配 id 的用户对象或 null</span><br></pre></td></tr></table></figure>

<p>在这个例子中，我们创建了一个 <code>userHandler</code> 对象，它有一个 <code>get</code> 陷阱函数。当尝试访问 <code>userProxy.findById</code> 时，<code>get</code> 函数会返回一个函数，该函数用于在 <code>users</code> 数组中查找具有指定 <code>id</code> 的用户。注意这里并没有在代理的目标对象上定义 <code>findById</code> 方法，它完全是由 <code>get</code> 陷阱函数动态提供的。</p>
<p><strong>总结</strong></p>
<p>代理（Proxy）是 TypeScript 中一个非常强大的特性，它允许我们创建可以拦截和自定义操作的对象代理。在构建 Web 框架时，代理可以用于实现各种高级功能，如属性访问控制、方法拦截、事件监听等。了解并掌握代理的使用，对于深入探索 IoC 和依赖注入等设计模式至关重要，因为这些模式经常需要在运行时动态地改变对象的行为。通过代理，我们可以更加灵活地控制对象的行为，实现更加健壮和可扩展的 Web 框架。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951478820875" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>我用这10招，能减少了70%的BUG</title>
    <url>/7358310951479427083.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>大家好，我是苏三，又跟大家见面了。</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>对于大部分程序员来说，主要的工作时间是在开发和修复BUG。</p>
<p>有可能修改了一个BUG，会导致几个新BUG的产生，不断循环。</p>
<p>那么，有没有办法能够减少BUG，保证代码质量，提升工作效率？</p>
<p>答案是肯定的。</p>
<p>如果能做到，我们多出来的时间，多摸点鱼，做点自己喜欢的事情，不香吗？</p>
<p>这篇文章跟大家一起聊聊减少代码BUG的10个小技巧，希望对你会有所帮助。<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c01b46b10d66943cf57bd656ba404fbd73d81a853c86e0eaf83fb500bbf64e00" alt="图片"></p>
<h2 id="1-找个好用的开发工具"><a href="#1-找个好用的开发工具" class="headerlink" title="1 找个好用的开发工具"></a>1 找个好用的开发工具</h2><p>在日常工作中，找一款好用的开发工具，对于开发人员来说非常重要。</p>
<p>不光可以提升开发效率，更重要的是它可以帮助我们减少BUG。</p>
<p>有些好的开发工具，比如：<code>idea</code>中，对于包没有引入，会在相关的类上面<code>标红</code>。<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/adbe7500eb63d7e6bd3ab68cb3c6608750883d01575389701f4ec96b25645079" alt="图片"></p>
<p>并且idea还有<code>自动补全</code>的功能，可以有效减少我们在日常开发的过程中，有些单词手动输入的时候敲错的情况发生。</p>
<h2 id="2-引入Findbugs插件"><a href="#2-引入Findbugs插件" class="headerlink" title="2 引入Findbugs插件"></a>2 引入Findbugs插件</h2><p>Findbugs是一款Java静态代码分析工具，它专注于寻找真正的缺陷或者潜在的性能问题，它可以帮助java工程师提高代码质量以及排除隐含的缺陷。</p>
<p>Findbugs运用Apache BCEL 库分析类文件，而不是源代码，将字节码与一组缺陷模式进行对比以发现可能的问题。</p>
<p>可以直接在idea中安装FindBugs插件：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2728e9e35d2bb5e540d7b9394eabb9fe2b0c910370e460a8fd9042661e6bddc5" alt="图片"></p>
<p>之后可以选择分析哪些代码：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d8c9b1578734cc1308e5bcd1407337e68774e80e1d2fe486ed65a91d0112c65d" alt="图片">)分析结果：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/35ebc9f3babcd06e9cb35850783e44fb50793748c9038037f42a2093810b9712" alt="图片">)点击对应的问题项，可以找到具体的代码行，进行修复。<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/04c7eb365412f50cb34e0290a225f4c2ce8dda2dfd0cb5472c9e7d99d534c90b" alt="图片"></p>
<p>Findbugs的检测器已增至300多条，被分为不同的类型，常见的类型如下：</p>
<ul>
<li>Correctness：这种归类下的问题在某种情况下会导致bug，比如错误的强制类型转换等。</li>
<li>Bad practice：这种类别下的代码违反了公认的最佳实践标准，比如某个类实现了equals方法但未实现hashCode方法等。</li>
<li>Multithreaded correctness：关注于同步和多线程问题。</li>
<li>Performance：潜在的性能问题。</li>
<li>Security：安全相关。</li>
<li>Dodgy：Findbugs团队认为该类型下的问题代码导致bug的可能性很高。</li>
</ul>
<h2 id="3-引入CheckStyle插件"><a href="#3-引入CheckStyle插件" class="headerlink" title="3 引入CheckStyle插件"></a>3 引入CheckStyle插件</h2><p>CheckStyle作为检验代码规范的插件，除了可以使用配置默认给定的开发规范，如Sun、Google的开发规范之外，还可以使用像阿里的开发规范的插件。</p>
<p>目前国内用的比较多的是阿里的代码开发规范，我们可以直接通过idea下载插件：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fed66c89c096af199d05142d4dd5e1b307d1c9131ba9c73a0bb52bde02511d20" alt="图片"></p>
<p>如果想检测某个文件：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46b861020136458583023b72b73a5cc3ad11bf62de392eb18f34a8c0c430c8c1" alt="图片"></p>
<p>可以看到结果：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0bf9820ef1236626aae94aa33648970f3d4d34d25cdd7480448428e3fbd6bdb1" alt="图片"></p>
<p>阿里巴巴规约扫描包括：</p>
<ol>
<li>OOP规约</li>
<li>并发处理</li>
<li>控制语句</li>
<li>命名规约</li>
<li>常量定义</li>
<li>注释规范</li>
</ol>
<p>Alibaba Java Coding Guidelines 专注于Java代码规范，目的是让开发者更加方便、快速规范代码格式。</p>
<p>该插件在扫描代码后，将不符合规约的代码按 Blocker、Critical、Major 三个等级显示出来，并且大部分可以自动修复。</p>
<p>它还基于Inspection机制提供了实时检测功能，编写代码的同时也能快速发现问题。</p>
<h2 id="4-用SonarQube扫描代码"><a href="#4-用SonarQube扫描代码" class="headerlink" title="4 用SonarQube扫描代码"></a>4 用SonarQube扫描代码</h2><p>SonarQube是一种自动代码审查工具，用于检测代码中的错误，漏洞和代码格式上的问题。</p>
<p>它可以与用户现有的工作流程集成，以实现跨项目分支和提取请求的连续代码检查，同时也提供了可视化的管理页面，用于查看检测出的结果。</p>
<p>SonarQube通过配置的代码分析规则，从可靠性、安全性、可维护性、覆盖率、重复率等方面分析项目，风险等级从A~E划分为5个等级；</p>
<p>同时，SonarQube可以集成pmd、findbugs、checkstyle等插件来扩展使用其他规则来检验代码质量。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0dcdf32d2bf5c87e40f440139aff51cc669177bc087c858d32ae3dcc65594caa" alt="图片"></p>
<p>一般推荐它跟Jenkins集成，做成每天定时扫描项目中test分支中的代码问题。</p>
<h2 id="5-用Fortify扫描代码"><a href="#5-用Fortify扫描代码" class="headerlink" title="5 用Fortify扫描代码"></a>5 用Fortify扫描代码</h2><p>Fortify 是一款广泛使用的静态应用程序安全测试（SAST）工具。</p>
<p>它具有代码扫描、漏斗扫描和渗透测试等功能。它的设计目的是有效地检测和定位源代码中的漏洞。</p>
<p>它能帮助开发人员识别和修复代码中的安全漏洞。</p>
<p>Fortify的主要功能：</p>
<ul>
<li>静态代码分析：它会对源代码进行静态分析，找出可能导致安全漏洞的代码片段。它能识别多种类型的安全漏洞，如 SQL 注入、跨站脚本（XSS）、缓冲区溢出等。</li>
<li>数据流分析：它不仅分析单个代码文件，还跟踪应用程序的数据流。这有助于找到更复杂的漏洞，如未经验证的用户输入在应用程序中的传播路径。</li>
<li>漏洞修复建议：发现潜在的安全漏洞时，它会为开发人员提供修复建议。</li>
<li>集成支持：它可以与多种持续集成（CI）工具（如 Jenkins）和应用生命周期管理（ALM）工具（如 Jira）集成，实现自动化的代码扫描和漏洞跟踪。</li>
<li>报告和度量：它提供了丰富的报告功能，帮助团队了解项目的安全状况和漏洞趋势。</li>
</ul>
<p>使用Fortify扫描代码的结果：<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c8ae17f422294917e93ae8a76fcbb67aecea771cfd47bd40616f34aa699408d4" alt="图片"></p>
<p>一般推荐它跟Jenkins集成，定期扫描项目中test分支中的代码安全问题。</p>
<h2 id="6-写单元测试"><a href="#6-写单元测试" class="headerlink" title="6 写单元测试"></a>6 写单元测试</h2><p>有些小伙伴可能会问：写单元测试可以减少代码的BUG？</p>
<p>答案是肯定的。</p>
<p>我之前有同事，使用的测试驱动开发模式，开发一个功能模块之前，先把单元测试写好，然后再真正的开发业务代码。</p>
<p>后面发现他写的代码速度很快，而且代码质量很高，是一个开发牛人。</p>
<p>如果你后期要做系统的代码重构，你只是重写了相关的业务代码，但业务逻辑并没有修改。</p>
<p>这时，因为有了之前写好的单位测试，你会发现测试起来非常方便。</p>
<p>可以帮你减少很多BUG。</p>
<h2 id="7-功能自测"><a href="#7-功能自测" class="headerlink" title="7 功能自测"></a>7 功能自测</h2><p>功能自测，是程序员的基本要求。</p>
<p>但有些程序员自测之后，BUG还是比较多，而有些程序员自测之后，BUG非常少，这是什么原因呢？</p>
<p>可能有些人比较粗心，有些人比较细心。</p>
<p>其实更重要的是测试的策略。</p>
<p>有些人喜欢把所有相关的功能都开发完，然后一起测试。</p>
<p>这种情况下，相当于一个黑盒测试，需要花费大量的时间，梳理业务逻辑才能测试完整，大部分情况下，开发人员是没法测试完整的，可能会有很多bug测试不出来。</p>
<p>这种做法是没有经过单元测试，直接进行了集成测试。</p>
<p>看似节省了很多单元测试的时间，但其实后面修复BUG的时间可能会花费更多。</p>
<p>比较推荐的自测方式是：一步一个脚印。</p>
<p>比如：你写了一个工具类的一个方法，就测试一下。如果这个方法中，调用了另外一个关键方法，我们可以先测试一下这个关键方法。</p>
<p>这样可以写出BUG更少的代码。</p>
<h2 id="8-自动化测试"><a href="#8-自动化测试" class="headerlink" title="8 自动化测试"></a>8 自动化测试</h2><p>有些公司引入了自动化测试的功能。</p>
<p>有专门的程序，每天都会自动测试，保证系统的核心流程没有问题。</p>
<p>因为我们的日常开发中，经常需要调整核心流程的代码。</p>
<p>不可能每调整一次，都需要把所有的核心流程都测试一遍吧，这样会浪费大量的时间，而且也容易遗漏一些细节。</p>
<p>如果引入了自动化测试的功能，可以帮助我们把核心流程都测试一下。</p>
<p>避免代码重构，或者修改核心流程，测试时间不够，或者测试不完全的尴尬。</p>
<p>自动化测试，可以有效的减少核心流程调整，或者代码重构中的BUG。</p>
<p>最近就业形式比较困难，为了感谢各位小伙伴对苏三一直以来的支持，我特地创建了一些工作内推群， 看看能不能帮助到大家。</p>
<p>你可以在群里发布招聘信息，也可以内推工作，也可以在群里投递简历找工作，也可以在群里交流面试或者工作的话题。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/baa20bdc534d592c5f317a2af5942513cbc68fb8448571247d61e01a127e5787" alt="image.png"></p>
<p><strong>进群方式</strong></p>
<p>添加苏三的<strong>私人微信</strong>：su_san_java，备注：<strong>掘金+所在城市</strong>，即可加入。</p>
<h2 id="9-代码review"><a href="#9-代码review" class="headerlink" title="9 代码review"></a>9 代码review</h2><p>很多公司都有代码review机制。</p>
<p>我之前也参与多次代码review的会议，发现代码review确实可以找出很多BUG。</p>
<p>比如：一些代码的逻辑错误，语法的问题，不规范的命名等。</p>
<p>这样问题通过组内的代码review一般可以检查出来。</p>
<p>有些国外的大厂，采用<code>结对编程</code>的模式。</p>
<p>同一个组的两个人A和B一起开发，开发完之后，A reivew B的代码，同时B review A的代码。</p>
<p>因为同组的A和B对项目比较熟，对对方开发的功能更有了解，可以快速找出对外代码中的一些问题。</p>
<p>能够有效减少一些BUG。</p>
<h2 id="10-多看别人的踩坑分享"><a href="#10-多看别人的踩坑分享" class="headerlink" title="10 多看别人的踩坑分享"></a>10 多看别人的踩坑分享</h2><p>如果你想减少日常工作中的代码BUG，或者线上事故，少犯错，少踩坑。</p>
<p>经常看别人真实的踩坑分享，是一个非常不错的选择，可以学到一些别人的工作经验，帮助你少走很多弯路。</p>
<p>网上有许多博主写过自己的踩坑记录，大家可以上网搜一下。</p>
<p>也可以看看我自己总结的《<a href="https://mp.weixin.qq.com/s?__biz=MzkwNjMwMTgzMQ==&mid=2247516100&idx=1&sn=d458cae6bded3d7c449246a7f5f0b3e3&chksm=c0e8672cf79fee3a6cfb02837172f9ed921cf0e426878b42cc669fa4cd396c644ba4dc4d44be&scene=21#wechat_redirect" target="_blank" rel="noopener">程序员最常见的100个问题</a>》，里面有非常详细的记录，干货很多，还是非常值得一看的。</p>
<p>最后说一句，本文总结了10种减少代码BUG的小技巧，但我们要根据实际情况选择使用，并非所有的场景都适合。</p>
<h3 id="最后说一句-求关注，别白嫖我"><a href="#最后说一句-求关注，别白嫖我" class="headerlink" title="最后说一句(求关注，别白嫖我)"></a>最后说一句(求关注，别白嫖我)</h3><p>如果这篇文章对您有所帮助，或者有所启发的话，帮忙扫描下发二维码关注一下，您的支持是我坚持写作最大的动力。</p>
<p>求一键三连：点赞、转发、在看。</p>
<p>关注公众号：【苏三说技术】，在公众号中回复：面试、代码神器、开发手册、时间管理有超赞的粉丝福利，另外回复：加群，可以跟很多BAT大厂的前辈交流和学习。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358310951479427083" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,程序员</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLAIchemy异步DBManager封装-03得心应</title>
    <url>/7358352353295106088.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<ol>
<li><a href="https://dev.newban.cn/7357703852726911016">SQLAIchemy 异步DBManager封装-01入门理解</a></li>
<li><a href="https://dev.newban.cn/7357957809072619554">SQLAIchemy 异步DBManager封装-02熟悉掌握</a></li>
</ol>
<p>在前两篇文章中，我们详细介绍了SQLAlchemy异步DBManager的封装过程。第一篇文章帮助我们入门理解了整体的封装结构和思路，第二篇文章则帮助我们更加熟悉和掌握了这个封装的使用。我们已经介绍了添加和查询操作，并且对整体的封装思路有了深入的了解。</p>
<p>在本文中，我将继续扩展封装，介绍如何进行更新和删除操作。同时，我将演示如何执行原生的SQL语句，并介绍在异常情况下如何进行事务回滚的场景。这些内容将帮助我们更全面地应对各种数据库操作的需求。</p>
</blockquote>
<h1 id="更新封装"><a href="#更新封装" class="headerlink" title="更新封装"></a>更新封装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码from sqlalchemy import Result, column, delete, func, select, text, update</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def update(</span><br><span class="line">        self,</span><br><span class="line">        values: dict,</span><br><span class="line">        *，</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    更新数据</span><br><span class="line">    Args:</span><br><span class="line">        values: 要更新的字段和对应的值，字典格式，例如 &#123;&quot;field1&quot;: value1, &quot;field2&quot;: value2, ...&#125;</span><br><span class="line">        orm_table: ORM表映射类</span><br><span class="line">        conds: 更新条件列表，每个条件为一个表达式，例如 [UserTable.username == &quot;hui&quot;, ...]</span><br><span class="line">        session: 数据库会话对象，如果为 None，则在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 影响的行数</span><br><span class="line">        cursor_result.rowcount</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    conds = conds or []</span><br><span class="line">    values = values or &#123;&#125;</span><br><span class="line">    if not values:</span><br><span class="line">        return</span><br><span class="line">    sql = update(orm_table).where(*conds).values(**values)</span><br><span class="line">    cursor_result = await session.execute(sql)</span><br><span class="line">    return cursor_result.rowcount</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def update_or_add(</span><br><span class="line">        self,</span><br><span class="line">        table_obj: [T_BaseOrmTable, dict],</span><br><span class="line">        *,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">        **kwargs,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    指定对象更新or添加数据</span><br><span class="line">    Args:</span><br><span class="line">        table_obj: 映射类实例对象 or dict，</span><br><span class="line">            e.g. UserTable(username=&quot;hui&quot;, age=18) or &#123;&quot;username&quot;: &quot;hui&quot;, &quot;v&quot;: 18, ...&#125;</span><br><span class="line">        orm_table: ORM表映射类</span><br><span class="line">        session: 数据库会话对象，如果为 None，则在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    if isinstance(table_obj, dict):</span><br><span class="line">        table_obj = orm_table(**table_obj)</span><br><span class="line"></span><br><span class="line">    return await session.merge(table_obj, **kwargs)</span><br></pre></td></tr></table></figure>

<ul>
<li>update 方法通过 sqlaichemy 的 update 来组织sql语句进行条件更新</li>
<li>update_or_add 则是指定对象进行更新或新增操作，有主键id则更新，没有则添加，具体是使用 <strong>session.merge</strong> 方法进行操作。入参的 table_obj 可以是库表映射类实例对象、dict，字典形式则是通过 Manager 下的orm_table 进行转换成映射类实例对象来操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class UserFileTable(BaseOrmTable):</span><br><span class="line">    &quot;&quot;&quot;用户文件表&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    __tablename__ = &quot;user_file&quot;</span><br><span class="line">    filename: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;文件名称&quot;)</span><br><span class="line">    creator: Mapped[int] = mapped_column(default=0, comment=&quot;文件创建者&quot;)</span><br><span class="line">    file_suffix: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;文件后缀&quot;)</span><br><span class="line">    file_size: Mapped[int] = mapped_column(default=0, comment=&quot;文件大小&quot;)</span><br><span class="line">    oss_key: Mapped[str] = mapped_column(String(100), default=&quot;&quot;, comment=&quot;oss key（minio）&quot;)</span><br><span class="line">    is_del: Mapped[int] = mapped_column(default=0, comment=&quot;是否删除&quot;)</span><br><span class="line">    deleted_at: Mapped[datetime] = mapped_column(nullable=True, comment=&quot;删除时间&quot;)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">class UserFileManager(DBManager):</span><br><span class="line">    orm_table = UserFileTable</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">async def update_demo():</span><br><span class="line">    ret = await UserFileManager().update(values=&#123;&quot;filename&quot;: &quot;hui&quot;&#125;, conds=[UserFileTable.id == 1])</span><br><span class="line">    print(&quot;update ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    # 添加</span><br><span class="line">    user_file_info = &#123;&quot;filename&quot;: &quot;huidbk&quot;, &quot;oss_key&quot;: uuid.uuid4().hex&#125;</span><br><span class="line">    user_file: UserFileTable = await UserFileManager().update_or_add(table_obj=user_file_info)</span><br><span class="line">    print(&quot;update_or_add add&quot;, user_file)</span><br><span class="line"></span><br><span class="line">    # 更新</span><br><span class="line">    user_file.file_suffix = &quot;png&quot;</span><br><span class="line">    user_file.file_size = 100</span><br><span class="line">    user_file.filename = &quot;hui-update_or_add&quot;</span><br><span class="line">    ret: UserFileTable = await UserFileManager().update_or_add(table_obj=user_file)</span><br><span class="line">    print(&quot;update_or_add update&quot;, ret)</span><br></pre></td></tr></table></figure>

<h1 id="删除封装"><a href="#删除封装" class="headerlink" title="删除封装"></a>删除封装</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码@with_session</span><br><span class="line">async def bulk_delete_by_ids(</span><br><span class="line">        self,</span><br><span class="line">        pk_ids: list,</span><br><span class="line">        *,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        logic_del: bool = False,</span><br><span class="line">        logic_field: str = &quot;deleted_at&quot;,</span><br><span class="line">        logic_del_set_value: Any = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据主键id批量删除</span><br><span class="line">    Args:</span><br><span class="line">        pk_ids: 主键id列表</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        logic_del: 逻辑删除，默认 False 物理删除 True 逻辑删除</span><br><span class="line">        logic_field: 逻辑删除字段 默认 deleted_at</span><br><span class="line">        logic_del_set_value: 逻辑删除字段设置的值</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 删除的记录数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    conds = [orm_table.id.in_(pk_ids)]</span><br><span class="line">    return await self.delete(</span><br><span class="line">        conds=conds,</span><br><span class="line">        orm_table=orm_table,</span><br><span class="line">        logic_del=logic_del,</span><br><span class="line">        logic_field=logic_field,</span><br><span class="line">        logic_del_set_value=logic_del_set_value,</span><br><span class="line">        session=session,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def delete_by_id(</span><br><span class="line">        self,</span><br><span class="line">        pk_id: int,</span><br><span class="line">        *,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        logic_del: bool = False,</span><br><span class="line">        logic_field: str = &quot;deleted_at&quot;,</span><br><span class="line">        logic_del_set_value: Any = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    根据主键id删除</span><br><span class="line">    Args:</span><br><span class="line">        pk_id: 主键id</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        logic_del: 逻辑删除，默认 False 物理删除 True 逻辑删除</span><br><span class="line">        logic_field: 逻辑删除字段 默认 deleted_at</span><br><span class="line">        logic_del_set_value: 逻辑删除字段设置的值</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 删除的记录数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line">    conds = [orm_table.id == pk_id]</span><br><span class="line">    return await self.delete(</span><br><span class="line">        conds=conds,</span><br><span class="line">        orm_table=orm_table,</span><br><span class="line">        logic_del=logic_del,</span><br><span class="line">        logic_field=logic_field,</span><br><span class="line">        logic_del_set_value=logic_del_set_value,</span><br><span class="line">        session=session,</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">@with_session</span><br><span class="line">async def delete(</span><br><span class="line">        self,</span><br><span class="line">        *,</span><br><span class="line">        conds: list = None,</span><br><span class="line">        orm_table: Type[BaseOrmTable] = None,</span><br><span class="line">        logic_del: bool = False,</span><br><span class="line">        logic_field: str = &quot;deleted_at&quot;,</span><br><span class="line">        logic_del_set_value: Any = None,</span><br><span class="line">        session: AsyncSession = None,</span><br><span class="line">):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    通用删除</span><br><span class="line">    Args:</span><br><span class="line">        conds: 条件列表, e.g. [UserTable.id == 1]</span><br><span class="line">        orm_table: orm表映射类</span><br><span class="line">        logic_del: 逻辑删除，默认 False 物理删除 True 逻辑删除</span><br><span class="line">        logic_field: 逻辑删除字段 默认 deleted_at</span><br><span class="line">        logic_del_set_value: 逻辑删除字段设置的值</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns: 删除的记录数</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    orm_table = orm_table or self.orm_table</span><br><span class="line"></span><br><span class="line">    if logic_del:</span><br><span class="line">        # 执行逻辑删除操作</span><br><span class="line">        logic_del_info = dict()</span><br><span class="line">        logic_del_info[logic_field] = logic_del_set_value or datetime.now()</span><br><span class="line">        delete_stmt = update(orm_table).where(*conds).values(**logic_del_info)</span><br><span class="line">    else:</span><br><span class="line">        # 执行物理删除操作</span><br><span class="line">        delete_stmt = delete(orm_table).where(*conds)</span><br><span class="line"></span><br><span class="line">    cursor_result = await session.execute(delete_stmt)</span><br><span class="line"></span><br><span class="line">    # 返回影响的记录数</span><br><span class="line">    return cursor_result.rowcount</span><br></pre></td></tr></table></figure>

<ul>
<li>通过主键ID单个删除，组织 <code>conds = [orm_table.id == pk_id]</code>，调用 delete 方法</li>
<li>通过主键ID列表批量删，组织 <code>conds = [orm_table.id.in_(pk_ids)]</code> 调用 delete 方法</li>
</ul>
<p>这两种删除操作都是通过调用 delete 方法实现的。默认情况下，这些操作执行的是物理删除。对于一些重要的数据，我们也可以选择执行逻辑删除。在逻辑删除中，默认使用 <code>deleted_at</code> 字段来记录删除时间。我们也可以指定具体的逻辑删除字段 <code>logic_field</code>，以及逻辑字段的赋值情况 <code>logic_del_set_value</code>，然后进行一个更新操作来实现逻辑删除。</p>
<p>如下是删除前的数据</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e1f9754184db11491688f69fa3c2021e6d4dbf28bd338faa0857622d00e68c4c" alt></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">async def delete_demo():</span><br><span class="line">    file_count = await UserFileManager().query_one(cols=[func.count()], flat=True)</span><br><span class="line">    print(&quot;file_count&quot;, file_count)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete_by_id(file_count)</span><br><span class="line">    print(&quot;delete_by_id ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().bulk_delete_by_ids(pk_ids=[10, 11, 12])</span><br><span class="line">    print(&quot;bulk_delete_by_ids ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete(conds=[UserFileTable.id == 13])</span><br><span class="line">    print(&quot;delete ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete(conds=[UserFileTable.id == 5], logic_del=True)</span><br><span class="line">    print(&quot;logic_del ret&quot;, ret)</span><br><span class="line"></span><br><span class="line">    ret = await UserFileManager().delete(</span><br><span class="line">        conds=[UserFileTable.id == 6], logic_del=True, logic_field=&quot;is_del&quot;, logic_del_set_value=1</span><br><span class="line">    )</span><br><span class="line">    print(&quot;logic_del set logic_field ret&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>删除结果展示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码file_count 20</span><br><span class="line">delete_by_id ret 0</span><br><span class="line">bulk_delete_by_ids ret 3</span><br><span class="line">delete ret 1</span><br><span class="line">logic_del ret 1</span><br><span class="line">logic_del set logic_field ret 1</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3968604488c7e7695d2ea2909e941a6db31a8ef07862e2157793107f37ca894a" alt></p>
<p>主键id 为5、6的被逻辑删除了，10，11，12，13 被物理删除了。</p>
<h1 id="执行原生sql"><a href="#执行原生sql" class="headerlink" title="执行原生sql"></a>执行原生sql</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码</span><br><span class="line">@with_session</span><br><span class="line">async def run_sql(</span><br><span class="line">        self, sql: str, *, params: dict = None, query_one: bool = False, session: AsyncSession = None</span><br><span class="line">) -&gt; Union[dict, List[dict]]:</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    执行并提交单条sql</span><br><span class="line">    Args:</span><br><span class="line">        sql: sql语句</span><br><span class="line">        params: sql参数, eg. &#123;&quot;:id_val&quot;: 10, &quot;:name_val&quot;: &quot;hui&quot;&#125;</span><br><span class="line">        query_one: 是否查询单条，默认False查询多条</span><br><span class="line">        session: 数据库会话对象，如果为 None，则通过装饰器在方法内部开启新的事务</span><br><span class="line"></span><br><span class="line">    Returns:</span><br><span class="line">        执行sql的结果</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    sql = text(sql)</span><br><span class="line">    cursor_result = await session.execute(sql, params)</span><br><span class="line">    if query_one:</span><br><span class="line">        return cursor_result.mappings().one() or &#123;&#125;</span><br><span class="line">    else:</span><br><span class="line">        return cursor_result.mappings().all() or []</span><br></pre></td></tr></table></figure>

<p>内部执行sql时需要通过 sqlaichemy 的 text 函数转一下，然后根据 query_one 的值来确定查询单条还是多条。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码async def run_raw_sql_demo():</span><br><span class="line">    &quot;&quot;&quot;运行原生sql demo&quot;&quot;&quot;</span><br><span class="line">    count_sql = &quot;select count(*) as total_count from user_file&quot;</span><br><span class="line">    count_ret = await UserFileManager().run_sql(count_sql, query_one=True)</span><br><span class="line">    print(&quot;count_ret&quot;, count_ret)</span><br><span class="line"></span><br><span class="line">    data_sql = &quot;select * from user_file where id &gt; :id_val and file_size &gt;= :file_size_val&quot;</span><br><span class="line">    params = &#123;&quot;id_val&quot;: 20, &quot;file_size_val&quot;: 0&#125;</span><br><span class="line">    data_ret = await UserFileManager().run_sql(data_sql, params=params)</span><br><span class="line">    print(&quot;dict data_ret&quot;, data_ret)</span><br><span class="line"></span><br><span class="line">    data_sql = &quot;select * from user_file where id &gt; :id_val&quot;</span><br><span class="line">    data_ret = await UserFileManager().run_sql(sql=data_sql, params=&#123;&quot;id_val&quot;: 4&#125;)</span><br><span class="line">    print(&quot;dict data_ret&quot;, data_ret)</span><br><span class="line"></span><br><span class="line">    # 连表查询</span><br><span class="line">    data_sql = &quot;&quot;&quot;</span><br><span class="line">        select</span><br><span class="line">            user.id as user_id,</span><br><span class="line">            username,</span><br><span class="line">            user_file.id as file_id,</span><br><span class="line">            filename,</span><br><span class="line">            oss_key</span><br><span class="line">        from </span><br><span class="line">            user_file</span><br><span class="line">            join user on user.id = user_file.creator</span><br><span class="line">        where </span><br><span class="line">            user_file.creator = :user_id</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    data_ret = await UserFileManager().run_sql(data_sql, params=&#123;&quot;user_id&quot;: 1&#125;)</span><br><span class="line">    print(&quot;join sql data_ret&quot;, data_ret)</span><br></pre></td></tr></table></figure>

<p>需要注意的执行原生sql，sql参数的展位符是 <strong>:param_name</strong> 冒号后面接参数名称，然后参数对应的值则是字典形式组织。</p>
<p>查询结果如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码count_ret &#123;&apos;total_count&apos;: 16&#125;</span><br><span class="line"></span><br><span class="line">dict data_ret [&#123;&apos;id&apos;: 62, &apos;filename&apos;: &apos;aaa&apos;, &apos;creator&apos;: 0, &apos;file_suffix&apos;: &apos;&apos;, &apos;file_size&apos;: 0, &apos;oss_key&apos;: &apos;6dd01a72599e467eb3fcdd9b47e1de9c&apos;, &apos;is_del&apos;: 0, &apos;deleted_at&apos;: None&#125;, ..]</span><br><span class="line"></span><br><span class="line">dict data_ret [&#123;&apos;id&apos;: 5, &apos;filename&apos;: &apos;eee&apos;, &apos;creator&apos;: 0, &apos;file_suffix&apos;: &apos;&apos;, &apos;file_size&apos;: 0, &apos;oss_key&apos;: &apos;6892400cc83845aca89b2ebafc675471&apos;, &apos;is_del&apos;: 0, &apos;deleted_at&apos;: datetime.datetime(2024, 4, 16, 23, 56, 49)&#125;, ...]</span><br><span class="line"></span><br><span class="line">join sql data_ret [&#123;&apos;user_id&apos;: 1, &apos;username&apos;: &apos;hui&apos;, &apos;file_id&apos;: 1, &apos;filename&apos;: &apos;hui&apos;, &apos;oss_key&apos;: &apos;bbb&apos;&#125;]</span><br></pre></td></tr></table></figure>

<h1 id="事务回滚操作"><a href="#事务回滚操作" class="headerlink" title="事务回滚操作"></a>事务回滚操作</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码async def create_and_transaction_demo():</span><br><span class="line">    async with UserFileManager.transaction() as session:</span><br><span class="line">        await UserFileManager().bulk_add(</span><br><span class="line">            table_objs=[&#123;&quot;filename&quot;: &quot;aaa&quot;, &quot;oss_key&quot;: uuid.uuid4().hex&#125;], session=session</span><br><span class="line">        )</span><br><span class="line">        user_file_obj = UserFileTable(filename=&quot;eee&quot;, oss_key=uuid.uuid4().hex)</span><br><span class="line">        file_id = await UserFileManager().add(table_obj=user_file_obj, session=session)</span><br><span class="line">        print(&quot;file_id&quot;, file_id)</span><br><span class="line"></span><br><span class="line">        ret: UserFileTable = await UserFileManager().query_by_id(2, session=session)</span><br><span class="line">        print(&quot;query_by_id&quot;, ret)</span><br><span class="line">        </span><br><span class="line">        # 异常回滚</span><br><span class="line">        a = 1 / 0</span><br><span class="line"></span><br><span class="line">        ret = await UserFileManager().query_one(</span><br><span class="line">            cols=[UserFileTable.filename, UserFileTable.oss_key],</span><br><span class="line">            conds=[UserFileTable.filename == &quot;ccc&quot;],</span><br><span class="line">            session=session</span><br><span class="line">        )</span><br><span class="line">        print(&quot;ret&quot;, ret)</span><br></pre></td></tr></table></figure>

<p>这里通过 transaction() 获取事务会话 session，让后面的数据库操作都指定 session 参数，with_session 装饰器就不会再次构造，实现了共用一个 session，事务内的操作要么都成功要么都失败。</p>
<h1 id="整体封装总结"><a href="#整体封装总结" class="headerlink" title="整体封装总结"></a>整体封装总结</h1><ul>
<li>SQLAIchemyManager 设计</li>
</ul>
<pre><code>+ 用于初始化数据库配置信息</code></pre><ul>
<li>BaseOrmTable、TimestampColumns、BaseOrmTableWithTS 设计</li>
</ul>
<pre><code>+ 通用库表映射类，一些主键id，时间戳字段让子类继承共享，以及 to\_dict 方法将对象属性转成字典</code></pre><ul>
<li>transaction 上下文管理器（事务会话）</li>
</ul>
<pre><code>+ 便捷的进行事务处理</code></pre><ul>
<li>with_session 装饰器</li>
</ul>
<pre><code>+ 复用开启事务会话 session 操作，减少冗余代码，没有 session 则动态的构造 session，兼容整体事务会话</code></pre><ul>
<li>orm_table 设计</li>
</ul>
<pre><code>+ 让继承DBManager的子类指定 orm\_table ，数据库操作时明确知道具体库表，减少参数传递</code></pre><ul>
<li>DBManager 设计</li>
</ul>
<pre><code>+ 封装了通用的CRUD方法，让子类可以共享和复用这些方法，推荐子类进行常用业务数据查询封装，实现业务逻辑的复用和灵活性。</code></pre><ul>
<li>查询扁平化 flat</li>
</ul>
<pre><code>+ 查询结果可以直接使用，不需要额外处理，简化了操作流程。</code></pre><ul>
<li>字典与库表映射类实例</li>
</ul>
<pre><code>+ 一些方法的入参，同时支持字典与库表映射类实例，提高了方法的通用性和灵活性。</code></pre><ul>
<li>分页查询</li>
</ul>
<pre><code>+ 指定页码、每页大小查询出总数与分页数据</code></pre><ul>
<li>逻辑删除</li>
</ul>
<pre><code>+ 支持默认的 `deleted_at` 字段 or 指定逻辑字段进行逻辑删除，保留重要数据</code></pre><ul>
<li>执行原生sql</li>
</ul>
<pre><code>+ 一些复杂sql操作，不使用 orm 组织，推荐使用原生 sql 进行操作</code></pre><p>到这就结束了，希望这些封装，可以满足各种复杂业务场景下的需求，提高数据库操作的灵活性和适用性，从而提高我们的开发效率。让代码变得更简单。</p>
<h1 id="Github源代码"><a href="#Github源代码" class="headerlink" title="Github源代码"></a>Github源代码</h1><p>源代码已上传到了Github，里面也有具体的使用Demo，欢迎大家一起体验、贡献。</p>
<p><a href="https://link.juejin.cn/?target=https%3A%2F%2Fgithub.com%2FHuiDBK%2Fpy-tools" target="_blank" rel="noopener">HuiDBK/py-tools: 打造 Python 开发常用的工具，让Coding变得更简单 (github.com)</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358352353295106088" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,ORM</tag>
      </tags>
  </entry>
  <entry>
    <title>9.轻松入门SuiMove:Ability</title>
    <url>/7358337136024010803.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在前面几章我们一直在说对象的ability，那什么是ability呢？ ability直译过来就是数据类型的能力。</p>
<p>Ability有四种，分别是key,store,copy,drop。基础数据类型和内建的数据类型的ability是默认的，不可修改的。他们默认有copy,drop,store这三种能力。结构体默认没有任何能力，但是我们可以自行设置结构体的能力。下面我主要讲解每种能力的含义和如何设置结构体的能力。</p>
<p>无论哪种ability，都是使用has关键字申明，具体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码//多个ability使用逗号隔开</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Key-Ability"><a href="#Key-Ability" class="headerlink" title="Key Ability"></a>Key Ability</h4><p>有些资料说拥有key ability代表能在全局存储中作为key使用，这个并不适用于Sui Move。关于key ability的作用官网如下描述：</p>
<blockquote>
<p>On Sui, the <code>key</code> ability indicates that a struct is an object type and comes with an additional requirement that the first field of the struct has signature <code>id: UID</code>, to contain the object’s unique address on-chain.</p>
</blockquote>
<p>翻译过来：**如果一个类型，带有key ability就代表他是一个对象，并且要求这个结构体的第一个字段必须是id:UID。**这个id字段包含了这个对象在区块链上的地址。</p>
<p>如果我们定义了一个结构体有key ability，但是没有id字段或者id字段没在第一位置，编译都会报错：有key ability第一字段就必须是类型为UID的id。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码 public struct Test3 has key &#123;</span><br><span class="line">     name: String     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码public struct Test3 has key &#123;</span><br><span class="line">--- The &apos;key&apos; ability is used to declare objects in Sui</span><br><span class="line">name: String     </span><br><span class="line">^^^^ Invalid object &apos;Test3&apos;. Structs with the &apos;key&apos; ability must have &apos;id: sui::object::UID&apos; as their first field</span><br></pre></td></tr></table></figure>

<p>所以<strong>key ability就是用来标识结构体是否是对象的</strong>。</p>
<h4 id="Store-Ability"><a href="#Store-Ability" class="headerlink" title="Store Ability"></a>Store Ability</h4><p>key是对象必有的能力，而store则是对象可选的能力。<strong>有以下两种情况需要指定store abiity:</strong></p>
<ul>
<li><strong>1.当一个对象需要在定义他的模块之外被转交</strong></li>
<li><strong>2.当 一个结构体需要被嵌套的时候</strong></li>
</ul>
<p>如果你想限定某一个独有对象只能在定义它的模块内transfer,就无需予对象store ability。比如以下代码中的company对象，如果在定义他的模块外调用transfer方法，或者在命令行使用sui client transfer都会报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码//没有store ability</span><br><span class="line">public struct Company  has key &#123;</span><br><span class="line">    id: UID,     </span><br><span class="line">    person: Person,</span><br><span class="line">    can_be_transfered: bool,</span><br><span class="line">&#125;</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你想限定某个对象只有满足特定条件的时候才能转交，就可以自定义transfer方法，并且限定只能在模块内transfer，这样。实现如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码const ECanNotTransfer = 1;</span><br><span class="line">//对象company没有store ability,只允许在定义对象的模块内transfer</span><br><span class="line">public struct Company  has key &#123;</span><br><span class="line">    id: UID,     </span><br><span class="line">    person: Person,</span><br><span class="line">    can_be_transfered: bool,</span><br><span class="line">&#125;</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line">//自定义transfer方法</span><br><span class="line">public fun transfer_company(company: Company, someone: address) &#123;</span><br><span class="line">    //只有can_be_transfered字段为true才可以transfer，否则退出程序</span><br><span class="line">    assert!(company.can_be_tra	nsfered, ECanNotTransfer);</span><br><span class="line">    transfer::transfer(company, someone);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Copy"><a href="#Copy" class="headerlink" title="Copy"></a>Copy</h4><p>与key ability相反，copy ability不能用于对象。copy ability 就是<strong>用于标记这个结构体是否可以被复制</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码public struct Company  has key &#123;</span><br><span class="line">    id: UID,     </span><br><span class="line">    person: Person,</span><br><span class="line">    can_be_transfered: bool,</span><br><span class="line">&#125;</span><br><span class="line">public struct Person has key,store &#123;</span><br><span class="line">    id:UID,</span><br><span class="line">    name: String,</span><br><span class="line">&#125;</span><br><span class="line">public entry fun new(ctx: &amp;mut TxContext) &#123;</span><br><span class="line">    let person = Person &#123;</span><br><span class="line">        id: object::new(ctx),</span><br><span class="line">        name: string::utf8(b&quot;hanmeimei&quot;),</span><br><span class="line">    &#125;;</span><br><span class="line">    let company = Company &#123;</span><br><span class="line">        id: object::new(ctx),</span><br><span class="line">        person: person,</span><br><span class="line">        can_be_transfered: false,</span><br><span class="line">    &#125;;</span><br><span class="line">    //使用关键词copy复制company对象</span><br><span class="line">    let _company2 = copy company;</span><br><span class="line">    transfer::transfer(company, tx_context::sender(ctx));</span><br><span class="line">    transfer::transfer(_company2, tx_context::sender(ctx))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译报错：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fd01fa0367d9eead24e9b7361839335086107f63223e361342b34fbce2d2532f" alt="copy.png"></p>
<p>那我们是不是加上copy ability就可以顺利通过编译呢？？？我们加上之后继续编译，报错如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6a73a3974d749f80ed7d16b089ce38215470c0ac15e1f45d42aadd79959aef91" alt="coyp2.png"></p>
<p><strong>如果要对一个结构体加上copy ability,那么这个结构体内所有字段都需要拥有该ability</strong>然而对象Company的id字段不具有copy ability，而这个id字段是每个对象都有的字段，所以可以得出结论：<strong>copy ability不能用于对象，只能用于非对象结构体</strong>。</p>
<p>值得注意的是在对结构体设置copy 、store 和drop能力的时候，都需要先确保结构体内所有字段包含这些能力。</p>
<h4 id="Drop"><a href="#Drop" class="headerlink" title="Drop"></a>Drop</h4><p>跟copy同理，drop ability也只能用于非对象结构体。drop表明<strong>这个结构体是否能在作用域结束的时候自动删除</strong>。如果不能自动删除则需要手动调用删除逻辑。删除结构体的方法详见：6.轻松入门Sui Move: 结构体</p>
<p>了解更多Sui Move内容：</p>
<ul>
<li>telegram: t.me/move_cn</li>
<li>QQ群: 79489587</li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358337136024010803" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>智能合约</tag>
      </tags>
  </entry>
  <entry>
    <title>webserverapachetomcat11-04-</title>
    <url>/7358354263868047386.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理这个官方翻译的系列，原因是网上大部分的 tomcat 版本比较旧，此版本为 v11 最新的版本。</p>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><blockquote>
<p>从零手写实现 tomcat <a href="https://github.com/houbb/minicat" target="_blank" rel="noopener">minicat</a> 别称【嗅虎】心有猛虎，轻嗅蔷薇。</p>
</blockquote>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-01-intro" target="_blank" rel="noopener">web server apache tomcat11-01-官方文档入门介绍</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-02-setup" target="_blank" rel="noopener">web server apache tomcat11-02-setup 启动</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-03-deploy" target="_blank" rel="noopener">web server apache tomcat11-03-deploy 如何部署</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-04-manager" target="_blank" rel="noopener">web server apache tomcat11-04-manager 如何管理？</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-06-host-manager" target="_blank" rel="noopener">web server apache tomcat11-06-Host Manager App – Text Interface</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-07-relam" target="_blank" rel="noopener">web server apache tomcat11-07-Realm Configuration</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-08-jndi" target="_blank" rel="noopener">web server apache tomcat11-08-JNDI Resources</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-09-jdbc-datasource" target="_blank" rel="noopener">web server apache tomcat11-09-JNDI Datasource</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-10-classloader-howto" target="_blank" rel="noopener">web server apache tomcat11-10-Class Loader</a></p>
<p>….</p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在许多生产环境中，具有能够部署新的 Web 应用程序或取消部署现有应用程序的能力而无需关闭和重新启动整个容器非常有用。</p>
<p>此外，您可以请求现有应用程序重新加载自身，即使您尚未在 Tomcat 服务器配置文件中声明其可重新加载。</p>
<p>为了支持这些功能，Tomcat 包括一个 Web 应用程序（默认安装在上下文路径 /manager），支持以下功能：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>从 WAR 文件的上传内容部署新的 Web 应用程序</td>
<td></td>
</tr>
<tr>
<td>从服务器文件系统上指定的上下文路径部署新的 Web 应用程序</td>
<td></td>
</tr>
<tr>
<td>列出当前部署的 Web 应用程序以及当前为这些 Web 应用程序活动的会话</td>
<td></td>
</tr>
<tr>
<td>重新加载现有的 Web 应用程序，以反映 /WEB-INF/classes 或 /WEB-INF/lib 内容的更改</td>
<td></td>
</tr>
<tr>
<td>列出操作系统和 JVM 属性值</td>
<td></td>
</tr>
<tr>
<td>列出可用的全局 JNDI 资源，供准备嵌套在 部署描述中的 元素的部署工具使用</td>
<td></td>
</tr>
<tr>
<td>启动已停止的应用程序（使其再次可用）</td>
<td></td>
</tr>
<tr>
<td>停止现有应用程序（使其不可用），但不取消部署它</td>
<td></td>
</tr>
<tr>
<td>取消部署已部署的 Web 应用程序并删除其文档基目录（除非它是从文件系统部署的）</td>
<td></td>
</tr>
</tbody></table>
<p>默认的 Tomcat 安装包括为默认虚拟主机配置的 Manager 应用程序的实例。</p>
<p>如果您创建了额外的虚拟主机，您可能希望将 Manager 应用程序的实例添加到其中一个或多个主机中。</p>
<p>要将 Manager Web 应用程序上下文的实例添加到新主机上，请在 $CATALINA_BASE/conf/[enginename]/[hostname] 文件夹中安装 manager.xml 上下文配置文件。</p>
<p>以下是一个示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;Context privileged=&quot;true&quot; antiResourceLocking=&quot;false&quot;</span><br><span class="line">         docBase=&quot;$&#123;catalina.home&#125;/webapps/manager&quot;&gt;</span><br><span class="line">  &lt;CookieProcessor className=&quot;org.apache.tomcat.util.http.Rfc6265CookieProcessor&quot;</span><br><span class="line">                   sameSiteCookies=&quot;strict&quot; /&gt;</span><br><span class="line">  &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">         allow=&quot;127\.\d+\.\d+\.\d+|::1|0:0:0:0:0:0:0:1&quot; /&gt;</span><br><span class="line">  &lt;Manager sessionAttributeValueClassNameFilter=&quot;java\.lang\.(?:Boolean|Integer|Long|Number|String)|org\.apache\.catalina\.filters\.CsrfPreventionFilter\$LruCache(?:\$1)?|java\.util\.(?:Linked)?HashMap&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<p>有三种使用 Manager Web 应用程序的方式：</p>
<ol>
<li>作为带有用户界面的应用程序，您可以在浏览器中使用。以下是一个示例 URL，您可以将 localhost 替换为您的网站主机名：<a href="http://localhost:8080/manager/html" target="_blank" rel="noopener">http://localhost:8080/manager/html</a> 。</li>
<li>仅使用 HTTP 请求的最小版本，适用于由系统管理员设置的脚本使用。命令作为请求 URI 的一部分给出，响应以易于解析和处理的简单文本形式呈现。有关更多信息，请参阅支持的 Manager 命令。</li>
<li>适用于 Ant（版本 1.4 或更高版本）构建工具的便捷任务定义集。有关更多信息，请参阅使用 Ant 执行 Manager 命令。</li>
</ol>
<h1 id="配置-Manager-应用程序访问"><a href="#配置-Manager-应用程序访问" class="headerlink" title="配置 Manager 应用程序访问"></a>配置 Manager 应用程序访问</h1><p>以下描述使用变量名 $CATALINA_BASE 来引用相对路径解析的基本目录。</p>
<p>如果您尚未通过设置 CATALINA_BASE 目录来配置 Tomcat 以用于多个实例，则 CATALINABASE将设置为CATALINA_BASE 将设置为 CATALINAB​ASE将设置为CATALINA_HOME 的值，即您安装 Tomcat 的目录。</p>
<p>使用默认设置将允许互联网上的任何人执行您服务器上的 Manager 应用程序是相当不安全的。</p>
<p>因此，Manager 应用程序附带了这样一个要求：任何试图使用它的人必须进行身份验证，使用具有其中一个 manager-xxx 角色的用户名和密码（角色名称取决于所需的功能）。</p>
<p>此外，默认用户文件（$CATALINA_BASE/conf/tomcat-users.xml）中没有分配给这些角色的用户名。</p>
<p>因此，默认情况下完全禁用了对 Manager 应用程序的访问。</p>
<p>您可以在 Manager Web 应用程序的 web.xml 文件中找到角色名称。可用的角色包括：</p>
<ul>
<li>manager-gui — 访问 HTML 界面。</li>
<li>manager-status — 仅访问 “服务器状态” 页面。</li>
<li>manager-script — 访问本文档中描述的面向工具友好的纯文本界面，以及 “服务器状态” 页面。</li>
<li>manager-jmx — 访问 JMX 代理接口和 “服务器状态” 页面。</li>
</ul>
<p>HTML 界面受到 CSRF（跨站点请求伪造）攻击的保护，但文本和 JMX 界面无法受到保护。这意味着被允许访问文本和 JMX 界面的用户在使用 Web 浏览器访问 Manager 应用程序时必须小心。为了保持 CSRF 保护：</p>
<ul>
<li>如果您使用 Web 浏览器使用具有 manager-script 或 manager-jmx 角色的用户访问 Manager 应用程序（例如用于测试纯文本或 JMX 界面），之后必须关闭所有浏览器窗口以终止会话。如果您不关闭浏览器并访问其他站点，您可能会成为 CSRF 攻击的受害者。</li>
<li>建议永远不要将 manager-script 或 manager-jmx 角色授予具有 manager-gui 角色的用户。</li>
</ul>
<p>请注意，JMX 代理接口实际上是 Tomcat 的类似低级根的管理接口。如果知道要调用的命令，可以做很多事情。启用 manager-jmx 角色时应谨慎。</p>
<p>要启用对 Manager Web 应用程序的访问，您必须创建新的用户名/密码组合并将其中一个 manager-xxx 角色与之关联，或者将 manager-xxx 角色添加到现有用户名/密码组合中。由于本文档的大部分内容都是使用文本界面，因此此示例将使用角色名称 manager-script。用户名/密码的配置方式取决于您正在使用的 Realm 实现：</p>
<ul>
<li>UserDatabaseRealm 和 MemoryUserDatabase，或 MemoryRealm — UserDatabaseRealm 和 MemoryUserDatabase 配置在默认的 CATALINABASE/conf/server.xml中。MemoryUserDatabase和MemoryRealm默认读取位于CATALINA_BASE/conf/server.xml 中。MemoryUserDatabase 和 MemoryRealm 默认读取位于 CATALINAB​ASE/conf/server.xml中。MemoryUserDatabase和MemoryRealm默认读取位于CATALINA_BASE/conf/tomcat-users.xml 的 XML 格式文件，可以使用任何文本编辑器进行编辑。</li>
</ul>
<p>此文件包含每个个人用户的 XML <code>&lt;user&gt;</code>，可能类似于以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;user username=&quot;craigmcc&quot; password=&quot;secret&quot; roles=&quot;standard,manager-script&quot; /&gt;</span><br></pre></td></tr></table></figure>

<p>它定义了此个人用于登录的用户名和密码，以及他们关联的角色名称。您可以将 manager-script 角色添加到一个或多个现有用户的逗号分隔的角色属性中，并/或创建具有分配了该角色的新用户。</p>
<ul>
<li>DataSourceRealm — 您的用户和角色信息存储在通过 JDBC 访问的数据库中。将 manager-script 角色添加到一个或多个现有用户，并/或按照您环境的标准程序创建一个或多个分配了此角色的新用户。</li>
<li>JNDIRealm — 您的用户和角色信息存储在通过 LDAP 访问的目录服务器中。将 manager-script 角色添加到一个或多个现有用户，并/或按照您环境的标准程序创建一个或多个分配了此角色的新用户。</li>
</ul>
<p>当您首次尝试发出下一节中描述的 Manager 命令之一时，将要求您使用 BASIC 身份验证登录。您输入的用户名和密码无关紧要，只要它们识别出具有 manager-script 角色的有效用户。</p>
<p>除了密码限制之外，还可以通过添加 RemoteAddrValve 或 RemoteHostValve 来限制对 Manager Web 应用程序的访问。</p>
<p>有关详细信息，请参阅阀门文档。以下是通过 IP 地址限制对 localhost 的访问的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;Context privileged=&quot;true&quot;&gt;</span><br><span class="line">         &lt;Valve className=&quot;org.apache.catalina.valves.RemoteAddrValve&quot;</span><br><span class="line">                allow=&quot;127\.0\.0\.1&quot;/&gt;</span><br><span class="line">&lt;/Context&gt;</span><br></pre></td></tr></table></figure>

<h1 id="HTML-用户友好界面"><a href="#HTML-用户友好界面" class="headerlink" title="HTML 用户友好界面"></a>HTML 用户友好界面</h1><p>Manager Web 应用程序的用户友好的 HTML 界面位于以下位置：</p>
<p><a href="http://%7Bhost%7D:%7Bport%7D/manager/html" target="_blank" rel="noopener">http://{host}:{port}/manager/html</a></p>
<p>如上所述，您需要 manager-gui 角色才能访问它。有一份单独的文档提供了有关此界面的帮助。请参阅：</p>
<p><a href="https://tomcat.apache.org/tomcat-9.0-doc/manager-howto.html#Manager_HTML_Interface" target="_blank" rel="noopener">HTML Manager documentation</a></p>
<p>HTML 界面受到 CSRF（跨站点请求伪造）攻击的保护。每次访问 HTML 页面都会生成一个随机令牌，该令牌存储在您的会话中，并包含在页面上的所有链接中。如果您的下一个操作没有正确的令牌值，则将拒绝该操作。如果令牌已过期，您可以从 Manager 的主页面或“列出应用程序”页面重新开始。</p>
<h2 id="支持的-Manager-命令"><a href="#支持的-Manager-命令" class="headerlink" title="支持的 Manager 命令"></a>支持的 Manager 命令</h2><p>Manager 应用程序知道如何处理的所有命令都在一个单独的请求 URI 中指定，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码http://&#123;host&#125;:&#123;port&#125;/manager/text/&#123;command&#125;?&#123;parameters&#125;</span><br></pre></td></tr></table></figure>

<p>其中 {host} 和 {port} 表示 Tomcat 运行的主机名和端口号，{command} 表示您希望执行的 Manager 命令，{parameters} 表示特定于该命令的查询参数。在下面的示例中，根据您的安装情况适当地自定义主机和端口。</p>
<p>这些命令通常由 HTTP GET 请求执行。/deploy 命令有一个通过 HTTP PUT 请求执行的表单。</p>
<h2 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h2><p>大多数命令接受以下一个或多个查询参数：</p>
<ul>
<li>path - 您正在处理的 Web 应用程序的上下文路径（包括前导斜杠）。要选择 ROOT Web 应用程序，请指定“/”。</li>
</ul>
<blockquote>
<p>注意：不可能对 Manager 应用程序本身执行管理命令。<br>注意：如果未显式指定路径参数，则将使用标准上下文命名规则从 config 参数或（如果未提供 config 参数）war 参数派生路径和版本。</p>
</blockquote>
<ul>
<li>version - 此 Web 应用程序的版本，由并行部署功能使用。如果您在需要路径的任何地方使用并行部署，则必须除了路径之外指定一个版本，并且组合路径和版本必须唯一，而不仅仅是路径。</li>
</ul>
<blockquote>
<p>注意：如果未显式指定路径，则忽略版本参数。</p>
</blockquote>
<ul>
<li>war - Web 应用程序存档（WAR）文件的 URL，或包含 Web 应用程序的目录的路径名，或包含 Context 配置 “.xml” 文件的路径名。您可以使用以下任何格式的 URL：<ul>
<li>file:/absolute/path/to/a/directory - 包含 Web 应用程序解压版本的目录的绝对路径。此目录将附加到您指定的上下文路径，而不进行任何更改。</li>
<li>file:/absolute/path/to/a/webapp.war - Web 应用程序存档（WAR）文件的绝对路径。这仅适用于 /deploy 命令，并且是该命令唯一可接受的格式。</li>
<li>file:/absolute/path/to/a/context.xml - 包含 Context 配置元素的 Web 应用程序上下文配置 “.xml” 文件的绝对路径。</li>
<li>directory - Host 的应用程序基目录中的 Web 应用程序上下文的目录名称。</li>
<li>webapp.war - Host 的应用程序基目录中位于的 Web 应用程序 WAR 文件的名称。</li>
</ul>
</li>
</ul>
<p>每个命令将以 text/plain 格式（即不带 HTML 标记的纯 ASCII 文本）返回响应，使人类和程序都可以轻松阅读。</p>
<p>响应的第一行将以 OK 或 FAIL 开头，指示请求的命令是否成功。在失败的情况下，第一行的其余部分将包含遇到的问题的描述。一些命令包括如下所述的其他信息行。</p>
<p>国际化说明 - Manager 应用程序在资源包中查找其消息字符串，因此可能已为您的平台翻译了这些字符串。以下示例显示了消息的英文版本。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358354263868047386" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Redis实现基本抢红包算法简介:发红包模块:抢红</title>
    <url>/7358352353294696488.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h1><p>抢红包是我们生活常用的社交功能, 这个功能最主要的特点就是用户的并发请求高, 在系统设计上, 可以使用非常多的办法来扛住用户的高并发请求, 在本文中简要介绍使用Redis缓存中间件来实现抢红包算法, Redis是一个在内存中基于 <strong>[key, value]</strong> 的缓存数据库, Redis官方性能描述非常高, 所以面对高并发场景, 使用Redis来克服高并发压力是一个不错的手段, 本文主要基于Redis来实现基本的抢红包系统设计.</p>
<h1 id="发红包模块"><a href="#发红包模块" class="headerlink" title="发红包模块:"></a>发红包模块:</h1><h2 id="1-发红包模块流程图如下"><a href="#1-发红包模块流程图如下" class="headerlink" title="1:发红包模块流程图如下:"></a>1:发红包模块流程图如下:</h2><p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d629cff36871e2227f10723ba774d76ed69d5e983fb260b9f16763a95760a4f7" alt></p>
<p>﻿﻿</p>
<p>用户首先输入红包金额和红包个数, 然后生成当前红包唯一标识, 并使用二倍均值算法生成随机金额的红包, 然后将生成的红包存入缓存Redis数据库中, Redis数据库中会保存当前剩余的红包数量和每个红包的金额, 由于Redis数据库是作为临时存储的地方, 所以发红包记录需要持久化存储在数据库中, 这里为加快系统响应, 使用异步的方式, 将红包金额纪录存储入Mysql数据库中, 以上就是发红包模块的简要系统设计.</p>
<h2 id="2-随机生成红包金额"><a href="#2-随机生成红包金额" class="headerlink" title="2:随机生成红包金额"></a>2:随机生成红包金额</h2><p>对于抢红包来说, 生成红包金额是非常关键的, 这里有许多生成随机数方法, 在本文中介绍一种使用较多的二倍均值算法来随机生成红包金额.对于抢红包来说, 如果发送一个金额为J的红包, 那么对与抢红包的N个人来说, 公平的概率是: 每个人抢到J / N 的金额的概率是相同的, 例如100元红包发给10个人，那么最公平的策略是使每个人抢到10元的概率相同, 二倍均值算法就是基于上面这个概率策略. 二倍均值算法流程如下: 首先设置红包金额为J, 抢红包人数为N, 接下来计算随机数区间上U = J / N * 2, 得到随机数区间(0,U), 从而在这个区间里生成第一个随机数金额M, 接下来继续生成第二个随机金额. 首先更新总红包金额为J-M,总抢红包人数为N-1, 然后生成第二个随机金额区间(0, (J-M) / (N-1) *2) , 从这个区间里面生成第二个随机金额M2, 继续迭代, 直到生成最后一个红包金额, 下图是二倍均值算法的流程</p>
<p>﻿</p>
<p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4785348eeeeb829574a81792fb773ccd7d8e29abeb2fff9569923fe84c9dbe10" alt></p>
<p>﻿﻿</p>
<p>二倍均值算法案例: 红包总金额100元, 总计10个人</p>
<p>计算第一个随机金额区间: 100/10X2 = 20, 第一个随机金额的区间是（0，20 )，区间均值为10</p>
<p>假设第一个人抢到10元，剩余金额是90 元</p>
<p>计算第二个随机金额区间: 90/9X2 = 20, 第一个随机金额的区间是（0，20 )，区间均值为10</p>
<p>假设第二个人抢到10元，剩余金额是80 元 计算第三个随机金额区间: 80/8X2 = 20, 第一个随机金额的区间是（0，20 )，区间均值为10</p>
<p>……………</p>
<p>所以使用二倍均值算法能够在不论谁先抢的情况下, 都能公平保证每个人抢到平均金额的概率是相等的, 二倍均值算法生成红包金额的代码如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码//这里输入的totalMoney单位是分,例如100元,totalMoney = 10000</span><br><span class="line">public List&lt;Integer&gt; getRedPackage(Integer totalMoney,Integer totalPeopleCount) &#123;</span><br><span class="line">    List&lt;Integer&gt; moneyList = new ArrayList&lt;&gt;();</span><br><span class="line">    //暂存剩余金额为红包的总金额</span><br><span class="line">    Integer restMoney = totalMoney;</span><br><span class="line">    //暂存剩余的总人数-初始化时即为指定的总人数</span><br><span class="line">    Integer restPeopleCount = totalPeopleCount;    </span><br><span class="line">    //随机数对象</span><br><span class="line">    Random random = new Random();</span><br><span class="line">    //开始循环迭代生成红包</span><br><span class="line">    for (int i =0;i&lt; totalPeopleNum-1;i++)&#123;</span><br><span class="line">       //加1是为了至少抢到1分钱</span><br><span class="line">       int money = random.nextInt (restMoney / restPeopleCount * 2) + 1;</span><br><span class="line">       restMoney -= money;</span><br><span class="line">       restPeopleCount--;</span><br><span class="line">       moneyList.add(money);</span><br><span class="line">    &#125;</span><br><span class="line">    //添加最后的一个红包金额</span><br><span class="line">    amountList.add(restAmount);</span><br><span class="line">    return amountList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-红包存储"><a href="#3-红包存储" class="headerlink" title="3: 红包存储"></a>3: 红包存储</h2><p>为了应对用户高并发的请求, 也就是需要频繁读取红包金额和数量, 所以将红包金额和数量存储在Mysql中是不行的, 所以只能借助基于内存的Redis数据库来支持高并发的读取操作.Redis中有5种基本的数据结构分别是:String, List, Set, Sorted Set, Map这五种, 红包金额数量是一个List集合, 所以使用List来存储最为合适,在发红包时, 我们先用二倍均值算法随机生成一定数量的红包金额, 然后将红包金额和红包数量存入Redis缓存中,等待用户抢红包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//随机生成全局唯一的红包id</span><br><span class="line">redId = getRedId();</span><br><span class="line">//首先生成红包金额</span><br><span class="line">List&lt;Integer&gt; moneyList = getRedPackage(totalMoney,totalPeopleCount);</span><br><span class="line">//放入redis</span><br><span class="line">redisClient.lpush(redId, moneyList);</span><br><span class="line">//redis中记录红包个数</span><br><span class="line">redisClient.set(redId, moneyList.size());</span><br><span class="line">//异步存储发红包记录到Mysql数据库</span><br><span class="line">//将红包id返回</span><br><span class="line">return redId;</span><br></pre></td></tr></table></figure>

<h1 id="抢红包模块"><a href="#抢红包模块" class="headerlink" title="抢红包模块:"></a>抢红包模块:</h1><h2 id="1-抢红包模块流程图如下"><a href="#1-抢红包模块流程图如下" class="headerlink" title="1:抢红包模块流程图如下:"></a>1:抢红包模块流程图如下:</h2><p>﻿</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/795d03677cc9554a409d9a08861330909d988b86649935a2d018d660ec7fbbb2" alt></p>
<p>﻿﻿</p>
<p>首先判断用户是否已经抢过红包了, 是否还有剩余的红包, 如果抢过或者剩余红包数量小于等于0, 则代表红包已经被抢完了, 直接结束用户本次抢红包流程. 如果还有剩余的红包数量, 则从Redis缓存列表中弹出一个红包金额, 然后将剩余红包数量减1, 同时异步将用户抢红包记录存入Mysql数据库, 最后将抢到的红包金额返回给用户, 结束本次抢红包流程</p>
<h2 id="2-首先判断是否已经抢过红包"><a href="#2-首先判断是否已经抢过红包" class="headerlink" title="2:首先判断是否已经抢过红包"></a>2:首先判断是否已经抢过红包</h2><p>通过在Redis中以用户ID构建一个唯一Key来判断是否抢过红包, Key的构建规则是:业务前缀+红包id+用户id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码redMoney = redisClient.get(&quot;rob&quot; + redId + useId)</span><br><span class="line">//如果不为空,则说明已经抢过了,直接返回抢过的红包金额</span><br><span class="line">if (redMoney != null) &#123;</span><br><span class="line">    return redMoney</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-判断是否还有红包"><a href="#3-判断是否还有红包" class="headerlink" title="3:判断是否还有红包"></a>3:判断是否还有红包</h2><p>通过在Redis中以红包id记录一个数量来判断是否还有红包, key的构建规则是:业务前缀+红包id</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码totalNum = redisClient.get(&quot;totalNum&quot; + redId)</span><br><span class="line">//如果为空或者小于等于0则代表没有了</span><br><span class="line">if (totalNum == null || totalNum &lt;= 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-弹出一个红包金额"><a href="#4-弹出一个红包金额" class="headerlink" title="4:弹出一个红包金额"></a>4:弹出一个红包金额</h2><p>因为我们是把红包金额存储到Redis的List列表中的, 所以直接使用列表的Pop操作就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    ....</span><br><span class="line">    红包个数减1</span><br><span class="line">    存储抢红包记录</span><br><span class="line">    设置该用户已经抢过红包</span><br><span class="line">    ....</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="5-减少红包个数"><a href="#5-减少红包个数" class="headerlink" title="5:减少红包个数"></a>5:减少红包个数</h2><p>红包总数是以一个[key, value] 键值对存储在Redis中的, 所以这里使用Redis的DECR命令就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    ....</span><br><span class="line">    存储抢红包记录</span><br><span class="line">    设置该用户已经抢过红包</span><br><span class="line">    ....</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="6-异步记录抢红包记录"><a href="#6-异步记录抢红包记录" class="headerlink" title="6:异步记录抢红包记录"></a>6:异步记录抢红包记录</h2><p>采用异步的方式将记录存入Mysql数据库, 异步的方式可以采用<strong>消息队列或者多线程</strong>的方式来实现</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    //异步存储抢红包记录</span><br><span class="line">    这里可以使用mq或者多线程的方式来实现</span><br><span class="line">    ....</span><br><span class="line">    设置该用户已经抢过红包</span><br><span class="line">    ....</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="7-设置该用户已经抢过红包"><a href="#7-设置该用户已经抢过红包" class="headerlink" title="7:设置该用户已经抢过红包"></a>7:设置该用户已经抢过红包</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    //异步存储抢红包记录</span><br><span class="line">    这里可以使用mq或者多线程的方式来实现</span><br><span class="line">    //设置该用户已经抢过红包</span><br><span class="line">    redisClient.set(&quot;rob&quot; + redId + useId, money)</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="8-整体的伪代码逻辑如下"><a href="#8-整体的伪代码逻辑如下" class="headerlink" title="8: 整体的伪代码逻辑如下:"></a>8: 整体的伪代码逻辑如下:</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码redMoney = redisClient.get(&quot;rob&quot; + redId + useId)</span><br><span class="line">//如果不为空,则说明已经抢过了,直接返回抢过的红包金额</span><br><span class="line">if (redMoney != null) &#123;</span><br><span class="line">    return redMoney</span><br><span class="line">&#125;</span><br><span class="line">totalNum = redisClient.get(&quot;totalNum&quot; + redId)</span><br><span class="line">//如果红包总数小于0, 则代表已经抢完了, 直接返回空</span><br><span class="line">if (totalNum == null || totalNum &lt;= 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line">money = redisClient.rpop(redId)</span><br><span class="line">//如果不为空,则说明抢到了</span><br><span class="line">if (money != null) &#123;</span><br><span class="line">    //红包个数减1</span><br><span class="line">    redisClient.decr(redId)</span><br><span class="line">    //异步存储抢红包记录</span><br><span class="line">    这里可以使用mq或者多线程的方式来实现</span><br><span class="line">    //设置该用户已经抢过红包</span><br><span class="line">    redisClient.set(&quot;rob&quot; + redId + useId, money)</span><br><span class="line">    //返回抢到的金额</span><br><span class="line">    return money</span><br><span class="line">&#125; </span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h2 id="9-分布式锁"><a href="#9-分布式锁" class="headerlink" title="9:分布式锁"></a>9:分布式锁</h2><p>这里涉及到了同一个用户多次高并发来抢红包的情况, 并且代码逻辑中包含了下面这种逻辑: <strong>判断条件成立然后进行业务操作,最后设置条件.</strong> 这种业务逻辑如果不防止并发的话, 就会产生重复操作, 所以需要使用锁来限制每一个用的访问频率, 加锁的方式是使用分布式锁, 这是因为我们抢红包服务不可能只在一台服务器上部署, 同时基于Redis也能很容易的实现分布式锁, 使用Redis命令setNx命令就可以实现简单分布式锁</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码redMoney = redisClient.get(&quot;rob&quot; + redId + useId)</span><br><span class="line">//如果不为空,则说明已经抢过了,直接返回抢过的红包金额</span><br><span class="line">if (redMoney != null) &#123;</span><br><span class="line">    return redMoney</span><br><span class="line">&#125;</span><br><span class="line">totalNum = redisClient.get(&quot;totalNum&quot; + redId)</span><br><span class="line">//如果红包总数小于0, 则代表已经抢完了, 直接返回空</span><br><span class="line">if (totalNum == null || totalNum &lt;= 0) &#123;</span><br><span class="line">    return null</span><br><span class="line">&#125;</span><br><span class="line">//加分布式锁</span><br><span class="line">lockResut = redisClient.setNx(useId,redId,timeOut);</span><br><span class="line">//加锁失败,直接返回</span><br><span class="line">if(!lockResult)&#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">try&#123;</span><br><span class="line">    money = redisClient.rpop(redId)</span><br><span class="line">    //如果不为空,则说明抢到了</span><br><span class="line">    if (money != null) &#123;</span><br><span class="line">        //红包个数减1</span><br><span class="line">        redisClient.decr(redId)</span><br><span class="line">        //异步存储抢红包记录</span><br><span class="line">        这里可以使用mq或者多线程的方式来实现</span><br><span class="line">        //设置该用户已经抢过红包</span><br><span class="line">        redisClient.set(&quot;rob&quot; + redId + useId, money)</span><br><span class="line">        //返回抢到的金额</span><br><span class="line">        return money</span><br><span class="line">    &#125;     </span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    //删除锁</span><br><span class="line">    redisClient.del(useId)</span><br><span class="line">&#125;</span><br><span class="line">//没抢到</span><br><span class="line">return null</span><br></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>以上就是完整的抢红包伪代码流程, 可以基本实现发红包以及抢红包功能, 该方法基于Redis来实现红包的存储和抢红包的操作, 基于二倍均值算法来实现红包金额的随即生成, 在整体功能上还有很多不完善的地方, 可以基于整体框架进行扩展开发, 实现更加完整的算法</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358352353294696488" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>图像分割之边缘分割法、区域分割法和形态学分割法原理及优缺点并</title>
    <url>/7358361832460337189.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图像分割是将图像划分为多个区域或对象的过程，以便于进一步分析、处理或理解。以下是三种常见的图像分割算法：</p>
<h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><h3 id="1-边缘分割法-Edge-based-Segmentation"><a href="#1-边缘分割法-Edge-based-Segmentation" class="headerlink" title="1. 边缘分割法 (Edge-based Segmentation)"></a>1. 边缘分割法 (Edge-based Segmentation)</h3><p>原理：边缘分割法依赖于图像中像素强度的突变来检测边缘。这种方法通常使用边缘检测算子（如Sobel、Canny、Prewitt、Roberts等）来计算图像中每个像素点的梯度值。梯度值高的地方通常对应于边缘。通过跟踪这些高梯度值，可以确定图像中对象的轮廓。<br>优点：</p>
<ul>
<li>能够识别出对象的精确边缘。</li>
<li>对于具有清晰边界的图像效果较好。</li>
<li>算法相对简单，计算速度较快。<br>缺点：</li>
<li>对噪声敏感，噪声可能被误检为边缘。</li>
<li>对噪声敏感，噪声可能被误检为边缘。</li>
<li>难以处理边缘不连续或边缘模糊的图像。</li>
<li>需要后续处理步骤来连接断裂的边缘。</li>
</ul>
<h3 id="2-区域分割法-Region-based-Segmentation"><a href="#2-区域分割法-Region-based-Segmentation" class="headerlink" title="2. 区域分割法 (Region-based Segmentation)"></a>2. 区域分割法 (Region-based Segmentation)</h3><p>原理：区域分割法基于图像中像素之间的相似性来进行分割。这种方法包括区域生长、区域合并和区域分裂等技术。区域生长是从一个或多个种子像素开始，逐步将相邻的像素添加到生长的区域中，直到满足某些相似性准则。区域合并和分裂则是通过合并或分裂现有区域来达到更好的分割效果。<br>优点：</p>
<ul>
<li>能够处理边缘不清晰的图像。</li>
<li>适合处理边缘信息不足或不完整的情况。</li>
<li>分割结果通常是连续的区域。<br>缺点：</li>
<li>计算成本较高，尤其是对于大图像。</li>
<li>选择合适的种子点和相似性准则可能比较困难。</li>
<li>分割结果可能受初始种子选择的影响。</li>
</ul>
<h3 id="3-形态学分割法-Morphological-Segmentation"><a href="#3-形态学分割法-Morphological-Segmentation" class="headerlink" title="3. 形态学分割法 (Morphological Segmentation)"></a>3. 形态学分割法 (Morphological Segmentation)</h3><p>原理：形态学分割法基于数学形态学，一个涉及结构元素对图像进行膨胀、腐蚀、开运算和闭运算等操作的理论。通过这些操作，可以强化或减弱图像中的特定结构，从而实现分割。例如，通过闭运算可以填充小的空洞，而通过开运算可以消除小的物体。<br>优点：</p>
<ul>
<li>能够在保持图像拓扑结构的同时去除噪声。</li>
<li>适用于形状分析和提取图像结构特征。</li>
<li>可以处理复杂的图像，如文本或生物医学图像。<br>缺点：</li>
<li>需要选择合适的结构元素和操作序列。</li>
<li>对于不规则或大小多变的对象，分割效果可能不理想。</li>
<li>可能需要结合其他分割技术来达到最佳效果。</li>
</ul>
<p>每种分割方法都有其适用的场景和限制，实际应用中可能需要根据图像的特点和分割目标来选择合适的方法，或者结合多种方法来提高分割的准确性和鲁棒性。</p>
<h2 id="源码："><a href="#源码：" class="headerlink" title="源码："></a>源码：</h2><p>实现图像分割算法通常涉及图像处理库，Java中常用的图像处理库有Java Advanced Imaging (JAI)、ImageJ等。由于实现图像分割算法需要复杂的操作和较长的代码，这里我将提供一个简化版本的边缘检测算法的示例，使用Java的基本图像处理能力，对于区域分割法和形态学分割法。<br>这种使用 ；Sobel算子</p>
<p>Sobel算子是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导的概念。Sobel算子主要用于图像处理领域，尤其是在边缘检测中，以突出图像中亮度变化剧烈的区域。</p>
<h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><p>Sobel算子通过计算图像亮度的一阶空间导数来找出边缘位置。具体来说，它使用两个3x3的卷积核（也称作滤波器或模板）来分别计算水平和垂直方向上的梯度：</p>
<ul>
<li>水平方向的Sobel卷积核（Gx）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码[ -1  0  1 ]</span><br><span class="line">[ -2  0  2 ]</span><br><span class="line">[ -1  0  1 ]</span><br></pre></td></tr></table></figure>

<ul>
<li>垂直方向的Sobel卷积核（Gy）：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码[ -1 -2 -1 ]</span><br><span class="line">[  0  0  0 ]</span><br><span class="line">[  1  2  1 ]</span><br></pre></td></tr></table></figure>

<p>这两个卷积核分别应用于图像的每个像素，通过与周围的像素值进行加权求和，计算出水平方向（Gx）和垂直方向（Gy）的梯度。然后，这两个梯度可以组合起来计算出每个像素点的边缘强度（梯度幅值）和方向：</p>
<ul>
<li>梯度幅值：<code>G = sqrt(Gx^2 + Gy^2)</code></li>
<li>梯度方向：<code>θ = atan2(Gy, Gx)</code></li>
</ul>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ol>
<li>相对简单：Sobel算子的实现简单，计算速度快。</li>
<li>同时考虑方向：Sobel算子能够检测水平和垂直方向的边缘。</li>
<li>抗噪声能力：由于卷积核的设计，Sobel算子在计算梯度前有一定的平滑效果，这使其对噪声有一定的抵抗能力。</li>
</ol>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>对噪声敏感：尽管有抗噪声能力，但在噪声较大的图像中，Sobel算子仍然可能产生错误的边缘。</li>
<li>边缘粗细：Sobel算子可能会产生较粗的边缘，不适合精确边缘定位。</li>
<li>边缘断裂：在边缘强度变化不连续的地方，Sobel算子可能会导致边缘断裂。</li>
<li>角点响应：Sobel算子对角点的响应不如一些其他算子（如Harris角点检测器）。</li>
</ol>
<p>在实际应用中，Sobel算子常常作为边缘检测的初步步骤，用于快速识别图像中的潜在边缘区域。针对其缺点，可以通过后续的图像处理步骤进行优化，比如使用非极大值抑制（Non-Maximum Suppression）来细化边缘，或者应用阈值方法来减少噪声影响。</p>
<p>以下是一个简单的边缘检测算法（Sobel算子）的Java实现示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码import java.awt.image.BufferedImage;</span><br><span class="line">import java.io.File;</span><br><span class="line">import javax.imageio.ImageIO;</span><br><span class="line">/**</span><br><span class="line"> * @author Derek-samrt</span><br><span class="line"> */</span><br><span class="line">public class EdgeDetection &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        // 加载图像</span><br><span class="line">        File file = new File(&quot;C:\\my\\1712392252385.jpg&quot;);</span><br><span class="line">        BufferedImage image = ImageIO.read(file);</span><br><span class="line"></span><br><span class="line">        // 灰度化</span><br><span class="line">        BufferedImage grayImage = toGray(image);</span><br><span class="line">        // Sobel边缘检测</span><br><span class="line">        BufferedImage edgeImage = sobelEdgeDetection(grayImage);</span><br><span class="line"></span><br><span class="line">        // 保存结果</span><br><span class="line">        File outputFile = new File(&quot;C:\\my\\test.jpg&quot;);</span><br><span class="line">        ImageIO.write(edgeImage, &quot;jpg&quot;, outputFile);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BufferedImage toGray(BufferedImage image) &#123;</span><br><span class="line">        BufferedImage grayImage = new BufferedImage(</span><br><span class="line">                image.getWidth(), image.getHeight(), BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; image.getWidth(); i++) &#123;</span><br><span class="line">            for (int j = 0; j &lt; image.getHeight(); j++) &#123;</span><br><span class="line">                int rgb = image.getRGB(i, j);</span><br><span class="line">                int r = (rgb &gt;&gt; 16) &amp; 0xFF;</span><br><span class="line">                int g = (rgb &gt;&gt; 8) &amp; 0xFF;</span><br><span class="line">                int b = rgb &amp; 0xFF;</span><br><span class="line">                int gray = (int) (0.2126 * r + 0.7152 * g + 0.0722 * b);</span><br><span class="line">                int newPixel = gray | (gray &lt;&lt; 8) | (gray &lt;&lt; 16);</span><br><span class="line">                grayImage.setRGB(i, j, newPixel);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return grayImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static BufferedImage sobelEdgeDetection(BufferedImage image) &#123;</span><br><span class="line">        int x = image.getWidth();</span><br><span class="line">        int y = image.getHeight();</span><br><span class="line">        BufferedImage edgeImage = new BufferedImage(x, y, BufferedImage.TYPE_BYTE_GRAY);</span><br><span class="line"></span><br><span class="line">        int[][] edgeColors = new int[x][y];</span><br><span class="line">        int maxGradient = -1;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; x - 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; y - 1; j++) &#123;</span><br><span class="line">                int val00 = getGrayScale(image.getRGB(i - 1, j - 1));</span><br><span class="line">                int val01 = getGrayScale(image.getRGB(i - 1, j));</span><br><span class="line">                int val02 = getGrayScale(image.getRGB(i - 1, j + 1));</span><br><span class="line"></span><br><span class="line">                int val10 = getGrayScale(image.getRGB(i, j - 1));</span><br><span class="line">                int val11 = getGrayScale(image.getRGB(i, j));</span><br><span class="line">                int val12 = getGrayScale(image.getRGB(i, j + 1));</span><br><span class="line"></span><br><span class="line">                int val20 = getGrayScale(image.getRGB(i + 1, j - 1));</span><br><span class="line">                int val21 = getGrayScale(image.getRGB(i + 1, j));</span><br><span class="line">                int val22 = getGrayScale(image.getRGB(i + 1, j + 1));</span><br><span class="line"></span><br><span class="line">                int gx = ((-1 * val00) + (0 * val01) + (1 * val02))</span><br><span class="line">                        + ((-2 * val10) + (0 * val11) + (2 * val12))</span><br><span class="line">                        + ((-1 * val20) + (0 * val21) + (1 * val22));</span><br><span class="line"></span><br><span class="line">                int gy = ((-1 * val00) + (-2 * val01) + (-1 * val02))</span><br><span class="line">                        + ((0 * val10) + (0 * val11) + (0 * val12))</span><br><span class="line">                        + ((1 * val20) + (2 * val21) + (1 * val22));</span><br><span class="line"></span><br><span class="line">                double gval = Math.sqrt((gx * gx) + (gy * gy));</span><br><span class="line">                int g = (int) gval;</span><br><span class="line"></span><br><span class="line">                if(maxGradient &lt; g) &#123;</span><br><span class="line">                    maxGradient = g;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                edgeColors[i][j] = g;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        double scale = 255.0 / maxGradient;</span><br><span class="line"></span><br><span class="line">        for (int i = 1; i &lt; x - 1; i++) &#123;</span><br><span class="line">            for (int j = 1; j &lt; y - 1; j++) &#123;</span><br><span class="line">                int edgeColor = edgeColors[i][j];</span><br><span class="line">                edgeColor = (int)(edgeColor * scale);</span><br><span class="line">                edgeColor = 0xff000000 | (edgeColor &lt;&lt; 16) | (edgeColor &lt;&lt; 8) | edgeColor;</span><br><span class="line"></span><br><span class="line">                edgeImage.setRGB(i, j, edgeColor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return edgeImage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int getGrayScale(int rgb) &#123;</span><br><span class="line">        int r = (rgb &gt;&gt; 16) &amp; 0xff;</span><br><span class="line">        int g = (rgb &gt;&gt; 8) &amp; 0xff;</span><br><span class="line">        int b = rgb &amp; 0xff;</span><br><span class="line"></span><br><span class="line">        // from https://en.wikipedia.org/wiki/Grayscale, calculating luminance</span><br><span class="line">        int gray = (int)(0.2126 * r + 0.7152 * g + 0.0722 * b);</span><br><span class="line">        // or use a simple average</span><br><span class="line">        // int gray = (r + g + b) / 3;</span><br><span class="line"></span><br><span class="line">        return gray;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果：<br>经典图分割：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bcf83dbe6ed450e50b878b9bafb97a105f7aad99e0354b34a2f5ec404e606f88" alt="1713235709319.png"></p>
<p>风景图分割：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/63fb7bdb54fe88381bdc8e052ba678a5871bf4154f645de0f7ef61a00779eaf4" alt="d93008b1e74f7d11cf261eadda3885a.png"></p>
<p>汽车图分割：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8092184d600010010edd9763ff2c643b13f7571d6a23e1fed23f096500601308" alt="1713316411310.png"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358361832460337189" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>算法,Java,图像识别</tag>
      </tags>
  </entry>
  <entry>
    <title>编程之路：从零到百度，探索有表现力的代码之嘎嘎嘎~</title>
    <url>/7358355063922982963.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>现在有一个国王，想要组成一个由1000鸭子组成的合唱团，要求鸭子能够嘎嘎嘎的叫，但是最后只找有999只鸭子，该怎么办？请用代码实现。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a4ad9daed46733095bbd5b726c168cbd2326aeab6c0a3fde9d8c4ee49a6f9ebb" alt="image.png"><br>分析<br>–</p>
<ol>
<li>组成合唱团，则需要定义一个choir数组对象，来存放1000只鸭子；</li>
<li>定义一个鸭子duck对象，对象用对象字面量来表达；</li>
<li>鸭子能够嘎嘎嘎的叫，那么就需要定义一个方法sing；</li>
<li>要筛选能够嘎嘎嘎的叫的鸭子，那么就需要定义一个方法joinChoir来筛选鸭子；</li>
<li>通过for循环来实现999只鸭子加入choir；</li>
<li>只有999只鸭子，但是要求1000只鸭子，那么这个时候定义一个chicken对象，并定义一个方法sing，再加入choir；</li>
<li>合唱团组成，可以嘎嘎嘎嘎嘎嘎了。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/52df3ef8770ca8be65756c484f71ba0b4c42a788729827ddaf1042f893650b97" alt="image.png"><br>代码<br>–</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;script&gt;</span><br><span class="line">        /*</span><br><span class="line">        国王 1000只鸭子合唱团 嘎嘎嘎的叫</span><br><span class="line">        */</span><br><span class="line">       //const 常量</span><br><span class="line">       //赋值语句</span><br><span class="line">       //js 弱类型，不需要像java要写明类型(用class声明对象)</span><br><span class="line">       const choir=[];//合唱团 数组也是对象</span><br><span class="line">       //对象字面量</span><br><span class="line">       const duck=&#123;</span><br><span class="line">        sing:function()&#123;</span><br><span class="line">            console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       //学外语</span><br><span class="line">       const chicken=&#123;</span><br><span class="line">        sing:function()&#123;</span><br><span class="line">            console.log(&apos;嘎嘎嘎&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       //封装</span><br><span class="line">       //加入合唱团有个流程</span><br><span class="line">       function joinChoir(animal)&#123;</span><br><span class="line">            //严谨性</span><br><span class="line">            if(animal &amp;&amp; typeof animal.sing==&apos;function&apos;)&#123;</span><br><span class="line">                 choir.push(animal);</span><br><span class="line">            &#125;</span><br><span class="line">            console.log(&apos;恭喜加入合唱团!&apos;);</span><br><span class="line">       &#125;</span><br><span class="line">       for(let i=0;i&lt;999;i++)&#123;</span><br><span class="line">        joinChoir(duck);</span><br><span class="line">       &#125;</span><br><span class="line">       joinChoir(chicken);</span><br><span class="line">       console.log(&apos;合唱团已有&apos;+choir.length+&apos;位成员&apos;);</span><br><span class="line">       if(choir.length===1000)&#123;</span><br><span class="line">        console.log(&apos;报告国王，合唱团招聘完成!&apos;);</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">    &lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>组成合唱团(敏锐的逻辑能力);</li>
<li>加入合唱团应该写成一个方法(封装能力);</li>
<li>鸭子模型(深入的语言能力)(弱类型,不需要像java要写明类型(用class声明对象));</li>
<li>JS不是传统的面向对象(class Duck),是基于原型式的面向对象();</li>
<li>JS才是最面向对象的面向对象,除了简单数据类型的一切都是对象。</li>
</ol>
<h2 id="小知识"><a href="#小知识" class="headerlink" title="小知识"></a>小知识</h2><ul>
<li>如何区分不同类型的对象=&gt;Object.prototype.toString.call()</li>
<li>例如：</li>
</ul>
<ol>
<li>Object.prototype.toString.call(choir)=&gt;’object Array’</li>
<li>Object.prototype.toString.call(duck)=&gt;’object Object’</li>
<li>Object.prototype.toString.call(sing)=&gt;’object Function’</li>
</ol>
<h6 id="记得点点赞，发表意见评论哦"><a href="#记得点点赞，发表意见评论哦" class="headerlink" title="记得点点赞，发表意见评论哦~"></a>记得点点赞，发表意见评论哦~</h6><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46698ecd645a53303662bf8a5c66fee8f589dbced2725165e23a651da9ead44f" alt="image.png"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358355063922982963" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>写一个爬虫脚本获取必应（Bing）搜索引擎首页每日的4K超清</title>
    <url>/7358381923922821146.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每次写文章的封面不知道从哪里获取，每次都是去谷歌，百度搜索文章关键字 去找一些图，要么就是从代码运行结果找相关截图，总是找不到合适的文章图片显得乱糟糟的，又没有找到相关的项目能够根据关键字生成文章封面，今天就要到了一个另类的方法，用爬虫获取 必应（Bing）搜索引擎首页每日的高清大图。</p>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>访问bing.com</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5184cf9692505b2d55657424d126bcfa43d5b192156d0390e9fc59d4964817f5" alt="微信截图_20240416230343.png"><br>很简单就能发现图片的请求地址隐藏到了网页里面</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eb0ef411be85fd0bd388efecd73ab6e559c11603aea4f6216177c615bea98a4d" alt="image.png"><br>通过网页找图片的关键的方法是有水印的，而且图不是高清的</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/269b0842d3e03520a89945e793e5541df3191669aa156c1b3ced90862a107ba1" alt="image.png"></p>
<p>最后通过GitHub找到一个公开的接口：<br><a href="https://cn.bing.com/HPImageArchive.aspx?format=js&idx=0&n=1&mkt=ZH-CN" target="_blank" rel="noopener">cn.bing.com/HPImageArch…</a></p>
<p>直接访问就能拿到高清无水印图片的地址文本内容，稍微做一下解析就行</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/66d00388bc19cf5e20b5efbee153bf21ff44a3c3759c810cb0a9f60d9d74da8b" alt="image.png"><br>接下来就简单写一下爬虫代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码# 下载并存储Bing每日壁纸到指定位置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">import os</span><br><span class="line">import re</span><br><span class="line">import requests</span><br><span class="line">from io import BytesIO</span><br><span class="line">from PIL import Image</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">class BingUHD(object):</span><br><span class="line"></span><br><span class="line">    def __init__(self):</span><br><span class="line">        # 默认bing图片查询地址</span><br><span class="line">        self.url = &apos;https://cn.bing.com/HPImageArchive.aspx?format=js&amp;idx=0&amp;n=1&amp;mkt=ZH-CN&apos;</span><br><span class="line">        self.path = &apos;./BingUHD/&apos;</span><br><span class="line">        self.headers = &#123;</span><br><span class="line">            &apos;User-Agent&apos;: &apos;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) &apos;</span><br><span class="line">                          &apos;Chrome/80.0.3987.132 Safari/537.36&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        self.resolution = &apos;UHD&apos;</span><br><span class="line"></span><br><span class="line">    # 取得图片相关信息</span><br><span class="line">    def get_img_info(self):</span><br><span class="line">        try:</span><br><span class="line">            # 获取图片信息</span><br><span class="line">            result = requests.get(self.url, headers=self.headers).json()</span><br><span class="line">            # 提取图片地址</span><br><span class="line">            raw_img_url = &apos;https://cn.bing.com&apos; + result[&apos;images&apos;][0][&apos;url&apos;]</span><br><span class="line">            # 得到默认图片链接</span><br><span class="line">            normal_img_url = raw_img_url[0:raw_img_url.find(&quot;.jpg&quot;) + 4]</span><br><span class="line">            # 得到UHD图片链接替换默认的 1080 图片为UHD图片链接</span><br><span class="line">            uhd_img_url = normal_img_url.replace(&quot;1920x1080&quot;, self.resolution)</span><br><span class="line">            # 提取中文标题和版权信息</span><br><span class="line">            date = result[&quot;images&quot;][0][&quot;startdate&quot;]</span><br><span class="line">            title = result[&quot;images&quot;][0][&quot;title&quot;]</span><br><span class="line">            copy_right = result[&quot;images&quot;][0][&quot;copyright&quot;]</span><br><span class="line"></span><br><span class="line">            return normal_img_url, uhd_img_url, date, title, copy_right</span><br><span class="line"></span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法获取到图片地址，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    def img_download(self,url,file_name):</span><br><span class="line">        try:</span><br><span class="line">            response = requests.get(url, stream=True)</span><br><span class="line"></span><br><span class="line">            if response.status_code == 200:</span><br><span class="line">                with open(file_name, &apos;wb&apos;) as f:</span><br><span class="line">                    response.raw.decode_content = True</span><br><span class="line">                    shutil.copyfileobj(response.raw, f)</span><br><span class="line">                print(file_name+&quot;图片下载成功&quot;)</span><br><span class="line">            else:</span><br><span class="line">                print(file_name+&quot;无法下载图片&quot;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法下载图片，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    # 得到今日图片信息并清洗</span><br><span class="line">    def get_today_img_download(self,file_name):</span><br><span class="line">        try:</span><br><span class="line">            info = self.get_img_info()</span><br><span class="line">            normal_url = info[0]</span><br><span class="line">            uhd_url = info[1]</span><br><span class="line"></span><br><span class="line">            </span><br><span class="line"></span><br><span class="line">            # 图片分辨率文字</span><br><span class="line">            # normal = normal_url[(normal_url.rfind(&quot;_&quot;) + 1): -4]</span><br><span class="line">            # uhd = uhd_url[(uhd_url.rfind(&quot;_&quot;) + 1): -4]</span><br><span class="line"></span><br><span class="line">            # 图片分辨率文字</span><br><span class="line">            normal = self.get_pic_size()[0]</span><br><span class="line">            uhd = self.get_pic_size()[1]</span><br><span class="line">            self.img_download(normal_url,file_name+normal+&apos;.jpg&apos;)</span><br><span class="line">            self.img_download(uhd_url,file_name+uhd+&apos;.jpg&apos;)</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法获取到图片信息，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    # 取得文件名称</span><br><span class="line">    def get_file_name(self):</span><br><span class="line">        try:</span><br><span class="line">            info = self.get_img_info()</span><br><span class="line">            # 定义文件夹</span><br><span class="line">            file_path = self.path + info[2][0:4] + &apos;-&apos; + info[2][4:6] + &apos;/&apos;</span><br><span class="line">            # 判断文件夹是否存在</span><br><span class="line">            if not os.path.exists(file_path):</span><br><span class="line">                os.makedirs(file_path)</span><br><span class="line">            # 定义文件名</span><br><span class="line">            copy_right = info[4]</span><br><span class="line">            copy_right = copy_right[0:copy_right.find(&apos; &apos;)]</span><br><span class="line">            # 绝对路径</span><br><span class="line">            name = info[2] + &apos;.&apos; + info[3] + &apos;.&apos; + copy_right + &apos;.&apos;</span><br><span class="line">            full_name = file_path + name</span><br><span class="line"></span><br><span class="line">            return full_name</span><br><span class="line">        except Exception as e:</span><br><span class="line">            print(&apos;错误: 无法获取到图片信息，请检查网络连接&apos; + &apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">    # 取得图片的尺寸</span><br><span class="line">    def get_pic_size(self):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        获取远程图片的尺寸</span><br><span class="line">        :return:</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        size_list = []</span><br><span class="line">        url = [self.get_img_info()[0], self.get_img_info()[1]]</span><br><span class="line">        for u in url:</span><br><span class="line">            r = requests.get(u)</span><br><span class="line">            img = Image.open(BytesIO(r.content))</span><br><span class="line">            pic_size = str(img.width) + &apos;x&apos; + str(img.height)</span><br><span class="line">            size_list.append(pic_size)</span><br><span class="line">        return size_list</span><br><span class="line"></span><br><span class="line">    # 取得今日美图文字</span><br><span class="line">    def get_description(self):</span><br><span class="line">        url = &apos;https://www.bing.com/?mkt=zh-CN&apos;</span><br><span class="line">        rsp = requests.get(url)</span><br><span class="line">        result = re.search(r&apos;(&#123;&quot;Description&quot;:&quot;)(.*?)(&quot;,&quot;Image&quot;)&apos;, rsp.text).group(2)</span><br><span class="line">        return result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    bing = BingUHD()</span><br><span class="line">    file_name = bing.get_file_name()</span><br><span class="line">    content = bing.get_today_img_download(file_name)</span><br></pre></td></tr></table></figure>

<p>进入脚本根目录执行python脚本就能自动创建相关的文件夹，自动下载图片，项目结构内容如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fa05e15eb56182ea4b0e796e71713f19bf0ff2c4ebfc264be4f88839c5a62600" alt="image.png"></p>
<h1 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h1><p>后面文章找不到封面我就拿这个做文章封面了，上面的代码通过已知隐藏的接口获取到了更高清图片的3140*2160 4K图片地址，看上图中的两种图片体积可以看出来，图片质量完全不一样。</p>
<p>可能对于Python 新手有些不友好，如果不抗拒一段段代码复制去询问ChatGPT 然后自己慢慢打印调试尝试，其实有那种精神就能慢慢学会了，站在技术实现的角度其实直接从F12控制台就能找到这个图片的源地址右键就能保存了，我的想法是后面有机会的话做一个图片展示的网站，尝试部署这个脚本用定时任务自动爬取收集这些图片，就不用特地手动运行脚本了。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358381923922821146" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>初识并发编程</title>
    <url>/7358375367340408883.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>并发是同一时间应对多件事情的能力——<a href="https://zh.wikipedia.org/wiki/%E7%BE%85%E5%8B%83%C2%B7%E6%B4%BE%E5%85%8B" target="_blank" rel="noopener">Rob Pike</a></p>
</blockquote>
<p><strong>并发编程是指在软件开发中处理多个任务或线程的方式</strong>。它涉及到同时执行多个任务，而不是一个接一个地执行。并发编程的目标是<strong>提高程序的效率和响应能力</strong>，使得程序能够更好地处理用户的请求，<strong>提高系统的吞吐量和并发性能</strong>。</p>
<h2 id="CPU-架构"><a href="#CPU-架构" class="headerlink" title="CPU 架构"></a>CPU 架构</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2d58c27e037d17a52577d1a2d3db48a6b95c1d19985be7ce0d34f890c59a3125" alt></p>
<blockquote>
<p>CPU（Central Processing Unit）是计算机中的中央处理器，它是计算机的大脑，负责执行程序指令、进行算术和逻辑运算，控制数据传输和处理。</p>
</blockquote>
<h3 id="单核-CPU-与多核-CPU"><a href="#单核-CPU-与多核-CPU" class="headerlink" title="单核 CPU 与多核 CPU"></a>单核 CPU 与多核 CPU</h3><p><strong>单核CPU</strong>：</p>
<ul>
<li>单核 CPU 是一种最基本的 CPU 架构，它只有一个处理器核心。</li>
<li>单核 CPU 通常只能同时执行一个任务，因此在执行多个任务时，会进行任务的排队和切换，从而导致任务执行的不连续和效率低下。</li>
</ul>
<p>单核CPU的优势在于价格低廉和简单的结构，一般适用于个人电脑、平板电脑和一些轻量级设备。</p>
<p><strong>多核CPU</strong>：</p>
<ul>
<li>多核 CPU 是一种具有多个处理器核心的 CPU 架构。</li>
<li>多核 CPU 可以同时执行多个任务，提高了计算机的处理能力和性能。</li>
</ul>
<h3 id="单核-CPU-和多核-CPU-的区别及优势"><a href="#单核-CPU-和多核-CPU-的区别及优势" class="headerlink" title="单核 CPU 和多核 CPU 的区别及优势"></a>单核 CPU 和多核 CPU 的区别及优势</h3><p><strong>区别</strong>：</p>
<ul>
<li>单核 CPU 只有一个处理器核心，而多核 CPU 具有多个处理器核心。</li>
<li>单核 CPU 只能同时执行一个任务，而多核 CPU 可以同时执行多个任务。</li>
<li>单核 CPU 的处理能力相对较低，而多核 CPU 的处理能力更高。</li>
</ul>
<p><strong>优势</strong>：</p>
<ul>
<li>多核 CPU 相比单核 CPU 具有更高的处理能力和性能，能够更好地利用系统资源，提高计算机的吞吐量和响应速度。</li>
<li>多核 CPU 可以同时执行多个任务，提高了计算机的并发处理能力。</li>
<li>多核 CPU 通过超线程技术可以提高单个任务的执行效率。</li>
<li>多核 CPU 的价格相对较高，但对于需要高性能计算和多任务处理的场景，它是一个很好的选择。</li>
</ul>
<h3 id="多核CPU如何实现并行处理"><a href="#多核CPU如何实现并行处理" class="headerlink" title="多核CPU如何实现并行处理"></a>多核CPU如何实现并行处理</h3><p>在早期只有一个 CPU 核心时，我们的任务是怎么处理的呢？是的，并发解君愁。当然，这里还得提到操作系统的多线程，正是操作系统多线程 + CPU 核心，才实现了现代化的多任务操作系统。在 OS 级别，多线程负责管理我们的任务队列，你可以简单认为一个线程管理着一个任务队列，然后线程之间还能根据空闲度进行任务调度。我们的程序只会跟 OS 线程打交道，并不关心 CPU 到底有多少个核心，真正关心的只是 OS，当线程把任务交给 CPU 核心去执行时，<strong>如果只有一个 CPU 核心，那么它就只能同时处理一个任务</strong>。</p>
<h4 id="多核心并行"><a href="#多核心并行" class="headerlink" title="多核心并行"></a>多核心并行</h4><p>当 CPU 核心增多到 N 时，那么能够在同一时间就能有 N 个任务被处理，则并行度就是 N，相应的处理效率也变成了单核心的 N 倍。</p>
<h4 id="多核心并发"><a href="#多核心并发" class="headerlink" title="多核心并发"></a>多核心并发</h4><p>当电脑的处理器核心增多时，操作系统需要处理的任务也会增多。这些任务被分成几个队列，然后交给处理器核心去执行。虽然看起来好像所有任务都在同时进行，但实际上，每个核心在同一时刻只能处理一个任务。所以，虽然任务都在同时进行，但实际上只有少数任务能够真正地同时被处理。</p>
<h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><p>进程和线程是操作系统中用于执行任务的基本单位。它们之间有一些重要区别：</p>
<p><strong>进程</strong>：</p>
<ul>
<li>进程是程序的一次执行实例，拥有独立的内存空间和资源。</li>
<li>每个进程都有自己的地址空间、文件描述符、环境变量等。</li>
<li>进程之间通常是相互独立的，彼此不会影响。</li>
<li>进程之间的通信需要使用 IPC（Inter-Process Communication）机制，如管道、消息队列、共享内存等。</li>
</ul>
<p><strong>线程</strong>：</p>
<ul>
<li>线程是在进程内部执行的轻量级任务单元，共享进程的资源。</li>
<li>线程共享相同的地址空间和文件描述符，可以直接访问进程的全局变量和数据。</li>
<li>线程之间的切换比进程之间的切换更快速，因为不涉及地址空间的切换。</li>
<li>线程之间的通信更容易，可以直接通过共享内存等方式进行通信。</li>
</ul>
<h2 id="并发与并行"><a href="#并发与并行" class="headerlink" title="并发与并行"></a>并发与并行</h2><blockquote>
<ul>
<li>究竟什么是并发？</li>
<li>它与并行有什么区别？</li>
</ul>
</blockquote>
<p>理解并发编程的关键是理解并发的概念。</p>
<ul>
<li>并发是指在<strong>同一时间处理多个任务</strong>；并发编程主要关注如何处理多个任务。</li>
<li>并行是指<strong>真正同时执行多个任务</strong>；并行编程则关注如何真正同时执行多个任务。</li>
</ul>
<p>Erlang 之父<a href="https://zh.wikipedia.org/wiki/%E5%96%AC%C2%B7%E9%98%BF%E5%A7%86%E6%96%AF%E7%89%B9%E6%9C%97" target="_blank" rel="noopener">约瑟夫·莱斯利·阿姆斯特朗</a>用一张很形象的图片解释了并发与并行的区别：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a385dbf3581f0c4955ba7a33bc3624dfa2dbef8646117c3365532623d887250e" alt></p>
<p>从上图可以看出：</p>
<ul>
<li>并发是多个队列使用同一个咖啡机，然后两个队列轮着使用（未必是1:1 轮换，也有可能是其他轮换规则），但最终每个人都能接到咖啡</li>
<li>并行是每个队列都拥有一个咖啡机，最终也是每个人都能接到咖啡，但是效率更高，因为同时可以有两个人在接咖啡</li>
</ul>
<blockquote>
<p><strong>并发和并行都是对“多任务”处理的描述，其中并发是轮流处理，而并行是同时处理</strong>。正如 Go 语言之父 Rob Pike 曾说过：<strong>并发不是并行，并发关乎结构，并行关乎执行</strong>。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358375367340408883" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Go</tag>
      </tags>
  </entry>
  <entry>
    <title>webserverapachetomcat11-03-</title>
    <url>/7358361832461156389.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>整理这个官方翻译的系列，原因是网上大部分的 tomcat 版本比较旧，此版本为 v11 最新的版本。</p>
<h2 id="开源项目"><a href="#开源项目" class="headerlink" title="开源项目"></a>开源项目</h2><blockquote>
<p>从零手写实现 tomcat <a href="https://github.com/houbb/minicat" target="_blank" rel="noopener">minicat</a> 别称【嗅虎】心有猛虎，轻嗅蔷薇。</p>
</blockquote>
<h2 id="系列文章"><a href="#系列文章" class="headerlink" title="系列文章"></a>系列文章</h2><p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-01-intro" target="_blank" rel="noopener">web server apache tomcat11-01-官方文档入门介绍</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-02-setup" target="_blank" rel="noopener">web server apache tomcat11-02-setup 启动</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-03-deploy" target="_blank" rel="noopener">web server apache tomcat11-03-deploy 如何部署</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-04-manager" target="_blank" rel="noopener">web server apache tomcat11-04-manager 如何管理？</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-06-host-manager" target="_blank" rel="noopener">web server apache tomcat11-06-Host Manager App – Text Interface</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-07-relam" target="_blank" rel="noopener">web server apache tomcat11-07-Realm Configuration</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-08-jndi" target="_blank" rel="noopener">web server apache tomcat11-08-JNDI Resources</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-09-jdbc-datasource" target="_blank" rel="noopener">web server apache tomcat11-09-JNDI Datasource</a></p>
<p><a href="https://houbb.github.io/2016/11/07/web-server-tomcat11-doc-10-classloader-howto" target="_blank" rel="noopener">web server apache tomcat11-10-Class Loader</a></p>
<p>….</p>
<h1 id="Tomcat-Web-应用部署"><a href="#Tomcat-Web-应用部署" class="headerlink" title="Tomcat Web 应用部署"></a>Tomcat Web 应用部署</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>部署是指将 Web 应用程序（无论是第三方 WAR 文件还是自定义的 Web 应用程序）安装到 Tomcat 服务器的过程。</p>
<p>在 Tomcat 服务器内，可以通过多种方式来完成 Web 应用程序的部署。</p>
<ul>
<li>静态部署：在启动 Tomcat 之前设置 Web 应用程序。</li>
<li>动态部署：通过直接操作已部署的 Web 应用程序（依赖自动部署功能）或通过使用 Tomcat Manager Web 应用程序来远程部署。</li>
</ul>
<p>Tomcat Manager 是一个 Web 应用程序，可以以交互方式（通过 HTML GUI）或以编程方式（通过基于 URL 的 API）来部署和管理 Web 应用程序。</p>
<p>有许多依赖于 Manager Web 应用程序的部署方式。</p>
<p>Apache Tomcat 提供了用于 Apache Ant 构建工具的任务。</p>
<p>Apache Tomcat Maven 插件项目提供了与 Apache Maven 的集成。</p>
<p>还有一个称为 Client Deployer 的工具，可以从命令行使用，并提供了额外的功能，例如编译和验证 Web 应用程序，以及将 Web 应用程序打包成 Web 应用资源（WAR）文件。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>对于静态部署 Web 应用程序，不需要安装，因为 Tomcat 默认提供了此功能。对于使用 Tomcat Manager 的部署功能，虽然需要一些配置（如 Tomcat Manager 手册中详细说明的那样），但不需要安装。但是，如果要使用 Tomcat Client Deployer (TCD)，则需要安装。</p>
<p>TCD 不包含在 Tomcat 核心发行版中，因此必须从下载区域单独下载。下载通常标记为 apache-tomcat-11.0.x-deployer。</p>
<p>TCD 的先决条件是 Apache Ant 1.6.2+ 和 Java 安装。您的环境应定义一个 ANT_HOME 环境值，指向 Ant 安装的根目录，以及一个 JAVA_HOME 值，指向您的 Java 安装。</p>
<p>另外，您应确保 Ant 的 ant 命令和 Java 的 javac 编译器命令可以在您的操作系统提供的命令 shell 中运行。</p>
<ol>
<li>下载 TCD 分发包。</li>
<li>TCD 分发包不需要解压到任何现有的 Tomcat 安装中，它可以解压到任何位置。</li>
<li>阅读《使用 Tomcat Client Deployer》文档。</li>
</ol>
<h2 id="关于-Context"><a href="#关于-Context" class="headerlink" title="关于 Context"></a>关于 Context</h2><p>在讨论 Web 应用程序的部署时，需要理解 Context 的概念。Context 是 Tomcat 所称的 Web 应用程序。</p>
<p>为了在 Tomcat 中配置 Context，需要一个 Context 描述符。Context 描述符只是一个包含与 Context 相关的 Tomcat 配置的 XML 文件，例如命名资源或会话管理器配置。在较早版本的 Tomcat 中，Context 描述符配置的内容通常存储在 Tomcat 的主配置文件 server.xml 中，但现在已不鼓励这样做（尽管目前仍然有效）。</p>
<p>Context 描述符不仅帮助 Tomcat 知道如何配置 Context，还帮助其他工具（如 Tomcat Manager 和 TCD）正确执行其功能。</p>
<p>Context 描述符的位置包括：</p>
<ul>
<li><code>$CATALINA_BASE/conf/[enginename]/[hostname]/[webappname].xml</code></li>
<li><code>$CATALINA_BASE/webapps/[webappname]/META-INF/context.xml</code></li>
</ul>
<p>第一种情况的文件命名为 <code>[webappname].xml</code>，而第二种情况的文件命名为 context.xml。如果没有为 Context 提供 Context 描述符，Tomcat 将使用默认值配置 Context。</p>
<h2 id="在-Tomcat-启动时部署"><a href="#在-Tomcat-启动时部署" class="headerlink" title="在 Tomcat 启动时部署"></a>在 Tomcat 启动时部署</h2><p>如果您不想使用 Tomcat Manager 或 TCD，则需要将 Web 应用程序静态部署到 Tomcat，然后启动 Tomcat。您需要将 Web 应用程序部署到称为 appBase 的位置，该位置由 Host 指定。您可以将所谓的“已解压” Web 应用程序（即非压缩的）复制到此位置，也可以将压缩的 Web 应用程序资源 .WAR 文件复制到此位置。</p>
<p>在默认的情况下，位于主机（默认主机为“localhost”）appBase 属性（默认 appBase 为“$CATALINA_BASE/webapps”）指定的位置中存在的 Web 应用程序仅在 Host 的 deployOnStartup 属性为“true”时才会在 Tomcat 启动时部署。</p>
<p>在这种情况下，以下部署顺序将在 Tomcat 启动时发生：</p>
<ol>
<li>首先部署任何 Context 描述符。</li>
<li>然后部署任何未被任何 Context 描述符引用的已解压的 Web 应用程序。如果它们在 appBase 中有一个关联的 .WAR 文件，并且该文件比已解压的 Web 应用程序更新，则将删除已解压的目录，并重新部署 Web 应用程序。</li>
<li>部署 .WAR 文件。</li>
</ol>
<h2 id="在运行的-Tomcat-服务器上部署"><a href="#在运行的-Tomcat-服务器上部署" class="headerlink" title="在运行的 Tomcat 服务器上部署"></a>在运行的 Tomcat 服务器上部署</h2><p>可以将 Web 应用程序部署到运行中的 Tomcat 服务器上。</p>
<p>如果 Host 的 autoDeploy 属性设置为“true”，则 Host 将尝试根据需要动态部署和更新 Web 应用程序，例如</p>
<p>，如果新的 .WAR 放入了 appBase 中。要使此功能正常工作，Host 需要启用后台处理，这是默认配置。</p>
<p>autoDeploy 设置为“true”并且运行中的 Tomcat 允许：</p>
<ul>
<li>将 .WAR 文件复制到 Host 的 appBase 中进行部署。</li>
<li>将已解压的 Web 应用程序复制到 Host 的 appBase 中进行部署。</li>
<li>如果提供了新的 .WAR 文件，则重新部署已经部署的 Web 应用程序。在这种情况下，将删除已解压的 Web 应用程序，并重新展开 .WAR。请注意，如果 Host 配置为不展开 .WAR（unpackWARs 属性设置为“false”），则不会执行展开操作，此时 Web 应用程序将作为压缩的存档重新部署。</li>
<li>如果更新了 /WEB-INF/web.xml 文件（或任何其他定义为 WatchedResource 的资源），则重新加载 Web 应用程序。</li>
<li>如果更新了从中部署了 Web 应用程序的 Context 描述符文件，则重新部署 Web 应用程序。</li>
<li>如果由 Web 应用程序使用的全局或每个主机的 Context 描述符文件已更新，则重新部署依赖的 Web 应用程序。</li>
<li>如果在 <code>$CATALINA_BASE/conf/[enginename]/[hostname]/</code> 目录中添加了一个文件（文件名对应于先前部署的 Web 应用程序的 Context 路径），则重新部署 Web 应用程序。</li>
<li>如果删除了其文档基址（docBase）的 Web 应用程序，则卸载它。请注意，在 Windows 上，这假定启用了反锁定功能（参见 Context 配置），否则无法删除正在运行的 Web 应用程序的资源。</li>
</ul>
<p>请注意，还可以在加载器中配置 Web 应用程序重新加载，这样加载的类将被跟踪以进行更改。</p>
<h2 id="使用-Tomcat-Manager-进行部署"><a href="#使用-Tomcat-Manager-进行部署" class="headerlink" title="使用 Tomcat Manager 进行部署"></a>使用 Tomcat Manager 进行部署</h2><p>Tomcat Manager 在自己的手册页面中进行了详细介绍。</p>
<h2 id="使用客户端部署包进行部署"><a href="#使用客户端部署包进行部署" class="headerlink" title="使用客户端部署包进行部署"></a>使用客户端部署包进行部署</h2><p>最后，可以使用 Tomcat 客户端部署程序来部署 Web 应用程序。这是一个可以用来验证、编译、压缩为 .WAR，并将 Web 应用程序部署到生产或开发 Tomcat 服务器的包。应该注意，此功能使用 Tomcat Manager，因此目标 Tomcat 服务器应该正在运行。</p>
<p>假设用户熟悉 Apache Ant 以使用 TCD。Apache Ant 是一个脚本化的构建工具。TCD 包含一个预打包的构建脚本。只需要对 Apache Ant 有一些基本的了解（如本页中列出的安装，并熟悉使用操作系统命令 shell 和配置环境变量）。</p>
<p>TCD 包含 Ant 任务，用于 JSP 编译的 Jasper 页面编译器，以及用于验证 Web 应用程序 Context 描述符的任务。验证器任务（类 org.apache.catalina.ant.ValidatorTask）仅允许一个参数：已解压的 Web 应用程序的基本路径。</p>
<p>TCD 使用已解压的 Web 应用程序作为输入（请参阅下面使用的属性列表）。通过 deployer 进行编程部署的 Web 应用程序可以在 /META-INF/context.xml 中包含 Context 描述符。</p>
<p>TCD 包含一个可立即使用的 Ant 脚本，具有以下目标：</p>
<ul>
<li>compile（默认）：编译和验证 Web 应用程序。这可以独立使用，不需要运行的 Tomcat 服务器。编译的应用程序仅在关联的 Tomcat X.Y.Z 服务器发布中运行，并不能保证在另一个 Tomcat 发布中工作，因为 Jasper 生成的代码依赖于其运行时组件。还应该注意，此目标还会自动编译位于 /WEB-INF/classes 文件夹中的任何 Java 源文件。</li>
<li>deploy：将 Web 应用程序（已编译或未编译）部署到 Tomcat 服务器。</li>
<li>undeploy：卸载 Web 应用程序</li>
<li>start：启动 Web 应用程序</li>
<li>reload：重新加载 Web 应用程序</li>
<li>stop：停止 Web 应用程序</li>
</ul>
<p>为了配置部署，需要在 TCD 安装目录根目录下创建一个名为 deployer.properties 的文件。在此文件中，每行添加以下名称=值对：</p>
<p>此外，您需要确保为目标 Tomcat Manager（TCD 使用的）设置了用户，否则 TCD 将无法与 Tomcat Manager 进行身份验证，部署将失败。</p>
<p>要执行此操作，请参阅 Tomcat Manager 页面。</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://tomcat.apache.org/tomcat-11.0-doc/deployer-howto.html" target="_blank" rel="noopener">tomcat.apache.org/tomcat-11.0…</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358361832461156389" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>基于SpringWebMultipartFile文件上传、</title>
    <url>/7358450927110832162.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在Web开发中，文件上传是一个常见的功能需求。Spring框架提供了MultipartFile接口，用于处理文件上传请求。MultipartFile可以代表一个多部分文件上传请求中的一个文件，提供了一系列方法用于获取文件的各种属性和内容，使得在后端处理文件上传变得十分方便。下面我们将介绍MultipartFile在Web应用中的几种常见使用场景。</p>
<p><strong>1. 图片上传</strong></p>
<p>在Web应用中，图片上传是一种常见的场景。用户需要上传头像、相片、证件照等图片文件，而后端需要接收并保存这些文件。使用MultipartFile接口可以轻松地实现图片文件的接收和处理。通过获取文件的原始文件名、内容类型、大小等属性，我们可以实现对图片文件的有效管理和存储。例如，我们可以将图片文件保存到服务器的文件系统中，或者将其存储到<a href="https://cloud.baidu.com/product/abc-storage.html" target="_blank" rel="noopener">云存储</a>服务中。</p>
<p><strong>2. 文件下载</strong></p>
<p>除了文件上传，文件下载也是Web应用中常见的功能需求。使用MultipartFile接口，我们可以实现文件的下载功能。在服务器端，我们可以将文件作为MultipartFile对象进行处理，并通过设置响应头信息，将文件作为下载内容返回给客户端。客户端接收到文件后，可以将其保存到本地磁盘或进行其他处理。</p>
<p><strong>3. 文件编辑</strong></p>
<p>在Web应用中，有时候用户需要对上传的文件进行编辑操作，例如修改文件名、修改文件内容等。使用MultipartFile接口，我们可以实现对文件的编辑功能。首先，我们可以通过MultipartFile接口获取上传的文件对象，然后对其进行相应的编辑操作。例如，我们可以修改文件的名称、修改文件的内容等。编辑完成后，我们可以将修改后的文件保存到服务器或返回给客户端。</p>
<p><strong>4. 文件预览和展示</strong></p>
<p>在Web应用中，有时候我们需要将上传的文件进行预览或展示。例如，在<a href="https://cloud.baidu.com/product/doc.html" target="_blank" rel="noopener">文档</a>管理系统中，用户需要预览或下载文档文件。使用MultipartFile接口，我们可以实现文件的预览和展示功能。我们可以将文件作为MultipartFile对象进行处理，然后将其内容转换为适当的格式进行展示。例如，对于PDF文件，我们可以使用PDF阅读器插件进行展示；对于图片文件，我们可以将其直接展示在网页上。</p>
<p><strong>5. 文件批量上传和处理</strong></p>
<p>在实际应用中，有时候用户需要批量上传多个文件，并对这些文件进行处理。使用MultipartFile接口，我们可以实现文件的批量上传和处理功能。我们可以将多个文件作为一个多部分文件上传请求进行处理，然后对每个文件进行相应的操作。例如，我们可以将多个图片文件批量上传到服务器，并对它们进行压缩、裁剪等处理。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package com.javagpt.back.controller;</span><br><span class="line"></span><br><span class="line">import com.javagpt.application.context.UserAppContextHolder;</span><br><span class="line">import com.javagpt.application.file.FileApplicationService;</span><br><span class="line">import com.javagpt.application.file.FileDTO;</span><br><span class="line">import com.javagpt.common.annotation.RespSuccess;</span><br><span class="line">import com.javagpt.common.constant.EMConstant;</span><br><span class="line">import io.swagger.annotations.Api;</span><br><span class="line">import io.swagger.annotations.ApiOperation;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br><span class="line">import jakarta.servlet.http.HttpServletResponse;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.springframework.web.bind.annotation.*;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">@Api(tags = &quot;文件接口&quot;)</span><br><span class="line">@Slf4j</span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(EMConstant.API_V1 + &quot;/file&quot;)</span><br><span class="line">@RespSuccess</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class FileController &#123;</span><br><span class="line"></span><br><span class="line">    private final FileApplicationService fileApplicationService;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;通用文件上传&quot;)</span><br><span class="line">    @PostMapping(value = &quot;/uploadFile&quot;)</span><br><span class="line">    public FileDTO uploadFile(@RequestParam(&quot;file&quot;) MultipartFile multipartFile) throws IOException &#123;</span><br><span class="line">        Long enterpriseId = UserAppContextHolder.getCurrentUser().getEnterpriseId();</span><br><span class="line">        FileDTO fileDTO = fileApplicationService.saveFile(enterpriseId, multipartFile);</span><br><span class="line">        return fileDTO;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //@PreAuthorize(&quot;hasAuthority(&apos;mp:file:download&apos;)&quot;)</span><br><span class="line">    @ApiOperation(&quot;下载文件&quot;)</span><br><span class="line">    @GetMapping(value = &quot;/downloadFile&quot;)</span><br><span class="line">    public void download(@RequestParam(value = &quot;id&quot;) Long id, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        fileApplicationService.downloadFile(response, id, UserAppContextHolder.getCurrentUser().getEnterpriseId());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;查看文件信息&quot;)</span><br><span class="line">    @GetMapping(value = &quot;/info&quot;)</span><br><span class="line">    public FileDTO fileInfo(@RequestParam(value = &quot;id&quot;) Long id) throws IOException &#123;</span><br><span class="line">        return fileApplicationService.findById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @ApiOperation(&quot;下载视频&quot;)</span><br><span class="line">    @GetMapping(value = &quot;/downloadFile2&quot;)</span><br><span class="line">    public void download2(@RequestParam(value = &quot;id&quot;) Long id, HttpServletRequest request, HttpServletResponse response) throws IOException &#123;</span><br><span class="line">        fileApplicationService.downloadVideo(request, response, id, UserAppContextHolder.getCurrentUser().getEnterpriseId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package com.javagpt.application.file;</span><br><span class="line"></span><br><span class="line">import com.javagpt.common.exception.BusinessRuntimeException;</span><br><span class="line">import com.javagpt.common.oos.OssService;</span><br><span class="line">import com.javagpt.common.util.ModelUtils;</span><br><span class="line">import com.javagpt.common.util.SpringResponseUtils;</span><br><span class="line">import com.javagpt.file.entity.FileEntity;</span><br><span class="line">import com.javagpt.file.repository.FileRepository;</span><br><span class="line">import jakarta.servlet.http.HttpServletRequest;</span><br><span class="line">import jakarta.servlet.http.HttpServletResponse;</span><br><span class="line">import lombok.RequiredArgsConstructor;</span><br><span class="line">import lombok.extern.slf4j.Slf4j;</span><br><span class="line">import org.apache.commons.io.FilenameUtils;</span><br><span class="line">import org.apache.commons.io.IOUtils;</span><br><span class="line">import org.apache.commons.lang3.StringUtils;</span><br><span class="line">import org.springframework.http.HttpHeaders;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line">import org.springframework.web.multipart.MultipartFile;</span><br><span class="line"></span><br><span class="line">import java.io.*;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">@Slf4j</span><br><span class="line">@RequiredArgsConstructor</span><br><span class="line">public class FileApplicationService &#123;</span><br><span class="line"></span><br><span class="line">    private final OssService ossService;</span><br><span class="line"></span><br><span class="line">    private final FileRepository fileRepository;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public FileDTO findById(Long id) &#123;</span><br><span class="line">        FileEntity fileEntity = fileRepository.findById(id);</span><br><span class="line">        return ModelUtils.convert(fileEntity, FileDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public FileDTO saveFile(Long enterpriseId, MultipartFile file) &#123;</span><br><span class="line">        FileEntity fileEntity = saveFile(enterpriseId, file, null);</span><br><span class="line">        return ModelUtils.convert(fileEntity, FileDTO.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public FileEntity saveFile(Long enterpriseId, MultipartFile file, String fileName) &#123;</span><br><span class="line">        String originalFilename = file.getOriginalFilename();</span><br><span class="line">        String name = StringUtils.isBlank(fileName) ? FilenameUtils.getBaseName(originalFilename) : fileName;</span><br><span class="line">        String suffix = FilenameUtils.getExtension(originalFilename);</span><br><span class="line">        long size = file.getSize();</span><br><span class="line">        FileEntity fileEntity = new FileEntity();</span><br><span class="line">        fileEntity.setName(name).setSuffix(suffix).setSize(size).setEnterpriseId(enterpriseId);</span><br><span class="line">        fileEntity = fileEntity.save();</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        InputStream inputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = file.getInputStream();</span><br><span class="line">        &#125; catch (IOException e) &#123;</span><br><span class="line">            log.error(&quot;saveFile error:&quot;, e);</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;上传文件失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        ossService.uploadFile(inputStream, key);</span><br><span class="line">        IOUtils.closeQuietly(inputStream);</span><br><span class="line">        return fileEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    public FileEntity saveFile(File file) &#123;</span><br><span class="line">        long size = file.length();</span><br><span class="line">        FileEntity fileEntity = new FileEntity();</span><br><span class="line">        String baseName = FilenameUtils.getBaseName(file.getName());</span><br><span class="line">        String extension = FilenameUtils.getExtension(file.getName());</span><br><span class="line">        fileEntity.setName(baseName).setSuffix(extension).setSize(size);</span><br><span class="line">        fileEntity = fileEntity.save();</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        FileInputStream inputStream = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            inputStream = new FileInputStream(file);</span><br><span class="line">            ossService.uploadFile(inputStream, key);</span><br><span class="line">        &#125; catch (FileNotFoundException e) &#123;</span><br><span class="line">            log.error(&quot;saveFile error:&quot;, e);</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;上传文件失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        IOUtils.closeQuietly(inputStream);</span><br><span class="line">        return fileEntity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void downloadFile(HttpServletResponse response, Long fileId, Long enterpriseId) throws IOException &#123;</span><br><span class="line">        FileEntity fileEntity = fileRepository.findById(fileId);</span><br><span class="line">        if (fileEntity == null) &#123;</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;无效的文件Id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        InputStream inputStream = ossService.downloadFile(key);</span><br><span class="line">        SpringResponseUtils.writeAndFlushResponse(inputStream, response, fileEntity.fileFullName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public void downloadVideo(HttpServletRequest request, HttpServletResponse response, Long fileId, Long enterpriseId) throws IOException &#123;</span><br><span class="line"></span><br><span class="line">        FileEntity fileEntity = fileRepository.findById(fileId);</span><br><span class="line">        if (fileEntity == null) &#123;</span><br><span class="line">            throw BusinessRuntimeException.error(&quot;无效的文件Id&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        response.setHeader(HttpHeaders.ACCEPT_RANGES, &quot;bytes&quot;);</span><br><span class="line">        Long fileSize = fileEntity.getSize();</span><br><span class="line">        long start = 0, end = fileSize - 1;</span><br><span class="line">        //判断前端需不需要分片下载</span><br><span class="line">        if (StringUtils.isNotBlank(request.getHeader(&quot;Range&quot;))) &#123;</span><br><span class="line">            response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);</span><br><span class="line">            String numRange = request.getHeader(&quot;Range&quot;).replaceAll(&quot;bytes=&quot;, &quot;&quot;);</span><br><span class="line">            String[] strRange = numRange.split(&quot;-&quot;);</span><br><span class="line">            if (strRange.length == 2) &#123;</span><br><span class="line">                start = Long.parseLong(strRange[0].trim());</span><br><span class="line">                end = Long.parseLong(strRange[1].trim());</span><br><span class="line">                //若结束字节超出文件大小 取文件大小</span><br><span class="line">                if (end &gt; fileSize - 1) &#123;</span><br><span class="line">                    end = fileSize - 1;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //若只给一个长度  开始位置一直到结束</span><br><span class="line">                start = Long.parseLong(numRange.replaceAll(&quot;-&quot;, &quot;&quot;).trim());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        long rangeLength = end - start + 1;</span><br><span class="line">        String contentRange = new StringBuffer(&quot;bytes &quot;).append(start).append(&quot;-&quot;).append(end).append(&quot;/&quot;).append(fileSize).toString();</span><br><span class="line">        response.setHeader(HttpHeaders.CONTENT_RANGE, contentRange);</span><br><span class="line">        response.setHeader(HttpHeaders.CONTENT_LENGTH, String.valueOf(rangeLength));</span><br><span class="line">        String key = fileEntity.getPath();</span><br><span class="line">        InputStream inputStream = ossService.downloadFile2(key, start, end);</span><br><span class="line">        SpringResponseUtils.writeAndFlushResponse(inputStream, response, fileEntity.fileFullName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总之，MultipartFile接口在Web应用中具有广泛的应用场景，可以实现文件上传、下载、编辑、预览和批量处理等功能。通过熟练掌握MultipartFile接口的使用方法和技巧，我们可以更加高效地处理文件上传和下载请求，提升Web应用的用户体验和功能性能。</p>
<blockquote>
<p>本文由博客一文多发平台 <a href="https://openwrite.cn?from=article_bottom" target="_blank" rel="noopener">OpenWrite</a> 发布！</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358450927110832162" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>OpenTelemetry实践指南：历史、架构与基本概念</title>
    <url>/7358450927110357026.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本文为稀土掘金技术社区首发签约文章，30天内禁止转载，30天后未获授权禁止转载，侵权必究！</p>
<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>之前陆续写过一些和 OpenTelemetry 相关的文章：</p>
<ul>
<li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/" target="_blank" rel="noopener">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li>
<li><a href="https://crossoverjie.top/2024/04/15/ob/how-to-write-otel-extensions/" target="_blank" rel="noopener">实战：如何编写一个 OpenTelemetry Extensions</a></li>
<li><a href="https://dev.newban.cn/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a></li>
</ul>
<p>这些内容的前提是最好有一些 OpenTelemetry 的背景知识，看起来就不会那么枯燥，为此这篇文章就来做一个入门科普，方便一些对 OpenTelemetry 不是那么熟的朋友快速掌握一些 OpenTelemetry 的基本概念。</p>
<hr>
<h2 id="历史发展"><a href="#历史发展" class="headerlink" title="历史发展"></a>历史发展</h2><p>早在 <code>OpenTelemetry</code> 诞生之前可观测性这个概念就一直存在了，我记得我最早接触到这个概念是在 16 年当时的公司所使用的一个产品：<a href="https://github.com/pinpoint-apm/pinpoint" target="_blank" rel="noopener">pinpoint</a></p>
<blockquote>
<p>现如今这个项目依然比较活跃。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f20ed5174b0536cba995d1bdc03a0a1ada83d39ece822cc403f053f54ba96f88" alt><br>依然还记得当时通过它可以直接看到项目调用的拓扑图，在时间坐标上框出高延迟的点就能列出这些请求，同时还能查看此时的运行日志。</p>
<p>这样强大的功能对于一个刚工作一年的小白来说冲击力实属太大了一点。</p>
<p>后来才了解到 pinpoint 属于 APM 这类产品，类似的产品还有：</p>
<ul>
<li>Apache SkyWalking</li>
<li>美团的 CAT 等</li>
</ul>
<p>他们都是可以用于性能分析和链路追踪的产品，到后来公司的运维层面也接入过 Zabbix、open-falcon 之类的产品：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b25088ba2bea7828804b744ca33a3be750e8e43b108a5827bce76d38512f6b4a" alt></p>
<p>17之后全面切换到 spring boot 时，也用过社区提供的 <a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener">spring-boot-admin</a> 项目：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5ae14e793b0d375a9dcc59168e8f7a720da10d0df49d4abf6a6294a3b0339977" alt><br>这就是一个简单的可以监控 spring boot 应用的产品，用于展示 JVM 指标，或者自己也可以定义一些健康指标。</p>
<hr>
<p>再之后进入云原生体系后可观测性的技术栈稍有变化。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f22de62a6a74cb2d98f2b1ea89826322cd7d2e444f9512621cdaffa62d1a37f1" alt></p>
<p>日志使用 Sidecar 代理的方式通过 Agent 将数据写入 ElasticSearch 中。<br>具体日志采集方式可以参考之前的文章：</p>
<ul>
<li><a href="https://dev.newban.cn/7347000319983419411">在 kubernetes 环境下如何采集日志</a></li>
</ul>
<p>而链路追踪则是使用的 <code>skywalking</code>，在 trace 这个领域 skywalking 还是非常受大家喜爱的。</p>
<p>不过最近也从 skywalking 切换到了我们本文所讲到的 OpenTelemetry，具体可以看之前的文章：</p>
<ul>
<li><a href="https://crossoverjie.top/2024/04/07/ob/otel-replace-sw/" target="_blank" rel="noopener">实战：如何优雅的从 Skywalking 切换到 OpenTelemetry</a></li>
</ul>
<p>指标采集使用的是自然也是 Prometheus 的那一套技术栈，只是 Prometheus 换为了与它完全兼容的 VictoriaMetric 目前是为了更省资源。</p>
<p>客户端使用则是直接使用 Prometheus 的库进行指标暴露：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;prometheus-metrics-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;prometheus-metrics-instrumentation-jvm&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;io.prometheus&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;prometheus-metrics-exporter-httpserver&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>最终通过配置抓取策略，由 VictoriaMetrics 的 <code>scrape</code> 程序来抓取指标最终写入到它自己的存储中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码apiVersion: operator.victoriametrics.com/v1beta1  </span><br><span class="line">kind: VMPodScrape  </span><br><span class="line">metadata:  </span><br><span class="line">  name: kubernetes-pod-scrape  </span><br><span class="line">  namespace: monitoring  </span><br><span class="line">spec:  </span><br><span class="line">  podMetricsEndpoints:  </span><br><span class="line">    - scheme: http  </span><br><span class="line">      scrape_interval: &quot;30s&quot;  </span><br><span class="line">      path: /metrics  </span><br><span class="line">      relabelConfigs:  </span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_scrape]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: &quot;true&quot;  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: keep  </span><br><span class="line">        # 端口相同  </span><br><span class="line">        - action: keep_if_equal  </span><br><span class="line">          source_labels: [ __meta_kubernetes_pod_annotation_prometheus_io_port, __meta_kubernetes_pod_container_port_number ]  </span><br><span class="line">        # 过滤INIT容器  </span><br><span class="line">        - action: drop  </span><br><span class="line">          source_labels: [ __meta_kubernetes_pod_container_init ]  </span><br><span class="line">          regex: &quot;true&quot;  </span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_annotation_prometheus_io_path]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: (.+)  </span><br><span class="line">          target_label: __metrics_path__  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: replace  </span><br><span class="line">        - source_labels: [__address__, __meta_kubernetes_pod_annotation_prometheus_io_port]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: ([^:]+)(?::\d+)?;(\d+)  </span><br><span class="line">          target_label: __address__  </span><br><span class="line">          replacement: $1:$2  </span><br><span class="line">          action: replace  </span><br><span class="line">        - separator: ;  </span><br><span class="line">          regex: __meta_kubernetes_pod_label_(.+)  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: labelmap  </span><br><span class="line">        - source_labels: [__meta_kubernetes_namespace]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: (.*)  </span><br><span class="line">          target_label: kubernetes_namespace  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: replace  </span><br><span class="line">        - source_labels: [__meta_kubernetes_pod_name]  </span><br><span class="line">          separator: ;  </span><br><span class="line">          regex: (.*)  </span><br><span class="line">          target_label: kubernetes_pod_name  </span><br><span class="line">          replacement: $1  </span><br><span class="line">          action: replace  </span><br><span class="line">      vm_scrape_params:  </span><br><span class="line">        stream_parse: true  </span><br><span class="line">  namespaceSelector:  </span><br><span class="line">    any: true</span><br></pre></td></tr></table></figure>

<blockquote>
<p>以上是 VM 提供的 CRD</p>
</blockquote>
<h1 id="OpenTelemetry-诞生"><a href="#OpenTelemetry-诞生" class="headerlink" title="OpenTelemetry 诞生"></a>OpenTelemetry 诞生</h1><p>到此铺垫完成，不知道有没有发现在可观测性中关键的三个部分：日志、指标、trace 都是使用不同的开源产品，从而会导致技术栈较多，维护起来自然也是比较麻烦的。</p>
<p>这么一个软件领域的核心能力自然需要提供一个完整方案的，将以上的不同技术栈都整合在一起，更加的方便开发者使用。</p>
<p>在这之前也有两个社区想要做类似的事情：</p>
<ul>
<li>OpenTracing</li>
<li>OpenCensus</li>
</ul>
<p>不过他们并没有统一整个可观测领域，直到 2019 年 CNCF 社区宣布成立 OpenTelemetry，并且将上述两个社区进行合并共同开发 OpenTelemetry。</p>
<blockquote>
<p>背靠 CNCF 云原生社区加上许多知名厂商的支持（Google、Amazon、Redhat 等），现在已经正式成为 CNCF 的顶级项目了。</p>
</blockquote>
<h1 id="OpenTelemetry-架构介绍"><a href="#OpenTelemetry-架构介绍" class="headerlink" title="OpenTelemetry 架构介绍"></a>OpenTelemetry 架构介绍</h1><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c218188aad73dbfa126a99d5b790e19ea6bbcb7eee339bba93479f8b3c98c9b" alt></p>
<p>但我们打开 OpenTelemetry 社区的 GitHub 首页时，会看到有许多项目；第一反应应该是比较蒙的，下面我会着重介绍一些比较重要的项目。</p>
<p>在开始之前还是先简单介绍下 OpenTelemetry 的一些基础组件和概念：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77733c0ec5d07e1b1558148113cd48360d76a6167212c9daad00a86bb61ece5f" alt></p>
<p>整个 OpenTelemetry 系统其实可以简单分为三个部分：</p>
<ul>
<li>客户端</li>
<li>OTel collector</li>
<li>数据存储</li>
</ul>
<p>第一个客户端很好理解，也就是我们的业务应用；如果是 Java 应用只需要挂载一个 agent 就可以自动采集系统的指标、链路信息、日志等上传到 Collector 中。</p>
<p>也就是上图的左边部分。</p>
<p>之后就是非常关键的组件 collector，它可以通过 OTLP 协议接收刚才提到的客户端上传的数据，然后再内部进行处理，最终输出到后续的存储系统中。</p>
<h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c7e11281a19115764c48073408f3e77cc7c95ec6270e13eba126e795b95b470a" alt></p>
<blockquote>
<p>上图是 collector 的架构图</p>
</blockquote>
<p>由于 OpenTelemetry 设计之初就是要做到厂商无关，所以它就得做出更高层级的设计。</p>
<p>关键点就是这里的 Receiver 和 Exporter 都是模块化的设计，第三方开发者可以基于它的标准开发不同组件从而兼容不同的产品。</p>
<p>Receiver：用于接收客户端上报的数据，不止是自己 agent 上报的数据，也可能会来自不同的厂商，比如 kubernetes、Kafka 等。</p>
<p>Exporter：同理，可以将 receiver 收到的数据进行处理之后输出到不同的组件中；比如 Kafka/Pulsar/Promethus/Jaeger 等。</p>
<p>比如我们可以使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/nginxreceiver" target="_blank" rel="noopener">Nginx Receiver</a>接收来着 Nginx 上报的数据。</p>
<p>使用 <a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver/mysqlreceiver" target="_blank" rel="noopener">MySQL Receiver</a>接收来自 MySQL 的数据。</p>
<p>当然通常我们使用最多的还是 <a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/receiver/otlpreceiver" target="_blank" rel="noopener">OTLP Receiver</a>，这是官方的 OTLP 协议的接收器，可以接受官方的一些指标，比如我们只使用了 Java Agent 进行数据上报时。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/45653e2ffc4bda20dc01ce32cc09f4c34f2d59d97580b722aaf0a79c0d67c9c0" alt><br><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/receiver" target="_blank" rel="noopener">github.com/open-teleme…</a></p>
<p>在这里是可以看到目前支持的所有第三方的 Receiver。</p>
<hr>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/91aa8cf4e27df5524a07f3fb77f391629d0f28ce1de6f156ff9ab266b5d19215" alt></p>
<p>OpenTelemetry 所支持的 Exporter 也很多，比如一些常见的存储：</p>
<ul>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/clickhouseexporter" target="_blank" rel="noopener">clickhouse exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/elasticsearchexporter" target="_blank" rel="noopener">elasticsearch exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/pulsarexporter" target="_blank" rel="noopener">pulsar exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector-contrib/tree/main/exporter/prometheusexporter" target="_blank" rel="noopener">prometheus exporter</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-collector/tree/main/exporter/otlphttpexporter" target="_blank" rel="noopener">otlp http exporter</a></li>
</ul>
<p>Exporter 的使用场景很多：如果是指标相关的数据可以直接写入 Prometheus，如果是日志数据也可以直接写入 ElasticSearch。</p>
<p>如果还有其他的特殊需求（删减属性等）则可以写入消息队列，自行处理完之后再发往 collector 进行后续的处理。</p>
<p>可能你已经发现了，由于 collector 非常的灵活，所以我们可以像搭积木一样组装我们的 receiver 和 exporter，它会以我们配置的流水线的方式进行调用，这样我们就可以实现任意可定制的处理逻辑。</p>
<p>而这些流水线的组装对于客户端来说都是透明的，也就是说 collector 的更改完全不会影响到业务；业务只需要按照 OTLP 的格式上报数据即可。</p>
<p>在之前的从 Skywalking 切换到 OpenTelemetry 的文章中有人问为什么要切换到 OpenTelemetry？</p>
<p>从这里也能看得出来，OpenTelemetry 的灵活度非常高，借助于 Exporter 可以任意的更换后端存储，或者增加/删减一些不需要的指标数据等。</p>
<hr>
<p>当然我们也可以统一的在这里进行搜索，可以列出所有的第三方集成的组件：<br><a href="https://opentelemetry.io/ecosystem/registry/" target="_blank" rel="noopener">opentelemetry.io/ecosystem/r…</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2dbed9e5d4e33e7a58b64537667f4f82eff8a810cab62729d3b74e28f8139430" alt></p>
<h1 id="OpenTelemetry-项目介绍"><a href="#OpenTelemetry-项目介绍" class="headerlink" title="OpenTelemetry 项目介绍"></a>OpenTelemetry 项目介绍</h1><h2 id="opentelemetry-java"><a href="#opentelemetry-java" class="headerlink" title="opentelemetry-java"></a>opentelemetry-java</h2><p>介绍完基本的概念后，我们可以看看 OTel 社区的一些主要开源项目。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/547d35675ba02d35cf2c4d499cd41ae76f6c79dfaf18e9183b5e38bdc4c9360f" alt></p>
<p>这里我们还是以刚才的那个架构图从作往右讲起，也就是主要分为客户端和 collector 端。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/882ec918332d38f78b65692c86462ae89bfa942f29f7f17ffef973da45f58424" alt><br>目前官方支持的客户端语言已经非常齐全了，大部分的版本都已经是 Stable 稳定版，意味着可以进入生产环境。</p>
<p>这里我们以 Java 客户端为例：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/509b7711106eba858255916e07db6ea10db4883c34e5b880b86e597f7009570e" alt><br>其中我们重点关注下 opentelemetry-java 和 opentelemetry-java-instrumentation 这两个项目。</p>
<p>我们用的最多的会是 <code>opentelemetry-java-instrumentation</code>，它会给我们提供一个 java agent 的 JAR 包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码java -javaagent:path/to/opentelemetry-javaagent.jar \</span><br><span class="line">     -jar myapp.jar</span><br></pre></td></tr></table></figure>

<p>我们只需要在 Java 应用中加上该 agent 就可以实现日志、指标、trace 的自动上报。</p>
<p>而且它还实现了不同框架、库的指标采集与 trace。</p>
<p>在这里可以查到支持的库与框架列表：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4cca4f6d4396e3a52bbb2e85127b900559dccc734524d6f04321fbf61b551a43" alt></p>
<p><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation/blob/main/docs/supported-libraries.md#libraries--frameworks" target="_blank" rel="noopener">github.com/open-teleme…</a></p>
<blockquote>
<p>总之几乎就是你能想到和不能想到的都支持了。</p>
</blockquote>
<p>而 opentelemetry-java 我们直接使用的几率会小一些，opentelemetry-java-instrumentation 本身也是基于它创建的，可以理解为是 Java 版本的核心基础库，一些社区支持的组件就可以移动到 <code>instrumentation</code> 这个库中。</p>
<p>比如我在上篇文章：<a href="https://dev.newban.cn/7356138322367266854">从一个 JDK21+OpenTelemetry 不兼容的问题讲起</a>中涉及到的 <code>HostResourceProvider</code> 资源加载就是从 <code>opentelemetry-java</code> 中移动到了 <code>opentelemetry-java-instrumentation</code>。</p>
<p>具体可以参考：<a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701" target="_blank" rel="noopener">github.com/open-teleme…</a></p>
<h2 id="collector"><a href="#collector" class="headerlink" title="collector"></a>collector</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6a215cc3a475ae233ff274c1d5006d019c1de4c3c30211891cf9818c78109c63" alt></p>
<p>之后就是 collector 的组件了，它同样的也有两个库：<br><strong>OpenTelemetry Collector</strong> 和 <strong>OpenTelemetry Collector Contrib</strong></p>
<p>其实通过他们的名字也可以看得出来，他们的作用与刚才的 Java 库类似：</p>
<ul>
<li>opentelemetry-collector：由官方社区维护，提供了一些核心能力；比如只包含了最基本的 otlp 的 receiver 和 exporter。</li>
<li>opentelemetry-collector-contrib：包含了官方的 collector，同时更多的维护了社区提供的各种 receiver 和 exporter；就如上文提到的，一些社区组件（pulsar、MySQL、Kafka）等都维护在这个仓库。</li>
</ul>
<p>而我们生产使用时通常也是直接使用 opentelemetry-collector-contrib，毕竟它所支持的社区组件更多。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>因为 OpenTelemetry 想要解决的是整个可观测领域的所有需求，所以仓库非常多，社区也很开放，感兴趣的朋友可以直接参与贡献，这么多 repo 总有一个适合你的。</p>
<p>后续会继续讲解如何安装以及配置我们的 OpenTelemetry。</p>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/pinpoint-apm/pinpoint" target="_blank" rel="noopener">github.com/pinpoint-ap…</a></li>
<li><a href="https://github.com/codecentric/spring-boot-admin" target="_blank" rel="noopener">github.com/codecentric…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java-instrumentation" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
<li><a href="https://github.com/open-telemetry/opentelemetry-java/issues/4701" target="_blank" rel="noopener">github.com/open-teleme…</a></li>
</ul>
<p>#Blog #OpenTelemetry</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358450927110357026" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>监控,开源</tag>
      </tags>
  </entry>
  <entry>
    <title>Redission排行榜、计数器实战-java示例排行榜的</title>
    <url>/7358464072545501199.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redission 是一个在 Redis 的基础上提供了许多分布式数据结构和服务的 Java 库。在实现排行榜或计数器等功能时，Redission 可以利用 Redis 的数据结构，如有序集合（sorted set）和哈希（hash），来高效地完成这些任务。</p>
<h1 id="排行榜的实现"><a href="#排行榜的实现" class="headerlink" title="排行榜的实现"></a>排行榜的实现</h1><p>在 Redis 中，有序集合（sorted set）是实现排行榜的理想数据结构，因为它能够保存唯一元素的集合，并且每个元素都关联着一个分数（score），集合中的元素会根据分数自动排序。</p>
<p>使用 Redission 实现排行榜的基本步骤如下：</p>
<ol>
<li>创建有序集合：使用 Redission 的 <code>RScoredSortedSet</code> 接口创建一个有序集合。</li>
<li>添加元素：向有序集合中添加元素（成员）及其对应的分数（score）。</li>
<li>获取排行：使用有序集合的方法获取元素的排名，以及根据排名或分数范围检索元素。</li>
</ol>
<h2 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例:"></a>代码示例:</h2><p>例如，以下是一段使用 Redission 实现排行榜的简单代码示例：</p>
<h3 id="poxm配置"><a href="#poxm配置" class="headerlink" title="poxm配置:"></a>poxm配置:</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.16.4&lt;/version&gt; </span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="java-代码："><a href="#java-代码：" class="headerlink" title="java 代码："></a>java 代码：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.Redisson;</span><br><span class="line">import org.redisson.api.RScoredSortedSet;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.redisson.config.Config;</span><br><span class="line"></span><br><span class="line">import java.util.Collection;</span><br><span class="line"></span><br><span class="line">public class LeaderboardRedissonExample &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // 配置 Redisson 客户端</span><br><span class="line">        Config config = new Config();</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;); // 替换为你的 Redis 服务器地址和端口</span><br><span class="line"></span><br><span class="line">        // 创建 Redisson 客户端实例</span><br><span class="line">        RedissonClient redisson = Redisson.create(config);</span><br><span class="line"></span><br><span class="line">        // 获取有序集合实例</span><br><span class="line">        RScoredSortedSet&lt;String&gt; leaderboard = redisson.getScoredSortedSet(&quot;userLeaderboard&quot;);</span><br><span class="line"></span><br><span class="line">        // 添加用户及其分数到排行榜</span><br><span class="line">        leaderboard.addScore(&quot;user1&quot;, 100);</span><br><span class="line">		  leaderboard.addScore(&quot;user2&quot;, 150);</span><br><span class="line">        leaderboard.addScore(&quot;user3&quot;, 120);</span><br><span class="line"></span><br><span class="line">        // 获取排行榜中的所有用户及其分数</span><br><span class="line">        Collection&lt;String&gt; topUsers = leaderboard.readAll();</span><br><span class="line">        for (String user : topUsers) &#123;</span><br><span class="line">            Double score = leaderboard.getScore(user);</span><br><span class="line">            System.out.println(&quot;User: &quot; + user + &quot;, Score: &quot; + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 获取特定用户的排名（排名从0开始，所以显示时需要加1）</span><br><span class="line">        int rank = leaderboard.rank(&quot;user2&quot;) + 1;</span><br><span class="line">        System.out.println(&quot;User2&apos;s rank: &quot; + rank);</span><br><span class="line"></span><br><span class="line">        // 获取排行榜前3名用户及其分数</span><br><span class="line">        Collection&lt;String&gt; topThreeUsers = leaderboard.entryRange(0, 2);</span><br><span class="line">        for (String user : topThreeUsers) &#123;</span><br><span class="line">            Double score = leaderboard.getScore(user);</span><br><span class="line">            System.out.println(&quot;Top User: &quot; + user + &quot;, Score: &quot; + score);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 关闭 Redisson 客户端</span><br><span class="line">        redisson.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们使用了 Redisson 的 <code>RScoredSortedSet</code> 接口来实现一个排行榜。有序集合在 Redis 中以分数作为排序的依据，这使得它非常适合用来实现排行榜。</p>
<h1 id="计数器的实现"><a href="#计数器的实现" class="headerlink" title="计数器的实现"></a>计数器的实现</h1><p>Redis 的字符串（string）数据类型可以用作计数器，通过原子操作 <code>INCR</code> 和 <code>DECR</code> 来增加或减少计数器的值。</p>
<p>使用 Redission 实现计数器的基本步骤如下：</p>
<ol>
<li>创建计数器：使用 Redission 的 <code>RAtomicLong</code> 接口创建一个原子长整型计数器。</li>
<li>增加/减少值：使用计数器的 <code>incrementAndGet()</code> 或 <code>decrementAndGet()</code> 方法来原子地增加或减少计数器的值。</li>
</ol>
<h2 id="代码示例-1"><a href="#代码示例-1" class="headerlink" title="代码示例:"></a>代码示例:</h2><p>例如，以下是一段使用 Redission 实现计数器的简单代码示例：</p>
<p>在Spring框架中使用Redisson实现计数器，首先需要将Redisson的依赖添加到你的Spring Boot项目中。如果你使用Maven，可以在<code>pom.xml</code>文件中添加以下依赖：</p>
<h3 id="pom-配置："><a href="#pom-配置：" class="headerlink" title="pom 配置："></a>pom 配置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.redisson&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;redisson&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;3.16.4&lt;/version&gt; </span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<h3 id="配置Redisson客户端"><a href="#配置Redisson客户端" class="headerlink" title="配置Redisson客户端"></a>配置Redisson客户端</h3><p>在Spring Boot应用中，你可以创建一个配置类来设置Redisson：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.Redisson;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.redisson.config.Config;</span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class RedissonConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public RedissonClient redissonClient() &#123;</span><br><span class="line">        Config config = new Config();</span><br><span class="line">          // 替换为你的Redis服务器地址和端口</span><br><span class="line">        config.useSingleServer().setAddress(&quot;redis://127.0.0.1:6379&quot;);</span><br><span class="line">        return Redisson.create(config);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Spring组件中注入RedissonClient"><a href="#Spring组件中注入RedissonClient" class="headerlink" title="Spring组件中注入RedissonClient"></a>Spring组件中注入<code>RedissonClient</code></h3><p>使用它来创建和操作计数器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.redisson.api.RAtomicLong;</span><br><span class="line">import org.redisson.api.RedissonClient;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class CounterService &#123;</span><br><span class="line"></span><br><span class="line">    private final RedissonClient redissonClient;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public CounterService(RedissonClient redissonClient) &#123;</span><br><span class="line">        this.redissonClient = redissonClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long incrementCounter(String counterName) &#123;</span><br><span class="line">        RAtomicLong atomicLong = redissonClient.getAtomicLong(counterName);</span><br><span class="line">        return atomicLong.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public long getCounterValue(String counterName) &#123;</span><br><span class="line">        RAtomicLong atomicLong = redissonClient.getAtomicLong(counterName);</span><br><span class="line">        return atomicLong.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务类中，我们定义了两个方法：<code>incrementCounter</code>用于递增计数器的值，<code>getCounterValue</code>用于获取计数器的当前值。</p>
<h3 id="控制器中使用这个服务："><a href="#控制器中使用这个服务：" class="headerlink" title="控制器中使用这个服务："></a>控制器中使用这个服务：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.web.bind.annotation.GetMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line">import org.springframework.web.bind.annotation.RequestParam;</span><br><span class="line">import org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line">@RestController</span><br><span class="line">@RequestMapping(&quot;/counter&quot;)</span><br><span class="line">public class CounterController &#123;</span><br><span class="line"></span><br><span class="line">    private final CounterService counterService;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    public CounterController(CounterService counterService) &#123;</span><br><span class="line">        this.counterService = counterService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/increment&quot;)</span><br><span class="line">    public long increment(@RequestParam(&quot;name&quot;) String counterName) &#123;</span><br><span class="line">        return counterService.incrementCounter(counterName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/get&quot;)</span><br><span class="line">    public long get(@RequestParam(&quot;name&quot;) String counterName) &#123;</span><br><span class="line">        return counterService.getCounterValue(counterName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个控制器中，我们创建了两个端点：一个用于递增计数器的值，另一个用于获取计数器的当前值。</p>
<p>在这个示例中，我们使用了 Redisson 的 <code>RAtomicLong</code> 接口来实现一个原子计数器。这个计数器可以安全地在多个线程或进程中增加或减少其值，因为 Redis 提供了原子操作保证。</p>
<h2 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h2><p>Redission 的原理主要是对 Redis 的各种操作提供了方便的 Java API。它封装了 Redis 的命令，使得开发者可以像操作本地 Java 对象一样使用 Redis 的数据结构和服务。</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ol>
<li>性能：Redis 是一个内存中的数据结构存储，提供极高的性能。</li>
<li>简单：Redission 提供了简单直观的 API，易于使用。</li>
<li>分布式：Redission 利用 Redis 的特性，可以很容易地实现分布式数据结构和服务。</li>
<li>丰富的功能：Redission 提供了丰富的分布式对象和服务，如分布式锁、队列、映射等。</li>
</ol>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>内存限制：由于 Redis 是基于内存的，数据量的大小受限于服务器内存。</li>
<li>持久性：虽然 Redis 提供了持久化机制，但在极端情况下可能会丢失数据。</li>
<li>复杂性：在大型系统中，管理 Redis 实例和确保其高可用性可能会增加系统的复杂性。</li>
</ol>
<p>总体来说，Redission 是一个功能强大的库，可以帮助 Java 开发者轻松地使用 Redis 实现排行榜、计数器和其他分布式数据结构和服务。然而，它也继承了 Redis 的限制，需要根据具体应用场景权衡其优缺点。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358464072545501199" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Redis,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>聊聊JIT是如何影响JVM性能的！方法内联分层编译逃逸</title>
    <url>/7358628571232190505.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>文章内容收录到个人网站，方便阅读</strong>：<a href="http://hardyfish.top/" target="_blank" rel="noopener">hardyfish.top/</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/328c647652bd5fae03b418d33dddf6e44b914720e1af269c2fe5a141a600132a" alt="image.png"></p>
<p>我们知道Java虚拟机栈是线程私有的，每个线程对应一个栈，每个线程在执行一个方法时会创建一个对应的栈帧，栈帧负责存储局部变量变量表、操作数栈、动态链接和方法返回地址等信息，每个方法的调用过程，相当于栈帧在Java栈的入栈和出栈过程</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c0a39f412d57aa3967df02152fa0c344a84c76574d61a3922a8d53a17ac96167" alt="图片"></p>
<p>但是栈帧的创建是需要耗费资源的，尤其是对于 Java 中常见的 getter、setter 方法来说，这些代码通常只有一行，每次都创建栈帧的话就太浪费了。</p>
<p>另外，Java 虚拟机栈对代码的执行，采用的是字节码解释执行的方式，考虑到下面这段代码，变量 a 声明之后，就再也不被使用，要是按照字节码指令解释执行的话，就要做很多无用功。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码public class A&#123;</span><br><span class="line">    int attr = 0;</span><br><span class="line">    public void test()&#123;</span><br><span class="line">        int a = attr;</span><br><span class="line">        System.out.println(&quot;月伴飞鱼&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码javap -v A</span><br></pre></td></tr></table></figure>

<p>可以看到这段代码的字节码指令</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/00d16db6e85aee80b99ca93d0d8d6fd3d8d78e9e47f02f784c39c8d420460a9e" alt="图片"></p>
<p>我们能够看到 <code>aload_0，getfield ，istore_1</code> 这三个无用的字节码指令操作。</p>
<blockquote>
<p>❝</p>
<p>aload_0 从局部变量0中装载引用类型值，getfield 从对象中获取字段，istore_1 将int类型值存入局部变量1</p>
<p>❞</p>
</blockquote>
<p>另外，我们知道垃圾回收器回收的目标区域主要是堆，堆上创建的对象越多，GC 的压力就越大。要是能把一些变量，直接在栈上分配，那 GC 的压力就会小一些。</p>
<p>其实，我们说的这几个优化的可能性，JVM 已经通过JIT 编译器（Just In Time Compiler）去做了，JIT 最主要的目标是把解释执行变成编译执行。</p>
<p>为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，这就是 JIT 编译器的功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3750eff2246c55203ce4a60f4085fc5af08385b4223792da228d3f9878c9c163" alt="图片"></p>
<p>如上图，JVM 会将调用次数很高，或者在 for 循环里频繁被使用的代码，编译成机器码，然后缓存起来，下次调用相同方法的时候，就可以直接使用。</p>
<p>那 JIT 编译都有哪些手段呢？接下来我们详细介绍。</p>
<h1 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h1><p>方法内联它会把一些短小的方法体，直接纳入目标方法的作用范围之内，就像是直接在代码块中追加代码。这样，就少了一次方法调用，执行速度就能够得到提升，这就是方法内联的概念。</p>
<p>可以使用 <code>-XX:-Inline</code> 参数来禁用方法内联，如果想要更细粒度的控制，可以使用 CompileCommand 参数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码-XX:CompileCommand=exclude,java/lang/String.indexOf</span><br></pre></td></tr></table></figure>

<p>在 JDK 的源码里，也有很多被 @ForceInline注解的方法，这些方法，会在执行的时候被强制进行内联；而被@DontInline注解的方法，则始终不会被内联。</p>
<p>JIT 编译之后的二进制代码，是放在 Code Cache 区域里的。这个区域的大小是固定的，而且一旦启动无法扩容。如果 Code Cache 满了，JVM 并不会报错，但会停止编译。所以编译执行就会退化为解释执行，性能就会降低。不仅如此，JIT 编译器会一直尝试去优化你的代码，造成 CPU 占用上升。</p>
<p>通过参数 <code>-XX:ReservedCodeCacheSize</code> 可以指定 Code Cache 区域的大小，如果你通过监控发现空间达到了上限，就要适当的增加它的大小。</p>
<h1 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h1><p>HotSpot 虚拟机包含多个即时编译器，有 C1，C2 和 Graal，JDK8 以后采用的是分层编译的模式。</p>
<p>JMV使用额外线程进行即时编译，可以不用阻塞解释执行的逻辑。JIT 通常会在触发之后就在后台运行，编译完成之后就将相应的字节码替换为编译后的代码。</p>
<p><strong>「JIT 编译方式有两种：一种是编译方法，另一种是编译循环。」</strong></p>
<p>具体介绍下几个编译器</p>
<p><strong>「C1 编译器」</strong></p>
<p>C1 编译器是一个简单快速的编译器，主要的关注点在于局部性的优化，适用于执行时间较短或对启动性能有要求的程序，也称为Client Compiler，例如，GUI 应用对界面启动速度就有一定要求。</p>
<p><strong>「C2 编译器」</strong></p>
<p>C2 编译器是为长期运行的服务器端应用程序做性能调优的编译器，适用于执行时间较长或对峰值性能有要求的程序，也称为Server Compiler，例如，服务器上长期运行的 Java 应用对稳定运行就有一定的要求。</p>
<p>在 Java7 之前，需要根据程序的特性来选择对应的 JIT，虚拟机默认采用解释器和其中一个编译器配合工作。</p>
<p><strong>「分层编译」</strong></p>
<p>Java7 引入了分层编译，这种方式综合了 C1 的启动性能优势和 C2 的峰值性能优势，我们也可以通过参数 -client或者-server 强制指定虚拟机的即时编译模式。</p>
<p>通常情况下，C2 的执行效率比 C1 高出30%以上。</p>
<p>注意：在 Java8 中，默认开启分层编译，-client 和 -server 的设置已经是无效的了。</p>
<p>如果只想开启 C2，可以关闭分层编译<code>（-XX:-TieredCompilation）</code>，如果只想用 C1，可以在打开分层编译的同时，使用参数：<code>-XX:TieredStopAtLevel=1</code>。</p>
<p>我们可以通过 java -version命令行可以直接查看到当前系统使用的编译模式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码C:\Users\Administrator&gt;java -version</span><br><span class="line">java version &quot;1.8.0_45&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_45-b14)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.45-b02, mixed mode)</span><br></pre></td></tr></table></figure>

<p>mixed mode代表是默认的混合编译模式，除了这种模式外，我们还可以使用-Xint参数强制虚拟机运行于只有解释器的编译模式下，这时 JIT 完全不介入工作；也可以使用参数-Xcomp强制虚拟机运行于只有 JIT 的编译模式下</p>
<h1 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h1><p>下面着重讲解一下逃逸分析，这个知识点在面试的时候经常会被问到。</p>
<p>有这样一个问题：我们常说的对象，除了基本数据类型，一定是在堆上分配的吗？</p>
<p>答案是否定的，通过逃逸分析，JVM 能够分析出一个新的对象的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析现在是 JVM 的默认行为，可以通过参数<code>-XX:-DoEscapeAnalysis</code> 关掉它。</p>
<p>那什么样的对象算是逃逸的呢？可以看一下下面的两种典型情况。</p>
<p>如代码所示，对象被赋值给成员变量或者静态变量，可能被外部使用，变量就发生了逃逸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class EscapeAttr &#123;</span><br><span class="line">    Object attr;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        attr = new Object();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再看下面这段代码，对象通过 return 语句返回。由于程序并不能确定这个对象后续会不会被使用，外部的线程能够访问到这个结果，对象也发生了逃逸。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class EscapeReturn &#123;</span><br><span class="line">    Object attr;</span><br><span class="line">    public Object test() &#123;</span><br><span class="line">        Object obj = new Object();</span><br><span class="line">        return obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那逃逸分析有什么好处呢？</p>
<p><strong>「1. 栈上分配」</strong></p>
<p>如果一个对象在子程序中被分配，指向该对象的指针永远不会逃逸，对象有可能会被优化为栈分配。栈分配可以快速地在栈帧上创建和销毁对象，不用再分配到堆空间，可以有效地减少 GC 的压力。</p>
<p><strong>「2. 分离对象或标量替换」</strong></p>
<p>但对象结构通常都比较复杂，如何将对象保存在栈上呢？</p>
<p>JIT 可以将对象打散，全部替换为一个个小的局部变量，这个打散的过程，就叫作标量替换（标量就是不能被进一步分割的变量，比如 int、long 等基本类型）。也就是说，标量替换后的对象，全部变成了局部变量，可以方便地进行栈上分配，而无须改动其他的代码。</p>
<p>从上面的描述我们可以看到，并不是所有的对象或者数组，都会在堆上分配。由于JIT的存在，如果发现某些对象没有逃逸出方法，那么就有可能被优化成栈分配。</p>
<p><strong>「3.同步消除」</strong></p>
<p>如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</p>
<p>注意这是针对 synchronized 来说的，JUC 中的 Lock 并不能被消除。</p>
<p>要开启同步消除，需要加上 <code>-XX:+EliminateLocks</code> 参数。由于这个参数依赖逃逸分析，所以同时要打开 <code>-XX:+DoEscapeAnalysis</code> 选项。</p>
<p>比如下面这段代码，JIT 判断对象锁只能被一个线程访问，就可以去掉这个同步的影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SyncEliminate &#123;</span><br><span class="line">    public void test() &#123;</span><br><span class="line">        synchronized (new Object()) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p><strong>文章内容收录到个人网站，方便阅读</strong>：<a href="http://hardyfish.top/" target="_blank" rel="noopener">hardyfish.top/</a></p>
<p>JIT 是现代 JVM 主要的优化点，能够显著地提升程序的执行效率。从解释执行到最高层次的 C2，一个数量级的性能提升也是有可能的。</p>
<p>注意：JIT 优化并不见得每次都有用，比如代码中如果发生死循环。但如果你在启动的时候，加上<code>-Djava.compiler=NONE</code> 参数，禁用 JIT，它就能够执行下去。</p>
<p>这篇文章中我们主要看了方法内联、逃逸分析等概念，了解到一些方法在被优化后，对象并不一定是在堆上分配的，它可能在被标量替换后，直接在栈上分配。这几个知识点也是在面试中经常被问到的。</p>
<p>JIT 的这些优化一般都是在后台进程默默地去做了，我们不需要关注太多。同时Code Cache 的容量达到上限，会影响程序执行的效率，但除非你有特别多的代码，默认的 240M 一般来说，足够用了。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358628571232190505" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>一款国产的开发辅助AI插件！一Comate介绍二价</title>
    <url>/7358628571231305769.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>@[toc]<br>昨天百度举行了 Create 2024 百度 AI 开发者大会，松哥得以近距离了解了百度的 AI 产品，以前就了解文心一言，其他的都用的少。昨天在会场上李彦宏介绍了百度的一个 AI 辅助工具 Comate，晚上回来赶紧体验了一把。</p>
<h1 id="一-Comate-介绍"><a href="#一-Comate-介绍" class="headerlink" title="一 Comate 介绍"></a>一 Comate 介绍</h1><p>百度的 Comate 插件是一款基于文心大模型的智能代码助手，它结合了百度多年积累的编程现场大数据和外部优秀开源数据，为开发者提供了全方位的编码辅助工具。这款插件的主要优势在于其智能性、丰富的应用场景、创造价值以及广泛的应用范围，能够实现“帮你想、帮你写、帮你改”的场景应用形态，从而显著提升编码效率，释放“十倍”软件生产力。</p>
<p>具体来说，“帮你想”体现在 Comate 插件的代码解释和代码知识问答功能上。它能够对整个函数代码或部分选中代码进行解释，让开发者快速理解新代码的含义。同时，开发者只需在对话框中用自然语言提问，就能立刻得到答案，极大地提高了学习和工作的效率。</p>
<p>“帮你写”的功能则包括实时续写、注释生成代码、生成函数注释、生成单元测试等。Comate 还支持单行推荐、多行推荐、多条推荐、代码生成、注释生成、注释文档生成等一系列编码相关能力。此外，它还能全面分析代码上下文、依赖文件、相邻文件的逻辑关系，使代码语法更规范、逻辑更严谨。</p>
<p>在“帮你改”方面，Comate 能够对长函数等可能存在问题的代码进行优化，发现并自动修复代码中的潜在错误，从而提高企业研发工作的脚本效率。</p>
<p>此外，Comate 插件还可以轻松集成到开发者最常用的主流集成开发环境中，如 VSCode、IntelliJ IDEA、XCode 等，开发者可以通过插件的方式在不同的软件中使用 Comate，极大地提高了开发工作的便利性和效率。</p>
<p>此外，Comate 还提供数据可视化功能，包括采纳率、采纳量趋势、采纳量按功能或语言分布等，帮助个人和企业全方位可视化提效成果，助力提效与复盘。同时，它还提供私有化部署服务以及详尽的技术支持，确保公司信息安全，让开发者在享受高效编码的同时无后顾之忧。</p>
<h1 id="二-价格"><a href="#二-价格" class="headerlink" title="二 价格"></a>二 价格</h1><p>很多小伙伴可能比较关心这个问题。</p>
<p>这是官方的三个不同的价格版本：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4bf25fa73a64a2ca560d6c6e98aa2c51877637c2281b8b68fd4c895b719e117a" alt></p>
<p>个人使用是免费的，另外，<strong>个人每周可免费使用 300 次高级功能</strong>，我觉得这个也够用了。</p>
<h1 id="三-安装"><a href="#三-安装" class="headerlink" title="三 安装"></a>三 安装</h1><p>安装比较容易，我们直接在 IDEA 的插件市场搜索 comate 安装即可：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/55f1d1276ec7c59bd23649885a55f3e223e521569f2e00eb1954057464279d49" alt></p>
<p>安装完成后，重启 IDEA。</p>
<p>重启之后我们在 IDEA 的右边栏可以看到 Baidu Comate 以及登录提示，这个插件要登录自己的百度账号后才可以使用。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/56d979657e691822e076f6a7dd2e399fa27ea915a54e24da1ef2e97da0ec90f3" alt></p>
<p>登录百度账号之后，会在 <a href="https://comate.baidu.com/zh/user" target="_blank" rel="noopener">comate.baidu.com/zh/user</a> 页面拿到自己的一个 License，然后在 IDEA 中配置一下用户名和 License，就可以使用了 Comate 了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/054d712b3cb79b5deec3f81b9bce816085033aa021e894f8477aefd3bf1c6765" alt></p>
<h1 id="四-体验"><a href="#四-体验" class="headerlink" title="四 体验"></a>四 体验</h1><p>装好之后来体验一把吧！</p>
<h2 id="4-1-智能推荐"><a href="#4-1-智能推荐" class="headerlink" title="4.1 智能推荐"></a>4.1 智能推荐</h2><h3 id="4-1-1-单行推荐"><a href="#4-1-1-单行推荐" class="headerlink" title="4.1.1 单行推荐"></a>4.1.1 单行推荐</h3><p>单行推荐是在续写代码场景中最直接、最高效的体现方式。在打开一个代码文件后，开始编码。在编码过程中稍微等待一下，即可看到 Baidu Comate 的推荐内容。</p>
<p>如下图，灰色代码就是 Comate 自动提示的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/23acb551b243ec297e61ac6fb468cef28ba2b5ba6ce7fc9ea5f2f917fd0781cf" alt></p>
<p>按 Tab 键可以选中自动提示的代码。</p>
<p>Comate 相关的操作可以参考下面这个表格：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/929ea6dffee5b4ed92ab99998c0848d7616c32413f8f7c0a71dc9860f5e6109e" alt></p>
<h3 id="4-1-2-多行推荐"><a href="#4-1-2-多行推荐" class="headerlink" title="4.1.2 多行推荐"></a>4.1.2 多行推荐</h3><p>多行推荐就是直接给一个完整的方法逻辑，类似下面这样：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/aefe051dcd99ba6c4d3ff12520be7b8f39dc39a1f5dd20a1a2662ffd9a539511" alt></p>
<p>可以按照提示给出来的快捷键，逐行采纳推荐的代码，也可以直接 Tab 键采纳所有。</p>
<p>不过对于一些涉及到最新 API 的，似乎还不能准确提示，例如下面这段提示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f6c3dec4b1e1cefac871a2bf78f8d0131bbc39beebbbf0611516a5189c613706" alt></p>
<p>实际上我现在使用的是最新版的 Spring Security，但是这里的提示不对。</p>
<h2 id="4-2-智能生成"><a href="#4-2-智能生成" class="headerlink" title="4.2 智能生成"></a>4.2 智能生成</h2><h3 id="4-2-1-注释生成代码"><a href="#4-2-1-注释生成代码" class="headerlink" title="4.2.1 注释生成代码"></a>4.2.1 注释生成代码</h3><p>写好注释之后，按回车，就会有提示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ab3c428e0dc7b0ced6db65a682bd0b927dde5b9f33bf260bc60a332f0352b70d" alt></p>
<h3 id="4-2-2-增强生成代码"><a href="#4-2-2-增强生成代码" class="headerlink" title="4.2.2 增强生成代码"></a>4.2.2 增强生成代码</h3><p>如果觉得注释生成代码中的结果不够准确，那么还可以使用增强生成代码功能调起更加精准的模型来理解和生成代码。</p>
<p>在通过注释生成代码之后，会出现<strong>增强生成</strong>按钮，如下图，点击<strong>增强生成</strong>，调出 Baidu Comate 对话框；然后等待结果返回即可。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e41ab68fc7a2bd60a6763ff29f24cc8cbf1dcc3dc12052c2a88b9e35a7ee8cf2" alt></p>
<h3 id="4-2-3-生成单元测试"><a href="#4-2-3-生成单元测试" class="headerlink" title="4.2.3 生成单元测试"></a>4.2.3 生成单元测试</h3><p>鼠标右键点击函数名前方的 Baidu Comate 图标，选择<strong>生成单测</strong>或者或右键点击函数名，选择<strong>Comate代码工具</strong> → <strong>生成单测</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5feb57a77614a4073a4ab5d080b40d983a267d8723bf0ff0bc10d995467d89fa" alt></p>
<p>单元测试生成之后，点击采纳，就可以自动在单元测试包下面生成对应的测试类：</p>
<p><img src alt="转存失败，建议直接上传图片文件"></p>
<h3 id="4-2-4-生成代码注释"><a href="#4-2-4-生成代码注释" class="headerlink" title="4.2.4 生成代码注释"></a>4.2.4 生成代码注释</h3><h4 id="文档注释"><a href="#文档注释" class="headerlink" title="文档注释"></a>文档注释</h4><p>生成的代码注释有两种，一种是文档注释，另外一种是行间注释。</p>
<p>我们可以点击函数名上方的<strong>函数注释</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cf75dc40649b16f836ffdd8582205215d422a309c6fe747a08ab94fe722f6504" alt></p>
<p>右边会唤起 Comate，代码注释生成之后，点击采纳，就会自动添加到方法头部。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/592ebc7b1a44f721b8b7b65b75627096a3cf8b9a3a37d13412c56e8d6d7a3bdf" alt></p>
<h4 id="行间注释"><a href="#行间注释" class="headerlink" title="行间注释"></a>行间注释</h4><p>行间注释是针对一段已有的代码，按段落生成行间注释。不过这个功能有一个限制条件，就是函数少于4500个字符时才有这个功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c91794fca907436d6fb7dd1d7524db4d9e6b0f75e51bab44b94703f1108d7dbe" alt></p>
<p>右边会唤起 Comate，代码注释生成之后，点击采纳，注释就会自动添加到方法里边。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/58bf11d3e4d16f574455d8d617e983181114a3d311d5488ab185a5cb7c85b289" alt></p>
<h2 id="4-3-代码解释"><a href="#4-3-代码解释" class="headerlink" title="4.3 代码解释"></a>4.3 代码解释</h2><p>代码解释就是使用大语言模型对给定的代码进行深入理解，然后生成易于人类理解的自然语言解释。这个功能可以协助开发人员迅速理解现有的代码，从而提高研发效率。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/20ca27e875e06c9f430cd97a23bbb5519e7ae27f4362a39e87e84096f6089b9d" alt></p>
<p>大家来看下，我感觉这个生成的解释还可以：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8b77622bb322d4859608056357657673953d8c9d57c04aac6fc2585deb15d80c" alt></p>
<h2 id="4-4-调优建议"><a href="#4-4-调优建议" class="headerlink" title="4.4 调优建议"></a>4.4 调优建议</h2><p>调优建议是一个旨在帮助开发者便捷优化代码质量的功能，通过大语言模型分析所选函数，提供有针对性的建议，如使代码更加规范易读，或提高执行效率、减少资源消耗。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/924ea139cdf23ce9ed3a99b19543f23fe72e137017e04bfbbc95cc6aff66e703" alt></p>
<p>似乎也还不错：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3263ea3b3733ddac37c1faaa7e4a8df5b0a23c8f60916dcd427ac6cfa1c48077" alt></p>
<h2 id="4-5-长函数拆分"><a href="#4-5-长函数拆分" class="headerlink" title="4.5 长函数拆分"></a>4.5 长函数拆分</h2><p>长函数拆分主要用于将一个冗长的函数，拆分成多个短函数，使得代码更加简洁易读，易于复用和维护。当函数大于等于20行，且少于4500个字符时将提供该功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d355c6bc548f4cadeeb325cd8b4cef4302d55373117c6745ab4ae995779334bb" alt></p>
<p>如果你的函数长度小于 20 行，那么就没有函数拆分这个选项。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d76017e5877bdced81460fca74f6791b638a69fb7d7a37dcd539c91e6288839d" alt></p>
<p>这个生成的还不错，点击采纳可以直接使用。</p>
<h1 id="五-智能问答"><a href="#五-智能问答" class="headerlink" title="五 智能问答"></a>五 智能问答</h1><p>点击 IDEA 右边栏可以唤起 Comate。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1d2b55520660e07beef8b689e95b317f0d9f8e419f6cfb9fe1fe3719539f8801" alt></p>
<p>唤起之后就可以直接提问了，支持多轮对话。</p>
<p>另外也可以选中代码输入问题。先选中代码，然后输入问题，这样 Comate 就会围绕生成的代码来展开对话。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ec95cefea8b39e36eb938b13995d6fc2b2a6c6fbdded27d76340aa0f6b4d4bd0" alt></p>
<h1 id="六-其他能力"><a href="#六-其他能力" class="headerlink" title="六 其他能力"></a>六 其他能力</h1><h2 id="6-1-插件配置"><a href="#6-1-插件配置" class="headerlink" title="6.1 插件配置"></a>6.1 插件配置</h2><p>Comate 提供了一些插件的能力，不过目前支持的插件不多。在和 Comate 交互的时候，通过 <code>@</code> 可以唤起插件。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/79e874d41f8b7af6fde5ffd73779bed0a1d2867a35f9c90b75a212ab63122e86" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/78404e499a7459dcf9f6ff687ed7016c7534859e4eecdb1bd2694edb9a243619" alt></p>
<p>如果需要对这些插件进行配置，可以在我网页上配置：</p>
<ul>
<li><a href="https://comate.baidu.com/cop/configSet/list" target="_blank" rel="noopener">comate.baidu.com/cop/configS…</a></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/11a455382d96a48093e75050d3c96a4706ce692640ca6f04079478845cd5719d" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ee203e273f3783c254928c2f007ecf4b47419c2873370a132114df246056b16c" alt></p>
<h2 id="6-2-知识中心"><a href="#6-2-知识中心" class="headerlink" title="6.2 知识中心"></a>6.2 知识中心</h2><p>利用 Comate 这个能力，我们可以非常方便的引入自己的知识集，比如松哥写了很多文档，我可以把这些文章内容构建成一个知识集，那么在发起自然语言对话的时候，就会自动使用到我的这些知识集。</p>
<p>这个我们可以在网页端进行配置。</p>
<ul>
<li><a href="https://comate.baidu.com/cop/knowledge/list" target="_blank" rel="noopener">comate.baidu.com/cop/knowled…</a></li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0606ab40d59b62e2805ab97844b2b62ae0322d8497cef0994be90b4cc285a55e" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2b22ae603257494e787b6751a01eb2fcf6a8b0e4adecda096086f9d81e15d92f" alt></p>
<p>新建知识集，然后上传即可。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f08cff4b74b2aeca2bd10d5794b1237fa7da2ad208da819d62b5f000cabd618a" alt></p>
<p>当我们和 Comate 对话的时候，可以通过 <code>#</code> 唤起，然后选择自己的知识库。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/183ee85d9dfd7df66647c38511e76ad8585bcb26c063e8d64af7111f4ed0ac2f" alt></p>
<p>好啦，小伙伴们感兴趣的话不妨去体验一下哦～</p>
<p>再来一个小视频，松哥带你体验 Baidu AI 开发者大会！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358628571231305769" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>实现视频的喜欢和不喜欢功能：Node.js与Mongoose</title>
    <url>/7358664464998842406.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="实现视频的喜欢和不喜欢功能：Node-js与Mongoose的实践指南"><a href="#实现视频的喜欢和不喜欢功能：Node-js与Mongoose的实践指南" class="headerlink" title="实现视频的喜欢和不喜欢功能：Node.js与Mongoose的实践指南"></a>实现视频的喜欢和不喜欢功能：Node.js与Mongoose的实践指南</h3><p>在视频分享或社交媒体平台中，”喜欢”和”不喜欢”的功能是用户互动的重要组成部分。本篇博客将详细介绍如何在使用Node.js和Mongoose的环境中实现这一功能。我们将通过创建模型、路由和控制器来逐步搭建这一功能。</p>
<h4 id="1-路由的设置"><a href="#1-路由的设置" class="headerlink" title="1. 路由的设置"></a>1. 路由的设置</h4><p>首先，我们需要为”喜欢”和”不喜欢”功能设置路由。这些路由将处理对特定视频的喜欢或不喜欢的请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// router/video.js</span><br><span class="line">router</span><br><span class="line">  .get(&apos;/like/:videoId&apos;, verifyToken(), videoController.likeVideo)</span><br><span class="line">  .get(&apos;/dislike/:videoId&apos;, verifyToken(), videoController.disLikeVideo);</span><br></pre></td></tr></table></figure>

<p>这里使用了<code>verifyToken()</code>中间件来确保只有认证过的用户可以进行操作。</p>
<h4 id="2-数据模型的创建"><a href="#2-数据模型的创建" class="headerlink" title="2. 数据模型的创建"></a>2. 数据模型的创建</h4><p>我们需要一个模型来存储用户对视频的喜欢或不喜欢的状态。我们创建了<code>videoLikeModel</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// model/videoLikeModel.js</span><br><span class="line">const mongoose = require(&apos;mongoose&apos;);</span><br><span class="line">const baseModel = require(&apos;./baseModel&apos;);</span><br><span class="line"></span><br><span class="line">const videoLikeSchema = new mongoose.Schema(&#123;</span><br><span class="line">  user: &#123;</span><br><span class="line">    type: mongoose.ObjectId,</span><br><span class="line">    required: true,</span><br><span class="line">    ref: &quot;User&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  video: &#123;</span><br><span class="line">    type: mongoose.ObjectId,</span><br><span class="line">    required: true,</span><br><span class="line">    ref: &quot;Video&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  like: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    enum: [1, -1], // 1 表示喜欢, -1 表示不喜欢</span><br><span class="line">    required: true</span><br><span class="line">  &#125;,</span><br><span class="line">  ...baseModel</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">module.exports = videoLikeSchema;</span><br></pre></td></tr></table></figure>

<p>此模型关联了用户和视频，并记录了用户是喜欢还是不喜欢该视频。</p>
<h4 id="3-更新视频模型"><a href="#3-更新视频模型" class="headerlink" title="3. 更新视频模型"></a>3. 更新视频模型</h4><p>为了跟踪每个视频的喜欢和不喜欢的总数，我们需要在视频模型中添加这些属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码// model/videoModel.js</span><br><span class="line">const videoSchema = new mongoose.Schema(&#123;</span><br><span class="line">  likeCount: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 0</span><br><span class="line">  &#125;,</span><br><span class="line">  dislikeCount: &#123;</span><br><span class="line">    type: Number,</span><br><span class="line">    default: 0</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="4-控制器逻辑"><a href="#4-控制器逻辑" class="headerlink" title="4. 控制器逻辑"></a>4. 控制器逻辑</h4><p>在控制器中，我们将处理喜欢和不喜欢的逻辑。这包括检查用户当前的喜欢状态，并据此更新状态和计数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">js复制代码jsCopy code</span><br><span class="line">// videoController.js</span><br><span class="line">exports.likeVideo = async (req, res) =&gt; &#123;</span><br><span class="line">  const videoId = req.params.videoId;</span><br><span class="line">  const userId = req.user.userinfo._id;</span><br><span class="line">  const video = await Video.findById(videoId);</span><br><span class="line">  if (!video) &#123;</span><br><span class="line">    return res.status(404).json(&#123; err: &quot;视频不存在&quot; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  let doc = await VideoLike.findOne(&#123; user: userId, video: videoId &#125;);</span><br><span class="line"></span><br><span class="line">  if (doc &amp;&amp; doc.like === 1) &#123;</span><br><span class="line">    await doc.deleteOne();</span><br><span class="line">    video.likeCount--;</span><br><span class="line">  &#125; else if (doc &amp;&amp; doc.like === -1) &#123;</span><br><span class="line">    doc.like = 1;</span><br><span class="line">    await doc.save();</span><br><span class="line">    video.likeCount++;</span><br><span class="line">    video.dislikeCount--;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    await new VideoLike(&#123; user: userId, video: videoId, like: 1 &#125;).save();</span><br><span class="line">    video.likeCount++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  await video.save();</span><br><span class="line">  res.status(200).json(&#123;</span><br><span class="line">    ...video.toJSON(),</span><br><span class="line">    isLike: doc ? doc.like === 1 : true</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>相似的逻辑适用于<code>disLikeVideo</code>函数。</p>
<h4 id="5-测试和验证"><a href="#5-测试和验证" class="headerlink" title="5. 测试和验证"></a>5. 测试和验证</h4><p>最后，我们需要确保这些API在实际应用中表现正常。这涉及到API的测试和直接数据库验证，以确保数据的正确性。</p>
<ul>
<li>postman接口测试</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5c6893a465fd85e2ff7f46595d51f8cdd681cc076ac08b3e4b4d39bc55e7476a" alt></p>
<ul>
<li>查看数据库中数据变化</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d9013f9c07a4666455b5a88f61f33198ff602dbae5537d17ea5ca0654b1dbf16" alt></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/55ba6a9eddd58c605a2a91e01194baf3ffd8028857d59c7f6672ff93783f8776" alt></p>
<p>通过实现这些功能，我们不仅增强了用户的互动体验，也为平台带来了更多关于用户偏好的数据，这有助于推荐系统等更高级的功能。这种实现方式展示了Node.js和Mongoose在构建现代Web应用中的灵活性和强大功能。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358664464998842406" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>DNS解析过程</title>
    <url>/7358664464999039014.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46e52f167b865b6e955522eb397787b3a9fd267d24cd9515c49f1c1d59ed812a" alt="image.png"></p>
<p>一张图即可说明，如果能看到上图就不用往下看了。下面是上图的文字版解析</p>
<h4 id="a-用户输入-URL"><a href="#a-用户输入-URL" class="headerlink" title="a. 用户输入 URL:"></a>a. <strong>用户输入 URL</strong>:</h4><p>当你在浏览器中点击一个链接或输入一个网址时，比如点击一个图片链接 <code>http://www.example.com/image.jpg</code>，这个过程开始于你的设备尝试理解这个地址所指向的服务器位置。</p>
<h4 id="b-浏览器检查缓存"><a href="#b-浏览器检查缓存" class="headerlink" title="b. 浏览器检查缓存:"></a>b. <strong>浏览器检查缓存</strong>:</h4><p>浏览器首先检查自身缓存中是否有这个网址的 DNS 记录存在（即该网址对应的 IP 地址）。如果缓存中有记录，它会直接使用这个 IP 地址。缓存不仅包括浏览器缓存，还可能查看操作系统缓存。</p>
<h4 id="c-请求本地-DNS-服务器"><a href="#c-请求本地-DNS-服务器" class="headerlink" title="c. 请求本地 DNS 服务器:"></a>c. <strong>请求本地 DNS 服务器</strong>:</h4><p>如果缓存中没有找到记录，浏览器会向配置的本地 DNS 服务器发起一个 DNS 查询请求。本地 DNS 服务器通常由你的互联网服务提供商(ISP)提供，也可能是你在网络设置中手动指定的，如 Google 的公共 DNS 服务器（8.8.8.8 或 8.8.4.4）。</p>
<ul>
<li><strong>本地 DNS 服务器</strong>: 这是一个响应你 DNS 查询请求的服务器，通常由 ISP 提供。它有助于将域名（如 <code>www.example.com</code>）解析为 IP 地址。</li>
<li><strong>设备如何知道本地 DNS 地址</strong>: 设备通过 DHCP (Dynamic Host Configuration Protocol) 从网络路由器或 ISP 获得本地 DNS 服务器的地址。当你的设备连接到网络时，DHCP 负责分配 IP 地址及 DNS 服务器地址等网络配置信息。</li>
</ul>
<h4 id="d-递归查询"><a href="#d-递归查询" class="headerlink" title="d. 递归查询:"></a>d. <strong>递归查询</strong>:</h4><p>如果本地 DNS 服务器没有缓存该域名的记录，它会进行递归查询，向更高级的 DNS 服务器（根、顶级域和权威 DNS 服务器）查询直到获取到 IP 地址。</p>
<h4 id="e-IP-地址响应"><a href="#e-IP-地址响应" class="headerlink" title="e. IP 地址响应:"></a>e. <strong>IP 地址响应</strong>:</h4><p>一旦 IP 地址被找到，本地 DNS 服务器将其返回给你的设备，并通常会缓存这个信息以加速未来的查询。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358664464999039014" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>部署服务时保存端口被占用如何解决？杀掉进程考虑使用不同的</title>
    <url>/7358664464999006246.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>有两个方法可以解决这个问题</p>
<h1 id="杀掉进程"><a href="#杀掉进程" class="headerlink" title="杀掉进程"></a>杀掉进程</h1><p>因为这个端口被占用的话意味着有进程占用了，所以先进行检测占用这个端口的进程。</p>
<h4 id="对于-Windows"><a href="#对于-Windows" class="headerlink" title="对于 Windows:"></a>对于 Windows:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码netstat -ano | findstr :你的端口号</span><br></pre></td></tr></table></figure>

<p>这条命令会显示所有使用指定端口的进程的列表，其中 <code>-ano</code> 参数列出了进程ID（PID），你可以通过这个PID找到对应的进程。</p>
<h4 id="对于-Linux-或-macOS"><a href="#对于-Linux-或-macOS" class="headerlink" title="对于 Linux 或 macOS:"></a>对于 Linux 或 macOS:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码sudo lsof -i :你的端口号</span><br></pre></td></tr></table></figure>

<p>检测到进程ID后杀掉它，<strong>终止进程可能会影响到依赖这个进程的服务，所以确保你了解这么做的后果。</strong></p>
<h4 id="在-Windows-上"><a href="#在-Windows-上" class="headerlink" title="在 Windows 上:"></a>在 Windows 上:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码bashCopy code</span><br><span class="line">taskkill /PID 进程号 /F</span><br></pre></td></tr></table></figure>

<p>这条命令将强制关闭PID对应的进程。</p>
<h4 id="在-Linux-或-macOS-上"><a href="#在-Linux-或-macOS-上" class="headerlink" title="在 Linux 或 macOS 上:"></a>在 Linux 或 macOS 上:</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码bashCopy code</span><br><span class="line">sudo kill -9 进程号</span><br></pre></td></tr></table></figure>

<h1 id="考虑使用不同的端口"><a href="#考虑使用不同的端口" class="headerlink" title="考虑使用不同的端口"></a>考虑使用不同的端口</h1><p>如题</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358664464999006246" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>腾讯音乐：说说Redis脑裂问题？</title>
    <url>/7358670107901886501.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>Redis 脑裂问题是指，在 Redis 哨兵模式或集群模式中，由于网络原因，导致主节点（Master）与哨兵（Sentinel）和从节点（Slave）的通讯中断，此时哨兵就会误以为主节点已宕机，就会在从节点中选举出一个新的主节点，此时 Redis 的集群中就出现了两个主节点的问题，就是 Redis 脑裂问题。</p>
<h2 id="脑裂问题影响"><a href="#脑裂问题影响" class="headerlink" title="脑裂问题影响"></a>脑裂问题影响</h2><p>Redis 脑裂问题会导致数据丢失，为什么呢？来看脑裂问题产生的过程：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f02593b823e8137fbfa474aba732bd0df94ccc451c0452a5530bcae1f0b43ece" alt="Redis脑裂问题.drawio.png"><br>而最后一步，当旧的 Master 变为 Slave 之后，它的执行流程如下：</p>
<ol>
<li>Slave（旧 Master）会向 Master（新）申请全量数据。</li>
<li>Master 会通过 bgsave 的方式生成当前 RDB 快照，并将 RDB 发送给 Slave。</li>
<li>Slave 拿到 RDB 之后，先进行 flush 清空当前数据（<strong>此时第四步旧客户端给他的发送的数据就丢失了</strong>）。</li>
<li>之后再加载 RDB 数据，初始化自己当前的数据。</li>
</ol>
<p>从以上过程中可以看出，在执行到第三步的时候，原客户端在旧 Master 写入的数据就丢失了，这就是数据丢失的问题。</p>
<h2 id="如何解决脑裂问题？"><a href="#如何解决脑裂问题？" class="headerlink" title="如何解决脑裂问题？"></a>如何解决脑裂问题？</h2><p>脑裂问题只需要在旧 Master 恢复网络之后，切换身份为 Slave 期间，不接收客户端的数据写入即可，那怎么解决这个问题呢？</p>
<p>Redis 为我们提供了以下两个配置，通过以下两个配置可以尽可能的避免数据丢失的问题：</p>
<ul>
<li><strong>min-slaves-to-write</strong>：与主节点通信的从节点数量必须大于等于该值主节点，否则主节点拒绝写入。</li>
<li><strong>min-slaves-max-lag</strong>：主节点与从节点通信的 ACK 消息延迟必须小于该值，否则主节点拒绝写入。</li>
</ul>
<p>这两个配置项必须同时满足，不然主节点拒绝写入。</p>
<p>在假故障期间满足 min-slaves-to-write 和 min-slaves-max-lag 的要求，那么主节点就会被禁止写入，脑裂造成的数据丢失情况自然也就解决了。</p>
<h2 id="课后思考"><a href="#课后思考" class="headerlink" title="课后思考"></a>课后思考</h2><p>设置了参数之后，Redis 脑裂问题能完全被解决吗？为什么？Zookeeper 有脑裂问题吗？它是如何解决脑裂问题的？</p>
<blockquote>
<p>本文已收录到我的面试小站 <a href="https://www.javacn.site" target="_blank" rel="noopener">www.javacn.site</a>，其中包含的内容有：Redis、JVM、并发、并发、MySQL、Spring、Spring MVC、Spring Boot、Spring Cloud、MyBatis、设计模式、消息队列等模块。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358670107901886501" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>👀那些你不知道的数据库知识：行式存储和列式存储1.列式存</title>
    <url>/7358688805157388325.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>前几天听课，听到老师讲数据列式存储。</p>
<p><strong>我</strong>🙋🏻‍♀️：等等，what，什么列式存储，数据一行一行的展示，然后一行一行的存在数据库里面不就好了，什么叫做列式存储，难道将数据按每一列存在数据库里面，那取出数据该有多麻烦啊，这绝对是几十年前的糟粕方法，这个课听不得了，教的东西太老套了。</p>
<p><strong>老师</strong>🧑🏻‍🏫：别急别急啊，同学，年轻人不要这么心浮气躁嘛，列式存储的存储效率在现在流行的大数据存储中发挥着重要的作用，其存储效率可比行式存储高的多。我先给你举个例子吧。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2cd3093621a6c95ab28112a48a13a7f6414f6778c045d9a5d43090b4de3ee960" alt></p>
<p>以学生信息表<code>stu</code>演示。sid为主键，表中记录这五位学生的信息。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77cdbf4092b3c4dba2b68332660893ddcb802379aa53d5b5e3938e3b6b006517" alt></p>
<p>大家比较熟悉的是<strong>行式存储</strong>，如关系型数据库（MySQL、Oracle等）的存储均采用行式存储，行式存储一目了然，如下图所示，每一位学生的信息存储在存储在存储介质上，先存储<code>zhangsan</code>同学的所有信息，再存储<code>lisi</code>同学的信息，依次存储剩下同学的信息，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/19c0bf4e9611da58cf918aff7431dc969aa39907ba34c50d446603bac24e5b85" alt></p>
<p>而列式存储，学生的信息数据都是分开保存的，即每一列的数据单独存放，如下图所示，每一列的数据存储在存储介质上，先存储sid这一列，然后存储sname这一列，依次存储剩下的列，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9a6f895fee885b704b847891b974470a94f02a8b9159012dde8ae3e1244ba4df" alt></p>
<p><strong>我</strong>🙋🏻‍♀️：好的老师，我已经明白您的背景了，快跟我讲讲列式存储的优点吧。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3fc76534ad46cd44f2d9a88b68d1201ce9acb19dae7213b311822c9fe4e6a375" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：那就先来一起看看两种存储方式存储在存储介质上的情况吧。</p>
<p>行式存储，每一个学生的信息都存储在相邻的地方，存储完一个学生的信息，再存储下一个学生的信息，以此类推，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2cc43f2f457c96758408a705be0700be9a66d9bc1941a22cd3683a6b736b65c3" alt></p>
<p>列式存储，将每一列的数据存储在相邻的地方，然后再存储下一列数据，以此类推，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/82522864fb2f08e244face386108a064d0f864388588026cd89b82d420834812" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：现在假设一种场景，我要你帮我取出所有学生的姓名，也就是<code>sname</code>这一列，你会怎么做？</p>
<p>对于SQL语句<code>select name from stu;</code>简简单单，可是在存储介质上取出数据的时候，你知道如何取出吗？</p>
<p>对于行式存储，必须从头到尾遍历存储数据，依次取出<code>sname</code>姓名的数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7fa5b172608272cade046707d54cba12fb3cbbda6e0c356f5d8545433e82b35e" alt></p>
<p>缺点就比较明显了，当我只需要访问几个列时，其他无关列的数据也会被读取，导致IO开销较大；而且数据 <strong>压缩比</strong> 较低，因为每行数据都存储在一起。</p>
<p>对于列式存储，这就简单了，直接定位到<code>sname</code>姓名的位置，就可以直接取出需要的数据了。</p>
<p>在分析型查询（OLAP）中，列式存储通常提供更高的性能。这是因为它只读取查询所需的列，大大减少了IO成本，加快了查询速度。</p>
<p>而且对于同一列的数据类型相同，便于压缩，通常具有更高的压缩比。非常适合大数据存储，如数据仓库，因为它可以快速读取和分析大量数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3e1b264900dc540887a32a7a189b59e964802cd1b14f54f8abd6acf881a207b9" alt></p>
<p><strong>我</strong>🙋🏻‍♀️：等等，MySQL不是有索引吗？我给<code>sname</code>单独加一条索引不就行了，这样查询的时候就可以利用 <strong>索引覆盖</strong> 的特性，直接拿到这一列的数据了呀！</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3fb5579a94f6e301e0ed18ff6a96d1094aa2d9fd6dd04462c7a5e6c36d7b480d" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：这位同学，请注意我们现在讲的是列式存储和行式存储，不是在讲MySQL哈。而且像你这样单独给<code>sname</code>加一条索引的做法，其实就是把同一列的数据存储在了一起，也是列式存储的一种应用方式。</p>
<p><strong>我</strong>🙋🏻‍♀️：原来MySQL里也有列式存储啊……</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d73111e11ecff76f5b8ed564e36508e17df4144677e2c1eaf0778155a31e7c67" alt></p>
<p><strong>我</strong>🙋🏻‍♀️：再等等，如果我要一个场景，请取出名字为‘zhangsan’的同学的所有信息，阁下该如何应对？</p>
<p><strong>老师</strong>🧑🏻‍🏫：啊这，角色互换了，这样列式存储的效率确实比行式存储的效率低很多了。</p>
<p>对于行式存储，只需要定位到“zhangsan”的位置，就可以直接取出需要的信息；</p>
<p>那行式存储的优点显而易见，对单行数据的操作效率更高，比较适用于事务型查询（OLTP），像频繁的增删改查的操作；当需要访问整行数据时，性能比较高；写入也会比较快，因为一次性完成整行的数据；</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2d3b161d6e2eaa985cd1bd970465009c39f80eef33d58ddfa8d3149ac739fdad" alt></p>
<p>对于列式存储，需要从头到尾遍历数据，根据元数据信息，一次取出“zhangsan”的信息。</p>
<p>列式存储的致命缺点就是行事查询、更新和删除操作比较复杂，因为需要处理多个列。而且写入性能比较低，因为需要将一行数据拆分成多个列分别写入。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/34ddedddeab2dc827e516d5a2f9c3547be9a9879bafdc3e8587bd068349f278f" alt></p>
<p><strong>老师</strong>🧑🏻‍🏫：你这小子，倒也不傻，我看你骨骼清奇，若勤加修炼，日后必得高升，我这有一本<code>数据库修炼秘籍</code>，只要九十九，你看，带不带一本走？</p>
<p><strong>我</strong>🙋🏻‍♀️：6啊，现在的广告真隐蔽。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/78e6d6e6d14af07746c048b161dac3f65a213e23f555230ccf6bf67e4fa9f9f8" alt></p>
<hr>
<p>言归正传，再来正式的聊聊行式存储和列式存储吧。</p>
<ol>
<li><h1 id="列式存储比行式存储可以节省多少空间"><a href="#列式存储比行式存储可以节省多少空间" class="headerlink" title="列式存储比行式存储可以节省多少空间"></a>列式存储比行式存储可以节省多少空间</h1></li>
</ol>
<p>大家一定非常好奇，列式存储比行式存储到底可以节省多少空间，才让博主绕这么一大圈来讲列式存储。</p>
<p>毫无疑问，列式存储比行式存储具有更高的数据压缩率。根据数据的类型和压缩技术，列式存储可以实现高达<strong>十倍</strong>甚至更高的压缩比，这意味着，列式存储能够节省大量的存储空间，降低存储成本。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7a8d957bad97223af57dac84a0e838a34b282012e3b184a14bffbce72c280486" alt></p>
<p>当然，具体节省的空间取决于多种因素，包括数据的重复性，列中数据类型的一致性以及采用的压缩算法。在实际应用中，节省的空间可能会有很大的差异，例如，如果一个数据集中的某些列包含大量重复的值，那么列式存储在这些列上的压缩效果会非常显著。</p>
<p>而对于数据变化较大，不适合压缩的场景，节省的空间可能就不那么明显了。</p>
<ol start="2">
<li><h1 id="列式存储和行式存储的区别"><a href="#列式存储和行式存储的区别" class="headerlink" title="列式存储和行式存储的区别"></a>列式存储和行式存储的区别</h1></li>
</ol>
<p>说了这么多，那列式存储和行式存储之间还有其他区别吗？</p>
<p>当然有，这区别可是非常大的，你且慢慢看来：</p>
<ol>
<li><strong>结构灵活性</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储倾向于结构弱化，更适合于不定长的记录和稀疏数据集，因为它可以有效地处理不存在的列。<ul>
<li>行式存储则倾向于结构固定，每行数据都需要有相同的列结构。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="2">
<li><strong>主键存储</strong>:</li>
</ol>
<ul>
<li><ul>
<li>行式存储中，一行数据仅需要一个主键。<ul>
<li>列式存储中，存储一行数据可能需要多份主键，因为每个列都是独立存储的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><strong>压缩算法的选择</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储可以针对不同列类型，选择最合适的压缩算法，因为每列数据的类型是已知的。<ul>
<li>行式存储的压缩算法选择不如列式存储灵活，因为它需要处理多种数据类型的混合。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><strong>IO消耗</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储在查询时只需要读取参与计算的列，极大地减低了IO消耗。<ul>
<li>行式存储在读取少数几列时，需要遍历其他无关列，IO开销较大。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li><strong>数据更新</strong>:</li>
</ol>
<ul>
<li><ul>
<li>列式存储不适用于数据需要频繁更新的交易场景，因为每次更新可能涉及多个列的变更。<ul>
<li>行式存储更适合频繁更新的场景，因为整行数据通常是连续存储的。</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="3">
<li><h1 id="拓展：ORC存储"><a href="#拓展：ORC存储" class="headerlink" title="拓展：ORC存储"></a>拓展：ORC存储</h1></li>
</ol>
<p>另外，向大家推荐一种存储方式，即ORC存储，也叫混合存储结构。</p>
<p>ORC（Optimized Row Columnar）是一种高效的列式存储格式，最初由Apache Hive项目开发，用于优化Hadoop数据存储和查询速度。它并不是纯粹的列式存储，而是采用了<strong>混合存储结构</strong>，先按行组分割表，然后在每个行组内部按列存储数据。ORC文件是自描述的，其元数据使用Protocol Buffers序列化，且数据尽可能压缩以减少存储空间消耗。</p>
<p>ORC文件的主要优势包括：</p>
<ul>
<li><strong>高压缩比</strong>：列式存储运行多种文件压缩方式，提供很高的压缩比；</li>
<li><strong>文件可切分</strong>：便于在Hive等系统中分布式处理。</li>
<li><strong>索引支持</strong>：提供多种索引，如row group index和bloom filter index，以优化查询。</li>
<li><strong>复杂数据结构支持</strong>：能够处理如Map等复杂数据类型。</li>
</ul>
<p>ORC文件结构包括多个层级，如文件级元数据、stripe（包含多条记录的行组）、stripe元数据和row group，这些结构支持有效的数据读取和查询优化。例如，ORC利用三个层级的统计信息来实现谓词下推，从而避免读取不必要的数据，提高查询性能。</p>
<ol start="4">
<li><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1></li>
</ol>
<p>这篇关于数据的行式存储和列式存储，其实是我女朋友在学习大数据知识的时候了解到的，我个人对这块也只是一知半解，如果文中有错误的地方，欢迎大家在评论区指出。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/415f322efdd7bfec073d8507a95fc097dec6497571b44a5bd51bd267d57f1bbc" alt></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358688805157388325" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>数据库,MySQL,大数据</tag>
      </tags>
  </entry>
  <entry>
    <title>你的第一款开源视频分析框架</title>
    <url>/7358687549848289331.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2ac8dfc848ab1780c777c4fe989155748b128082bb7fdddc92e3eab1cc8aa92f" alt></p>
<p>现在，刷视频已经成为我们生活中的一部分，而且很容易一看就停不下来。你有没有好奇过，它是如何在海量的视频里，找到让你感兴趣的视频？又是如何让你可以通过关键字，搜索到与之相关的视频内容的呢？这一切都离不开计算机对视频内容的分析和理解。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dc58483d1895c70511dade99108c47e4810b920690ff4850bc6bf0733fdcef6b" alt></p>
<p>计算机是如何“看懂”海量视频的呢？<strong>视频本质上是一系列连续的图像帧，按照一定的帧率播放，从而形成连续的动态效果</strong>。因此，计算机分析视频的基本原理就是：解码（视频转图片）-&gt; 分析/推理（AI 算法）-&gt; 编码（结果呈现）</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7108ceb987c73d0fd9066f998390438d96f5d3b4b779da9dbf19594a2342bd1b" alt></p>
<p>尽管这看起来就寥寥几步，但其中涉及许多技术细节和复杂的算法。比如，如何将训练好的 AI 图像算法模型，快速部署落地到实际应⽤场景中呢？对于没有接触过计算机视觉（Computer Vision，后简称 CV）的程序员，或是纯搞算法的算法工程师，要实现+落地 AI 视频分析相关功能可能会有点难度。然而，随着视频在日常生活中的普及和应用越来越广泛，处理和分析视频类数据的需求也在逐渐增加。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/484e3ecee2a913f5ecce9762f60703a82621785dfb48a3bbb35cc9cfdb63de80" alt></p>
<p>因此，今天 HelloGitHub 带来了一款开源的视频分析/结构化框架——VideoPipe，旨在让开发视频分析应用像使用 Django 写 Web 一样方便。<strong>VideoPipe 独创的管道可视化显示，让每一步的处理状态都可以一目了然</strong>。该框架能够轻松集成各种 CV 领域的模型，通过即插即用的方式轻松实现 AI 加持下的视频分析，适用于视频结构化、图片搜索、人脸识别、安防领域的行为分析（⻋牌识别、交通事故检测）等场景。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fc941c3f3bc0daf17901ad649d1f16de6382bb1902ab7ab230728f5431aea716" alt></p>
<blockquote>
<p>GitHub 地址：<a href="https://github.com/sherlockchou86/VideoPipe" target="_blank" rel="noopener">github.com/sherlockcho…</a></p>
</blockquote>
<p>下面，让我们跟着该项目的作者（周智）一起来了解、上手 VideoPipe，然后深入其内部学习更多的技术细节。</p>
<h2 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h2><p>VideoPipe 这是一个用于视频分析和结构化的框架，采用 C++ 编写、依赖少、易上手。它就像一个管道每个节点相互独立可自行搭配，用来构建不同类型的视频分析管道，适用于视频结构化、图片搜索、人脸识别、安防领域的行为分析（如交通事件检测）等场景。</p>
<p>你只需准备好模型并了解如何解析其输出即可，推理可以基于不同的后端实现，如 OpenCV::DNN（默认）、TensorRT、PaddleInference、ONNXRuntime 等，任何你喜欢的都可以。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/43b6004ba92ebf171dd2bae4b23ed6df8a87f74eb15304a31574ab1957084d24" alt></p>
<p>通过上面的 VideoPipe 工作示意图，可以发现它提供了以下功能：</p>
<ul>
<li>流读取/推送：⽀持主流的视频流协议，如 udp、rtsp、rtmp、文件。</li>
<li>视频解码/编码：⽀持基于 OpenCV/GStreamer 的视频和图片解/编码（⽀持硬件加速）。</li>
<li>基于深度学习的算法推理：⽀持基于深度学习算法的多级推理，例如⽬标检测、图像分类、特征提取。</li>
<li>⽬标跟踪：⽀持⽬标追踪，例如 IOU、SORT 跟踪算法等。</li>
<li>⾏为分析（BA）：⽀持基于跟踪的⾏为分析，例如越线、停⻋、违章等交通判断。</li>
<li>数据代理：⽀持将结构化数据（json/xml/⾃定义格式）以 kafka/Sokcet 等⽅式推送到云端、文件或其他<br>第三⽅平台。</li>
<li>录制：⽀持特定时间段的视频录制，特定帧的截图。</li>
<li>屏幕显⽰（OSD）：支持将模型输出结果绘制到帧上。</li>
</ul>
<p>对比功能类似、耳熟能详的 DeepStream（英伟达）和 mxVision（华为）框架，<strong>VideoPipe 更易于使⽤和调试、具备更好的可移植性，它完全由原生 C++ 编写，仅依赖于少量主流的第三方模块（如 OpenCV）</strong>。同时提供了可视化管道，框架的运行状态会自动在屏幕上刷新，包括管道中每个连接点的 fps、缓存大小、延迟等信息，你可以根据这些运行信息快速定位处理时的瓶颈所在。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>是否开源</th>
<th>学习门槛</th>
<th>适用平台</th>
<th>性能</th>
<th>三方依赖</th>
</tr>
</thead>
<tbody><tr>
<td>DeepStream</td>
<td>否</td>
<td>高</td>
<td>仅限英伟达</td>
<td>高</td>
<td>多</td>
</tr>
<tr>
<td>mxVision</td>
<td>否</td>
<td>高</td>
<td>仅限华为</td>
<td>高</td>
<td>多</td>
</tr>
<tr>
<td>VideoPipe</td>
<td>是</td>
<td>低</td>
<td>不限平台</td>
<td>中</td>
<td>少</td>
</tr>
</tbody></table>
<h2 id="二、快速上手"><a href="#二、快速上手" class="headerlink" title="二、快速上手"></a>二、快速上手</h2><p>VideoPipe 对机器硬件没有要求，仅用 CPU 都可以运行，不需要额外的加速卡。而且项目中还提供了丰富的示例代码，下面让我们通过运行一个简单的「人脸识别」示例，快速上手该框架。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c++复制代码/*</span><br><span class="line">* 名称：1-1-N sample</span><br><span class="line">* 完整代码位于：samples/1-1-N_sample.cpp</span><br><span class="line">* 功能说明：1个视频输入，1个视频分析任务（人脸检测和识别），2个输出（屏幕输出/RTMP推流输出）</span><br><span class="line">* 注意：模型和视频文件需要自行准备</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    VP_SET_LOG_INCLUDE_CODE_LOCATION(false);</span><br><span class="line">    VP_SET_LOG_INCLUDE_THREAD_ID(false);</span><br><span class="line">    VP_LOGGER_INIT();</span><br><span class="line"></span><br><span class="line">    // 1、创建节点</span><br><span class="line">    // 视频获取 Node</span><br><span class="line">    auto file_src_0 = std::make_shared&lt;vp_nodes::vp_file_src_node&gt;(&quot;file_src_0&quot;, 0, &quot;./test_video/10.mp4&quot;, 0.6);</span><br><span class="line">    // 2、模型推理 Node</span><br><span class="line">    // 一级推理：人脸检测</span><br><span class="line">    auto yunet_face_detector_0 = std::make_shared&lt;vp_nodes::vp_yunet_face_detector_node&gt;(&quot;yunet_face_detector_0&quot;, &quot;./models/face/face_detection_yunet_2022mar.onnx&quot;);</span><br><span class="line">    // 二级推理：人脸识别</span><br><span class="line">    auto sface_face_encoder_0 = std::make_shared&lt;vp_nodes::vp_sface_feature_encoder_node&gt;(&quot;sface_face_encoder_0&quot;, &quot;./models/face/face_recognition_sface_2021dec.onnx&quot;);</span><br><span class="line">    // 3、OSD Node</span><br><span class="line">    // 处理结果绘制到帧上</span><br><span class="line">    auto osd_0 = std::make_shared&lt;vp_nodes::vp_face_osd_node_v2&gt;(&quot;osd_0&quot;);</span><br><span class="line">    // 屏幕展示</span><br><span class="line">    auto screen_des_0 = std::make_shared&lt;vp_nodes::vp_screen_des_node&gt;(&quot;screen_des_0&quot;, 0);</span><br><span class="line">    // 推流展示</span><br><span class="line">    auto rtmp_des_0 = std::make_shared&lt;vp_nodes::vp_rtmp_des_node&gt;(&quot;rtmp_des_0&quot;, 0, &quot;rtmp://192.168.77.60/live/10000&quot;);</span><br><span class="line"></span><br><span class="line">    // 构建管道，将节点的处理结果关联起来</span><br><span class="line">    yunet_face_detector_0-&gt;attach_to(&#123;file_src_0&#125;);</span><br><span class="line">    sface_face_encoder_0-&gt;attach_to(&#123;yunet_face_detector_0&#125;);</span><br><span class="line">    osd_0-&gt;attach_to(&#123;sface_face_encoder_0&#125;);</span><br><span class="line"></span><br><span class="line">    // 管道自动拆分，通过屏幕/推流输出结果</span><br><span class="line">    screen_des_0-&gt;attach_to(&#123;osd_0&#125;);</span><br><span class="line">    rtmp_des_0-&gt;attach_to(&#123;osd_0&#125;);</span><br><span class="line"></span><br><span class="line">    // 启动管道</span><br><span class="line">    file_src_0-&gt;start();</span><br><span class="line"></span><br><span class="line">    // 可视化管道</span><br><span class="line">    vp_utils::vp_analysis_board board(&#123;file_src_0&#125;);</span><br><span class="line">    board.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过阅读上面的示例代码，可以发现 <strong>VideoPipe 框架将视频分析/处理的步骤，抽象成了一个管道（pipe），每一步的处理都是管道中的一个节点（Node）</strong>，处理流程如下：</p>
<ol>
<li>视频读取 Node：完成读取视频和解码的工作</li>
<li>模型推理 Node：分为人脸检测和人脸识别两个模型</li>
<li>OSD Node：将模型输出的处理结果绘制到帧上</li>
<li>构建管道：将上述节点依次连接，并将结果分成屏幕输出和推流输出，</li>
<li>启动：启动程序，并展示管道的运行情况</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/710a6720882ee5cbaacbccafa7ca6324cbcaed23d27b1f8c4bcf28823017abdd" alt></p>
<p>代码运⾏后，会出现上面的 3 个画⾯。它们分别是管道运⾏状态图（状态⾃动刷新）、屏幕显⽰结果（GUI）、播放器显⽰结果（RTMP），至此就算上手 VideoPipe 了！</p>
<h2 id="三、技术原理"><a href="#三、技术原理" class="headerlink" title="三、技术原理"></a>三、技术原理</h2><p>接下来，将详细介绍 VideoPipe 框架实现的技术原理和细节，干货来啦！在深入了解 VideoPipe 框架技术细节之前，我们需要先弄清楚视频的整体处理流程。</p>
<h3 id="3-1-视频结构化应⽤的核⼼环节"><a href="#3-1-视频结构化应⽤的核⼼环节" class="headerlink" title="3.1 视频结构化应⽤的核⼼环节"></a>3.1 视频结构化应⽤的核⼼环节</h3><p>视频结构化是将非结构化数据（视频/图片）转换为结构化数据的过程。非结构化数据通常包括：视频、图像、⾳频、⾃然语⾔文本，⽽结构化数据主要包括诸如 JSON、XML 或数据库中的数据表等，这些数据可以直接由机器（程序）处理。具体到视频（含图片，下同）结构化的过程，主要涉及以下核⼼部分：</p>
<ul>
<li>读取流：从⽹络或本地机器获取视频流。</li>
<li>解码：将字节流解码为帧，因为算法只能作⽤于图像。</li>
<li>推理：对图像进⾏深度学习推理，如检测、分类或特征提取。</li>
<li>跟踪：跟踪视频中的⽬标。</li>
<li>⾏为分析/逻辑处理：分析⽬标的轨迹、属性。</li>
<li>OSD：在图像上显⽰结果，⽤于调试或得到直观效果。</li>
<li>消息代理：将结构化数据推送到外部，供业务平台使⽤。</li>
<li>编码：对包含结果的帧进⾏编码，以便传输、存储。</li>
<li>推送流：将字节流推送到外部或直接保存</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ccf7090679105a13b6d15ffb975ba3f13cb45ef6fbfd8434a951132e9fe2287c" alt></p>
<p>上述每个环节对应 VideoPipe 中的⼀种插件类型，即代码中的 Node 对象。下面我们将逐一讲解 VideoPipe 的 Node、数据流、钩子的技术细节和实现。</p>
<h3 id="3-2-Node"><a href="#3-2-Node" class="headerlink" title="3.2 Node"></a>3.2 Node</h3><p>VideoPipe 中的每个 Node 负责⼀种任务（严格遵循单⼀职责原则），例如解码或推理。我们可以将许多节点串在⼀起构建成管道，并让视频数据流经整个管道。每个 Node 内部都有两个队列，⼀个⽤于缓存上游节点推送的数据，另⼀个⽤于缓存等待被推送到下游节点的数据。我们可以在两个队列之间编写逻辑代码，这是典型的⽣产者-消费者模式。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/be77369fb20e7cad50070d640c2d224ee0e044b5bfdf420341052ba263b48e35" alt></p>
<p>VideoPipe 中有三种类型的节点，分别是：</p>
<ol>
<li>SRC节点：源节点，数据被创建的地⽅（内部只有⼀个队列，⽤于缓存被推送到下游节点的数据）。</li>
<li>MID节点：中间节点，数据将在此处理。</li>
<li>DES节点：⽬标节点，数据消失的地⽅（内部只有⼀个队列，⽤于缓存来⾃上游节点的数据）。</li>
</ol>
<p>每个节点本⾝具有合并多个上游节点和拆分成多个下游节点的能⼒。注意，默认情况下节点在将数据从⼀个节点传输到另⼀个节点时使⽤浅拷⻉和等值拷⻉。如果您需要深拷⻉或希望按通道索引传输数据（希望数据不混淆），则在分裂点添加⼀个 <code>vp_split_node</code> 类型节点。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/62bddd0ace545b3e720021a3203ae044e9766e79dee2495ef6b283c88304e11c" alt></p>
<h3 id="3-3-数据流"><a href="#3-3-数据流" class="headerlink" title="3.3 数据流"></a>3.3 数据流</h3><p>视频是一种重量级数据，因此频繁进行深拷贝会降低管道的性能。实际上，VideoPipe 中两个节点之间传递的数据默认使用智能指针，一旦数据由源节点创建，数据内容在整个管道中大多数时间不会被复制。但如果需要，我们可以指定深度拷贝模式，使用 <code>vp_split_node</code> 类型节点。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d5748e7a01589f7309767c416dadb0a194c27c66374e7b8a147979aa9e3dc00a" alt></p>
<p>视频由连续的帧组成，因此 VideoPipe 逐帧处理这些帧，所以帧元数据中的帧索引也会连续增加。</p>
<h3 id="3-4-钩子"><a href="#3-4-钩子" class="headerlink" title="3.4 钩子"></a>3.4 钩子</h3><p>钩子是一种机制，让主体在发生某些事件时通知检测者，VideoPipe 也支持钩子。管道触发回调函数 <code>std::function</code> 与外部代码通信，例如实时推送管道自身的 fps、延迟和其他状态信息。我们在编写回调函数内部代码时，不允许有阻塞出现，否则影响整个管道性能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6bab2c1513b8a0dd67ef60fcc191fc13aa4672aa867bc9f9b6bca28b5580ff89" alt></p>
<p>钩子有助于调试我们的应用程序，并快速找出整个管道中的瓶颈，VideoPipe 框架中自带的可视化工具 <code>vp_analysis_board</code> 就是依赖于钩子机制实现的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/aec4355c7c80440625e00bff8c72bb5222f247ce83606f38067be8ea539d7f4e" alt></p>
<h3 id="3-5-如何实现新的-Node-类型"><a href="#3-5-如何实现新的-Node-类型" class="headerlink" title="3.5 如何实现新的 Node 类型"></a>3.5 如何实现新的 Node 类型</h3><p>首先 <code>vp_node</code> 是 VideoPipe 中所有节点的基类，我们可以定义一个从 <code>vp_node</code> 派生的新节点类，并重写一些虚函数：</p>
<ul>
<li><code>handle_frame_meta</code>：处理流经当前节点的帧数据。</li>
<li><code>handle_control_meta</code>：处理流经当前节点的控制指令数据。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/75f8af13018747130b9ca20ab9f14a6a7e6a71870b43b11f72815722e43ba6ae" alt></p>
<p>帧数据指的是 VideoPipe 中的 <code>vp_frame_meta</code>，其中包含与帧相关的数据，如帧索引、数据缓冲区、原始宽度等等。控制指令数据指的是 VideoPipe 中的 <code>vp_control_meta</code>，其中包含与命令相关的数据，例如记录视频、记录图像等。并非所有流经当前节点的数据都应该被处理，只需要处理我们感兴趣的内容。</p>
<h2 id="四、最后"><a href="#四、最后" class="headerlink" title="四、最后"></a>四、最后</h2><p>目前，基于深度学习的视频分析技术的入门门槛还是比较高的，一些成熟的框架比如 DeepStream、mxVision 等，它们大多晦涩难懂、上手门槛高、对于新手不太友好。所以，我就花了两年的业余时间创建了 VideoPipe 视频分析框架，我的想法很简单就是想让<strong>初学者能够快速了解视频分析相关技术栈，轻松地在自己机器上跑通一个人脸识别的应用</strong>，让更多人掌握视频分析相关技术，同时搞清楚应该从哪里开始。</p>
<p>我深知这是一件道阻且长的事情，所以 VideoPipe 在诞生之初就是完全开源，我希望能够借助开源的力量让它“发光发热”，真正地做到降低开发视频分析应用的门槛，帮助更多的开发者进入到视频分析的领域。</p>
<blockquote>
<p>GitHub 地址：<a href="https://github.com/sherlockchou86/VideoPipe" target="_blank" rel="noopener">github.com/sherlockcho…</a></p>
</blockquote>
<p>最后，感谢「HelloStar 计划」提供的机会，能够让更多人了解 VideoPipe 框架。我作为开源生态的受益者，深知开源的力量和责任，此举也是希望 VideoPipe 项目能够成为一座连接对视频分析、结构化技术感兴趣的小伙伴的桥梁，能够和大家一起交流学习、共同进步、回馈开源社区！</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358687549848289331" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>10.数据库链路追踪实现设计</title>
    <url>/7358688805157404709.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>分布式链路追踪中，记录数据库的调用是必不可少的，但是数据库的分布式链路追踪，与调用下游服务或者发送<strong>Kafka</strong>有着显著的不同，那就是链路信息不需要传递到数据库服务端，所以就不需要将<strong>Span</strong>通过某种方式进行传递，而需要做的，就是把请求数据库服务端时的一些信息记录下来并作为链路日志输出。</p>
<p>这里选择基于<strong>MyBatis</strong>实现数据库链路追踪，实现的机制是基于<strong>MyBatis</strong>的拦截器，因此实际上<strong>MyBatis-Plus</strong>也是适用的。</p>
<p><strong>github</strong>地址：<a href="https://github.com/SakuraSacrifice/honey-tracing" target="_blank" rel="noopener">honey-tracing</a></p>
<h2 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h2><h3 id="一-链路日志改造说明"><a href="#一-链路日志改造说明" class="headerlink" title="一. 链路日志改造说明"></a>一. 链路日志改造说明</h3><p>之前的链路日志格式如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;</span><br><span class="line">    &quot;traceId&quot;: &quot;testTraceId&quot;, // 当前节点所属链路的Id</span><br><span class="line">    &quot;spanId&quot;: &quot;testSpanId&quot;, // 当前节点的SpanId</span><br><span class="line">    &quot;parentSpanId&quot;: &quot;testparentSpanId&quot;, // 当前节点的父节点的SpanId</span><br><span class="line">    &quot;timestamp&quot;: &quot;1704038400000&quot;, // 接收到请求那一刻的毫秒时间戳</span><br><span class="line">    &quot;duration&quot;: &quot;10&quot;, // 表示接收请求到响应请求的耗时</span><br><span class="line">    &quot;httpCode&quot;: &quot;200&quot;, // 请求的HTTP状态码</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;, // 当前节点的主机地址</span><br><span class="line">    &quot;requestStacks&quot;: [ // 请求堆栈</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;subSpanId&quot;: &quot;testSubSpanId&quot;, // 当前节点的子节点的SpanId</span><br><span class="line">            &quot;subHttpCode&quot;: &quot;200&quot;, // 请求子节点的HTTP状态码</span><br><span class="line">            &quot;subTimestamp&quot;: &quot;1704038401000&quot;, // 当前节点请求子节点的毫秒时间戳</span><br><span class="line">            &quot;subDuration&quot;: &quot;5&quot;, // 表示发起请求到收到响应的耗时</span><br><span class="line">            &quot;subHost&quot;: &quot;192.168.10.5&quot; // 当前节点的子节点的主机地址</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<strong>requestStacks</strong>字段用于记录下游的<strong>Span</strong>信息，而由于数据库链路追踪中并不需要将链路信息传递给数据库服务端，所以<strong>requestStacks</strong>字段不再适用，我们新增加一个<strong>dbStacks</strong>字段来记录数据库操作的信息，示例如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;</span><br><span class="line">    &quot;traceId&quot;: &quot;testTraceId&quot;, // 当前节点所属链路的Id</span><br><span class="line">    &quot;spanId&quot;: &quot;testSpanId&quot;, // 当前节点的SpanId</span><br><span class="line">    &quot;parentSpanId&quot;: &quot;testparentSpanId&quot;, // 当前节点的父节点的SpanId</span><br><span class="line">    &quot;timestamp&quot;: &quot;1704038400000&quot;, // 接收到请求那一刻的毫秒时间戳</span><br><span class="line">    &quot;duration&quot;: &quot;10&quot;, // 表示接收请求到响应请求的耗时</span><br><span class="line">    &quot;httpCode&quot;: &quot;200&quot;, // 请求的HTTP状态码</span><br><span class="line">    &quot;host&quot;: &quot;127.0.0.1&quot;, // 当前节点的主机地址</span><br><span class="line">    &quot;requestStacks&quot;: [ // 请求堆栈</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;subSpanId&quot;: &quot;testSubSpanId&quot;, // 当前节点的子节点的SpanId</span><br><span class="line">            &quot;subHttpCode&quot;: &quot;200&quot;, // 请求子节点的HTTP状态码</span><br><span class="line">            &quot;subTimestamp&quot;: &quot;1704038401000&quot;, // 当前节点请求子节点的毫秒时间戳</span><br><span class="line">            &quot;subDuration&quot;: &quot;5&quot;, // 表示发起请求到收到响应的耗时</span><br><span class="line">            &quot;subHost&quot;: &quot;192.168.10.5&quot; // 当前节点的子节点的主机地址</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;dbStacks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;dbServer&quot;: &quot;127.0.0.1:3306&quot;, // 数据库服务端地址</span><br><span class="line">            &quot;dbName&quot;: &quot;test&quot;, // 数据库名</span><br><span class="line">            &quot;sqlText&quot;: &quot;SELECT * FROM book WHERE id=?&quot;, // SQL语句</span><br><span class="line">            &quot;sqlParams&quot;: &quot;50&quot;, // SQL语句参数</span><br><span class="line">            &quot;sqlDuration&quot;: &quot;5&quot;, // 数据库操作耗时</span><br><span class="line">            &quot;sqlTimestamp&quot;: &quot;1704038402000&quot; // 数据库操作时的毫秒时间戳</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新增字段说明如下。</p>
<ol>
<li><strong>dbServer</strong>。表示数据库服务端地址，从<strong>url</strong>连接串中解析出；</li>
<li><strong>dbName</strong>。表示操作的数据库名，从<strong>url</strong>连接串中解析出；</li>
<li><strong>sqlText</strong>。表示执行的<strong>SQL</strong>语句信息，从<strong>MyBatis</strong>的<strong>BoundSql</strong>中获取；</li>
<li><strong>sqlParams</strong>。表示执行的<strong>SQL</strong>参数，同样从<strong>MyBatis</strong>的<strong>BoundSql</strong>中获取；</li>
<li><strong>sqlDuration</strong>。表示操作数据库的耗时，单位<strong>ms</strong>，由于<strong>MyBatis</strong>拦截器的拦截时机是先于从数据源中拿出连接的，所以这里的耗时包括等待获取数据库连接的时间；</li>
<li><strong>sqlTimestamp</strong>。表示开始操作数据库的时间点的毫秒时间戳。</li>
</ol>
<h3 id="二-MyBatis拦截器回顾"><a href="#二-MyBatis拦截器回顾" class="headerlink" title="二. MyBatis拦截器回顾"></a>二. MyBatis拦截器回顾</h3><p><strong>MyBatis</strong>的拦截器也就是常说的插件，可以作用于<strong>Executor</strong>，<strong>ParameterHandler</strong>，<strong>ResultSetHandler</strong>和<strong>StatementHandler</strong>这四个组件，所有拦截器都需要实现<strong>org.apache.ibatis.plugin.Interceptor</strong>接口，一个简单的拦截器示例如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class TestInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        // 获取被拦截的对象</span><br><span class="line">        Object target = invocation.getTarget();</span><br><span class="line">        // 获取被拦截的方法</span><br><span class="line">        Method method = invocation.getMethod();</span><br><span class="line">        // 获取被拦截的方法的参数</span><br><span class="line">        Object[] args = invocation.getArgs();</span><br><span class="line"></span><br><span class="line">        // 执行被拦截的方法前，做一些事情</span><br><span class="line"></span><br><span class="line">        // 执行被拦截的方法</span><br><span class="line">        Object result = invocation.proceed();</span><br><span class="line"></span><br><span class="line">        // 执行被拦截的方法后，做一些事情</span><br><span class="line"></span><br><span class="line">        // 返回执行结果</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面出现的@<strong>Signature</strong>注解的<strong>type</strong>，<strong>method</strong>和<strong>args</strong>三个字段共同决定拦截器会作用于哪个组件的哪个方法上，例如上面示例中，就会作用于<strong>Executor</strong>组件的<strong>update()</strong> 方法和两个重载的<strong>query()</strong> 方法，而我们又知道，<strong>MyBatis</strong>执行<strong>SQL</strong>时，无论是增删改查，其实都是会调用到<strong>Executor</strong>的<strong>update()</strong> 方法或者<strong>query()</strong> 方法，所以上面示例的拦截器，其实就可以拦截所有<strong>SQL</strong>的执行。</p>
<h3 id="三-数据库链路追踪MyBatis拦截器设计与实现"><a href="#三-数据库链路追踪MyBatis拦截器设计与实现" class="headerlink" title="三. 数据库链路追踪MyBatis拦截器设计与实现"></a>三. 数据库链路追踪MyBatis拦截器设计与实现</h3><p>在开始前，需要在<strong>pom</strong>文件中先添加如下依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.alibaba&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;druid&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.11&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;</span><br><span class="line">    &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>我们要实现数据库链路追踪，其实就是记录操作数据库的行为，所以需要拦截每一条<strong>SQL</strong>的执行，因此拦截器作用的目标组件就是<strong>Executor</strong>，作用的目标方法就是<strong>update()</strong> 和两个重载的<strong>query()</strong> 方法，拦截器实现如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * MyBaits作用于&#123;@link Executor&#125;用于记录&#123;@link Span&#125;的拦截器。</span><br><span class="line"> */</span><br><span class="line">@Intercepts(&#123;</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="line">        @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class HoneyDbExecutorTracingInterceptor implements Interceptor &#123;</span><br><span class="line"></span><br><span class="line">    private final Tracer tracer;</span><br><span class="line">    private final List&lt;HoneyDbExecutorTracingDecorator&gt; decorators;</span><br><span class="line"></span><br><span class="line">    public HoneyDbExecutorTracingInterceptor(Tracer tracer, List&lt;HoneyDbExecutorTracingDecorator&gt; decorators) &#123;</span><br><span class="line">        this.tracer = tracer;</span><br><span class="line">        this.decorators = decorators;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object intercept(Invocation invocation) throws Throwable &#123;</span><br><span class="line">        if (null == tracer.activeSpan()) &#123;</span><br><span class="line">            return invocation.proceed();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Span span = tracer.buildSpan(HONEY_DB_NAME)</span><br><span class="line">                .withTag(Tags.SPAN_KIND.getKey(), Tags.SPAN_KIND_CLIENT)</span><br><span class="line">                .start();</span><br><span class="line">        for (HoneyDbExecutorTracingDecorator decorator : decorators) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                decorator.onExecute(invocation, span);</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                // do nothing</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object result;</span><br><span class="line">        try (Scope scope = tracer.activateSpan(span)) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                result = invocation.proceed();</span><br><span class="line">            &#125; catch (Exception e1) &#123;</span><br><span class="line">                for (HoneyDbExecutorTracingDecorator decorator : decorators) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        decorator.onError(invocation, e1, span);</span><br><span class="line">                    &#125; catch (Exception e2) &#123;</span><br><span class="line">                        // do nothing</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                throw e1;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            for (HoneyDbExecutorTracingDecorator decorator : decorators) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    decorator.onFinish(invocation, span);</span><br><span class="line">                &#125; catch (Exception e) &#123;</span><br><span class="line">                    // do nothing</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            span.finish();</span><br><span class="line">            tracer.activeSpan().log(DbStackUtil.assembleDbStack((JaegerSpan) span));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述实现的拦截器，主要干了下面几件事情。</p>
<ol>
<li>针对当前操作数据库的行为创建<strong>Span</strong>。这里创建<strong>Span</strong>并不是要把<strong>Span</strong>传递给数据库服务端，而是通过<strong>Span</strong>来记录开始时间，执行耗时以及数据库操作的一些信息；</li>
<li>在<strong>SQL</strong>执行前，执行成功和执行失败时分别应用装饰器的逻辑。拦截器并没有写很重的逻辑，解析<strong>url</strong>，解析<strong>SQL</strong>等逻辑全部放到装饰器中，让拦截器和记录信息的行为解耦，方便后续扩充<strong>dbStack</strong>的内容；</li>
<li>在拦截器的最后生成<strong>dbStack</strong>并记录在当前节点的<strong>Span</strong>中。注意，生成<strong>dbStack</strong>是基于我们在拦截器中创建出来的<strong>Span</strong>，在<strong>dbStack</strong>生成出来后，在拦截器中创建出来的<strong>Span</strong>的使命就完成了，后续就需要把生成出来的<strong>dbStack</strong>记录在当前节点的<strong>Span</strong>中。</li>
</ol>
<p>基于<strong>Span</strong>生成<strong>dbStack</strong>的工具类<strong>DbStackUtil</strong>实现如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * dbStack记录工具。</span><br><span class="line"> */</span><br><span class="line">public class DbStackUtil &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 生成操作数据库时的dbStack。</span><br><span class="line">     */</span><br><span class="line">    public static Map&lt;String, Object&gt; assembleDbStack(JaegerSpan span) &#123;</span><br><span class="line">        Map&lt;String, Object&gt; requestStack = new HashMap&lt;&gt;();</span><br><span class="line">        requestStack.put(LOG_EVENT_KIND, LOG_EVENT_KIND_DB_STACK);</span><br><span class="line">        requestStack.put(FIELD_DB_SERVER, span.getTags().get(FIELD_DB_SERVER));</span><br><span class="line">        requestStack.put(FIELD_DB_NAME, span.getTags().get(FIELD_DB_NAME));</span><br><span class="line">        requestStack.put(FIELD_SQL_TEXT, span.getTags().get(FIELD_SQL_TEXT));</span><br><span class="line">        requestStack.put(FIELD_SQL_PARAMS, span.getTags().get(FIELD_SQL_PARAMS));</span><br><span class="line">        requestStack.put(FIELD_SQL_DURATION, span.getDuration());</span><br><span class="line">        requestStack.put(FIELD_SQL_TIMESTAMP, span.getStart());</span><br><span class="line">        return requestStack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class CommonConstants &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">     public static final String LOG_EVENT_KIND = &quot;logEventKind&quot;;</span><br><span class="line">     public static final String LOG_EVENT_KIND_DB_STACK = &quot;dbStack&quot;;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中很关键的一点是在于将<strong>logEventKind</strong>设置为了<strong>dbStack</strong>，这样在打印链路日志时，可以根据<strong>logEventKind</strong>来知道当前要按照<strong>dbStack</strong>的格式来组装日志。</p>
<p>最后再看一下装饰器接口的定义，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * 作用于&#123;@link Executor&#125;的装饰器。</span><br><span class="line"> */</span><br><span class="line">public interface HoneyDbExecutorTracingDecorator &#123;</span><br><span class="line"></span><br><span class="line">    void onExecute(Invocation invocation, Span span);</span><br><span class="line"></span><br><span class="line">    void onFinish(Invocation invocation, Span span);</span><br><span class="line"></span><br><span class="line">    void onError(Invocation invocation, Exception exception, Span span);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="四-数据库链路追踪装饰器设计与实现"><a href="#四-数据库链路追踪装饰器设计与实现" class="headerlink" title="四. 数据库链路追踪装饰器设计与实现"></a>四. 数据库链路追踪装饰器设计与实现</h3><p>提供一个<strong>HoneyDbExecutorTracingDecorator</strong>接口的实现类，在<strong>SQL</strong>执行前，完成记录数据库服务端地址，数据库名，<strong>SQL</strong>语句和<strong>SQL</strong>参数，这些记录的信息，全部存储在<strong>Span</strong>的<strong>Tags</strong>字段中。</p>
<h4 id="1-数据库服务端地址和数据库名获取"><a href="#1-数据库服务端地址和数据库名获取" class="headerlink" title="1. 数据库服务端地址和数据库名获取"></a>1. 数据库服务端地址和数据库名获取</h4><p>装饰器实现如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * 作用于&#123;@link Executor&#125;的装饰器，装饰&#123;@link Span&#125;。</span><br><span class="line"> */</span><br><span class="line">public class HoneyDbExecutorTracingSpanDecorator implements HoneyDbExecutorTracingDecorator &#123;</span><br><span class="line"></span><br><span class="line">    private static final String QUESTION_MARK = &quot;?&quot;;</span><br><span class="line">    private static final String COMMA = &quot;,&quot;;</span><br><span class="line">    private static final String NULL_STR = &quot;null&quot;;</span><br><span class="line">    private static final char SPACE_CHAR = &apos; &apos;;</span><br><span class="line">    private static final String LINE_BREAK_REGEX = &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onExecute(Invocation invocation, Span span) &#123;</span><br><span class="line">        // 设置数据库服务端地址信息和数据库名</span><br><span class="line">        try &#123;</span><br><span class="line">            DataSource dataSource = ((MappedStatement) invocation.getArgs()[0]).getConfiguration().getEnvironment().getDataSource();</span><br><span class="line">            assembleDbServerAndName(dataSource, (JaegerSpan) span);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFinish(Invocation invocation, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Invocation invocation, Exception exception, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void assembleDbServerAndName(DataSource dataSource, JaegerSpan span) &#123;</span><br><span class="line">        String url = StringUtils.EMPTY;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (dataSource instanceof HikariDataSource) &#123;</span><br><span class="line">                url = ((HikariDataSource) dataSource).getJdbcUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof DruidDataSource) &#123;</span><br><span class="line">                url = ((DruidDataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof org.apache.tomcat.jdbc.pool.DataSource) &#123;</span><br><span class="line">                url = ((org.apache.tomcat.jdbc.pool.DataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 无法判断数据库连接池类型的情况下才通过连接拿url</span><br><span class="line">                Connection connection = dataSource.getConnection();</span><br><span class="line">                DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">                url = metaData.getURL();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isNotEmpty(url)) &#123;</span><br><span class="line">            // 从连接串中解析出数据库服务端地址信息</span><br><span class="line">            int left = url.indexOf(SLASH_DOUBLE) + 2;</span><br><span class="line">            int mid = url.indexOf(SLASH, left);</span><br><span class="line">            int right = url.indexOf(QUESTION_MARK);</span><br><span class="line">            span.setTag(FIELD_DB_SERVER, url.substring(left, mid));</span><br><span class="line">            if (right == -1) &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1, right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述装饰器首先会从拦截方法的参数中拿到<strong>MappedStatement</strong>，从而最终可以拿到当前使用的数据源<strong>DataSource</strong>，再然后判断数据源的类型，如果能够明确数据源的类型，那么就可以直接拿到数据库连接串<strong>url</strong>，如果无法判断出数据源类型，则可以选择先从数据源中获取一个数据库连接，然后再从数据库连接的元数据信息中拿到<strong>url</strong>。</p>
<p>获取到<strong>url</strong>后，就按照如下两种<strong>url</strong>格式来解析出数据库服务端地址和数据库名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt复制代码jdbc:mysql://数据库服务端地址/数据库名</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt复制代码jdbc:mysql://数据库服务端地址/数据库名?配置项1=配置值1</span><br></pre></td></tr></table></figure>

<h4 id="2-SQL语句和SQL参数获取"><a href="#2-SQL语句和SQL参数获取" class="headerlink" title="2. SQL语句和SQL参数获取"></a>2. SQL语句和SQL参数获取</h4><p>继续在上一小节的装饰器中添加代码，完成<strong>SQL</strong>语句和<strong>SQL</strong>参数的获取，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码/**</span><br><span class="line"> * 作用于&#123;@link Executor&#125;的装饰器，装饰&#123;@link Span&#125;。</span><br><span class="line"> */</span><br><span class="line">public class HoneyDbExecutorTracingSpanDecorator implements HoneyDbExecutorTracingDecorator &#123;</span><br><span class="line"></span><br><span class="line">    private static final String QUESTION_MARK = &quot;?&quot;;</span><br><span class="line">    private static final String COMMA = &quot;,&quot;;</span><br><span class="line">    private static final String NULL_STR = &quot;null&quot;;</span><br><span class="line">    private static final char SPACE_CHAR = &apos; &apos;;</span><br><span class="line">    private static final String LINE_BREAK_REGEX = &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onExecute(Invocation invocation, Span span) &#123;</span><br><span class="line">        // 设置数据库服务端地址信息和数据库名</span><br><span class="line">        try &#123;</span><br><span class="line">            DataSource dataSource = ((MappedStatement) invocation.getArgs()[0]).getConfiguration().getEnvironment().getDataSource();</span><br><span class="line">            assembleDbServerAndName(dataSource, (JaegerSpan) span);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 设置SQL语句和参数信息</span><br><span class="line">        try &#123;</span><br><span class="line">            assembleSqlTextAndParams(invocation.getArgs(), (JaegerSpan) span);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onFinish(Invocation invocation, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onError(Invocation invocation, Exception exception, Span span) &#123;</span><br><span class="line">        // do nothing</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void assembleDbServerAndName(DataSource dataSource, JaegerSpan span) &#123;</span><br><span class="line">        String url = StringUtils.EMPTY;</span><br><span class="line">        try &#123;</span><br><span class="line">            if (dataSource instanceof HikariDataSource) &#123;</span><br><span class="line">                url = ((HikariDataSource) dataSource).getJdbcUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof DruidDataSource) &#123;</span><br><span class="line">                url = ((DruidDataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else if (dataSource instanceof org.apache.tomcat.jdbc.pool.DataSource) &#123;</span><br><span class="line">                url = ((org.apache.tomcat.jdbc.pool.DataSource) dataSource).getUrl();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // 无法判断数据库连接池类型的情况下才通过连接拿url</span><br><span class="line">                Connection connection = dataSource.getConnection();</span><br><span class="line">                DatabaseMetaData metaData = connection.getMetaData();</span><br><span class="line">                url = metaData.getURL();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            // do nothing</span><br><span class="line">        &#125;</span><br><span class="line">        if (StringUtils.isNotEmpty(url)) &#123;</span><br><span class="line">            // 从连接串中解析出数据库服务端地址信息</span><br><span class="line">            int left = url.indexOf(SLASH_DOUBLE) + 2;</span><br><span class="line">            int mid = url.indexOf(SLASH, left);</span><br><span class="line">            int right = url.indexOf(QUESTION_MARK);</span><br><span class="line">            span.setTag(FIELD_DB_SERVER, url.substring(left, mid));</span><br><span class="line">            if (right == -1) &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1));</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                span.setTag(FIELD_DB_NAME, url.substring(mid + 1, right));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void assembleSqlTextAndParams(Object[] args, Span span) &#123;</span><br><span class="line">        MappedStatement mappedStatement = ((MappedStatement) args[0]);</span><br><span class="line">        // 先获取SQL</span><br><span class="line">        BoundSql boundSql;</span><br><span class="line">        if (args.length == 6) &#123;</span><br><span class="line">            boundSql = ((BoundSql) args[5]);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            boundSql = mappedStatement.getBoundSql(args[1]);</span><br><span class="line">        &#125;</span><br><span class="line">        span.setTag(FIELD_SQL_TEXT, toPrettySql(boundSql.getSql()));</span><br><span class="line"></span><br><span class="line">        // 再获取Params</span><br><span class="line">        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();</span><br><span class="line">        Object parameterObject = boundSql.getParameterObject();</span><br><span class="line">        TypeHandlerRegistry typeHandlerRegistry = mappedStatement.getConfiguration().getTypeHandlerRegistry();</span><br><span class="line">        if (null != parameterMappings) &#123;</span><br><span class="line">            String[] paramStrs = new String[parameterMappings.size()];</span><br><span class="line">            for (int i = 0; i &lt; parameterMappings.size(); i++) &#123;</span><br><span class="line">                ParameterMapping parameterMapping = parameterMappings.get(i);</span><br><span class="line">                if (parameterMapping.getMode() != ParameterMode.OUT) &#123;</span><br><span class="line">                    Object value;</span><br><span class="line">                    String propertyName = parameterMapping.getProperty();</span><br><span class="line">                    if (boundSql.hasAdditionalParameter(propertyName)) &#123;</span><br><span class="line">                        value = boundSql.getAdditionalParameter(propertyName);</span><br><span class="line">                    &#125; else if (parameterObject == null) &#123;</span><br><span class="line">                        value = null;</span><br><span class="line">                    &#125; else if (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;</span><br><span class="line">                        value = parameterObject;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        MetaObject metaObject = mappedStatement.getConfiguration().newMetaObject(parameterObject);</span><br><span class="line">                        value = metaObject.getValue(propertyName);</span><br><span class="line">                    &#125;</span><br><span class="line">                    if (null == value) &#123;</span><br><span class="line">                        paramStrs[i] = NULL_STR;</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        paramStrs[i] = value.toString();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String sqlParamsStr = String.join(COMMA, paramStrs);</span><br><span class="line">            span.setTag(FIELD_SQL_PARAMS, sqlParamsStr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private String toPrettySql(String sql) &#123;</span><br><span class="line">        // 去除换行符</span><br><span class="line">        sql = sql.replaceAll(LINE_BREAK_REGEX, StringUtils.EMPTY);</span><br><span class="line">        // 去除多余空格</span><br><span class="line">        StringBuilder sqlBuilder = new StringBuilder();</span><br><span class="line">        boolean necessarySpace = true;</span><br><span class="line">        for (int i = 0; i &lt; sql.length(); i++) &#123;</span><br><span class="line">            if (sql.charAt(i) == SPACE_CHAR) &#123;</span><br><span class="line">                if (necessarySpace) &#123;</span><br><span class="line">                    sqlBuilder.append(sql.charAt(i));</span><br><span class="line">                &#125;</span><br><span class="line">                necessarySpace = false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                sqlBuilder.append(sql.charAt(i));</span><br><span class="line">                necessarySpace = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sqlBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先从拦截的方法的参数中拿到<strong>MappedStatement</strong>，然后再从<strong>MappedStatement</strong>中拿到<strong>BoundSql</strong>，我们需要的<strong>SQL</strong>语句和<strong>SQL</strong>参数，都在<strong>BoundSql</strong>中，其中<strong>SQL</strong>语句的获取比较简单，直接通过<strong>BoundSql</strong>就可以拿到<strong>SQL</strong>语句，我们需要做的就是把多余的空格和换行符给去掉，让<strong>SQL</strong>看起来好看一些。而参数要稍微麻烦一点，因为参数是不确定的，在<strong>BoundSql</strong>中是这样来表示参数的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class BoundSql &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    private final List&lt;ParameterMapping&gt; parameterMappings;</span><br><span class="line">    private final Object parameterObject;</span><br><span class="line"> </span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际就是要使用<strong>parameterMappings</strong>和<strong>parameterObject</strong>共同来解析出<strong>SQL</strong>参数，这里的解析逻辑，直接参考的<strong>DefaultParameterHandler</strong>中的代码。</p>
<p>至此数据库链路追踪装饰器就实现完毕了，使用到的一些常量如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class CommonConstants &#123;</span><br><span class="line"></span><br><span class="line">    public static final double DEFAULT_SAMPLE_RATE = 1.0;</span><br><span class="line"></span><br><span class="line">    public static final String HONEY_TRACER_NAME = &quot;HoneyTracer&quot;;</span><br><span class="line">    public static final String HONEY_REST_TEMPLATE_NAME = &quot;HoneyRestTemplate&quot;;</span><br><span class="line">    public static final String HONEY_KAFKA_NAME = &quot;HoneyKafka&quot;;</span><br><span class="line">    public static final String HONEY_DB_NAME = &quot;HoneyDb&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String FIELD_HOST = &quot;host&quot;;</span><br><span class="line">    public static final String FIELD_API = &quot;api&quot;;</span><br><span class="line">    public static final String FIELD_HTTP_CODE = &quot;httpCode&quot;;</span><br><span class="line">    public static final String FIELD_SUB_SPAN_ID = &quot;subSpanId&quot;;</span><br><span class="line">    public static final String FIELD_SUB_HTTP_CODE = &quot;subHttpCode&quot;;</span><br><span class="line">    public static final String FIELD_SUB_TIMESTAMP = &quot;subTimestamp&quot;;</span><br><span class="line">    public static final String FIELD_SUB_DURATION = &quot;subDuration&quot;;</span><br><span class="line">    public static final String FIELD_SUB_HOST = &quot;subHost&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String FIELD_DB_SERVER = &quot;dbServer&quot;;</span><br><span class="line">    public static final String FIELD_DB_NAME = &quot;dbName&quot;;</span><br><span class="line">    public static final String FIELD_SQL_TEXT = &quot;sqlText&quot;;</span><br><span class="line">    public static final String FIELD_SQL_PARAMS = &quot;sqlParams&quot;;</span><br><span class="line">    public static final String FIELD_SQL_DURATION = &quot;sqlDuration&quot;;</span><br><span class="line">    public static final String FIELD_SQL_TIMESTAMP = &quot;sqlTimestamp&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String HOST_PATTERN_STR = &quot;(?&lt;=(https://|http://)).*?(?=/)&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String SLASH = &quot;/&quot;;</span><br><span class="line">    public static final String SLASH_DOUBLE = &quot;//&quot;;</span><br><span class="line"></span><br><span class="line">    public static final String LOG_EVENT_KIND = &quot;logEventKind&quot;;</span><br><span class="line">    public static final String LOG_EVENT_KIND_REQUEST_STACK = &quot;requestStack&quot;;</span><br><span class="line">    public static final String LOG_EVENT_KIND_DB_STACK = &quot;dbStack&quot;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="五-注册MyBatis拦截器"><a href="#五-注册MyBatis拦截器" class="headerlink" title="五. 注册MyBatis拦截器"></a>五. 注册MyBatis拦截器</h3><p>在<strong>MyBatis</strong>中注册拦截器，其实就是拿到<strong>MyBatis</strong>的<strong>Configuration</strong>后，调用其<strong>addInterceptor()</strong> 方法即可，所以有两种实现思路。</p>
<ol>
<li>提供<strong>ConfigurationCustomizer</strong>并在其<strong>customize()</strong> 方法中添加拦截器。<strong>ConfigurationCustomizer</strong>是<strong>mybatis-spring-boot-starter</strong>中提供出来专门用于定制化<strong>Configuration</strong>的，所以如果有使用<strong>mybatis-spring-boot-starter</strong>，那么可以基于<strong>ConfigurationCustomizer</strong>来添加拦截器到<strong>Configuration</strong>中；</li>
<li>自定义<strong>BeanPostProcessor</strong>并处理所有<strong>SqlSessionFactory</strong>。因为<strong>MyBatis</strong>整合到<strong>Spring</strong>中后，很核心的一点就是<strong>SqlSessionFactory</strong>会作为<strong>bean</strong>被注册到<strong>Spring</strong>容器中，所以可以提供一个<strong>BeanPostProcessor</strong>来处理所有的<strong>SqlSessionFactory</strong>，通过<strong>SqlSessionFactory</strong>拿到其持有的<strong>Configuration</strong>，然后调用<strong>addInterceptor()</strong> 方法添加拦截器。</li>
</ol>
<p>注意，在使用了<strong>mybatis-spring-boot-starter</strong>后，其实我们只需要将拦截器注册到<strong>Spring</strong>容器中即可，<strong>mybatis-spring-boot-starter</strong>提供的<strong>MybatisAutoConfiguration</strong>会获取到所有<strong>Spring</strong>容器中的拦截器，然后在构建<strong>SqlSessionFactory</strong>时会把拦截器都添加到<strong>Configuration</strong>中，所以此时我们再提供一个<strong>ConfigurationCustomizer</strong>，实际是会重复添加拦截器的，因此下面通过自定义<strong>BeanPostProcessor</strong>的方式来注册拦截器。</p>
<p>首先自定义一个<strong>BeanPostProcessor</strong>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SqlSessionFactoryBeanPostProcessor implements BeanPostProcessor &#123;</span><br><span class="line"></span><br><span class="line">    private final List&lt;Interceptor&gt; interceptors;</span><br><span class="line"></span><br><span class="line">    public SqlSessionFactoryBeanPostProcessor(List&lt;Interceptor&gt; interceptors) &#123;</span><br><span class="line">        if (null == interceptors) &#123;</span><br><span class="line">            this.interceptors = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            this.interceptors = interceptors;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;</span><br><span class="line">        if (bean instanceof SqlSessionFactory) &#123;</span><br><span class="line">            for (Interceptor interceptor : interceptors) &#123;</span><br><span class="line">                ((SqlSessionFactory) bean).getConfiguration().addInterceptor(interceptor);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后提供一个自动装配类<strong>HoneyDbTracingConfig</strong>，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Configuration</span><br><span class="line">@ConditionalOnClass(org.apache.ibatis.session.Configuration.class)</span><br><span class="line">@AutoConfigureAfter(HoneyTracingConfig.class)</span><br><span class="line">public class HoneyDbTracingConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public HoneyDbExecutorTracingInterceptor honeyDbExecutorTracingInterceptor(</span><br><span class="line">            Tracer tracer, List&lt;HoneyDbExecutorTracingDecorator&gt; honeyDbExecutorTracingDecorators) &#123;</span><br><span class="line">        honeyDbExecutorTracingDecorators.add(new HoneyDbExecutorTracingSpanDecorator());</span><br><span class="line">        return new HoneyDbExecutorTracingInterceptor(tracer, honeyDbExecutorTracingDecorators);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    @ConditionalOnMissingClass(&quot;org.mybatis.spring.boot.autoconfigure.ConfigurationCustomizer&quot;)</span><br><span class="line">    public BeanPostProcessor sqlSessionFactoryBeanPostProcessor(List&lt;Interceptor&gt; interceptors) &#123;</span><br><span class="line">        return new SqlSessionFactoryBeanPostProcessor(interceptors);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后在<strong>spring.factories</strong>文件中添加上述自动装配类，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line"> com.honey.tracing.config.HoneyTracingConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyTracingFilterConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyRestTemplateTracingConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyKafkaTemplateConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyKafkaTracingConfig,\</span><br><span class="line"> com.honey.tracing.config.HoneyDbTracingConfig</span><br></pre></td></tr></table></figure>

<h3 id="六-链路日志打印"><a href="#六-链路日志打印" class="headerlink" title="六. 链路日志打印"></a>六. 链路日志打印</h3><p>现在还需要在原有链路日志打印的基础上，把<strong>dbStack</strong>添加进去。</p>
<p>定义<strong>HoneyDbStack</strong>表示链路日志中的<strong>dbStacks</strong>字段，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class HoneyDbStack &#123;</span><br><span class="line"></span><br><span class="line">    private String dbServer;</span><br><span class="line">    private String dbName;</span><br><span class="line">    private String sqlText;</span><br><span class="line">    private String sqlParams;</span><br><span class="line">    private String sqlDuration;</span><br><span class="line">    private String sqlTimestamp;</span><br><span class="line"></span><br><span class="line">    private HoneyDbStack() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line">    </span><br><span class="line">    public static class HoneyDbStackBuilder &#123;</span><br><span class="line">        private LogData logData;</span><br><span class="line"></span><br><span class="line">        private HoneyDbStackBuilder() &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public static HoneyDbStackBuilder builder() &#123;</span><br><span class="line">            return new HoneyDbStackBuilder();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public HoneyDbStackBuilder withLogData(LogData logData) &#123;</span><br><span class="line">            this.logData = logData;</span><br><span class="line">            return this;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public HoneyDbStack build() &#123;</span><br><span class="line">            if (logData == null || logData.getFields() == null) &#123;</span><br><span class="line">                throw new HoneyTracingException();</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, ?&gt; logDataFields = logData.getFields();</span><br><span class="line">            HoneyDbStack honeyDbStack = new HoneyDbStack();</span><br><span class="line">            honeyDbStack.dbServer = (String) logDataFields.get(FIELD_DB_SERVER);</span><br><span class="line">            honeyDbStack.dbName = (String) logDataFields.get(FIELD_DB_NAME);</span><br><span class="line">            honeyDbStack.sqlText = (String) logDataFields.get(FIELD_SQL_TEXT);</span><br><span class="line">            honeyDbStack.sqlParams = (String) logDataFields.get(FIELD_SQL_PARAMS);</span><br><span class="line">            honeyDbStack.sqlDuration = new BigDecimal(String.valueOf(logDataFields.get(FIELD_SQL_DURATION)))</span><br><span class="line">                    .divide(BigDecimal.valueOf(1000), SCALE , RoundingMode.DOWN).toString();</span><br><span class="line">            honeyDbStack.sqlTimestamp = new BigDecimal(String.valueOf(logDataFields.get(FIELD_SQL_TIMESTAMP)))</span><br><span class="line">                    .divide(BigDecimal.valueOf(1000), SCALE , RoundingMode.DOWN).toString();</span><br><span class="line">            return honeyDbStack;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在<strong>HoneySpanReportEntity</strong>中做如下修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class HoneySpanReportEntity &#123;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    private List&lt;HoneyDbStack&gt; dbStacks = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    public void addDbStack(HoneyDbStack honeyDbStack) &#123;</span><br><span class="line">        dbStacks.add(honeyDbStack);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line"></span><br><span class="line">    public static class HoneySpanReportEntityBuilder &#123;</span><br><span class="line"></span><br><span class="line">        ......</span><br><span class="line">        </span><br><span class="line">        private Consumer&lt;LogData&gt; handleLogData(HoneySpanReportEntity honeySpanReportEntity) &#123;</span><br><span class="line">            return new Consumer&lt;LogData&gt;() &#123;</span><br><span class="line">                @Override</span><br><span class="line">                public void accept(LogData logData) &#123;</span><br><span class="line">                    if (LOG_EVENT_KIND_REQUEST_STACK.equals(logData.getFields().get(LOG_EVENT_KIND))) &#123;</span><br><span class="line">                        HoneyRequestStack honeyRequestStack = HoneyRequestStack.HoneyRequestStackBuilder</span><br><span class="line">                                .builder()</span><br><span class="line">                                .withLogData(logData)</span><br><span class="line">                                .build();</span><br><span class="line">                        honeySpanReportEntity.addRequestStack(honeyRequestStack);</span><br><span class="line">                    &#125; else if (LOG_EVENT_KIND_DB_STACK.equals(logData.getFields().get(LOG_EVENT_KIND))) &#123;</span><br><span class="line">                        HoneyDbStack honeyDbStack = HoneyDbStack.HoneyDbStackBuilder</span><br><span class="line">                                .builder()</span><br><span class="line">                                .withLogData(logData)</span><br><span class="line">                                .build();</span><br><span class="line">                        honeySpanReportEntity.addDbStack(honeyDbStack);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如此，在打印链路日志时，就会带上<strong>dbStack</strong>了。</p>
<h3 id="七-演示案例"><a href="#七-演示案例" class="headerlink" title="七. 演示案例"></a>七. 演示案例</h3><p>改造<strong>example-service-1</strong>，进行数据库链路追踪的测试。</p>
<p>首先<strong>pom</strong>文件添加如下依赖。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-j&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>由于需要把映射文件打进<strong>jar</strong>包，<strong>pom</strong>文件还需要添加如下构建步骤。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/java&lt;/directory&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/*.xml&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">            &lt;filtering&gt;false&lt;/filtering&gt;</span><br><span class="line">        &lt;/resource&gt;</span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>然后使用如下<strong>DDL</strong>语句在<strong>MySQL</strong>数据库中创建一张表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码CREATE TABLE `people` (</span><br><span class="line">  `id` int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  `p_name` varchar(255) NOT NULL,</span><br><span class="line">  `p_age` int(11) NOT NULL,</span><br><span class="line">  PRIMARY KEY (`id`)</span><br><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8;</span><br></pre></td></tr></table></figure>

<p>这张表的映射接口，映射文件和对应实体对象如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public interface PeopleMapper &#123;</span><br><span class="line"></span><br><span class="line">    People selectOne(@Param(&quot;peopleName&quot;) String peopleName,</span><br><span class="line">                     @Param(&quot;peopleAge&quot;) int peopleAge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.honey.tracing.example.mapper.PeopleMapper&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;peopleResultMap&quot; type=&quot;com.honey.tracing.example.entity.People&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;id&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;peopleName&quot; column=&quot;p_name&quot;/&gt;</span><br><span class="line">        &lt;result property=&quot;peopleAge&quot; column=&quot;p_age&quot;/&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;selectOne&quot; resultMap=&quot;peopleResultMap&quot;&gt;</span><br><span class="line">        SELECT</span><br><span class="line">            p.id,</span><br><span class="line">            p.p_name,</span><br><span class="line">            p.p_age</span><br><span class="line">        FROM</span><br><span class="line">            people p</span><br><span class="line">        WHERE</span><br><span class="line">            p.p_name=#&#123;peopleName&#125;</span><br><span class="line">        AND</span><br><span class="line">            p.p_age=#&#123;peopleAge&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class People &#123;</span><br><span class="line"></span><br><span class="line">    private int id;</span><br><span class="line">    private String peopleName;</span><br><span class="line">    private int peopleAge;</span><br><span class="line"></span><br><span class="line">    // 省略getter和setter</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后在配置文件中加入数据库相关配置。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码spring:</span><br><span class="line">  datasource:</span><br><span class="line">    username: root</span><br><span class="line">    password: root</span><br><span class="line">    url: jdbc:mysql://192.168.101.5:3306/test</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br></pre></td></tr></table></figure>

<p>由于并没有通过<strong>mybatis.mapper-locations</strong>来指定映射文件位置，所以我们需要在启动类上添加@<strong>MapperScan</strong>注解来扫描得到映射接口和映射文件，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@MapperScan</span><br><span class="line">@EnableAsync</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class Application &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后提供一个<strong>MyBatisController</strong>来查询数据库，如下所示。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@RestController</span><br><span class="line">public class MyBatisController &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private PeopleMapper peopleMapper;</span><br><span class="line"></span><br><span class="line">    @GetMapping(&quot;/mybatis/select&quot;)</span><br><span class="line">    public People selectOne(@RequestParam(&quot;peopleName&quot;) String peopleName,</span><br><span class="line">                            @RequestParam(&quot;peopleAge&quot;) int peopleAge) &#123;</span><br><span class="line">        return peopleMapper.selectOne(peopleName, peopleAge);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动<strong>example-service-1</strong>，调用如下接口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt复制代码http://localhost:8080/mybatis/select?peopleName=Lee&amp;peopleAge=20</span><br></pre></td></tr></table></figure>

<p>链路日志打印如下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">json复制代码&#123;</span><br><span class="line">    &quot;traceId&quot;: &quot;a33ddc958ecc4a46cf2a63b19a6fd064&quot;,</span><br><span class="line">    &quot;spanId&quot;: &quot;cf2a63b19a6fd064&quot;,</span><br><span class="line">    &quot;parentSpanId&quot;: &quot;0000000000000000&quot;,</span><br><span class="line">    &quot;timestamp&quot;: &quot;1709298263420&quot;,</span><br><span class="line">    &quot;duration&quot;: &quot;7&quot;,</span><br><span class="line">    &quot;httpCode&quot;: &quot;200&quot;,</span><br><span class="line">    &quot;host&quot;: &quot;http://localhost:8080&quot;,</span><br><span class="line">    &quot;requestStacks&quot;: [],</span><br><span class="line">    &quot;dbStacks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;dbServer&quot;: &quot;192.168.101.8:3306&quot;,</span><br><span class="line">            &quot;dbName&quot;: &quot;test&quot;,</span><br><span class="line">            &quot;sqlText&quot;: &quot;SELECT p.id, p.p_name, p.p_age FROM people p WHERE p.p_name=? AND p.p_age=?&quot;,</span><br><span class="line">            &quot;sqlParams&quot;: &quot;Lee,20&quot;,</span><br><span class="line">            &quot;sqlDuration&quot;: &quot;4&quot;,</span><br><span class="line">            &quot;sqlTimestamp&quot;: &quot;1709298263421&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文基于<strong>MyBatis</strong>拦截器，实现了数据库链路追踪，核心思路就是通过拦截器，拿到本次<strong>SQL</strong>执行的相关信息，并输出到链路信息中。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358688805157404709" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>NopReport的可扩展设计如何实现二维码导出</title>
    <url>/7358691823545581603.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>NopReport是从零开始编写的下一代中国式报表引擎，它的核心仅有3000多行代码，但是完整实现了中国式非线性报表理论所定义的层次坐标和行列对称展开算法。</p>
<ul>
<li>使用介绍：<a href="https://zhuanlan.zhihu.com/p/620250740" target="_blank" rel="noopener">采用Excel作为设计器的开源中国式报表引擎:NopReport</a>, <a href="https://www.bilibili.com/video/BV1Sa4y1K7tD/" target="_blank" rel="noopener">视频讲解</a></li>
<li>源码分析: <a href="https://zhuanlan.zhihu.com/p/663964073" target="_blank" rel="noopener">非线性中国式报表引擎NopReport源码解析</a>，<a href="https://www.bilibili.com/video/BV17g4y1o7wr/" target="_blank" rel="noopener">视频讲解</a></li>
</ul>
<p>NopReport并没有内置二维码展现这种业务相关的组件，但是它遵循了可逆计算理论，所以内置了大量可扩展机制可以用于引入扩展组件。本文以实现二维码导出为例介绍NopReport中的可扩展机制，这些机制是基于可逆计算理论自然导出，并不限于在Nop平台中使用，对于其他框架的可扩展性也可以起到指导作用。</p>
<h2 id="一-配置导出二维码"><a href="#一-配置导出二维码" class="headerlink" title="一. 配置导出二维码"></a>一. 配置导出二维码</h2><p>目前<code>nop-report-ext</code>模块提供了二维码扩展组件。使用时需要引入如下jar包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码    &lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;io.github.entropy-cloud&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;nop-report-ext&lt;/artifactId&gt;</span><br><span class="line">    &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在Excel模板中，通过单元格的注解调用<code>QRCODE()</code>扩展函数。<a href="https://gitee.com/canonical-entropy/nop-entropy/raw/master/nop-report/nop-report-demo/src/main/resources/_vfs/nop/report/demo/base/11-%E6%89%93%E5%8D%B0%E6%9D%A1%E7%A0%81%E5%92%8C%E4%BA%8C%E7%BB%B4%E7%A0%81.xpt.xlsx" target="_blank" rel="noopener">示例模板</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c47cea60b36eacea792851cf4b31bc0f0825ccfa9149fd0c2968efd1b6d43216" alt></p>
<ul>
<li>valueExpr: 这里只是通过valueExpr来直接指定一个演示用的输出值，实际开发中可以利用NopReport内置的其他机制来生成单元格的值</li>
<li>formatExpr: 因为在最终输出的Excel以及展示用的HTML页面上我们并不需要输出单元格的值，所以这里指定formatExpr返回空字符串。否则在二维码上会叠加显示对应的文本。</li>
<li>processExpr: 调用扩展函数<code>QRCODE</code>，实际生成二维码</li>
<li><code>qr:barcodeFormat</code>: 指定输出条码格式，缺省是<code>QRCODE</code>，指定为<code>CODE_128</code>生成条形码。</li>
</ul>
<p><code>qr:</code>为前缀的变量是传递给<code>QRCODE</code>函数的扩展数据，但是并不需要直接作为<code>QRCODE</code>函数的参数传递。可以设置的属性值对应于<a href="https://gitee.com/canonical-entropy/nop-entropy/blob/master/nop-integration/nop-integration-api/src/main/java/io/nop/integration/api/qrcode/QrcodeOptions.java" target="_blank" rel="noopener">QrcodeOptions.java</a>类中的成员变量。</p>
<p>可以通过<code>qr:width</code>和<code>qr:height</code>来指定输出图形的大小。如果不指定，则会自动使用当前单元格的宽高。</p>
<h2 id="二-实现原理"><a href="#二-实现原理" class="headerlink" title="二. 实现原理"></a>二. 实现原理</h2><h3 id="1-单元格模型的可扩展属性"><a href="#1-单元格模型的可扩展属性" class="headerlink" title="1. 单元格模型的可扩展属性"></a>1. 单元格模型的可扩展属性</h3><p>NopReport的设计遵循可逆计算原理，系统化的采用 <code>(data,ext_data)</code>这样的配对设计，确保在任何模型节点上都可以追加扩展属性。缺省情况下，所有具有名字空间的属性都不参与元模型校验，因此我们可以引入<code>qr</code>名字空间，通过它设置二维码输出所需要的配置信息，比如二维码格式、大小等。如果需要校验qr名字空间中的属性格式，则可以引入一个自定义的xdef元模型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;workbook xdef:check-ns=&quot;qr&quot;&gt;</span><br><span class="line">  &lt;sheets&gt;</span><br><span class="line">    &lt;sheet&gt;</span><br><span class="line">      &lt;table&gt;</span><br><span class="line">        &lt;rows&gt;</span><br><span class="line">          &lt;cell&gt;</span><br><span class="line">            &lt;model xdef:name=&quot;XptCellModel&quot;</span><br><span class="line">                   qr:barcodeFormat=&quot;string&quot; qr:margin=&quot;int&quot; qr:imgType=&quot;string&quot; qr:width=&quot;double&quot;</span><br><span class="line">                   qr:height=&quot;double&quot; qr:encoding=&quot;string&quot; qr:errorCorrection=&quot;int&quot;&gt;</span><br><span class="line">            &lt;/model&gt;</span><br><span class="line">          &lt;/cell&gt;</span><br><span class="line">        &lt;/rows&gt;</span><br><span class="line">      &lt;/table&gt;</span><br><span class="line">    &lt;/sheet&gt;</span><br><span class="line">  &lt;/sheets&gt;</span><br><span class="line">&lt;/workbook&gt;</span><br></pre></td></tr></table></figure>

<p>目前NopReport采用Excel为可视化设计器，在单元格的注解中设置单元格模型信息。后续还会提供在线可视化编辑，此时就可以xdef元模型中声明的属性定义自动生成可视化编辑页面。</p>
<h3 id="2-可扩展的函数空间"><a href="#2-可扩展的函数空间" class="headerlink" title="2. 可扩展的函数空间"></a>2. 可扩展的函数空间</h3><p>NopReport提供了<code>expandExpr</code>、<code>valueExpr</code>、<code>formatExpr</code>、<code>styleIdExpr</code>、<code>processExpr</code>等多种表达式配置，可以调用外部函数来完成复杂逻辑处理。NopReport的表达式引擎从Nop平台内置的XLang表达式引擎扩展而来（在XLang EL的基础上增加了报表层次坐标语法），因此它自动继承了XLang中定义的全局函数和全局对象。同时，报表引擎还为报表执行环境引入了报表专用的一系列函数。</p>
<h4 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码// 注册XLang EL全局函数</span><br><span class="line">EvalGlobalRegistry.instance().registerStaticFunctions(GlobalFunctions.class);</span><br><span class="line"></span><br><span class="line">// 注册Report执行环境专用的报表函数</span><br><span class="line">ReportFunctionProvider.INSTANCE.registerStaticFunctions(ReportExtFunctions.class);</span><br></pre></td></tr></table></figure>

<p>一般情况下可以仿照<code>nop-report-ext</code>模块中的做法，在初始化的时候注册扩展函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class ReportExtInitializer &#123;</span><br><span class="line"></span><br><span class="line">    @PostConstruct</span><br><span class="line">    public void init() &#123;</span><br><span class="line">        ReportFunctionProvider.INSTANCE.</span><br><span class="line">                  registerStaticFunctions(ReportExtFunctions.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="集成IoC容器"><a href="#集成IoC容器" class="headerlink" title="集成IoC容器"></a>集成IoC容器</h4><p>除了全局注册之外，在表达式中还可以直接通过<code>inject</code>函数获取到NopIoC容器中管理的bean，例如<code>inject(&#39;qrService&#39;).genQrCode(&#39;123456&#39;)</code>。</p>
<blockquote>
<p>因为NopIoC支持类似Spring容器的BeanScope概念，从NopIoC获取的bean不一定都是单例对象</p>
</blockquote>
<h4 id="调用时传入"><a href="#调用时传入" class="headerlink" title="调用时传入"></a>调用时传入</h4><p>在调用具体报表时还可以通过scope对象传入帮助对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码IEvalScope scope = XLang.newEvalScope();</span><br><span class="line">scope.setLocalValue(&quot;myTool&quot;, new MyTool());</span><br><span class="line">reportEngine.getRenderer(&quot;/my.xpt.xlsx&quot;,&quot;html&quot;).generateToFile(file, scope);</span><br></pre></td></tr></table></figure>

<p>在表达式中就可以调用myTool对象上的方法，例如<code>myTool.myMethod(cell.value)</code></p>
<h4 id="报表内定义"><a href="#报表内定义" class="headerlink" title="报表内定义"></a>报表内定义</h4><p>NopReport引擎与一般的报表引擎非常不一样的地方是，它非常强调报表模型的自包含性和自定义抽象的能力。在报表模型的【展开前】配置中，我们可以定义仅在这个报表中使用的函数。<strong>这个函数定义存放在报表模型中，而不需要外部注册或者传入</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/193f0f39a6875fceba5c9b2590f58ae0183cef3db93de8b65dac951943267a24" alt></p>
<p>在【展开前】配置中，我们可以利用XPL模板语言的标签库抽象，来动态加载外部标签函数。后续Nop平台将会为所有XPL配置段提供通用的逻辑编排可视化设计器，这样就可以使用可视化配置的方式为报表模型引入自定义函数。</p>
<ol start="3">
<li>隐式传递的上下文</li>
</ol>
<hr>
<p>Nop平台为开发自定义的领域模型(Domain Model)和领域特定语言(DSL, Domain Specific Language)提供了一系列标准的套路，这其中就包含在表达式语言中引入的隐式上下文的概念。</p>
<p>当我们在一个特定领域（或者特定业务场景）中工作的时候，总是会有一些系统性的背景知识，当我们编写特定的业务代码时，我们可以假定这些背景知识是已知的或者可以按照某种确定性的方式推导得到的，从而原则上并不需要在代码中明确指明。<br>但是一般情况下，我们编码使用的是通用语言和通用框架，并不存在一种简单的、标准化的方式将这些知识内置到语言中，因此我们经常会发现大量仅起粘结作用的胶水代码中，一些背景信息被重复的表达多次。</p>
<p>比如说，在报表引擎中，我们的背景知识是报表运行时总是存在一个上下文对象<code>IXptRuntime</code>，在我们调用函数的时候能否不显式传递这个参数，而是假定它是一种可以隐式传递的背景知识？<br>如果我们不希望在调用所有函数的时候都显式传递IXptRuntime，一般的做法是将上下文对象通过<code>ThreadLocal</code>这种近似全局变量的方式进行传递，这种方式会破坏函数的结构，引入不必要的复杂性。</p>
<p>Nop平台的XLang语言中引入了隐式参数的概念，它类似于Scala语言中的implicit语法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scala复制代码// scala语言中的隐式参数</span><br><span class="line">def welcome(implicit name: String) = s&quot;Welcome, $name!&quot;</span><br><span class="line"></span><br><span class="line">implicit val guestName: String = &quot;Guest&quot;</span><br><span class="line"></span><br><span class="line">println(welcome) // 输出: Welcome, Guest!</span><br></pre></td></tr></table></figure>

<p>scala语言中会按照类型自动查找上下文中的implicit变量，并自动绑定为函数参数。 Nop平台的Xpl模板语言提供了implicit参数，但是它是按照name来实现隐式绑定。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;!-- 标签库my.xlib --&gt;</span><br><span class="line"></span><br><span class="line">&lt;lib&gt;</span><br><span class="line">  &lt;tags&gt;</span><br><span class="line">    &lt;MyTag&gt;</span><br><span class="line">      &lt;attr name=&quot;xptRt&quot; implicit=&quot;true&quot; /&gt;</span><br><span class="line">      &lt;source&gt;</span><br><span class="line">        ...</span><br><span class="line">      &lt;/source&gt;</span><br><span class="line">    &lt;/MyTag&gt;</span><br><span class="line">  &lt;/tags&gt;</span><br><span class="line">&lt;/lib&gt;</span><br></pre></td></tr></table></figure>

<p>调用标签的时候可以传入xptRt参数。也可以不设置参数，则会自动绑定上下文中的同名变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;my:MyTag /&gt;</span><br></pre></td></tr></table></figure>

<p>在XLang表达式中，也提供了隐式传递IEvalScope的机制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码    @EvalMethod</span><br><span class="line">    public static ExcelImage QRCODE(IEvalScope scope) &#123;</span><br><span class="line">        IXptRuntime xptRt = IXptRuntime.fromScope(scope);</span><br><span class="line">        ExpandedCell cell = xptRt.getCell();</span><br><span class="line"></span><br><span class="line">        QrcodeOptions options = new QrcodeOptions();</span><br><span class="line">        cell.getModel().readExtProps(&quot;qr:&quot;, true, options);</span><br><span class="line">        ...</span><br><span class="line">        return image;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>如果函数上标记了<code>@EvalMethod</code>注解，则第一个参数必须是IEvalScope。在表达式中调用的时候会自动传入表达式的运行时scope。通过scope可以获取到上下文中的其他变量。</p>
<p><code>ReportExtFunctions</code>中定义的<code>QRCODE</code>函数就是使用这种隐式参数机制，因此不需要显式传递IXptRuntime上下文对象。在<code>QRCODE</code>函数中可以通过IXptRuntime得到当前正在处理的单元格对象，并进而可以获取到单元格模型上的扩展属性。</p>
<p>基于可逆计算理论设计的低代码平台NopPlatform已开源：</p>
<ul>
<li>gitee: <a href="https://gitee.com/canonical-entropy/nop-entropy" target="_blank" rel="noopener">canonical-entropy/nop-entropy</a></li>
<li>github: <a href="https://github.com/entropy-cloud/nop-entropy" target="_blank" rel="noopener">entropy-cloud/nop-entropy</a></li>
<li>开发示例：<a href="https://gitee.com/canonical-entropy/nop-entropy/blob/master/docs/tutorial/tutorial.md" target="_blank" rel="noopener">docs/tutorial/tutorial.md</a></li>
<li><a href="https://www.bilibili.com/video/BV14u411T715" target="_blank" rel="noopener">可逆计算原理和Nop平台介绍及答疑_哔哩哔哩_bilibili</a></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358691823545581603" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,低代码,架构</tag>
      </tags>
  </entry>
  <entry>
    <title>突破数据存储瓶颈！转转业财系统亿级数据存储优化实践</title>
    <url>/7358704806779437097.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1.背景"></a>1.背景</h2><h3 id="1-1-现状"><a href="#1-1-现状" class="headerlink" title="1.1 现状"></a>1.1 现状</h3><p>目前转转业财系统接收了上游各个业务系统（例如：订单、oms、支付、售后等系统）的数据，并将其转换为财务数据，最终输出财务相关报表和指标数据，帮助公司有效地进行财务管理和决策。</p>
<p>转转业财系统于2021年开始构建，前期为了满足需求短时间内上线，选择了主动接收上游业务系统的数据。然而随着时间的推移，数据量在不断增长，系统已经达到无法承载的边缘，引发了许多问题。因此，我们需要对数据存储进行优化。</p>
<h3 id="1-2-数据量统计"><a href="#1-2-数据量统计" class="headerlink" title="1.2 数据量统计"></a>1.2 数据量统计</h3><p>业财系统数据量较大表统计：</p>
<table>
<thead>
<tr>
<th>表名</th>
<th>行数</th>
<th>数据长度</th>
<th>索引长度</th>
</tr>
</thead>
<tbody><tr>
<td>出库明细表</td>
<td>106280176</td>
<td>29.48GB</td>
<td>34GB</td>
</tr>
<tr>
<td>出库单头表</td>
<td>25344110</td>
<td>7GB</td>
<td>6GB</td>
</tr>
<tr>
<td>入库明细表</td>
<td>22766910</td>
<td>8GB</td>
<td>5GB</td>
</tr>
<tr>
<td>销售订单表</td>
<td>29578659</td>
<td>10GB</td>
<td>9GB</td>
</tr>
<tr>
<td>应收单表</td>
<td>24686267</td>
<td>5GB</td>
<td>2GB</td>
</tr>
<tr>
<td>入库单表</td>
<td>20777457</td>
<td>4GB</td>
<td>6GB</td>
</tr>
<tr>
<td>应付单表</td>
<td>15387724</td>
<td>4GB</td>
<td>2GB</td>
</tr>
</tbody></table>
<p>以下是数据量较大的表数据增量趋势图，可以观察到近几个月由于新业务的增加，每月的数据增量已经达到一千万。 <img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c89e234fc5c49460148a6e0cf5e7b1b360c7f34496ab2c305585f4f676296f68" alt></p>
<h3 id="1-3-慢查询情况"><a href="#1-3-慢查询情况" class="headerlink" title="1.3 慢查询情况"></a>1.3 慢查询情况</h3><p>从慢查询监控平台可以看到，每天慢查询个数已经到达千量级别。慢查询不仅影响用户体验，还会大量消耗所在机器资源，严重可能导致机器宕机。另外，转转MySQL数据库架构属于单机多实例，一台物理机上部署多套集群的实例，所以不仅会影响系统本身集群，还会拖累其他集群，引发雪球效应。 <img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/50b3d204816435d46970ed348685fdbc7b7c66458b4b424fc7cad68dca916f83" alt></p>
<h2 id="2-设计目标"><a href="#2-设计目标" class="headerlink" title="2.设计目标"></a>2.设计目标</h2><h3 id="2-1-解决数据量问题"><a href="#2-1-解决数据量问题" class="headerlink" title="2.1 解决数据量问题"></a>2.1 解决数据量问题</h3><p>在未来五年，不用考虑数据库数据量问题，能够轻松应对未来的业务增长和覆盖公司全量业务，且具备良好的扩展性，最终可以稳定向外输出更多数据报表等。</p>
<h3 id="2-2-解决读写性能"><a href="#2-2-解决读写性能" class="headerlink" title="2.2 解决读写性能"></a>2.2 解决读写性能</h3><p>通过此次优化，提升报表查询效率，减少定时任务执行时间，避免因为慢查询导致任务失败和接口超时问题，提高服务稳定性。</p>
<h2 id="3-方案选择"><a href="#3-方案选择" class="headerlink" title="3.方案选择"></a>3.方案选择</h2><h3 id="3-1-db存储方案选型"><a href="#3-1-db存储方案选型" class="headerlink" title="3.1 db存储方案选型"></a>3.1 db存储方案选型</h3><p>为解决底层表数据量问题，我们对比了以下四个方案：</p>
<ul>
<li><strong>方案一：分库分表</strong></li>
<li>优点</li>
</ul>
<ol>
<li>将数据分散到多个数据库和表中，从而减轻单一数据库的负载压力。这样可以提高数据库的读写性能和响应速度，降低查询延迟。</li>
<li>拆分的表结构相同，程序改造较少。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>需要提前规划好分片规则，一旦定好规则就难以移动，扩展性比较差。</li>
<li>拆分规则很难抽象出来。</li>
<li>跨库事务问题。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>数据库面临高并发访问的压力，又需要面对海量数据的存储问题，这时需要对数据库既采用分表策略，又采用分库策略，以便同时扩展系统的并发处理能力，以及提升单表的查询性能。</li>
<li>数据有统一的业务规则主键，使数据可以均匀分布。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>业财系统作为底层系统，接受了各个业务系统的数据，数据比较多样性和复杂性，很难定义出一个业务主键，数据分布均匀困难。</li>
<li>若某业务数据量迅速增长或接入其他业务数据，那么可能又会面对数据量问题。</li>
</ol>
<ul>
<li><strong>方案二：冷热库</strong></li>
<li>优点</li>
</ul>
<ol>
<li>将不常访问的数据从在线存储中移动到归档存储中，减少了在线存储的容量需求，从而降低了存储成本。</li>
<li>减少了在线存储中数据的数量，因此可以提高数据库读写性能。</li>
<li>可以将历史数据长期保存，避免了数据的丢失。</li>
<li>可以将数据备份到不同的存储位置，以便在需要时进行数据恢复。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>需要保证归档事务性，防止归档数据同时出现在冷热库，出现数据重复。</li>
<li>需要考虑合适的归档策略，不影响服务访问。</li>
<li>需要有明确的业务边界，业务复杂的数据不适用。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>数据库中存在大量的历史数据，且查询频率比较低。</li>
<li>数据库的写入操作比读取操作更频繁。</li>
<li>数据库的存储成本较高，需要降低成本。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>业财系统业务数据复杂，现阶段还会更改和查询历史数据，时间口径不统一，边界比较模糊，无法确认一个准确的边界。</li>
<li>考虑后续接入更多的业务数据，由于目前无法统一数据格式，那么可能就需要重新考虑边界等问题。</li>
</ol>
<ul>
<li><strong>方案三：TiDB</strong></li>
<li>优点</li>
</ul>
<ol>
<li>高度兼容 MySQL：大多数情况下，无需修改代码即可从MySQL轻松迁移至TiDB。</li>
<li>水平弹性扩展：通过简单地增加新节点即可实现 TiDB 的水平扩展，按需扩展吞吐或存储，轻松应对高并发、海量数据场景。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>仍有一些MySQL的特性和行为，TiDB目前暂时不支持或表现与MySQL有差异。</li>
<li>系统复杂，组件太多。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>对数据一致性及高可靠、系统高可用、可扩展性、容灾要求较高的金融行业属性的场景。</li>
<li>对存储容量、可扩展性、并发要求较高的大量数据及高并发的OLTP场景。</li>
<li>数据汇聚、二次加工处理的场景。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>由于TiDB兼容了MySQL，所以改动点也较少。</li>
<li>近几年是不用考虑数据量问题，可以接入更多样化数据。</li>
<li>TiDB能够支持大表经常有加列减列的需求，可扩展性高，目前也比较符合业财现状。</li>
</ol>
<ul>
<li><strong>方案四：OceanBase</strong></li>
<li>优点</li>
</ul>
<ol>
<li>高性能：采用了读写分离的架构，把数据分为基线数据和增量数据。其中增量数据放在内存里（MemTable），基线数据放在SSD盘（SSTable）。对数据的修改都是增量数据，只写内存。所以DML是完全的内存操作，性能非常高。</li>
<li>高兼容：兼容常用MySQL/ORACLE功能及MySQL/ORACLE前后台协议，业务零修改或少量修改即可从MySQL/ORACLE迁移至OceanBase。</li>
<li>高可用：数据采用多副本存储，少数副本故障不影响数据可用性。</li>
</ol>
<ul>
<li>缺点</li>
</ul>
<ol>
<li>对环境要求极高，需要采购使用其指定的服务器。</li>
<li>学习和运维成本比较高。</li>
<li>尽管OceanBase具有高可用性的特性，但其实现仍然依赖于底层硬件和网络的稳定性。</li>
</ol>
<ul>
<li>适用场景</li>
</ul>
<ol>
<li>金融级数据可靠性需求。金融环境下通常对数据可靠性有更高的要求，OceanBase 每一次事务提交，对应日志总是会在多个数据中心实时同步，并持久化。</li>
<li>数据库面对飞速增长的业务数据量。</li>
</ol>
<ul>
<li>业财系统适用分析</li>
</ul>
<ol>
<li>目前运维没有维护，所以就不考虑此方案，大家可以参考此方案是否适用于本身系统。</li>
</ol>
<p>综合以上各个方案的分析，目前最适用于转转业财系统的方案是TiDB。该方案能够在短时间内解决数据量问题，并且改动成本相对较低。</p>
<h3 id="3-2-慢查询优化方案"><a href="#3-2-慢查询优化方案" class="headerlink" title="3.2 慢查询优化方案"></a>3.2 慢查询优化方案</h3><p>在分析了慢查询语句以后，发现大部分慢查询都是由于联表查询导致的，所以此次主要解决联表问题。 联表解决方案对比如下，根据适用分析选择ES方案。</p>
<table>
<thead>
<tr>
<th>方案</th>
<th>业财适用分析</th>
</tr>
</thead>
<tbody><tr>
<td>宽表</td>
<td>1.宽表可能包含大量重复数据，导致存储空间的浪费。这会增加数据库的存储需求，尤其在大规模数据集上会更为显著 2.由于涉及到大量列和关联数据，后续性能优化可能需要考虑更多的因素，而且可能需要采用复杂的索引策略 3.复杂度增加，改动量比较大</td>
</tr>
<tr>
<td>ES</td>
<td>1.通过建立索引方式解决联表问题，也一并提高了查询效率 2.后续可扩展性比较高，增加查询条件等，都易实现 3.需要保持数据源与ES数据一致问题 4.可以减低现有的数据库索引数据量</td>
</tr>
</tbody></table>
<h2 id="4-方案实践"><a href="#4-方案实践" class="headerlink" title="4.方案实践"></a>4.方案实践</h2><h3 id="4-1-方案实践步骤"><a href="#4-1-方案实践步骤" class="headerlink" title="4.1 方案实践步骤"></a>4.1 方案实践步骤</h3><p>根据方案选择分析，最适合业财系统当前状况的方案是首先切换底层数据存储，然后再接入ES。在实施这两个方案之前，我们需要考虑它们的先后顺序，并分析业财系统的现状。 由于数据量的突增，考虑到现有业务和后续新增业务，同时在不影响现有使用的前提下，首要需要解决的问题是数据量。因此，我们建议首先切换底层数据存储。这样做的好处是，即使在后续的实施中遇到问题，我们仍然可以回滚到原有的数据存储。这样既可以保证数据的完整性，也减少了实施过程中的风险。另一方面，如果我们选择先接入ES，就需要考虑如何保证数据切换过程中的数据完整性，并且同步方式也需要考虑两种不同数据存储方案之间的兼容性，这将增加许多额外的工作量和风险。</p>
<p>综上所述，我们选择的优化步骤是首先切换底层数据存储，待其稳定后再接入ES。这样能够有效解决当前的数据量问题，同时保证系统的稳定性和数据完整性。随后，我们可以继续进行ES的接入，以进一步优化业财系统的性能。</p>
<h3 id="4-2-切换底层数据存储步骤"><a href="#4-2-切换底层数据存储步骤" class="headerlink" title="4.2 切换底层数据存储步骤"></a>4.2 切换底层数据存储步骤</h3><p>在选择数据迁移方式时，考虑到业财系统对实时性要求并不是很高，且评估了下目前大部分数据接入写入方式，是可以接受停写几分钟，这样便大大降低了整个数据迁移成本。</p>
<p>迁移过程要求：</p>
<ol>
<li>检查TiDB是否都能兼容目前服务中的SQL语句，保证迁移之后系统不会报错。</li>
<li>数据需要保证完整性，迁移之后需要保证MySQL库和TiDB库的数据是严格一致。</li>
<li>迁移过程中需要做到可以回滚，一旦迁移过程中出现问题，可以立即回滚到MySQL库，不会对系统可用性造成影响。 <img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ca8cc0dcb8368371405ac5d8db4ac494a48e229de05f76d868f282b38f4e5d59" alt></li>
</ol>
<h3 id="4-3-接入ES"><a href="#4-3-接入ES" class="headerlink" title="4.3 接入ES"></a>4.3 接入ES</h3><ol>
<li>根据报表查询页面的功能和联表SQL分析，我们进行了索引模型设计，核心是优化查询性能和提高系统的响应速度。</li>
<li>在建立索引模型之后，我们需要考虑数据库（DB）与Elasticsearch（ES）之间增量数据的同步方式。</li>
</ol>
<p>以下表格是对比了四种不同的同步方式，我们根据已设计的索引分析，考虑到每个索引涉及的表较多、相关业务代码尚未收口以及对实时性较高的需求，我们决定采用数据订阅的方式进行同步。在当前公司提供的实现方式中，我们选择了Kafka。</p>
<table>
<thead>
<tr>
<th>同步方式</th>
<th>优点</th>
<th>缺点</th>
</tr>
</thead>
<tbody><tr>
<td>同步双写</td>
<td>这种方式简单粗暴，实时性高</td>
<td>1.业务耦合：这种方式代码侵入性强，耦合大量数据同步代码，要在写DB的地方写ES的代码 2. 影响性能：写入两个存储，响应时间变长，系统的性能必然会下降 3.不便扩展：搜索可能有一些个性化需求，需要对数据进行聚合，这种方式不便实现 4.高风险：存在双写失败丢数据风险</td>
</tr>
<tr>
<td>异步双写</td>
<td>1.性能高 2.不易出现数据丢失问题 3.多源写入之间相互隔离，便于扩展更多的数据源写入</td>
<td>1.硬编码问题，接入新的数据源需要实现新的消费者代码 2.系统复杂度增加，引入了消息中间件 3.MQ是异步消费模型，用户写入的数据不一定可以马上看到，造成延时</td>
</tr>
<tr>
<td>定期同步</td>
<td>实现比较简单</td>
<td>1.实时性难以保证 2.对存储压力较大</td>
</tr>
<tr>
<td>数据订阅</td>
<td>1.业务入侵较少 2.实时性比较高</td>
<td>需要选型数据订阅框架，系统复杂度增加</td>
</tr>
</tbody></table>
<ol start="3">
<li>在增量数据同步以后，最后一步就是需要完成历史数据的同步，此次我们选择的同步方式是公司内部提供的ECP，可以参考文章： <a href="https://dev.newban.cn/7354922285094207540">不可思议！亿级数据竟然如此轻松同步至ES！</a></li>
</ol>
<h2 id="5-总结与成果"><a href="#5-总结与成果" class="headerlink" title="5.总结与成果"></a>5.总结与成果</h2><p>目前，业财系统已成功完成底层数据存储的切换，可以看到近几年来不再担心数据量存储的问题，并且成功接入了更多的业务数据。随着引入了Elasticsearch（ES），业务人员也不再反馈报表页面超时等问题。这次针对数据存储的优化实质上是对系统的重构，选择方案时考虑了对系统影响范围较小且不影响业务人员使用的因素，这也是优化的核心所在。</p>
<p>由于历史原因，业财系统仍存在许多需要优化的方面，如慢SQL的持续治理、定时任务优化等。因此，我们需要保持此优化的核心理念，并在后续的重构中继续完善，以使业财系统更加稳定。</p>
<hr>
<blockquote>
<p>关于作者</p>
</blockquote>
<p>戴美琪，转转交易中台研发工程师</p>
<p><code>&gt; 转转研发中心及业界小伙伴们的技术学习交流平台，定期分享一线的实战经验及业界前沿的技术话题。</code></p>
<p><code>&gt; 关注公众号「转转技术」（综合性）、「大转转FE」（专注于FE）、「转转QA」（专注于QA），更多干货实践，欢迎交流分享~</code></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358704806779437097" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSFTP和FTP访问时相对路径引发的问题汇总</title>
    <url>/7358699186630098979.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>常用的 Java SSH 操作工具包是 jsch ，FTP 工具包 commons-net ，本文将总结 Java 程序通过 SFTP 协议和 FTP 协议访问远程文件的过程中，需要注意的路径问题。</p>
<p>本文主要包括下面三个问题：</p>
<ol>
<li>FTPClient 获取当前用户根目录的方法</li>
<li>ChannelSftp 获取当前用户根目录的方法。</li>
<li>目录切换时，如果是相对目录，可能存在的问题。</li>
<li>目标目录不存在时，逐级创建目录的方法。</li>
</ol>
<h3 id="相对路径操作注意事项"><a href="#相对路径操作注意事项" class="headerlink" title="相对路径操作注意事项"></a>相对路径操作注意事项</h3><p>jsch 通过 ChannelSftp 访问 SFTP 时，获取当前登录用户根目录的方法有两种：</p>
<ol>
<li><code>pwd()</code> 方法</li>
<li><code>getHome()</code> 方法</li>
</ol>
<p>两者在刚刚登录成功后返回的值是一样的，都是当前登录用户的 home 目录。<br>FTPClient 获取当前登录用户的根目录方法为：<code>printWorkingDirectory()</code> 。</p>
<p><strong>注意：如果操作的目标目录是相对路径</strong>，例如目标目录变量名称为 dir，判断绝对路径的方法为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">boolean isNotAbsolutePath = !dir.startWith(File.separator);</span><br><span class="line">if (isNotAbsolutePath) &#123;</span><br><span class="line">   String homePath = ftpClient.printWorkingDirectory();</span><br><span class="line">   或 </span><br><span class="line">   String homePath = sftpChannel.pwd();</span><br><span class="line">   </span><br><span class="line">   // 最后拼接上根目录</span><br><span class="line">   dir = homePath + File.separator + dir;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修正操作目标路径为绝对路径后，后面的操作就不会报文件不存在错误了。</p>
<h3 id="listFiles-的内容"><a href="#listFiles-的内容" class="headerlink" title="listFiles 的内容"></a>listFiles 的内容</h3><p>FTPClient 的 listFiles 文件列表中不包含 <code>.</code> 和 <code>..</code> 这两个特殊的文件，但是使用 jsch 的 <code>ChannelSftp</code> 的 ls 直接列出的文件却包含 <code>.</code> 和 <code>..</code> 。</p>
<p>所以在遍历文件过程中，对于 Sftp 访问操作，需要排除这两种特殊文件。</p>
<h3 id="相对路径时-ls-或-cd-异常问题"><a href="#相对路径时-ls-或-cd-异常问题" class="headerlink" title="相对路径时 ls 或 cd 异常问题"></a>相对路径时 ls 或 cd 异常问题</h3><p>如果使用相对路径，ChannelSftp 的 ls 操作会异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.jcraft.jsch.SftpException: No such file</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp.throwStatusError(ChannelSftp.java:2873) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2225) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp._stat(ChannelSftp.java:2242) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1592) ~[jsch-0.1.54.jar:?]</span><br><span class="line">	at com.jcraft.jsch.ChannelSftp.ls(ChannelSftp.java:1553) ~[jsch-0.1.54.jar:?]</span><br></pre></td></tr></table></figure>

<p>解决办法，就是第二部分「相对路径操作注意事项」的内容，必须在真正切换目录之前拼接上当前登录用户的根目录。</p>
<h3 id="逐级创建目录的方法"><a href="#逐级创建目录的方法" class="headerlink" title="逐级创建目录的方法"></a>逐级创建目录的方法</h3><p>Java 的 FTP 和 SFTP 工具操作是的 mkdir 方法，当父级目录不存在时，直接用目录创建方法会失败，只能逐级创建每个目录。</p>
<p>确实有些场景下需要自动创建一个多层级的新目录，解决办法就是逐级拆解路径，判断当前路径是否存在，如果不存在，就创建，直到到达最后一级。</p>
<p>FTPClient 逐级创建一个目标目录 <code>dirPath</code> 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void createFilePath(FTPClient ftpClient, String filePath) &#123;</span><br><span class="line">    String[] dirPaths = filePath.split(&quot;/&quot;);</span><br><span class="line">    for (int i = 0; i &lt; dirPaths.length; i++) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(dirPaths[i])) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            buffer.append(dirPaths[j]).append(&quot;/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tempDir = buffer.toString();</span><br><span class="line">        try &#123;</span><br><span class="line">            // 切换目录，如果成功，则忽略</span><br><span class="line">            boolean change= ftpClient.changeWorkingDirectory(filePath);</span><br><span class="line">            if (change) &#123;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            // 切换失败，则创建</span><br><span class="line">            boolean result = ftpClient.makeDirectory(tempDir);</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            // ERROR</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ChannelSftp 逐级创建一个目标目录 <code>dirPath</code> 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private boolean createFilePath(ChannelSftp channelSftp, String filePath) &#123;</span><br><span class="line">    String[] dirPaths = filePath.split(&quot;/&quot;);</span><br><span class="line">    for (int i = 0; i &lt; dirPaths.length; i++) &#123;</span><br><span class="line">        if (StringUtils.isEmpty(dirPaths[i])) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        StringBuffer buffer = new StringBuffer();</span><br><span class="line">        for (int j = 0; j &lt;= i; j++) &#123;</span><br><span class="line">            buffer.append(dirPaths[j]).append(&quot;/&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String tempDir = buffer.toString();</span><br><span class="line">        try &#123;</span><br><span class="line">            channelSftp.mkdir(tempDir);</span><br><span class="line">        &#125; catch (SftpException ex) &#123;</span><br><span class="line">            // ERROR</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FTPClient 有 changeWorkingDirectory 方法返回一个 boolean 值，可以判断目录是否存在，不存在可以执行创建操作；ChannelSftp 的 cd 没有返回值，所以直接mkdir 逐级创建。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358699186630098979" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs开发进阶L-异步执行和优化机制</title>
    <url>/7358704808525381651.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>本章节笔者想要来讨论一下JavaScript异步执行相关的内容，这个内容本来是应该放在本系列中比较前面的部分的，但由于思考和规划的问题，到现在才有机会涉及和实现。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>在准备本文的时候，笔者参考了一些技术博客和文档，结合以前的一些应用的经验和体验，笔者已经了解到JS代码执行的基本原理，包括其中的一些核心概念。关于同步线程这部分一般没有太多的疑问。但很多材料都提到了异步任务这里面包括了微任务和宏任务及其执行策略等，并例举了一些方法并对其进行了归类。笔者原来也是大致这么理解的，但随着深入的了解和思考，特别是参考了nodejs官方的技术文档，笔者觉得原来的一些常规的理解，好像有一些不准确或者被误导的地方，当然也可能是版本或者认知演进的结果。这里笔者想来先探讨一下。</p>
<p>这个文档在这里： <a href="https://nodejs.org/en/guides/event-loop-timers-and-nexttick" target="_blank" rel="noopener">nodejs.org/en/guides/e…</a></p>
<p>笔者觉得这个材料里面的描述应该更加准确，本文中的阐述，就以此文作为基本的依据，并结合笔者的理解展开。</p>
<p>首先我们还是来复述和熟悉和复述一下JS执行代码的基本原理和方式。和传统程序顺序式的执行方式不同，JS程序的执行特点是虽然JS主要以单线程的模式运行，但通过事件循环的调度模式，它可以支持异步代码以非阻塞的方式执行，从而获得更充分的CPU运行资源的利用，和更高效的IO操作。整个执行模型，涉及以下核心的流程和概念：</p>
<ul>
<li>单线程模型 (Single Thread)</li>
</ul>
<p>在JS程序执行时，在其主进程中，代码和程序默认是以单线程模型来进行执行的。它将要执行的代码和任务分成两个大类：同步线程和异步任务。程序会先执行同步线程中，此处所有任务完成后，会使用事件循环的调度机制来实现代码和程序的非阻塞的异步执行。</p>
<p>同步线程的执行容易理解，和常规的软件程序基本无异。但在事件循环机制中，异步化程序和任务可能是以交错的形式来进行的，但编写代码和调用程序只能使用顺序的方式，这通常是刚接触JS程序的开发者容易感到比较困惑的地方。</p>
<p>但笔者觉得不必过分担心，在对JS的执行机制有了基础的理解和认知，并且经过一段时间的实践和操作后，开发者一个个就可以比较熟练的掌握这个机制，并正确的编写和执行相关代码，来满足应用和业务的需求。</p>
<ul>
<li>同步线程（Synchronous Thread）</li>
</ul>
<p>指的是在JS的主线程中，使用同步方式，按照顺序执行的普通代码和任务。这些代码会按照书写顺序从上到下执行，每行同步代码在执行时，JavaScript引擎其实会一直阻塞，直到此任务执行完毕，然后才会执行下一个任务。这就是所谓的阻塞式执行。</p>
<p>所有同步线程代码执行完成之后，JS引擎就会使用事件循环机制来执行异步代码。整个程序进入事件循环的处理阶段。从表面上看来，这个主线程已经执行完成了，分支任务会进入非阻塞的执行模式。就是所谓的非阻塞执行。</p>
<ul>
<li>事件循环</li>
</ul>
<p>事件循环是nodejs进行异步代码执行的核心调度和控制机制。通过这个机制，nodejs可以尽量将操作卸载到操作系统内核来执行非阻塞I/O操作。由于大多数现代操作系统内核都是多线程的，因此它们可以处理在后台执行的多个操作。当这些操作之一完成时，内核会通知nodejs，以便将适当的回调添加到轮询队列中以完成最终执行。</p>
<p>下图简化显示了事件循环的操作顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">   ┌───────────────────────────┐</span><br><span class="line">┌─&gt;│           Timers          │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │     pending callbacks     │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">│  │       idle, prepare       │</span><br><span class="line">│  └─────────────┬─────────────┘      ┌───────────────┐</span><br><span class="line">│  ┌─────────────┴─────────────┐      │   incoming:   │</span><br><span class="line">│  │           poll            │&lt;─────┤  connections, │</span><br><span class="line">│  └─────────────┬─────────────┘      │   data, etc.  │</span><br><span class="line">│  ┌─────────────┴─────────────┐      └───────────────┘</span><br><span class="line">│  │           check           │</span><br><span class="line">│  └─────────────┬─────────────┘</span><br><span class="line">│  ┌─────────────┴─────────────┐</span><br><span class="line">└──┤      close callbacks      │</span><br><span class="line">   └───────────────────────────┘</span><br></pre></td></tr></table></figure>

<p>图中，每个框被称为事件循环的一个“阶段”。整个事件循环大体分为六个阶段，并且进行循环往复的运行。在每次运行事件循环之间，系统都会检查是否正在等待任何异步I/O或计时器，如果没有，则彻底关闭当前程序(程序自动退出)。</p>
<p>每个阶段都有一个要执行的回调的FIFO(先入先出)队列。虽然每个阶段都有其特殊之处，但通常，当事件循环进入给定阶段时，它将执行特定于该阶段的任何操作，然后执行该阶段队列中的回调，直到队列耗尽或达到最大回调数已执行。当队列耗尽或达到回调限制时，事件循环将进入下一阶段，依此类推。</p>
<p>由于这些操作中的任何一个都可能调度更多的操作，并且在轮询阶段处理的新事件由内核排队，因此轮询事件可以在处理轮询事件时排队。因此，长时间运行的回调可能会使轮询阶段的运行时间比计时器的阈值长得多。有关更多详细信息，请参阅计时器和轮询部分。</p>
<p>Windows和Unix/Linux实现之间存在轻微差异(因为涉及到操作系统底层的执行机制)，但这对于基本原理而言并不重要。下面我们分别简单说明一下这些执行阶段。</p>
<ul>
<li>计时器 Timers</li>
</ul>
<p>这个阶段，将会执行setTimeout和setInterval计划的回调。计时器指定了一个时间阈值，在该阈值之后可以执行所提供的回调，而非指定其希望执行的确切时间。这个回调方法将在指定时间过后“尽早”运行，显然操作系统调度或其他回调的运行可能会造成它们的延迟。从技术上讲，这个执行其实是在轮询阶段启动的。</p>
<ul>
<li>待处理回调 Pending Callbacks</li>
</ul>
<p>此阶段，执行被推迟到下一个循环迭代的I/O回调方法。</p>
<p>此阶段执行一下系统操作的回调，如TCP错误。例如，如果 TCP 套接字ECONNREFUSED在尝试连接时接收，某些 *nix 系统希望等待报告错误。这将在待处理回调阶段排队执行。</p>
<ul>
<li>空闲/准备 Idle/Prepare</li>
</ul>
<p>这个阶段仅在内部使用，和用户程序无关 。</p>
<ul>
<li>轮询 Poll</li>
</ul>
<p>这个阶段，其实是事件循环处理的核心阶段。此阶段主要有两个功能，第一是计算应该阻塞和轮询I/O的时间，然后处理轮询队列中的事件。具体而言，当事件循环进入轮询阶段并且没有调度计时器时，将发生以下两种情况之一：</p>
<p>一、如果轮询队列不为空，则事件循环将迭代其回调队列，并以同步方式执行它们，直到队列耗尽或达到系统相关的硬限制</p>
<p>二、如果轮询队列为空，则会发生以下两种情况之一：如果脚本已被调度setImmediate()，事件循环将结束轮询阶段并继续到检查阶段以执行那些调度的脚本；如果脚本尚未被调度setImmediate()，事件循环将等待回调被添加到队列中，然后立即执行它们。</p>
<p>一旦轮询队列执行完毕，事件循环将检查是否已达到时间阈值的计时器。如果一个或多个计时器准备就绪，事件循环将返回到计时器阶段以执行这些计时器的回调。</p>
<ul>
<li>检查 Check</li>
</ul>
<p>此阶段允许在轮询阶段完成后立即执行回调。如果轮询阶段变得空闲并且脚本已排队setImmediate()，则事件循环可能会继续进入检查阶段而不是等待。</p>
<p>setImmediate()实际上是一个特殊的计时器，在事件循环的单独阶段运行。它使用libuv API安排回调在轮询阶段完成后执行。</p>
<p>一般来说，随着代码的执行，事件循环最终将进入轮询阶段，它将等待传入的连接、请求等。但是，如果已安排回调并且setImmediate() 轮询阶段变得空闲，则它将结束并继续 检查阶段而不是等待轮询事件。</p>
<ul>
<li>关闭回调 Close Callbacks</li>
</ul>
<p>如果系统关联的套接字或句柄突然关闭(例如socket.destroy()），该’close’事件将在此阶段发出。否则它将通过 发出process.nextTick()。</p>
<ul>
<li>setTimeout和setImmediate</li>
</ul>
<p>两者的主要差异是调用的时机不同。setImmediate设计为在当前轮询阶段完成后执行，setTimeout安排在最小时间阈值过去后运行。所以，在真正的程序中，计时器的执行顺序将根据调用它们的上下文而变化。如果两者都是从主模块内部调用的，那么计时将受到进程性能的约束，并可能受到其他程序的影响。</p>
<p>例如，如果我们运行以下不在I/O周期（即主模块）内的脚本，则两个计时器的执行顺序是不确定的，因为它受到进程性能的约束：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// timeout_vs_immediate.js</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(&apos;timeout&apos;);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">setImmediate(() =&gt; console.log(&apos;immediate&apos;));</span><br></pre></td></tr></table></figure>

<p>有趣的是，笔者在实验中，并没有找到一个特定场景能够来验证这一点。大部分实验的结果表明，似乎setImmediate有更高的优先级和立即执行的机会。简单的理论上也可以理解，就是它会在poll阶段，有机会被执行，而不需要等待到timer阶段来处理。</p>
<p>实际上，这些细微的差异，对于我们开发普通的应用程序，几乎没有什么影响。除非是我们需要开发系统级，或者对性能和执行次序需要非常精密的控制，才有机会需要深入的理解和应用。我们只需要大致理解，回调方法，作为异步调用，可能会改变代码执行的顺序(相对于编写)，这时可能需要编写特别的代码组织方式，才可能可以控制异步代码可以按照预先的方式和顺序执行。</p>
<h2 id="回调地狱-Callback-Hell"><a href="#回调地狱-Callback-Hell" class="headerlink" title="回调地狱 Callback Hell"></a>回调地狱 Callback Hell</h2><p>按照JS异步调用函数默认的回调工作方式，当在逻辑上，对于比较复杂的有多个步骤的业务流程，可能需要将很多函数调用链接起来的时候，最简单的方式，就是将回调“嵌套起来”，就是在回调方法中，来调用其他的异步方法。这个时候，对于一个比较复杂的调用链，就会出现所谓“回调地狱”的情况(借用下图)。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c37a6971c99c1b06ba748a2e4bc162c5da550ae78843899a726d66c745aea80" alt="callback-hell.png"></p>
<p>JS程序和执行器，其实对于这个情况是无所谓的，只要逻辑不冲突，写成什么样子，都不影响它的执行。感到恐慌的其实只有开发者，特别是那些有代码洁癖的人。当然，从软件工程的角度，这样的代码也确实不好调试、移植和维护，比如要在中间加一个处理环节，就不能像普通顺序执行的代码那么轻松简单了。</p>
<p>所以我们还是希望，尽量以人类比较好理解的方式，来组织这些代码和逻辑。因此，JS语言就引入了Promise和Async/Await等模式，它们都是用来方便解决这类问题而产生的。</p>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>解决回调地狱的一个方式，是使用Promise(承诺)机制。关于这个机制的比较官方的解释和说明，应该在这里：</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">developer.mozilla.org/en-US/docs/…</a></p>
<p>笔者的简单解读和理解如下。</p>
<p>首先Promise是一个类和对象，它用于表示一个异步操作的事件性结束(无论成功或者失败)和其结果值。这个对象，有下列三种状态之一：</p>
<ul>
<li>Pending(等待): 也是其初始状态</li>
<li>Fulfilled(实现): 操作已经成功完成</li>
<li>Rejected(拒绝): 操作失败</li>
</ul>
<p>基于这个结构，我们可以进一步理解，Promise是未来某个值的代理，就是在Promise创建时该值可能还不确定，但是它允许你用它封装一个异步操作的处理程序，来返回最终成功值或者失败的信息。然后，可以像同步方法一样调用，并返回结果，不是立即返回最终值，而是返回Promise来在将来提供值(下图)。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b586bfdc6b7e72ddbf33f957000c3b0f73cd8beb604ef012d4568ce41a9a2ac9" alt="promises.png"></p>
<p>为了便于读者理解这个问题，并对Promise的执行方式有直观的了解，笔者编写了一个简单的扔硬币游戏，用到了Promise对象，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// promise define</span><br><span class="line">const p = new Promise((f,r)=&gt; Math.random()*10 &gt; 5 ? f(&quot;win&quot;) : r(&quot;false&quot;));</span><br><span class="line"></span><br><span class="line">// promise call</span><br><span class="line">p</span><br><span class="line">.then(d1=&gt;&#123; return d1; &#125;)</span><br><span class="line">.then(d2=&gt;console.log(d2))</span><br><span class="line">.catch(console.log);</span><br></pre></td></tr></table></figure>

<p>眼尖的读者应该可以看到，这个游戏的规则是必须两次都扔到正面才能算赢，否则都是输。这里的要点如下:</p>
<ul>
<li>Promise的构建函数，参数是一个方法，回调参数就是fulfill和reject方法</li>
<li>开发者应该可以根据业务需求，重写回调方法内容，在其中进行业务操作</li>
<li>在业务操作代码中的合适的场景，调用fulfill或者reject，代表Promise的等待状态结束并返回结果(成功或者失败)</li>
<li>可以使用then方法，来执行Promise，并捕获处理结果</li>
<li>可以使用catch方法，来捕获失败的信息</li>
<li>then方法可以多次调用，上一次成功调用的返回值，会作为参数传递到下一个调用</li>
<li>利用then的链接式调用，Promise可以处理逻辑前后关联的多个异步业务操作</li>
</ul>
<p>Promise的正常调用方法，都是在其原型中定义的：</p>
<ul>
<li>Promise.prototype.then()</li>
</ul>
<p>用于承载和处理fulfilled的结果，这个结果将会作为then方法的参数注入，便于在then方法内部进行引用和处理。由于此方法的返回结果是Promise实例本身，所以then方法可以支持链式调用的形式，可以处理流程化执行的场景。</p>
<ul>
<li>Promise.prototype.catch()</li>
</ul>
<p>用于承载和处理reject或者错误throw的结果，这个结果将会作为catch方法的参数注入，便于在其内部进行引用和处理。</p>
<ul>
<li>Promise.prototype.finally()</li>
</ul>
<p>表示Promise调用的结束，在这里可以做一些收尾的工作。我们可以发现，这个结构其实很像JS标准的try-catch-finally结构。</p>
<h2 id="Promise扩展方法"><a href="#Promise扩展方法" class="headerlink" title="Promise扩展方法"></a>Promise扩展方法</h2><p>前面我们已经看到了Promise的典型用法，但实际上原生的Promise其实有更丰富的特性。它们体现为一系列相关的静态方法，我们可以查阅Promise的文档，获得更完整的信息。</p>
<h3 id="快捷构造方法"><a href="#快捷构造方法" class="headerlink" title="快捷构造方法"></a>快捷构造方法</h3><p>首先是一类快速构造方法，它们可以用于快速的创建确定结果的Promise对象，方便日常开发和操作。</p>
<ul>
<li>resolve</li>
</ul>
<p>resolve方法，可以用于直接创建一个只能fulfilled的Promise对象。其参数是成功处理的结果。</p>
<ul>
<li>reject</li>
</ul>
<p>和resolve方法相对，它可以用于直接创建一个只能reject的Promise对象。</p>
<ul>
<li>withResolvers()</li>
</ul>
<p>这个方法用于快速的创建一个可结构的对象，包括Promise、Resolve和Reject方法，然后可以在后续定义处理方法。下面是一个简单的示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let &#123; promise, resolve, reject &#125; = Promise.withResolvers();</span><br><span class="line"></span><br><span class="line">// 等效于</span><br><span class="line">let resolve, reject;</span><br><span class="line">const promise = new Promise((res, rej) =&gt; &#123; resolve = res; reject = rej; &#125;);</span><br></pre></td></tr></table></figure>

<h3 id="组合Promise方法"><a href="#组合Promise方法" class="headerlink" title="组合Promise方法"></a>组合Promise方法</h3><p>其中有一类是可以将多个Promise进行组合处理的方法，包括了all、allSettled、any、race等，它们都是Promise的静态方法，输入参数是多个Promise对象，可以处理多个Promise对象和它们之间的业务逻辑关系。</p>
<ul>
<li>all</li>
</ul>
<p>all方法的输入是一个Promise实例数组，它可以迭代这个数组并生成一个新的Promise对象，如果数组中所有的Promise都fulfilled，则整体fulfilled，并返回完成结果的数组；否则返回第一个reject的值。all方法将一个Promise数组当成单一Promise对象看待，只有所有操作都成功，则返回成功结果(也是以数组方式)，否则返回第一个失败的结果作为整体失败的结果。</p>
<ul>
<li>allSettled</li>
</ul>
<p>allSettled和all方法稍有差异，它也是返回一个结果Promise，但这个Promise的结果总是fulfilled一个和输入Promise数组对应的结果数组，里面同时包括成功或者失败结果。就如它的名字一样，它是能够成功返回所有结果已经设置好的这么一个Promise，只不过结果中有成功或者失败信息而已。这个结果是一个对象数组，对象属性包括status和value（详见示例）。</p>
<ul>
<li>any</li>
</ul>
<p>这个可以和all对应，类似于与和或的逻辑关系。就是只需要有一个fulfilled，这个结果就fulfilled；只有所有Promise都reject，结果Promise才reject。</p>
<ul>
<li>race</li>
</ul>
<p>就如方法名称那样，这个方法将同步执行输入Promise的数组，并将第一个有结果(成功或者失败)的Promise作为这个race Promise整体的结果。</p>
<p>可以看到，上面几个方法的基本逻辑都是可以将多个Promise转换并作为成为单一的Promise来处理，可以用于处理很多组合式的业务操作。下面笔者编写了一个简单的示例，让我们方便的对比和理解这些操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">const p1 = Promise.resolve(3);</span><br><span class="line">const p2 = Promise.reject(&quot;false2&quot;);</span><br><span class="line">const p3 = 42;</span><br><span class="line">const p4 = new Promise((f,r) =&gt; setTimeout(f, 500, &apos;bar&apos;));</span><br><span class="line">const p5 = new Promise((f,r) =&gt; setTimeout(f, 200, &apos;foo&apos;));</span><br><span class="line"></span><br><span class="line">// all </span><br><span class="line">const pAll = (plist)=&gt; </span><br><span class="line">Promise.all(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;1 OK:&quot;, values))</span><br><span class="line">.catch(err=&gt;console.log(&quot;1 False:&quot;, err));</span><br><span class="line"></span><br><span class="line">pAll([p1,p3,p4]);</span><br><span class="line">pAll([p1,p4,p2]);</span><br><span class="line"></span><br><span class="line">// all setteled</span><br><span class="line">const pAllSet = (plist)=&gt; </span><br><span class="line">Promise.allSettled(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;2 Result:&quot;, values));</span><br><span class="line"></span><br><span class="line">pAllSet([p1,p3,p4]);</span><br><span class="line"></span><br><span class="line">// all setteled</span><br><span class="line">const pAny = (plist)=&gt; </span><br><span class="line">Promise.any(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;3 Result:&quot;, values))</span><br><span class="line">.catch(err=&gt;console.log(&quot;3 False:&quot;, err));</span><br><span class="line"></span><br><span class="line">pAny([p2,p3,p4]);</span><br><span class="line"></span><br><span class="line">// all setteled</span><br><span class="line">const pRace = (plist)=&gt; </span><br><span class="line">Promise.race(plist)</span><br><span class="line">.then((values) =&gt; console.log(&quot;4 Result:&quot;, values))</span><br><span class="line">.catch(err=&gt;console.log(&quot;4 False:&quot;, err));</span><br><span class="line"></span><br><span class="line">pRace([p4,p5]);</span><br><span class="line"></span><br><span class="line">// result </span><br><span class="line">3 Result: 42</span><br><span class="line">1 False: false2</span><br><span class="line">4 Result: foo</span><br><span class="line">1 OK: [ 3, 42, &apos;bar&apos; ]</span><br><span class="line">2 Result: [</span><br><span class="line">  &#123; status: &apos;fulfilled&apos;, value: 3 &#125;,</span><br><span class="line">  &#123; status: &apos;fulfilled&apos;, value: 42 &#125;,</span><br><span class="line">  &#123; status: &apos;fulfilled&apos;, value: &apos;bar&apos; &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="async-await"><a href="#async-await" class="headerlink" title="async / await"></a>async / await</h2><p>我们前面已经看到，使用Promise的链接的then方法调用，可以将多个异步调用可以从先后的逻辑上组织起来，模拟顺序调用的形式。但很多人觉得，这可能离传统的代码书写方式，天然的前后逻辑关系和调用次序的组织，还是有一些差异的。因此，JS社区就在Promise的基础上，进一步提出的async/await的执行模式。</p>
<p>我们先研究一段简单的代码，方便后续讨论：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">const pcall2 = async()=&gt;&#123;</span><br><span class="line">    await pAll([p1,p4,p2]);</span><br><span class="line">    await pAllSet([p1,p3,p4]);</span><br><span class="line">    await pAny([p4,p5]);</span><br><span class="line">    await pRace([p4,p5]);</span><br><span class="line">&#125;; pcall2();</span><br></pre></td></tr></table></figure>

<p>如果有读者注意到前面Promise章节示例代码的执行顺序的话，就会发现，它们并不是按照代码编写的顺序来执行的，而是按照异步执行的逻辑来执行。如果我们想要强制的按照调用顺序来执行，就需要使用asnyc/await机制来进行控制。从示例中，我们可以看到这个相关代码编写的规则如下：</p>
<p>async是一个修饰符或者声明，它加在函数的定义或者声明之前。这样，这个函数就有了两个额外的特性。第一，作为被调用者，这个函数可以返回一个Promise对象，并可以被await语句；第二，作为调用者，它可以作为await方法的容器，在其中，使用await方式调用的异步方法，都会严格按照编写顺序执行。</p>
<p>await是个异步方法执行修饰符。它可以像同步方法一样用于执行一个被Promise化的异步方法，它的返回值是正常resolve值。如果需要处理reject值，则可能需要使用try-catch机制。</p>
<p>所以我们可以看到，本质而言，async/await就是一个“语法糖”，用于满足编写更简洁、优雅、直观的JS异步执行代码的需求。在很多情况下，如果弄清了调用的逻辑关系， Promise的Then方法，和await调用方式也是可以组合使用的，它们在逻辑上是等效的。</p>
<h2 id="Async-Npm"><a href="#Async-Npm" class="headerlink" title="Async Npm"></a>Async Npm</h2><p>除了Nodejs官方提供的异步执行处理机制之外，开源社区在原来Nodejs异步机制尚不是特别完善的阶段，也提出了很多相关的技术方案，并以npm的形式交付。典型的如async，bluebird等等，但随着Nodejs本身的异步机制逐渐成熟，这些第三方库的必要性也在降低。</p>
<p>即便如此，除了处理Promise之外，以Async为代表的异步库，其实可以提供更多丰富而强大的异步执行控制的扩展功能。特别是Async库，笔者认为，对其充分的了解、掌握和使用，对于业务应用开发，还是有很大的帮助的。关于这一点，笔者有机会会另外专门写一个博客来讨论。async npm的官方页面在此处：</p>
<p><a href="https://caolan.github.io/async/v3/" target="_blank" rel="noopener">caolan.github.io/async/v3/</a></p>
<p>这里考虑到篇幅限制，只讨论一个简单的应用场景和实现，就是将多个并行的任务队列化。比如业务需求，需要在短时间内，通过请求外部 HTTP API接口方式，发送大量消息。我们了解到，最佳的策略并不是完全并发执行，那样会造成服务器短时间负载过大而宕机的风险，而是使用一个队列来处理发送，才能保证比较平稳而高效的完成所有的发送任务，从整体上达到最高的效率。这通常也被形象的称为“削峰填谷”。</p>
<p>我们下面，就以async为例，探讨一下它对于任务队列(queue)这种场景实现，它使用了queue模块。我们先讨论一下它的基本原理。</p>
<p>async/queue的大致工作原理是基于通过维护和执行一个任务队列对象来完成的。首先创建一个任务队列，这个步骤需要定义任务排队后执行的回调方法和并发数量；有任务到来时，默认被添加到队列尾部；任务处理从队列头部开始，队列会依次取出并且调用执行任务，它会将任务作为参数传入回调函数，并执行这个方法；执行完成后，会执行此回调预定的完成回调方法，来标识当前任务的完成； 看到任务完成之后，队列就将任务从队列中取出下一个任务来执行；如此往复，直到这个队列中所有的任务都完成，这里有一个名词就是Drain(耗尽)，这时队列就是空的了，它会等待新的任务入队。</p>
<p>基于此原理，其相关示例代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import queue from &apos;async/queue&apos;;</span><br><span class="line"></span><br><span class="line">// create a queue object with concurrency 2</span><br><span class="line">const q = async.queue(function(task, callback) &#123;</span><br><span class="line">    console.log(&apos;hello &apos; + task.name);</span><br><span class="line">    callback();</span><br><span class="line">&#125;, 2);</span><br><span class="line"></span><br><span class="line">// assign an error callback</span><br><span class="line">q.error(function(err, task) &#123;</span><br><span class="line">    console.error(&apos;task experienced an error&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// assign a callback</span><br><span class="line">q.drain(function() &#123;</span><br><span class="line">    console.log(&apos;all items have been processed&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// add some items to the queue</span><br><span class="line">q.push(&#123;name: &apos;foo&apos;&#125;, function(err) &#123;</span><br><span class="line">    console.log(&apos;finished processing foo&apos;);</span><br><span class="line">&#125;);</span><br><span class="line">// callback is optional</span><br><span class="line">q.push(&#123;name: &apos;bar&apos;&#125;);</span><br><span class="line"></span><br><span class="line">// add some items to the queue (batch-wise)</span><br><span class="line">q.push([&#123;name: &apos;baz&apos;&#125;,&#123;name: &apos;bay&apos;&#125;,&#123;name: &apos;bax&apos;&#125;], function(err) &#123;</span><br><span class="line">    console.log(&apos;finished processing item&apos;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// add some items to the front of the queue</span><br><span class="line">q.unshift(&#123;name: &apos;bar&apos;&#125;, function (err) &#123;</span><br><span class="line">    console.log(&apos;finished processing bar&apos;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码来自async的官方示例，笔者进行了最简单的修改，这里的要点如下：</p>
<ul>
<li>queue是async库的一个模块和类，用于处理队列，需要先引用一下</li>
<li>在使用之前，需要先创建一个queue的实例</li>
<li>构建方法包括两个参数，第一个参数定义任务处理回调，第二个参数是可选并行任务的数量</li>
<li>任务处理回调方法中，定义具体的任务执行方式(业务需求)，并且在任务执行完成后，回调执行任务完成方法</li>
<li>可选定义error方法，用于处理队列级别的错误</li>
<li>可选定义drain方法，用于处理队列耗尽时，需要进行的操作</li>
<li>使用push方法，可以将任务加入到队列的尾部，排队等待处理，并且可选使用数组，同时加入多个任务</li>
<li>使用unshift方法，可以将任务加入到队列的头部，它们会被优先执行(在当前任务接收后就会被调用)</li>
<li>单个任务，也可以选择定义完成时的回调，作为一些任务的特别处理的机会</li>
<li>这里的任务，可以只包括业务数据，相关的调用和回调方法，可以选择设置</li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>本文探讨了Nodejs应用中，异步执行相关的话题。包括Nodejs程序和代码执行的基本工作原理，对于异步执行的理解，回调地狱，Promise，Async/Await，以及Async NPM等相关的内容，希望能够帮助读者从简单的基础理论出发，结合Promise、Async等的实际应用，对JS的异步执行有更深入和细致的理解。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358704808525381651" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,JavaScript,Node.js</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】如何在Vue&lt;component&gt;切换子组</title>
    <url>/7358702198589341734.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在项目中使用 Vue <code>&lt;component&gt;</code> 遇到了一些挑战，特别是在需要对子组件中的表单进行校验时。问题在于，通过点击 <code>&lt;el-aside&gt;</code> 标签切换子组件时，并不能自动触发表单校验，这就需要在父组件中集成对子组件表单的校验逻辑。因此写下本篇博文记录这个问题并分享相关思考以及解决方法。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3aaea1a5f0ad04d25e6627d0bc060036b2f6921d61864b38075a7744014deb10" alt="q0.gif"></p>
<p>本篇博文所使用到的所有代码<a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components" target="_blank" rel="noopener">点击此处进行跳转</a>。</p>
<p>博文中的所有代码全部收集在<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fsid10t%2Fvue-learn_and_upgrade" target="_blank" rel="noopener">博主的 GitHub 仓库</a>中，相关技术栈专栏如下：</p>
<ul>
<li><a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a>;</li>
<li><a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>;</li>
</ul>
<h1 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h1><ul>
<li>Vue2；</li>
<li>element 2.15.14；</li>
</ul>
<p>这里参照 <a href="https://element.eleme.cn/#/zh-CN/component/installation" target="_blank" rel="noopener">官方文档</a> 安装 Element，并在项目的 <code>main.js</code> 文件里进行导入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import Vue from &apos;vue&apos;</span><br><span class="line">import ElementUI from &apos;element-ui&apos;;</span><br><span class="line">import &apos;element-ui/lib/theme-chalk/index.css&apos;;</span><br><span class="line">import App from &apos;./App.vue&apos;</span><br><span class="line"></span><br><span class="line">Vue.config.productionTip = false</span><br><span class="line">Vue.use(ElementUI);</span><br><span class="line"></span><br><span class="line">new Vue(&#123;</span><br><span class="line">  render: h =&gt; h(App),</span><br><span class="line">&#125;).$mount(&apos;#app&apos;)</span><br></pre></td></tr></table></figure>

<p>根据 <a href="https://element.eleme.cn/#/zh-CN/component/container" target="_blank" rel="noopener">官方文档</a> 构建一个自定义化容器，效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/becc929d12271c779ec37b9f62addce915fae1767f0d62364130bad426988d58" alt="q1.gif"></p>
<p>构建容器代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;el-container style=&quot;height: 700px; border: 1px solid #eee&quot;&gt;</span><br><span class="line">    &lt;el-aside width=&quot;200px&quot; style=&quot;background-color: rgb(238, 241, 246)&quot;&gt;</span><br><span class="line">      &lt;el-menu :default-openeds=&quot;[&apos;1&apos;]&quot; @select=&quot;handleSelect&quot;&gt;</span><br><span class="line">        &lt;el-submenu index=&quot;1&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;</span><br><span class="line">            &gt;&lt;i class=&quot;el-icon-message&quot;&gt;&lt;/i&gt;导航一</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">          &lt;el-menu-item index=&quot;1-1&quot;&gt;选项1&lt;/el-menu-item&gt;</span><br><span class="line">          &lt;el-menu-item index=&quot;1-2&quot;&gt;选项2&lt;/el-menu-item&gt;</span><br><span class="line">        &lt;/el-submenu&gt;</span><br><span class="line">        &lt;el-menu-item index=&quot;2&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;&gt;&lt;i class=&quot;el-icon-menu&quot;&gt;&lt;/i&gt;导航二&lt;/template&gt;</span><br><span class="line">        &lt;/el-menu-item&gt;</span><br><span class="line">        &lt;el-menu-item index=&quot;3&quot;&gt;</span><br><span class="line">          &lt;template slot=&quot;title&quot;&gt;</span><br><span class="line">            &lt;i class=&quot;el-icon-setting&quot;&gt;&lt;/i&gt;导航三</span><br><span class="line">          &lt;/template&gt;</span><br><span class="line">        &lt;/el-menu-item&gt;</span><br><span class="line">      &lt;/el-menu&gt;</span><br><span class="line">    &lt;/el-aside&gt;</span><br><span class="line"></span><br><span class="line">    &lt;el-container&gt;</span><br><span class="line">      &lt;el-main&gt;</span><br><span class="line">        &lt;ItemOne v-if=&quot;currentIndex === &apos;1&apos;&quot;&gt;&lt;/ItemOne&gt;</span><br><span class="line">        &lt;GroupOne v-else-if=&quot;currentIndex === &apos;1-1&apos;&quot;&gt;&lt;/GroupOne&gt;</span><br><span class="line">        &lt;GroupTwo v-else-if=&quot;currentIndex === &apos;1-2&apos;&quot;&gt;&lt;/GroupTwo&gt;</span><br><span class="line">        &lt;ItemTwo v-else-if=&quot;currentIndex === &apos;2&apos;&quot;&gt;&lt;/ItemTwo&gt;</span><br><span class="line">        &lt;ItemThree v-else-if=&quot;currentIndex === &apos;3&apos;&quot;&gt;&lt;/ItemThree&gt;</span><br><span class="line">      &lt;/el-main&gt;</span><br><span class="line">    &lt;/el-container&gt;</span><br><span class="line">  &lt;/el-container&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import GroupOne from &quot;@/components/GroupOne.vue&quot;;</span><br><span class="line">import GroupTwo from &quot;@/components/GroupTwo.vue&quot;;</span><br><span class="line">import ItemOne from &quot;@/components/ItemOne.vue&quot;;</span><br><span class="line">import ItemTwo from &quot;@/components/ItemTwo.vue&quot;;</span><br><span class="line">import ItemThree from &quot;@/components/ItemThree.vue&quot;;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;App&quot;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    GroupOne,</span><br><span class="line">    GroupTwo,</span><br><span class="line">    ItemOne,</span><br><span class="line">    ItemTwo,</span><br><span class="line">    ItemThree,</span><br><span class="line">  &#125;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      currentIndex: &apos;1&apos;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    handleSelect(index) &#123;</span><br><span class="line">      this.currentIndex = index</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>子组件模板代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;p&gt;导航一&lt;/p&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ItemOne&quot;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h1 id="使用-lt-component-gt-标签优化代码"><a href="#使用-lt-component-gt-标签优化代码" class="headerlink" title="使用 &lt;component&gt; 标签优化代码"></a>使用 <code>&lt;component&gt;</code> 标签优化代码</h1><p>当构建容器组件时，我们通常希望根据不同的条件，动态地渲染不同的子组件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-container&gt;</span><br><span class="line">  &lt;el-main&gt;</span><br><span class="line">    &lt;ItemOne v-if=&quot;currentIndex === &apos;1&apos;&quot;&gt;&lt;/ItemOne&gt;</span><br><span class="line">    &lt;GroupOne v-else-if=&quot;currentIndex === &apos;1-1&apos;&quot;&gt;&lt;/GroupOne&gt;</span><br><span class="line">    &lt;GroupTwo v-else-if=&quot;currentIndex === &apos;1-2&apos;&quot;&gt;&lt;/GroupTwo&gt;</span><br><span class="line">    &lt;ItemTwo v-else-if=&quot;currentIndex === &apos;2&apos;&quot;&gt;&lt;/ItemTwo&gt;</span><br><span class="line">    &lt;ItemThree v-else-if=&quot;currentIndex === &apos;3&apos;&quot;&gt;&lt;/ItemThree&gt;</span><br><span class="line">  &lt;/el-main&gt;</span><br><span class="line">&lt;/el-container&gt;</span><br></pre></td></tr></table></figure>

<p>在上述代码中，使用了 <code>if-else</code> 结构来根据 <code>currentIndex</code> 的值选择不同的子组件进行展示。虽然这种方法可以实现功能，但随着子组件数量的增加，代码会变得冗长且难以维护。</p>
<p>为了优化这段代码，我们可以引入一个用于渲染动态组件或元素的 “元组件”：<code>&lt;component&gt;</code>，这是一个对象映射的方式，使代码更加简洁和易于管理，详细原理见<a href="https://cn.vuejs.org/api/built-in-special-elements.html#component" target="_blank" rel="noopener">官方文档</a>。</p>
<p>下面是详细的优化步骤：</p>
<ol>
<li>在 <code>data()</code> 中定义一个包含组件名称与对应索引关系的映射对象 <code>componentMap</code>，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    currentIndex: &apos;1&apos;,</span><br><span class="line">    componentMap: &#123;</span><br><span class="line">      &apos;1&apos;: &apos;ItemOne&apos;,</span><br><span class="line">      &apos;1-1&apos;: &apos;GroupOne&apos;,</span><br><span class="line">      &apos;1-2&apos;: &apos;GroupTwo&apos;,</span><br><span class="line">      &apos;2&apos;: &apos;ItemTwo&apos;,</span><br><span class="line">      &apos;3&apos;: &apos;ItemThree&apos;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然后，通过计算属性来返回当前需要渲染的子组件，在组件中添加计算属性 <code>currentComponent</code>，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">computed:&#123;</span><br><span class="line">  currentComponents() &#123;</span><br><span class="line">    return this.componentMap[this.currentIndex]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后，在模板中使用这个计算属性来渲染子组件，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-container&gt;</span><br><span class="line">  &lt;el-main&gt;</span><br><span class="line">    &lt;component :is=&quot;currentComponents&quot;&gt;&lt;/component&gt;</span><br><span class="line">  &lt;/el-main&gt;</span><br><span class="line">&lt;/el-container&gt;</span><br></pre></td></tr></table></figure>

<h1 id="单个组件表单验证"><a href="#单个组件表单验证" class="headerlink" title="单个组件表单验证"></a>单个组件表单验证</h1><p>我们以 <strong>导航二</strong> <code>ItemTwo</code> 为例，创建一个表单 Form，效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9eb2645af6ffd724763722f76e951664e7a9ca9b5fe672f85025c49a0577bd0c" alt="v1.png"></p>
<p>如果直接点击 “提交” 按钮，即使还有选项没有填写，表单也会被直接提交，效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c1634b44293b025f313e3cc7fcab4d79f232f8ce988592899444b96fb842fd44" alt="v2.png"></p>
<p><strong>因此我们需要进行表单验证，设置数据校验规则，在防止用户犯错的前提下，尽可能让用户更早地发现并纠正错误。</strong></p>
<p>Form 组件提供了表单验证的功能，只需要通过 <code>rules</code> 属性传入约定的验证规则，并将 Form-Item 的 <code>prop</code> 属性设置为需校验的字段名即可。校验规则参见 <a href="https://github.com/yiminghe/async-validator" target="_blank" rel="noopener">async-validator</a>。</p>
<p>下面是详细的验证步骤：</p>
<ol>
<li>在 <code>data()</code> 中定义一个表单规则 <code>rules</code>，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data() &#123;</span><br><span class="line">  return &#123;</span><br><span class="line">    ...,</span><br><span class="line">    rules: &#123;</span><br><span class="line">      name: [&#123; required: true, message: &quot;请输入姓名&quot;, trigger: &quot;blur&quot; &#125;],</span><br><span class="line">      sex: [&#123; required: true, message: &quot;请选择性别&quot;, trigger: &quot;change&quot; &#125;],</span><br><span class="line">      food: [</span><br><span class="line">        &#123; required: true, message: &quot;请选择喜欢吃的食物&quot;, trigger: &quot;change&quot; &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接着在 Form 组件中传入验证规则，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;el-form ref=&quot;form&quot; :model=&quot;form&quot; :rules=&quot;rules&quot;&gt;</span><br><span class="line">    &lt;el-form-item label=&quot;姓名&quot; prop=&quot;name&quot;&gt;</span><br><span class="line">        ...</span><br><span class="line">    &lt;/el-form-item&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;el-form&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最后在提交表单时，进行数据的校验，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  submitForm() &#123;</span><br><span class="line">    this.$refs.form.validate((valid) =&gt; &#123;</span><br><span class="line">      if (valid) &#123;</span><br><span class="line">        ...</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>最终效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e9165f934cc0d7b0117c64c2894c3d694909ff351856d7be0e37a0dd38e70c65" alt="v3.png"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components/ItemTwo.vue" target="_blank" rel="noopener">【ItemTwo.vue】代码点击此处跳转</a>。</p>
<h1 id="父组件调用子组件方法"><a href="#父组件调用子组件方法" class="headerlink" title="父组件调用子组件方法"></a>父组件调用子组件方法</h1><p>在介绍父组件验证子组件表单之前，需要了解一个前置知识：父组件如何调用子组件的方法。</p>
<p>接下来我们以 <code>App.vue</code> 作为父组件，<code>ItemThree.vue</code> 作为子组件进行介绍父组件如何调用子组件的方法。</p>
<p>1、构建子组件页面，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;导航三&lt;/h1&gt;</span><br><span class="line">    &lt;p&gt;</span><br><span class="line">      响应内容: &lt;span style=&quot;color: #e86666&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/span&gt;</span><br><span class="line">    &lt;/p&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &quot;ItemThree&quot;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      msg: &quot;当前没有响应内容！&quot;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6b820c499230678f472110f4cefef9885b71bd82edf3a5b565f4e4ee2e7a6113" alt="z1.png"></p>
<p>2、编写一个子组件方法，可以更改 “响应内容”，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  changeMsg(owner) &#123;</span><br><span class="line">    this.msg = `$&#123;owner&#125; 组件改变了响应内容！`</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ea3410b5e16798d47613e1875080ef4b1e2ed375973f50c83b050e35e768565a" alt="z2.png"></p>
<p>3、父组件通过 <code>ref</code> 属性来调用子组件的方法。</p>
<ol>
<li>向子组件添加 <code>ref</code> 属性，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;component :is=&quot;currentComponents&quot; ref=&quot;child&quot;&gt;&lt;/component&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>编写父组件调用子组件的方法，代码如下所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleClick() &#123;</span><br><span class="line">  this.$refs.child.changeMsg(&quot;Parent&quot;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f0ca818a15370826fd580438cc699a1f354a9e16ad7404c62090077c2f3f6123" alt="z3.png"></p>
<ul>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/App.vue" target="_blank" rel="noopener">【App.vue】代码点击此处跳转</a>。</li>
<li><a href="https://github.com/sid10t/vue-learn_and_upgrade/blob/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components/ItemThree.vue" target="_blank" rel="noopener">【ItemThree.vue】代码点击此处跳转</a>。</li>
</ul>
<h1 id="父组件校验子组件表单"><a href="#父组件校验子组件表单" class="headerlink" title="父组件校验子组件表单"></a>父组件校验子组件表单</h1><p>1、在子组件中创建一个校验方法 <code>handleValidForm()</code>，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleValidForm() &#123;</span><br><span class="line">  let flag = false</span><br><span class="line">  this.$refs.form.validate((valid) =&gt; &#123;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">      flag = true</span><br><span class="line">      this.submitForm()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  return flag</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>上述代码先对表单进行校验，若校验通过则触发表单提交，并返回一个标识位 <code>flag</code>，用于标识表单校验是否通过。</p>
<p>2、在父组件中调用此方法，通过获取到的标识位 <code>flag</code> 来判断表单是否校验通过，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">handleSelect(index) &#123;</span><br><span class="line">  if (this.$refs.child.handleValidForm())</span><br><span class="line">    this.currentIndex = index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码表示如果校验通过，则实现子组件的切换，否则不做任何操作。</p>
<p>需要注意的是，每个被 <code>&lt;componet&gt;</code> 所使用的子组件都需要具有 <code>handleValidForm()</code> 方法，否则会出现报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vue.runtime.esm.js:4427 [Vue warn]: Error in v-on handler: &quot;TypeError: this.$refs.child.handleValidForm is not a function&quot;</span><br></pre></td></tr></table></figure>

<p>3、效果如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f73ccef27d5d74179d842703bc15f7735485f1cbf0d5f8221a1e390e7c009b16" alt="q2.gif"></p>
<p><a href="https://github.com/sid10t/vue-learn_and_upgrade/tree/main/%E5%89%8D%E7%AB%AF%E5%A4%A7%E6%9D%82%E7%83%A9/element/data-validate/src/components" target="_blank" rel="noopener">【整体】代码点击此处跳转</a>。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>以上就是 <strong><em>如何在 Vue <code>&lt;component&gt;</code> 切换子组件时优雅地进行 Form 表单校验</em></strong> 的所有内容了，希望本篇博文对大家有所帮助！欢迎大家持续关注我的博客，一起分享学习和成长的乐趣！✨</p>
<blockquote>
<p>📝 上篇精讲：<a href="https://dev.newban.cn/7354960709010800677">解决 ECharts 图表窗口自适应与数据不渲染问题</a></p>
<p>💖 我是 <strong>𝓼𝓲𝓭𝓲𝓸𝓽</strong>，期待你的关注，创作不易，请多多支持；</p>
<p>👍 公众号：<strong>sidiot的技术驿站</strong>；</p>
<p>🔥 系列专栏：<a href="https://juejin.cn/column/7173959753385967646" target="_blank" rel="noopener">问题解决</a>；<a href="https://juejin.cn/column/7297090176877395977" target="_blank" rel="noopener">前端大杂烩</a>；<a href="https://juejin.cn/column/7282666367239766016" target="_blank" rel="noopener">Vue.js 打怪升级之路</a></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358702198589341734" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,前端,Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>服务器端的图片一般存储在哪？图片服务器</title>
    <url>/7358702198589505574.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>图片和其他静态文件通常存储在服务器的硬盘或 SSD 上，可能直接存储在本地，或通过网络文件系统（如 NFS）访问，也可能存储在专门的静态内容服务器或 CDN（内容分发网络）上。</p>
<h1 id="图片服务器"><a href="#图片服务器" class="headerlink" title="图片服务器"></a>图片服务器</h1><p>那么这种专门用于存储和提供图片及其他多媒体内容的服务器叫做图片服务器，而这些服务器通常配置有用于快速读取的优化技术，如高速缓存和特定的文件访问策略。CDN 是提高全球访问速度的一种常用方法。</p>
<h2 id="处理其故障"><a href="#处理其故障" class="headerlink" title="处理其故障"></a>处理其故障</h2><ul>
<li><strong>使用 CDN</strong>: CDN 可以缓存全球多个位置的内容，如果原服务器挂掉，请求可以被重新定向到最近的缓存节点。</li>
<li><strong>服务器冗余</strong>: 大型服务通常会部署多台服务器，或使用云服务来提高可靠性，确保至少有一台服务器能处理请求。</li>
<li><strong>自动故障转移</strong>: 在多服务器配置中，可以配置负载均衡器自动检测服务器故障，并将流量转移到正常服务器。</li>
</ul>
<h2 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h2><ul>
<li><strong>硬盘驱动器（HDD）</strong> : 传统的硬盘驱动器因其较高的容量和较低的成本而被广泛使用，适合存储大量的图片文件。</li>
<li><strong>固态驱动器（SSD）</strong> : SSDs 提供更快的数据访问速度，对于需要频繁读取的图片，如网站的图标和常用图像，使用 SSD 可以提高访问速度。</li>
<li><strong>网络附加存储（NAS）</strong> : 对于大规模的应用，可能会使用 NAS 设备来集中管理图片文件，便于维护和扩展存储容量。</li>
<li><strong>对象存储</strong>: 大型应用，尤其是在云环境中，常使用对象存储（如 Amazon S3, Google Cloud Storage）来存储图片。对象存储提供了可扩展、耐用和高度可用的存储解决方案</li>
</ul>
<p>在这里详细讲下对象存储，因为我之前做项目时有用到过这个。</p>
<blockquote>
<p>对象存储是一种以非结构化格式（称为对象）存储和管理数据的技术。现代组织需要创建和分析大量非结构化数据，例如照片、视频、电子邮件、网页、传感器数据和音频文件。云对象存储系统将这些数据分布在多个物理设备上，但允许用户从单个虚拟存储库有效地访问内容。对象存储解决方案非常适合用于构建需要扩展和灵活性的云原生应用程序；您还可以使用这些解决方案导入现有数据存储以进行分析、备份或存档。</p>
</blockquote>
<p>这是<a href="https://aws.amazon.com/cn/what-is/object-storage/" target="_blank" rel="noopener">AWS</a>上对于对象存储的解释,那么我们可以从这提取到几个特点，它的可拓展性较好，因为存储的对象是非结构化格式。它也没有传统的目录结构，都是通过一个urlId进行访问的，同时它会把数据复制到多个存储设备上，保证其可用性和持久性。</p>
<h2 id="数据访问"><a href="#数据访问" class="headerlink" title="数据访问"></a>数据访问</h2><ul>
<li><strong>直接文件访问</strong>: 在小型或低负载的应用中，直接从文件系统访问图片通常是可行的。</li>
<li><strong>CDN（内容分发网络）</strong> : 对于访问量大的应用，使用 CDN 可以将图片缓存于全球多个节点，用户可以从最近的节点加载图片，大幅提高速度。</li>
<li><strong>缓存机制</strong>: 在服务器端或应用层面实施缓存策略，如使用 Redis 或 Memcached 来缓存热点图片，可以减少对存储设备的访问次数，提高响应速度。</li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358702198589505574" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>一文搞懂Redis的RDB、AOF以及混合持久化机制</title>
    <url>/7358704808526102547.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>  Redis ⽀持 RDB 和 AOF 两种持久化机制，Redis 4.0 之后又新增了混合持久化的方式。持久化功能有效地避免因进程退出造成数据丢失问题，当下次重启时利用之前持久化的⽂件即可实现数据恢复。</p>
<h2 id="1-RDB-持久化"><a href="#1-RDB-持久化" class="headerlink" title="1.RDB 持久化"></a>1.RDB 持久化</h2><p>  RDB 持久化是把<strong>当前进程数据⽣成快照保存到硬盘的过程</strong>，触发 RDB 持久化过程分为⼿动触发和⾃动触发。</p>
<h3 id="1-1-触发"><a href="#1-1-触发" class="headerlink" title="1.1 触发"></a>1.1 触发</h3><p>  ⼿动触发分别对应<code>save</code>和<code>bgsave</code>命令：</p>
<ol>
<li><code>save</code>命令：阻塞当前<code>Redis</code>服务器，直到<code>RDB</code>过程完成为⽌，当内存⽐较⼤的时候可能造成⻓时间阻塞。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ebd234f00fb12cb85d960ba5d3072aec4173a87a715ee94172b5d48a4f9772d6" alt="image-20240417184452896"></p>
<ol>
<li><code>bgsave</code>命令：<code>Redis</code>进程执⾏<code>fork</code>操作创建⼦进程，<code>RDB</code>持久化过程由⼦进程负责，完成后⾃动结束。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d7a1a071587db1e143685c02e3c1ffd17b4d2a3aafd6b2d90c327509877007e0" alt="image-20240417184441652"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/16d8c5f2e1a76a7e50c1d8130bbc970f12cf502a96bc1b216a898e372bb6d5a7" alt="image-20240417190532767"></p>
<blockquote>
<p><code>fork()</code> 操作在<code>Linux</code>中是用于创建一个新的进程的系统调用，并且子进程的创建是对父进程的复制。参考了<a href="https://dev.newban.cn/7250283546367557692?searchId=202404171908050B578BFE9B0EAC21E7B5">Linux进程 | fork()系统调用详解 - 掘金 (juejin.cn)</a></p>
</blockquote>
<p>  自动触发的情况：</p>
<ol>
<li>在配置文件中<code>redis.conf</code>，配置 <code>save</code>，如<code>&quot;save m n&quot;</code>表⽰ <code>m</code> 秒内数据集发⽣了 <code>n</code> 次修改，⾃动<code>RDB</code>持久化。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0a2bdab225f3fb12beb9155ecc027bf967e9d2719e1c653500cd6b1ed880f104" alt="image-20240417184217337"></p>
<ol start="2">
<li>执⾏<code>shutdown</code>命令关闭<code>Redis</code>时，执⾏<code>RDB</code>持久化。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码shutdown save</span><br></pre></td></tr></table></figure>

<h3 id="1-2-RDB-文件的处理"><a href="#1-2-RDB-文件的处理" class="headerlink" title="1.2 RDB 文件的处理"></a>1.2 RDB 文件的处理</h3><p>  持久化的数据是默认保存在<code>“/var/lib/redis/”</code>下，文件名可以通过 <code>dbfilename</code> 指定。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8f2a15ea81e03a3d11ef566693bb96d5117297ba301fef9eef238123c78d3c53" alt="image-20240417185444048"></p>
<p>  可以通过执⾏<code>config set dir{newDir}</code>和<code>config set dbfilename{newFilename}</code>运⾏期间动态执⾏，当下次运⾏时RDB⽂件会保存到新⽬录。</p>
<p>  <code>Redis</code>默认采⽤<code>LZF</code>算法对⽣成的<code>RDB</code>⽂件做压缩处理，压缩后的⽂件远远⼩于内存⼤⼩，默认开启，可以通过参数<code>config set rdbcompression{yes|no}</code> 动态修改。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/06d967cb4a70f5365f91faf7ec2b081f9f23e5048e6e55ca38ccb445ca650d0e" alt="image-20240417185718585"></p>
<h3 id="1-3-RDB-优缺点"><a href="#1-3-RDB-优缺点" class="headerlink" title="1.3 RDB 优缺点"></a>1.3 RDB 优缺点</h3><ul>
<li>优点：<ul>
<li><strong>性能高效</strong>：RDB持久化是将内存中的数据以二进制形式保存到硬盘上，因此在持久化过程中不需要进行额外的序列化和反序列化操作，具有很高的性能。</li>
<li><strong>恢复速度快</strong>：因为 RDB 文件是一个完整的数据库快照，所以在 Redis 重启后，可以非常快速地将数据恢复到内存中。</li>
</ul>
</li>
<li>缺点：<ul>
<li><strong>数据可能丢失</strong>：RDB持久化是间隔一定时间进行的，如果Redis意外崩溃，会导致最后一次持久化之后的数据丢失。</li>
<li><strong>不适合实时备份</strong>：<code>RDB</code>⽅式数据没办法做到实时持久化/秒级持久化。因为<code>bgsave</code>每次运⾏都要执⾏<code>fork</code>创建⼦进程，属于重量级操作，频繁执⾏成本过⾼。</li>
</ul>
</li>
</ul>
<h2 id="2-AOF-持久化"><a href="#2-AOF-持久化" class="headerlink" title="2.AOF 持久化"></a>2.AOF 持久化</h2><p>  <code>AOF</code>持久化：以独⽴⽇志的⽅式<strong>记录每次写命令</strong>，重启时再重新执⾏<code>AOF</code>⽂件中的命令达到恢复数据的⽬的。<code>AOF</code>的主要作⽤是解决了数据持久化的<strong>实时性</strong>。</p>
<h3 id="2-1-开启-AOF"><a href="#2-1-开启-AOF" class="headerlink" title="2.1 开启 AOF"></a>2.1 开启 AOF</h3><ol>
<li>在配置文件中设置，<code>appendonly yes</code>，默认是不开启的。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8731a00e929fb6f5da91cb515f70e385c3be18828ed372d7970b410adb492ade" alt="image-20240417193051405"></p>
<ul>
<li>流程</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/554c60ead3ce2c56fbdc18635733e90039ed31585f95a9df35f72a5311281a92" alt="image-20240417194516818"></p>
<ol>
<li>所有的写⼊命令会追加到缓冲区中。</li>
<li>AOF 缓冲区根据对应的策略向硬盘做同步操作。</li>
<li>随着 AOF ⽂件越来越⼤，需要定期对 AOF ⽂件进⾏重写，达到压缩的⽬的。</li>
<li>当 Redis 服务器启动时，可以加载 AOF ⽂件进⾏数据恢复。</li>
</ol>
<blockquote>
<p>AOF 为什么需要缓冲区？如果每次写 AOF ⽂件都直接同步硬盘，性能从内存的读写变成 IO 读写，必然会下降。先写⼊缓冲区可以有效减少 IO 次数。</p>
</blockquote>
<h3 id="2-2-AOF缓冲区同步⽂件策略"><a href="#2-2-AOF缓冲区同步⽂件策略" class="headerlink" title="2.2 AOF缓冲区同步⽂件策略"></a>2.2 AOF缓冲区同步⽂件策略</h3><p>  可以在配置文件中设置文件同步策略。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6ce7d7322558f6f77948ce18bb75433a8b48d3fdc325fe24ac2ca15cfc30a86b" alt="image-20240417195508861"></p>
<ul>
<li>一共有三种策略<ul>
<li>always：每次写入缓冲区后直接写入 AOF 文件中。</li>
<li>everysec（默认）：写入缓冲区后，不进行同步。一秒后再进行写入 AOF 文件。</li>
<li>no：只执行 write 操作（也就是只缓存），由操作系统控制写入 AOF 文件的频率。</li>
</ul>
</li>
</ul>
<h3 id="2-3-重写机制"><a href="#2-3-重写机制" class="headerlink" title="2.3 重写机制"></a>2.3 重写机制</h3><p>  随着命令不断写⼊ AOF，⽂件会越来越⼤，当达到一定的程度后，Redis 会重写文件，减少文件的体积。</p>
<ul>
<li>AOF重写过程可以⼿动触发和⾃动触发：<ul>
<li>手动：调⽤<code>bgrewriteaof</code>命令。</li>
<li>自动：在配置文件中<ul>
<li><code>auto-aof-rewrite-min-size</code>：表⽰触发重写时AOF的最⼩⽂件⼤⼩，默认为64MB。</li>
<li><code>auto-aof-rewrite-percentage</code>：代表当前AOF占⽤⼤⼩相⽐较上次重写时增加的⽐例。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c60d8861ab1ee0e8e3b446bac27c96cf646b1c91560274c950bd6ef37ce945a2" alt="image-20240417201815379"></p>
<ul>
<li>重写流程</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bc839c8e2143f4eb9a05ada27332243dec0a642b596857972fa6d1ea7adf8912" alt="image-20240417205234622"></p>
<ol>
<li>父进程执行 fork 创建子进程后。</li>
<li>重写<ol>
<li>主进程 fork 后，继续响应其它命令。所有修改操作写入 AOF 缓冲区，并根据同步策略同步到硬盘，来保证旧 AOF 文件机制的正确。</li>
<li>⼦进程只有 fork 之前的所有内存信息，⽗进程中需要将 fork 之后这段时间的修改操作写⼊ AOF <strong>重写缓冲区中</strong>。</li>
</ol>
</li>
<li>⼦进程根据内存快照，将命令合并到新的 AOF ⽂件中（这里跟 RDB 有点相似）。</li>
<li>子进程完成重写<ol>
<li>新⽂件写⼊后，⼦进程发送信号给⽗进程。</li>
<li>⽗进程把 AOF 重写缓冲区内 临时保存的命令追加到新AOF⽂件中。</li>
<li>⽤新AOF⽂件替换⽼AOF⽂件。</li>
</ol>
</li>
</ol>
<h3 id="2-4-AOF-的优缺点"><a href="#2-4-AOF-的优缺点" class="headerlink" title="2.4 AOF 的优缺点"></a>2.4 AOF 的优缺点</h3><ul>
<li>优点<ul>
<li><strong>实时性好</strong>：由于 AOF 持久化方式是将每一个写命名记录到文件中，因此实时性比 RDB 更好。</li>
<li><strong>可读性高</strong>：AOF 文件是一个纯文本文件，可以被人类读取和理解。</li>
</ul>
</li>
<li>缺点<ul>
<li><strong>写入性能略低</strong>：由于 AOF 持久化方式需要将每一个写命令记录到文件中，因此相对于 RDB 持久化方式，它的写入性能略低。</li>
<li><strong>占用磁盘空间大</strong>：由于 AOF 持久化方式需要记录每一个写命令，因此相对于 RDB 持久化方式，它占用的磁盘空间更大。</li>
</ul>
</li>
</ul>
<h2 id="3-混合模式持久化"><a href="#3-混合模式持久化" class="headerlink" title="3.混合模式持久化"></a>3.混合模式持久化</h2><p>  在开启混合持久化的情况下，<strong>AOF 重写时</strong>会把 Redis 的持久化数据，以 RDB 的格式写入到 AOF 文件的开头，之后的数据再以 AOF 的格式化追加的文件的末尾。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7c096db2ce974090dcaec466528c7dca4fdb83d8609d006f25dfb1fdf16e4bcd" alt="image-20240417215009418"></p>
<h3 id="3-1-开启混合持久化"><a href="#3-1-开启混合持久化" class="headerlink" title="3.1 开启混合持久化"></a>3.1 开启混合持久化</h3><ol>
<li>在配置文件中如下设置：</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/975b225af5af4291f6d13c8f2229508d0de541731fcc0a16627503fc478f0ea9" alt="image-20240417210744726"></p>
<h3 id="3-2-混合持久化的优缺点"><a href="#3-2-混合持久化的优缺点" class="headerlink" title="3.2 混合持久化的优缺点"></a>3.2 混合持久化的优缺点</h3><ul>
<li>优点</li>
</ul>
<pre><code>+ 混合持久化结合了 RDB 和 AOF 持久化的优点，开头为 RDB 的格式，使得 Redis 可以更快的启动，同时结合 AOF 的优点，又减低了大量数据丢失的风险。</code></pre><ul>
<li>缺点</li>
</ul>
<pre><code>+ **可读性差**：AOF 文件中添加了 RDB 格式的内容，就让 AOF 文件的可读性变得很差。
+ **兼容性差**：如果开启混合持久化，那么此混合持久化 AOF 文件，就不能用在 Redis 4.0 之前版本了。</code></pre><h2 id="4-启动恢复数据的流程"><a href="#4-启动恢复数据的流程" class="headerlink" title="4.启动恢复数据的流程"></a>4.启动恢复数据的流程</h2><ol>
<li>判断是否开启 AOF 持久化，开启继续执行后续流程，未开启执行加载 RDB 文件的流程。</li>
<li>判断 appendonly.aof 文件是否存在，文件存在则执行后续流程。</li>
<li>判断 AOF 文件开头是 RDB 的格式, 先加载 RDB 内容再加载剩余的 AOF 内容。</li>
<li>判断 AOF 文件开头不是 RDB 的格式，直接以 AOF 格式加载整个文件。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e59d685384c8b36398fcc7147065805b751f2ba2855ac3d0c01fdba75249d207" alt="image-20240417212632723"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7358704808526102547" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>并查集的理论、实现与应用【纯干货】</title>
    <url>/7359077652445921330.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实现并查集数据结构的技术指南"><a href="#实现并查集数据结构的技术指南" class="headerlink" title="实现并查集数据结构的技术指南"></a>实现并查集数据结构的技术指南</h2><p>并查集（Disjoint Set Union，简称并查集）是一种常用的数据结构，用于管理元素之间的等价关系。它主要支持两种操作：合并（Union）和查找（Find）。并查集通常用于解决各种问题，如图论中的连通性问题、最小生成树算法中的边的选择等。</p>
<h3 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h3><p>并查集通过维护一棵树来表示集合，其中每个节点都指向其父节点，根节点指向自身。在实际实现中，可以使用数组来表示这棵树，数组的索引表示元素，数组的值表示指向的父节点。</p>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ol start="0">
<li><strong>初始化：</strong> 初始化时，每个元素都是独立的集合，即每个元素都是一个单独的树，且每个元素的父节点指向自身。</li>
<li><strong>查找（Find）：</strong> 查找操作用于确定元素所属的集合。通过不断向上查找父节点，直到找到根节点，即自身指向自身的节点，确定元素所在的集合。</li>
<li><strong>合并（Union）：</strong> 合并操作用于将两个集合合并为一个集合。通过找到两个元素所在集合的根节点，将其中一个根节点的父节点指向另一个根节点，从而实现集合的合并。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/718b1eb29862b37f8ca578cd6e8f1210f383c48832d5bfde56f731ac6d638701" alt="image-20240418192626687"></p>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>下面是并查集的简单实现，使用了路径压缩和按秩合并的优化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  # 路径压缩</span><br><span class="line">        return self.parent[x]</span><br><span class="line">    </span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        if root_x != root_y:</span><br><span class="line">            if self.rank[root_x] &lt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_x] = root_y</span><br><span class="line">            elif self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">            else:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">                self.rank[root_x] += 1</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 创建并查集对象，包含5个元素</span><br><span class="line">uf = UnionFind(5)</span><br><span class="line">​</span><br><span class="line"># 合并元素1和元素2所在的集合</span><br><span class="line">uf.union(1, 2)</span><br><span class="line">​</span><br><span class="line"># 合并元素3和元素4所在的集合</span><br><span class="line">uf.union(3, 4)</span><br><span class="line">​</span><br><span class="line"># 检查元素1和元素2是否属于同一个集合</span><br><span class="line">print(uf.find(1) == uf.find(2))  # 输出：True</span><br><span class="line">​</span><br><span class="line"># 检查元素1和元素3是否属于同一个集合</span><br><span class="line">print(uf.find(1) == uf.find(3))  # 输出：False</span><br></pre></td></tr></table></figure>

<h3 id="进一步优化与应用"><a href="#进一步优化与应用" class="headerlink" title="进一步优化与应用"></a>进一步优化与应用</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/07383b11675281baa05fcaff9a6b0a22821d6768885365d01c759a3a9295ba00" alt="image-20240418192715175"></p>
<h4 id="路径压缩"><a href="#路径压缩" class="headerlink" title="路径压缩"></a>路径压缩</h4><p>在查找操作中，路径压缩可以进一步提高并查集的效率。路径压缩的核心思想是在查找过程中，将节点直接连接到根节点，以减少后续查找的时间复杂度。路径压缩可以通过递归或迭代实现。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  # 路径压缩</span><br><span class="line">        return self.parent[x]</span><br></pre></td></tr></table></figure>

<h4 id="按秩合并"><a href="#按秩合并" class="headerlink" title="按秩合并"></a>按秩合并</h4><p>按秩合并的思想是，始终将较小的树合并到较大的树中，以减少树的深度，进而降低查找操作的复杂度。在合并操作中，需要比较两个根节点的秩（即树的高度），并将秩较小的根节点连接到秩较大的根节点上。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        if root_x != root_y:</span><br><span class="line">            if self.rank[root_x] &lt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_x] = root_y</span><br><span class="line">            elif self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">            else:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">                self.rank[root_x] += 1</span><br></pre></td></tr></table></figure>

<h4 id="应用示例：判断图中连通分量的数量"><a href="#应用示例：判断图中连通分量的数量" class="headerlink" title="应用示例：判断图中连通分量的数量"></a>应用示例：判断图中连通分量的数量</h4><p>并查集常用于图论中的连通性问题。下面是一个示例，通过并查集来判断无向图中连通分量的数量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def count_components(n, edges):</span><br><span class="line">    uf = UnionFind(n)</span><br><span class="line">    for edge in edges:</span><br><span class="line">        uf.union(edge[0], edge[1])</span><br><span class="line">    </span><br><span class="line">    components = set()</span><br><span class="line">    for i in range(n):</span><br><span class="line">        components.add(uf.find(i))</span><br><span class="line">    </span><br><span class="line">    return len(components)</span><br></pre></td></tr></table></figure>

<p>用并查集解决区域填充问题。假设有一个二维网格，其中包含了若干个岛屿（由’1’表示）和海洋（由’0’表示），岛屿被海洋包围。现在需要对每个岛屿进行区域填充，使得每个岛屿都被水域包围。以下是代码示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class UnionFind:</span><br><span class="line">    def __init__(self, n):</span><br><span class="line">        self.parent = [i for i in range(n)]</span><br><span class="line">        self.rank = [0] * n</span><br><span class="line">    </span><br><span class="line">    def find(self, x):</span><br><span class="line">        if self.parent[x] != x:</span><br><span class="line">            self.parent[x] = self.find(self.parent[x])  # 路径压缩</span><br><span class="line">        return self.parent[x]</span><br><span class="line">    </span><br><span class="line">    def union(self, x, y):</span><br><span class="line">        root_x = self.find(x)</span><br><span class="line">        root_y = self.find(y)</span><br><span class="line">        </span><br><span class="line">        if root_x != root_y:</span><br><span class="line">            if self.rank[root_x] &lt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_x] = root_y</span><br><span class="line">            elif self.rank[root_x] &gt; self.rank[root_y]:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">            else:</span><br><span class="line">                self.parent[root_y] = root_x</span><br><span class="line">                self.rank[root_x] += 1</span><br><span class="line">​</span><br><span class="line">def fill_surrounded_regions(grid):</span><br><span class="line">    if not grid:</span><br><span class="line">        return grid</span><br><span class="line">    </span><br><span class="line">    m, n = len(grid), len(grid[0])</span><br><span class="line">    uf = UnionFind(m * n + 1)  # 最后一个节点表示海洋</span><br><span class="line">    </span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if grid[i][j] == &apos;0&apos;:</span><br><span class="line">                uf.union(i * n + j, m * n)  # 将海洋连接到一个虚拟节点</span><br><span class="line">            else:</span><br><span class="line">                if i &gt; 0 and grid[i - 1][j] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, (i - 1) * n + j)</span><br><span class="line">                if i &lt; m - 1 and grid[i + 1][j] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, (i + 1) * n + j)</span><br><span class="line">                if j &gt; 0 and grid[i][j - 1] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, i * n + j - 1)</span><br><span class="line">                if j &lt; n - 1 and grid[i][j + 1] == &apos;1&apos;:</span><br><span class="line">                    uf.union(i * n + j, i * n + j + 1)</span><br><span class="line">    </span><br><span class="line">    for i in range(m):</span><br><span class="line">        for j in range(n):</span><br><span class="line">            if uf.find(i * n + j) != uf.find(m * n):</span><br><span class="line">                grid[i][j] = &apos;X&apos;</span><br><span class="line">    </span><br><span class="line">    return grid</span><br><span class="line">​</span><br><span class="line"># 示例</span><br><span class="line">grid = [</span><br><span class="line">    [&quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;1&quot;, &quot;0&quot;],</span><br><span class="line">    [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;1&quot;, &quot;0&quot;],</span><br><span class="line">    [&quot;1&quot;, &quot;1&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;],</span><br><span class="line">    [&quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;, &quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">​</span><br><span class="line">filled_grid = fill_surrounded_regions(grid)</span><br><span class="line">for row in filled_grid:</span><br><span class="line">    print(&quot; &quot;.join(row))</span><br></pre></td></tr></table></figure>

<p>这个代码示例演示了如何使用并查集来解决区域填充问题。通过判断岛屿之间的连通性，并将与海洋相连的岛屿合并到一起，然后将不与海洋相连的岛屿标记为水域。</p>
<h3 id="并查集的应用领域"><a href="#并查集的应用领域" class="headerlink" title="并查集的应用领域"></a>并查集的应用领域</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/65d1c03b541a951c99df878473e9c2a4758f4199a7ce10f8615b84039631ad34" alt="image-20240418192728898"></p>
<p>除了在图论中的连通性问题之外，并查集还在各种领域得到广泛应用，其中包括但不限于：</p>
<h4 id="1-算法竞赛"><a href="#1-算法竞赛" class="headerlink" title="1. 算法竞赛"></a>1. 算法竞赛</h4><p>在算法竞赛中，例如ACM/ICPC、Codeforces等比赛中，并查集常被用来解决一些关于连通性的问题，比如判断图的连通性、求解最小生成树、最短路径等。并查集的高效实现可以帮助竞赛选手在有限的时间内解决问题。</p>
<h4 id="2-图像处理"><a href="#2-图像处理" class="headerlink" title="2. 图像处理"></a>2. 图像处理</h4><p>在图像处理中，像素的连通性是一个重要的概念。并查集可以用来判断图像中的像素是否连通，从而进行图像分割、边缘检测等操作。例如，可以利用并查集来合并相邻的像素，将它们视为同一连通分量。</p>
<h4 id="3-社交网络分析"><a href="#3-社交网络分析" class="headerlink" title="3. 社交网络分析"></a>3. 社交网络分析</h4><p>在社交网络分析中，常常需要判断社交网络中的用户之间是否存在关系，以及他们之间的关系强度。并查集可以用来管理用户之间的关系，快速判断两个用户是否属于同一社交圈子，进而进行社交网络分析和推荐系统的优化。</p>
<h4 id="4-数据库系统"><a href="#4-数据库系统" class="headerlink" title="4. 数据库系统"></a>4. 数据库系统</h4><p>在数据库系统中，常常需要处理大量的数据并对其进行关联。并查集可以用来管理数据之间的关系，例如在数据库中实现集合操作、聚类分析等。并查集的高效实现可以加速数据库查询和数据处理的速度。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2b48a4bf7a2c0a10bd2a7e7b015605e020f5cec9f5056b4f5d4017858f08bb42" alt="image-20240418192745041"></p>
<h4 id="5-任务调度与资源分配"><a href="#5-任务调度与资源分配" class="headerlink" title="5. 任务调度与资源分配"></a>5. 任务调度与资源分配</h4><p>在任务调度和资源分配领域，经常需要解决资源之间的依赖关系和任务之间的调度顺序。并查集可以用来管理任务和资源之间的关系，快速判断任务之间的依赖关系，进而进行任务调度和资源分配的优化。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文介绍了并查集数据结构的基本原理、实现方法以及优化技巧，并提供了代码示例展示了其在实际问题中的应用。首先，我们了解了并查集的基本操作：合并（Union）和查找（Find），以及如何使用数组来表示并查集中的树结构。随后，我们介绍了路径压缩和按秩合并两种优化技巧，用于提高并查集的效率。通过路径压缩，我们可以减少查找操作的时间复杂度；而按秩合并则可以降低树的深度，进而减少查找和合并操作的时间复杂度。</p>
<p>在代码示例部分，我们展示了如何实现一个简单的并查集类，并给出了一个应用示例：使用并查集解决区域填充问题。在这个示例中，我们通过并查集来判断岛屿之间的连通性，然后对每个岛屿进行区域填充，确保每个岛屿都被水域包围。这个示例展示了并查集在图论和图像处理等领域的应用。</p>
<p>综上所述，虽然并查集是一种简单的数据结构，但它在解决各种实际问题中具有广泛的应用。通过合并和查找操作，可以高效地管理元素之间的关系，解决连通性、区域填充等问题。希望本文能够帮助读者更深入地理解并查集，并在实际工作和学习中发挥作用。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359077652445921330" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>03.maven聚合和继承</title>
    <url>/7359083767564091407.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Maven聚合"><a href="#Maven聚合" class="headerlink" title="Maven聚合"></a>Maven聚合</h2><p>maven聚合需要创建一个新的maven项目， 用来管理其他的maven构件模块，新的maven项目中加入如下配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;modules&gt;    </span><br><span class="line">    &lt;module&gt;模块1&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;模块2&lt;/module&gt;</span><br><span class="line">    &lt;module&gt;模块n&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br><span class="line">&lt;package&gt;pom&lt;/package&gt;</span><br></pre></td></tr></table></figure>

<p>新的项目中执行任何<code>mvn</code>命令，都会<code>modules</code>中包含的所有模块执行同样的命令，而被包含的模块不需要做任何特殊的配置，正常的maven项目就行。</p>
<p>注意上面的<code>module</code>元素，这部分是被聚合的模块<code>pom.xml</code>所在目录的相对路径。</p>
<blockquote>
<p><code>package</code>的值必须为<code>pom</code></p>
</blockquote>
<p>pom.xml中的<code>module</code>元素的值为被聚合的模块pom.xml所在的目录路径，只能是相对路径，比如下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;modules&gt;    </span><br><span class="line">    &lt;module&gt;zipkin-server-source-demo&lt;/module&gt;   </span><br><span class="line">    &lt;module&gt;../../../tmp/child-project&lt;/module&gt;   </span><br><span class="line">    &lt;module&gt;../../../tmp/child-project/pom.xml&lt;/module&gt;</span><br><span class="line">&lt;/modules&gt;</span><br></pre></td></tr></table></figure>

<p>聚合的功能中，聚合模块的pom.xml中通过<code>modules-&gt;module</code>来引用被聚合的模块，被聚合的模块是不用感知自己被聚合了，所以被聚合的模块中<code>pom.xml</code>中是不知道父模块的存在的。</p>
<h2 id="maven继承"><a href="#maven继承" class="headerlink" title="maven继承"></a>maven继承</h2><p>如果有很多项目他们依赖相同的配置，那么能不能把这些相同的配置提取出来放到父项目中，这些子项目通过继承可以自动依赖这些功能配置，这就是<code>继承</code>。</p>
<ol>
<li>创建一个父maven构件，将依赖信息放在pom.xml中</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependencies&gt;   </span><br><span class="line">        &lt;dependency&gt;依赖的构件的坐标信息&lt;/dependency&gt;   </span><br><span class="line">        &lt;dependency&gt;依赖的构件的坐标信息&lt;/dependency&gt;    </span><br><span class="line">        &lt;dependency&gt;依赖的构件的坐标信息&lt;/dependency&gt;</span><br><span class="line">&lt;/dependencies&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>将父构件的package元素的值置为pom</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;packaging&gt;pom&lt;/packaging&gt;</span><br></pre></td></tr></table></figure>

<ol>
<li>在子构件的pom.xml引入父构件的配置：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;parent&gt;    </span><br><span class="line">        &lt;groupId&gt;父构件groupId&lt;/groupId&gt; </span><br><span class="line">        &lt;artifactId&gt;父构件artifactId&lt;/artifactId&gt; </span><br><span class="line">        &lt;version&gt;父构件的版本号&lt;/version&gt;  </span><br><span class="line">        &lt;relativePath&gt;父构件pom.xml路径&lt;/relativePath&gt;</span><br><span class="line">&lt;/parent&gt;</span><br></pre></td></tr></table></figure>

<p><code>relativePath</code>表示父构件pom.xml相对路径，默认是<code>../pom.xml</code>，所以一般情况下父子结构的maven构件在目录结构上一般也采用父子关系。</p>
<h3 id="relativePath元素"><a href="#relativePath元素" class="headerlink" title="relativePath元素"></a>relativePath元素</h3><p>如果父构件和子构件的目录不是父子关系，比如都位于同等级别的目录或者位于更复杂的目录的时候，此时我们需要在子<code>pom.xml</code>的<code>parent</code>元素中使用<code>relativePath</code>元素来指定父<code>pom.xml</code>相对路径位置，这个值默认是<code>../pom.xml</code>，表示父pom.xml位于子pom.xml的上一级目录。</p>
<p>正确的设置<code>relativePath</code>是非常重要的，这个需要注意，子模块中执行<code>mvn</code>命令的时候，会去找父<code>pom.xml</code>的配置，会先通过<code>relativePath</code>指定的路径去找，如果找不到，会尝试通过坐标在本地仓库进行查找，如果本地找不到，会去远程仓库找，如果远程仓库也没有，会报错。</p>
<h3 id="可以通过继承的元素有以下这些"><a href="#可以通过继承的元素有以下这些" class="headerlink" title="可以通过继承的元素有以下这些"></a>可以通过继承的元素有以下这些</h3><p>可以从父<code>pom.xml</code>中继承过来的的元素：</p>
<ul>
<li>groupId：项目组ID，项目坐标的核心元素</li>
<li>version：项目版本，项目坐标的核心元素</li>
<li>description：项目的描述信息</li>
<li>organization：项目的组织信息</li>
<li>inceptionYear：项目的创始年份</li>
<li>url：项目的url地址</li>
<li>developers：项目的开发者信息</li>
<li>contributors：项目的贡献者信息</li>
<li>distributionManagement：项目的部署配置信息</li>
<li>issueManagement：项目的缺陷跟踪系统信息</li>
<li>ciManagement：项目的持续集成系统信息</li>
<li>scm：项目的版本控制系统信息</li>
<li>mailingLists：项目的邮件列表信息</li>
<li>properties：自定义的maven属性配置信息</li>
<li>dependencyManagement：项目的依赖管理配置</li>
<li>repositories：项目的仓库配置</li>
<li>build：包括项目的源码目录配置、输出目录配置、插件管理配置等信息</li>
<li>reporting：包括项目的报告输出目录配置、报告插件配置等信息</li>
</ul>
<h2 id="依赖管理-dependencyManagement"><a href="#依赖管理-dependencyManagement" class="headerlink" title="依赖管理(dependencyManagement)"></a>依赖管理(dependencyManagement)</h2><p>maven提供的dependencyManagement元素既能让子模块继承到父模块的依赖配置，又能保证子模块依赖使用的灵活性，<strong>在<code>dependencyManagement</code>元素下声明的依赖不会引入实际的依赖，他只是声明了这些依赖，不过它可以对<code>dependencies</code>中使用的依赖起到一些约束作用。</strong></p>
<p>子模块如果想用到父模块<code>dependencyManagement</code>中的配置，可以<code>dependencies</code>进行引用，引用之后，依赖才会真正的起效。我们可以使用<code>mvn dependency:tree</code>验证</p>
<p>dependencyManagement不会引入实际的依赖，只有在子类中使用<code>dependency</code>来引入父<code>dependencyManagement</code>声明的依赖之后，依赖的构建才会被真正的引入。</p>
<p>使用dependencyManagement来解决继承的问题，子pom.xml中只用写<code>groupId,artifactId</code>就可以了，其他信息都会从父<code>dependencyManagement</code>中声明的依赖关系中传递过来，通常我们使用这种方式将所有依赖的构建在父pom.xml中定义好，子构件中只需要通过<code>groupId,artifactId</code>就可以引入依赖的构建，而不需要写<code>version</code>，可以很好的确保多个子项目中依赖构件的版本的一致性，对应依赖构件版本的升级也非常方便，只需要在父pom.xml中修改一下就可以了。</p>
<h2 id="单继承问题解决"><a href="#单继承问题解决" class="headerlink" title="单继承问题解决"></a>单继承问题解决</h2><p>如果一个项目X的父项目是P，但是X又想使用另外一个项目Z中<code>dependencyManagement</code>中声明的依赖，此时该咋办？这个就是<code>单继承的问题</code></p>
<p>解决办法：在项目X中增加以下配置，然后项目X就可以使用项目Z中<code>dependencyManagement</code>声明的依赖了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;!-- 下面的配置相当于把项目Z的pom.xml中的dependencyManagement元素中声明的所有依赖导入到当前pom.xml的dependencyManagement中 --&gt;</span><br><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;项目Z&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;项目Z&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">            &lt;!-- type的值必须是pom，scope元素的值必须是import --&gt;</span><br><span class="line">            &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">            &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line">&lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>

<p>上的配置相当于把项目Z的pom.xml中的dependencyManagement元素中声明的所有依赖导入到当前pom.xml的dependencyManagement中</p>
<h2 id="插件管理-pluginManagement"><a href="#插件管理-pluginManagement" class="headerlink" title="插件管理(pluginManagement)"></a>插件管理(pluginManagement)</h2><p>maven中提供了解决插件继承问题的<code>pluginManagement</code>元素，在父pom中可以在这个元素中声明插件的配置信息，但是子pom.xml中不会引入此插件的配置信息，只有在子pom.xml中使用<code>plugins-&gt;plugin</code>元素正在引入这些声明的插件的时候，插件才会起效，子插件中只需要写<code>groupId、artifactId</code>，其他信息都可以从父构件中传递过来。</p>
<p>比如我在父项目pom.xml中声明以下插件配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;</span><br><span class="line">    &lt;pluginManagement&gt;</span><br><span class="line">        &lt;plugins&gt;</span><br><span class="line">            &lt;plugin&gt;</span><br><span class="line">                &lt;!--在default生命周期的verify阶段执行jar-no-fork目标--&gt;</span><br><span class="line">                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;3.2.0&lt;/version&gt;</span><br><span class="line">                &lt;executions&gt;</span><br><span class="line">                    &lt;execution&gt;</span><br><span class="line">                        &lt;id&gt;attach-source&lt;/id&gt;</span><br><span class="line">                        &lt;phase&gt;verify&lt;/phase&gt;</span><br><span class="line">                        &lt;goals&gt;</span><br><span class="line">                            &lt;goal&gt;jar-no-fork&lt;/goal&gt;</span><br><span class="line">                        &lt;/goals&gt;</span><br><span class="line">                    &lt;/execution&gt;</span><br><span class="line">                &lt;/executions&gt;</span><br><span class="line">            &lt;/plugin&gt;</span><br><span class="line">        &lt;/plugins&gt;</span><br><span class="line">    &lt;/pluginManagement&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>在子项目中使用如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;build&gt;</span><br><span class="line">    &lt;plugins&gt;</span><br><span class="line">        &lt;plugin&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;maven-source-plugin&lt;/artifactId&gt;</span><br><span class="line"></span><br><span class="line">            &lt;!--如果没有executions，那就会完全引用父插件中的配置，</span><br><span class="line">            如果有executions，那么就会合并父插件中的配置</span><br><span class="line">            可以使用mvn help:effective-pom验证最终的pom.xml</span><br><span class="line">            --&gt;</span><br><span class="line">            &lt;executions&gt;</span><br><span class="line">                &lt;execution&gt;</span><br><span class="line">                    &lt;id&gt;attach-source&lt;/id&gt;</span><br><span class="line">                    &lt;goals&gt;</span><br><span class="line">                        &lt;goal&gt;help&lt;/goal&gt;</span><br><span class="line">                    &lt;/goals&gt;</span><br><span class="line">                &lt;/execution&gt;</span><br><span class="line">            &lt;/executions&gt;</span><br><span class="line">        &lt;/plugin&gt;</span><br><span class="line">    &lt;/plugins&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure>

<p>我们可以通过<code>mvn help:effective-pom</code>查看子项目生成的最终的pom.xml文件是咋样的来验证插件管理是否生效</p>
<h2 id="聚合与继承的关系"><a href="#聚合与继承的关系" class="headerlink" title="聚合与继承的关系"></a>聚合与继承的关系</h2><ul>
<li>聚合：主要是为了方便多模块快速构建。对于聚合来说，聚合模块是知道被聚合模块的存在的，而被聚合模块是感知不到聚合模块的存在。</li>
<li>继承：主要是为了重用相同的配置。对于继承来说，父构件是感知不到子构件的存在，而子构件需要使用<code>parent</code>来引用父构件。</li>
</ul>
<p>两者的共同点是，聚合模块和继承中的父模块的package属性都必须是pom类型的，同时，聚合模块和父模块中的除了pom.xml，一般都是没有什么内容的。</p>
<p>实际使用是，我们经常将聚合和继承一起使用，能同时使用到两者的优点。</p>
<p>本文参考：<a href="http://www.itsoku.com/course/2/68" target="_blank" rel="noopener">www.itsoku.com/course/2/68</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359083767564091407" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,maven</tag>
      </tags>
  </entry>
  <entry>
    <title>签到功能_redis_bitmap实现笔记</title>
    <url>/7359083483237957671.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>签到功能：签到，补签，查询当月签到记录。</p>
<blockquote>
<p>笔记记录签到最核心代码，无涉及什么条件下可签到等业务需求。</p>
</blockquote>
<h2 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h2><ul>
<li>redis服务</li>
<li>springboot项目</li>
</ul>
<p>使用到的依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;lombok&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;cn.hutool&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hutool-all&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.8.27&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码spring:</span><br><span class="line">  redis:</span><br><span class="line">    host: redis服务地址</span><br><span class="line">    password: redis服务密码</span><br></pre></td></tr></table></figure>

<h2 id="利用redis中bitmap数据结构来应用签到需求"><a href="#利用redis中bitmap数据结构来应用签到需求" class="headerlink" title="利用redis中bitmap数据结构来应用签到需求"></a>利用redis中bitmap数据结构来应用签到需求</h2><p>签到命令：<code>SETBIT key offset value</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码&gt; SETBIT sign:1001:202404 0 1</span><br><span class="line">0</span><br></pre></td></tr></table></figure>

<p>解释：用户1001在2024年4月1号签到。</p>
<p><strong>重复签到执行命令的结果</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码&gt; SETBIT sign:1001:202404 0 1</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>解释：如果返回<code>1</code>代表已经签到了。</p>
<h3 id="Java代码实现签到功能："><a href="#Java代码实现签到功能：" class="headerlink" title="Java代码实现签到功能："></a>Java代码实现签到功能：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public void signIn(String uid) &#123;</span><br><span class="line"></span><br><span class="line">    // 拼接业务key</span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line"></span><br><span class="line">    // 哪一天签到</span><br><span class="line">    int offset = now.getDayOfMonth() - 1;</span><br><span class="line"></span><br><span class="line">    // 提交签到记录</span><br><span class="line">    Boolean res = redisTemplate.opsForValue().setBit(key, offset, true);</span><br><span class="line"></span><br><span class="line">    if (BooleanUtil.isTrue(res)) &#123;</span><br><span class="line">        log.error(&quot;用户：&#123;&#125; 签到失败，重复签到，签到时间：&#123;&#125;&quot;, uid, now);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;用户：&#123;&#125; 签到成功，签到时间：&#123;&#125;&quot;, uid, now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="补签需求"><a href="#补签需求" class="headerlink" title="补签需求"></a>补签需求</h2><p>补签需求使用到的命令与签到命令一样，需要加入补签的业务条件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public void repairSignIn(String uid, LocalDate date) &#123;</span><br><span class="line"></span><br><span class="line">    // 业务要求补签只能补当月缺少签到的天进行补签</span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    if (now.getYear() != date.getYear() || now.getMonthValue() != date.getMonthValue()) &#123;</span><br><span class="line">        log.error(&quot;用户：&#123;&#125; 补签失败，补签日期不在当月，补签日期：&#123;&#125;&quot;, uid, date);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String format = date.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line">    int offset = date.getDayOfMonth() - 1;</span><br><span class="line">    Boolean res = redisTemplate.opsForValue().setBit(key, offset, true);</span><br><span class="line"></span><br><span class="line">    if (BooleanUtil.isTrue(res)) &#123;</span><br><span class="line">        log.error(&quot;用户：&#123;&#125; 补签失败，重复签到，签到时间：&#123;&#125;&quot;, uid, date);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    log.info(&quot;用户：&#123;&#125; 补签成功，签到时间：&#123;&#125;&quot;, uid, date);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1f40294c3245b533e42c8f24350a8d0cc0d5a16f9292899968cabc1634066edc" alt="image.png"></p>
<h2 id="查询当月当下连续签到的天数"><a href="#查询当月当下连续签到的天数" class="headerlink" title="查询当月当下连续签到的天数"></a>查询当月当下连续签到的天数</h2><p>redis命令：<code>bitfield key get u获取的数量 开始的下标</code>,这里的<code>u</code>代表返回时是<code>无符号位</code>，结果返回十进制数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码&gt; bitfield sign:in:uid:1001:202404 get u18 0</span><br><span class="line">131135</span><br></pre></td></tr></table></figure>

<h3 id="Java代码实现查询当月当下连续签到次数"><a href="#Java代码实现查询当月当下连续签到次数" class="headerlink" title="Java代码实现查询当月当下连续签到次数"></a>Java代码实现查询当月当下连续签到次数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public int continuousDays(String uid) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line"></span><br><span class="line">    int day = now.getDayOfMonth();</span><br><span class="line"></span><br><span class="line">    List&lt;Long&gt; res = redisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands</span><br><span class="line">                    .create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(day))</span><br><span class="line">                    .valueAt(0));</span><br><span class="line">    if (CollUtil.isEmpty(res)) &#123;</span><br><span class="line">        log.error(&quot;无签到记录&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 获取十进制数</span><br><span class="line">    Long num = res.get(0);</span><br><span class="line"></span><br><span class="line">    // 记录连续签到数量</span><br><span class="line">    int count = 0;</span><br><span class="line"></span><br><span class="line">    // 利用 &amp; 1 判断最低位是否为1</span><br><span class="line">    while ((num &amp; 1) == 1) &#123;</span><br><span class="line">        count++;</span><br><span class="line">        num &gt;&gt;&gt;= 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在处理redis返回的十进制数时，使用 <code>&amp;运算</code>，<code>无符号右移机制</code>，实现对签到<code>1</code>的判断与记录。</p>
</blockquote>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5d44d8f3466e1a0291f5f7280fd3fb7937a6bb0d84b2c9fab0880b7c5dc2de9c" alt="image.png"></p>
<p>查询结果应该为：6。<code>bitmap初始化8位，当位数不够时，每次增加8位。</code></p>
<h2 id="查询当月签到记录"><a href="#查询当月签到记录" class="headerlink" title="查询当月签到记录"></a>查询当月签到记录</h2><p>Java代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public byte[] signInRecord(String uid) &#123;</span><br><span class="line"></span><br><span class="line">    LocalDate now = LocalDate.now();</span><br><span class="line">    String format = now.format(DateTimeFormatter.ofPattern(&quot;:yyyyMM&quot;));</span><br><span class="line">    String key = SIGN_IN_KEY + uid + format;</span><br><span class="line">    int day = now.getDayOfMonth();</span><br><span class="line">    List&lt;Long&gt; res = redisTemplate.opsForValue().bitField(</span><br><span class="line">            key,</span><br><span class="line">            BitFieldSubCommands</span><br><span class="line">                    .create()</span><br><span class="line">                    .get(BitFieldSubCommands.BitFieldType.unsigned(day))</span><br><span class="line">                    .valueAt(0));</span><br><span class="line">    if (CollUtil.isEmpty(res)) &#123;</span><br><span class="line">        return new byte[0];</span><br><span class="line">    &#125;</span><br><span class="line">    Long num = res.get(0);</span><br><span class="line"></span><br><span class="line">    byte[] bytes = new byte[day];</span><br><span class="line">    int i = day - 1;</span><br><span class="line">    while (i &gt;= 0) &#123;</span><br><span class="line">        bytes[i] = (byte) (num &amp; 1);</span><br><span class="line">        num &gt;&gt;&gt;= 1;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    return bytes;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果：<code>[1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1]</code>，返回给前端，使用相应组件显示效果如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e684eec96277a7478f22514c2137d0eb2815135ae58828eb05a3a3daf6875362" alt="image.png"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用户在某年某月某日签到的数据记录存储在redis中，利用bitmap数据类型的先天优势，0与1代表未签到与签到的设定，实现签到功能。</p>
<p>在获取签到数据时，redis返回的数据是十进制，需要加工处理，利用到 &amp;运算 与 无符号右移，进行二进制的操作计算。</p>
<p>从效率和存储空间来看，redis的bitmap来实现签到功能还是非常合适的。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359083483237957671" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>go语言是如何实现协程的</title>
    <url>/7359083767564795919.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="写在文章开头"><a href="#写在文章开头" class="headerlink" title="写在文章开头"></a>写在文章开头</h2><p><code>go语言</code>的精华就在于协程的设计，只有理解协程的设计思想和工作机制，才能确保我们能够完全的利用协程编写强大的并发程序。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b231c2cf2efa76b739a757c889700c7e3b0e5df17d6f44a4685a63cdc34da777" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<p>Hi，我是 <strong>sharkChili</strong> ，是个不断在硬核技术上作死的 <strong>java coder</strong> ，是 <strong>CSDN的博客专家</strong> ，也是开源项目 <strong>Java Guide</strong> 的维护者之一，熟悉 <strong>Java</strong> 也会一点 <strong>Go</strong> ，偶尔也会在 <strong>C源码</strong> 边缘徘徊。写过很多有意思的技术博客，也还在研究并输出技术的路上，希望我的文章对你有帮助，非常欢迎你关注我的公众号： <strong>写代码的SharkChili</strong> 。</p>
<p>因为近期收到很多读者的私信，所以也专门创建了一个交流群，感兴趣的读者可以通过上方的公众号获取笔者的联系方式完成好友添加，点击备注 <strong>“加群”</strong> 即可和笔者和笔者的朋友们进行深入交流。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cc5e08f46f41722a78eec887a399b58dc6faa5cd50760dfc014a006ee88f694a" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<h2 id="详解协程工作机制和实现"><a href="#详解协程工作机制和实现" class="headerlink" title="详解协程工作机制和实现"></a>详解协程工作机制和实现</h2><h3 id="协程示例"><a href="#协程示例" class="headerlink" title="协程示例"></a>协程示例</h3><p>正式介绍底层之前，我们给出一段协程的代码示例，可以看到笔者开启一个协程进行函数内部调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码func foo1() &#123;</span><br><span class="line"> fmt.Println(&quot;foo1 调用 foo2&quot;)</span><br><span class="line"> foo2()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func foo2() &#123;</span><br><span class="line"> fmt.Println(&quot;foo2调用foo3&quot;)</span><br><span class="line"> foo3()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func foo3() &#123;</span><br><span class="line"> fmt.Println(&quot;foo3 执行了&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"> //设置WaitGroup等待协程结束</span><br><span class="line"> var wg sync.WaitGroup</span><br><span class="line"> wg.Add(1)</span><br><span class="line"></span><br><span class="line"> go func() &#123;</span><br><span class="line">  foo1()</span><br><span class="line">  defer wg.Done()</span><br><span class="line"> &#125;()</span><br><span class="line"></span><br><span class="line"> //等待上述协程运行结束</span><br><span class="line"> wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">复制代码foo1 调用 foo2</span><br><span class="line">foo2调用foo3</span><br><span class="line">foo3 执行了</span><br></pre></td></tr></table></figure>

<p>结合debug我们可以看到当前协程的调用栈帧，在函数调用前插入一个<code>goexit</code>的东西，结合这一点我们开始对协程的深入剖析：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fadee10358da21e3205f3d4ab4905f35840a0a372d3021332b0b77591d5b637c" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<h3 id="协程实现结构"><a href="#协程实现结构" class="headerlink" title="协程实现结构"></a>协程实现结构</h3><p>在<code>go语言</code>的协程结构为:</p>
<ol>
<li>通过一个<code>stack</code>记录其高地址和低地址。</li>
<li>通过<code>sched</code>的<code>sp(即stackpointer)栈帧的指针</code>和<code>程序计数器pc(指向下一条运行的指令)</code>.</li>
<li>采用<code>goid</code>生成唯一标识。</li>
<li>然后再用<code>atomicstatus</code>记录其执行状态。</li>
</ol>
<p>基于这几点我们结合上述的代码给出协程的底层结构，如下图所示，当前协程的<code>stack</code>记录整个foo1函数的高低地址，假设我们当前的协程<code>go</code>来到<code>foo2</code>函数准备调用<code>foo3</code>函数，我们的<code>sched</code>中的sp即<code>stackpointer</code>记录foo2的指针，同时因为<code>foo2</code>内部会调用<code>foo3</code>所以程序计数器<code>pc</code>记录着调用<code>foo3</code>的指令。</p>
<p>最后因为协程都是由线程调度的，所以协程的内部也有一个变量记录着当前线程的指针m：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/becb6b23e5cc1710193a22f486133323c8b2faae8379df0382015bb1c5377a0a" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<p>到此我们了解了协程核心结构，同时我们也在<code>runtime2.go</code>这一文件中即给出上述所说的核心变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码type g struct &#123;</span><br><span class="line"> //记录栈帧的高地址和低地址</span><br><span class="line"> stack       stack   // offset known to runtime/cgo</span><br><span class="line"> //......</span><br><span class="line"> m         *m //执行当前协程的线程指针</span><br><span class="line"> //记录当前堆栈的指针以及下一条指令的运行地址</span><br><span class="line"> sched     gobuf</span><br><span class="line"> atomicstatus atomic.Uint32</span><br><span class="line"> goid         uint64</span><br><span class="line"> </span><br><span class="line"> //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>步入<code>stack</code>可以看到<code>lo</code>和<code>hi</code>两个专门记录栈帧高低地址的指针：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码type stack struct &#123;</span><br><span class="line"> lo uintptr</span><br><span class="line"> hi uintptr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的我们也给出<code>sched</code> 的类型<code>gobuf</code>，可以看到<code>sp</code>和<code>pc</code>两个核心指针变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码type gobuf struct &#123;</span><br><span class="line"> </span><br><span class="line"> sp   uintptr</span><br><span class="line"> pc   uintptr</span><br><span class="line"> //......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="谈谈go语言对于线程的抽象"><a href="#谈谈go语言对于线程的抽象" class="headerlink" title="谈谈go语言对于线程的抽象"></a>谈谈go语言对于线程的抽象</h3><p>上文我们提出线程的用<code>m</code>指针记录，如下源码所示，我们都知道在go语言中每个线程都会从一个协程队列中获取协程执行，所以执行时它会用<code>curg</code>记录当前运行的协程，然后通过id对自己进行唯一标识，而<code>mOS</code>则是及记录当前操作系统信息，这其中最核心的就是<code>g0</code>它就是每一个线程的操作调度器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码type m struct &#123;</span><br><span class="line"> g0      *g     // goroutine with scheduling stack</span><br><span class="line"> id            int64 </span><br><span class="line"> </span><br><span class="line"> curg          *g       // current running goroutine</span><br><span class="line"> </span><br><span class="line"> mOS</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>了解整体结构之后我们再来聊聊go语言线程的g0栈是如何工作的，如下图所示，每一个g0栈都会通过schedule开始工作：</p>
<ol>
<li>通过execute从协程队列中获取任务。</li>
<li>调用gogo方法在协程调用前插入<code>go exit</code>指针它记录g0栈帧，这个指针就是用于协程执行退出或者挂起是可以通过这个指针跳回<code>g0</code>栈。</li>
<li>然后就是执行当前协程。</li>
<li>协程执行完成切换回<code>g0</code>栈，重新调用schedule方法再次从步骤1开始执行，由此构成一个循环。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a7d8241129c186004355b2a67382372e9cbf7a493830864364ce5ea90c7999df" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<p>这里我们也给出<code>asm_amd64.s</code>中关于<code>gogo</code>的汇编代码，可以看到gobuf_sp方法它会记录当前<code>stack pointer</code>也就是我们上文针对<code>g0</code>所说的<code>g0</code>栈地址：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码TEXT gogo&lt;&gt;(SB), NOSPLIT, $0</span><br><span class="line"> get_tls(CX)</span><br><span class="line"> MOVQ DX, g(CX)</span><br><span class="line"> MOVQ DX, R14  // set the g register</span><br><span class="line"> //记录g0栈地址</span><br><span class="line"> MOVQ gobuf_sp(BX), SP // restore SP</span><br><span class="line"> MOVQ gobuf_ret(BX), AX</span><br><span class="line"> MOVQ gobuf_ctxt(BX), DX</span><br><span class="line"> MOVQ gobuf_bp(BX), BP</span><br><span class="line"> MOVQ $0, gobuf_sp(BX) // clear to help garbage collector</span><br><span class="line"> MOVQ $0, gobuf_ret(BX)</span><br><span class="line"> MOVQ $0, gobuf_ctxt(BX)</span><br><span class="line"> MOVQ $0, gobuf_bp(BX)</span><br><span class="line"> MOVQ gobuf_pc(BX), BX</span><br><span class="line"> JMP BX</span><br></pre></td></tr></table></figure>

<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>自此我们从go语言底层实现的角度完整的剖析的协程与线程的关系和实现，希望对你有帮助。</p>
<p>我是 <strong>sharkchili</strong> ，<strong>CSDN Java 领域博客专家</strong>，<strong>开源项目—JavaGuide contributor</strong>，我想写一些有意思的东西，希望对你有帮助，如果你想实时收到我写的硬核的文章也欢迎你关注我的公众号： <strong>写代码的SharkChili</strong> 。 因为近期收到很多读者的私信，所以也专门创建了一个交流群，感兴趣的读者可以通过上方的公众号获取笔者的联系方式完成好友添加，点击备注 <strong>“加群”</strong> 即可和笔者和笔者的朋友们进行深入交流。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/010663761676d3b15cab65c855e8765c963fd6f297397fe69d33a99caba0e519" alt="在这里插入图片描述"></p>
<p>在这里插入图片描述</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>程序计数器（PC）、堆栈指针（SP）与函数调用过程:<a href="https://www.cnblogs.com/uestcliming666/p/11488782.html" target="_blank" rel="noopener">www.cnblogs.com/uestcliming…</a></p>
<p>本文使用 <a href="https://markdown.com.cn" target="_blank" rel="noopener">markdown.com.cn</a> 排版</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359083767564795919" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>Go下载安装及切换不同版本的方法</title>
    <url>/7359084604663300148.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="一、下载安装"><a href="#一、下载安装" class="headerlink" title="一、下载安装"></a>一、下载安装</h2><p><a href="https://go.dev/dl/" target="_blank" rel="noopener">Go下载地址</a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4753ee60e1bb255882601b3d9de93b4e313522b35cedc43c4a07be9036b14e7a" alt="go-switch-version-image.png"></p>
<p>Go提供了Windows、MacOS(ARM64) 和 MacOS(x86-64)、Linux版本，也可以下载源码自己编译安装。</p>
<blockquote>
<p>Linux &amp;&amp; MacOS</p>
</blockquote>
<ul>
<li>下载压缩包</li>
<li>解压到指定目录，如：/usr/local</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码rm -rf /usr/local/go &amp;&amp; tar -C /usr/local -xzf go1.22.2.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>把go的bin目录添加到环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码在 ~/.zshrc或~/.bashrc中添加如下行</span><br><span class="line"></span><br><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure>

<ul>
<li>使用环境变量立即生效</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码source ~/.zshrc 或 source ~/.bashrc</span><br></pre></td></tr></table></figure>

<ul>
<li>测试go是否安装成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码go version</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Windows</p>
</blockquote>
<ul>
<li>直接双击 .msi文件进行引导安装</li>
<li>安装完成后打开 cmd 或 power shell 输入 go version 验证安装是否成功</li>
</ul>
<h2 id="二、如何切换Go版本？"><a href="#二、如何切换Go版本？" class="headerlink" title="二、如何切换Go版本？"></a>二、如何切换Go版本？</h2><h3 id="方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本"><a href="#方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本" class="headerlink" title="方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本"></a>方法一：直接下载不同版本的压缩包，使用软连接指向不同的版本</h3><ul>
<li>下载完压缩包，解压到其他目录，如：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码tar -C ~/Downloads -xzf go1.21.9.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<ul>
<li>把go目录重命名为 go1.21.9</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码mv go go1.21.9</span><br></pre></td></tr></table></figure>

<ul>
<li>新建一个go全局目录，如：go_version</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码mkdir ~/go_version</span><br></pre></td></tr></table></figure>

<ul>
<li>做一个软链接指向go1.21.9版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码ln -s ~/Downloads/go1.21.9 ~/go_version/go</span><br></pre></td></tr></table></figure>

<ul>
<li>把~/go_version/go/bin目录加到到环境变量</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码export PATH=~/go_version/go/bin:$PATH</span><br></pre></td></tr></table></figure>

<ul>
<li>验证是否安装成功</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码go1.21.9 version</span><br></pre></td></tr></table></figure>

<p>扩展：此法为切换软件的通法，其他软件也适用。</p>
<h3 id="方法二：使用go-install-命令安装其他版本"><a href="#方法二：使用go-install-命令安装其他版本" class="headerlink" title="方法二：使用go install 命令安装其他版本"></a>方法二：使用go install 命令安装其他版本</h3><p>已经安装go的情况下(例如当前版本为：1.22.2)，可以通过go install 来安装其他版本</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码go install golang.org/dl/go1.22.1@latest</span><br><span class="line"></span><br><span class="line">go1.22.1 download</span><br></pre></td></tr></table></figure>

<p>go install 命令会把go1.22.1版本作为1.22.2的可执行安装包，存放在 ~/go/bin下面</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5f1f580ca6b165ca37c6fd8515869b2ca7ceeede6d58185574301254d4f4cbe4" alt="go-switch-version-image-1.png"></p>
<p>再去用go1.22.1 download 则会下载1.22.1的源码，放到~/sdk下面</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e7ab2ed5c25850eebfe022d8ac4129b8e0425ba411e448fbb48ea5c8fc207a9b" alt="go-switch-version-image-2.png"></p>
<p>此时就可以用go1.22.1 version来验证是否安装成功了</p>
<p>为什么可以直接敲go1.22.1呢？实际上执行的是<del>/go/bin/go1.22.1这个二进制文件，而</del>/go/bin又加入了PATH变量，所以能执行。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d18e875e8df1697b8f9dc2317d6f6edbe5a4192f7bc99947367e795fd57c528a" alt="go-switch-version-image-3.png"></p>
<p>sdk是不能删除的，go1.22.1会读取sdk里面的源码，删除后会提示sdk没有下载。</p>
<h3 id="方法三：使用gvm来切换"><a href="#方法三：使用gvm来切换" class="headerlink" title="方法三：使用gvm来切换"></a>方法三：使用gvm来切换</h3><p>gvm全称：Go Version Manager (GVM)是一个用于管理Go环境的开源工具。它支持安装多个Go版本，并使用GVM “pkgsets” 管理每个项目的模块。GVM(与Ruby中的RVM一样)最初是由Josh Bussdieker开发的，它允许为每个项目或项目组创建开发环境，分离不同的Go版本和包依赖关系，以提供更大的灵活性并防止版本问题。</p>
<blockquote>
<p>安装gvm</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码bash &lt; &lt;(curl -s -S -L https://raw.githubusercontent.com/moovweb/gvm/master/binscripts/gvm-installer)</span><br><span class="line"></span><br><span class="line">命令解析：</span><br><span class="line"></span><br><span class="line">-s -S 连用表示禁用进度条但可以显示错误信息</span><br><span class="line"></span><br><span class="line">-L 表示重定向跟随</span><br><span class="line"></span><br><span class="line">&lt;(...) 此处为&lt;(curl ...) ，此语法表示curl的执行结果被视作文件</span><br><span class="line"></span><br><span class="line">bash &lt; 表示拿到curl的执行结果作为标准输入传给bash</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过gvm安装go</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm install go1.22.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>通过gvm切换go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm use go1.22.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有通过gvm安装的go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm list</span><br></pre></td></tr></table></figure>

<blockquote>
<p>列出所有可用的线上go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shel复制代码gvm listall</span><br></pre></td></tr></table></figure>

<blockquote>
<p>卸载go版本</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm uninstall go1.22.2</span><br></pre></td></tr></table></figure>

<blockquote>
<p>完全移除gvm及其所有安装的go版本和依赖包</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm implode</span><br><span class="line"></span><br><span class="line">如果卸载失败，直接 rm -rf ~/.gvm</span><br></pre></td></tr></table></figure>

<blockquote>
<p>管理go的依赖包</p>
</blockquote>
<p>pkgset允许独立管理不同的Go包集及其版本，从而更容易在不同的项目依赖关系之间切换。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码// 创建包集合</span><br><span class="line">gvm pkgset create [name]</span><br><span class="line"></span><br><span class="line">// 选择包集合</span><br><span class="line">gvm pkgset use [name]</span><br><span class="line"></span><br><span class="line">// 列出创建的包集合</span><br><span class="line">gvm pkgset list</span><br><span class="line"></span><br><span class="line">// 删除包集合</span><br><span class="line">gvm pkgset delete [name]</span><br></pre></td></tr></table></figure>

<p>切换到指定的包集后，后续使用go build、go run命令时会把下载的包安装到包集目录</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dd8fcb56ca51e9857ea590082e8d8bf74a222dd653a6255eefe66d2e54d9862c" alt="go-switch-version-image-4.png"></p>
<blockquote>
<p>其他gvm命令</p>
</blockquote>
<ul>
<li>打印gvm版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm version</span><br></pre></td></tr></table></figure>

<ul>
<li>获取gvm最新版本</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm get</span><br></pre></td></tr></table></figure>

<ul>
<li>打印帮助信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码gvm help</span><br></pre></td></tr></table></figure>

<blockquote>
<p>gvm 原理</p>
</blockquote>
<p>其内部核心也是使用软连接，通过指向不同的版本使用不同的环境变量</p>
<p>后面再进行源码分析</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359084604663300148" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>【tokio实战】如何在rust中调用腾讯&amp;百度的翻译服务</title>
    <url>/7359084920596103206.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="如何在rust中调用腾讯-amp-百度的翻译服务"><a href="#如何在rust中调用腾讯-amp-百度的翻译服务" class="headerlink" title="如何在rust中调用腾讯&amp;百度的翻译服务"></a>如何在rust中调用腾讯&amp;百度的翻译服务</h2><p><strong>阅读本篇博客后，您将掌握关于Tokio库实现批量任务处理的实用技巧，并了解如何有效地进行并发限制。</strong></p>
<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>在开发<a href="https://github.com/yexiyue/Comfyui-Startup" target="_blank" rel="noopener">ComfyUI Startup</a>插件管理和模型管理功能的过程中，我发现对模型数据和插件数据的需求。在研究ComfyUI Manager如何实现将模型下载至特定目录时，我注意到其仓库中包含的数据文件仅提供英文版本。为了满足国际化需求，我决定着手翻译这些数据文件。然而，显然逐一手动翻译并不现实。<strong>因此，我选择利用<code>tokio</code>和<code>reqwest</code>库调用百度或腾讯的翻译API，以自动化的方式进行翻译工作。</strong></p>
<h3 id="先实现一个翻译请求的调用"><a href="#先实现一个翻译请求的调用" class="headerlink" title="先实现一个翻译请求的调用"></a>先实现一个翻译请求的调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码use crate::CLIENT;</span><br><span class="line">use anyhow::&#123;anyhow, Result&#125;;</span><br><span class="line">use once_cell::sync::Lazy;</span><br><span class="line">use serde_json::Value;</span><br><span class="line"></span><br><span class="line">static APP_ID: Lazy&lt;String&gt; = Lazy::new(|| std::env::var(&quot;APP_ID&quot;).unwrap());</span><br><span class="line">static APP_KEY: Lazy&lt;String&gt; = Lazy::new(|| std::env::var(&quot;APP_KEY&quot;).unwrap());</span><br><span class="line">static URL: &amp;str = &quot;http://api.fanyi.baidu.com/api/trans/vip/translate&quot;;</span><br><span class="line"></span><br><span class="line">// 对请求进行封装，只获取想要的数据</span><br><span class="line">pub async fn trans(src: &amp;str, from: &amp;str, to: &amp;str) -&gt; Result&lt;Value&gt; &#123;</span><br><span class="line">    let res: Value = CLIENT</span><br><span class="line">        .get(URL)</span><br><span class="line">        .query(&amp;[</span><br><span class="line">            (&quot;q&quot;, src),</span><br><span class="line">            (&quot;appid&quot;, &amp;APP_ID),</span><br><span class="line">            (&quot;from&quot;, from),</span><br><span class="line">            (&quot;to&quot;, to),</span><br><span class="line">            (&quot;salt&quot;, &quot;10086&quot;),</span><br><span class="line">            (&quot;sign&quot;, &amp;sign(src)),</span><br><span class="line">        ])</span><br><span class="line">        .send()</span><br><span class="line">        .await?</span><br><span class="line">        .json()</span><br><span class="line">        .await?;</span><br><span class="line"></span><br><span class="line">    let trans_result = res[&quot;trans_result&quot;]</span><br><span class="line">        .as_array()</span><br><span class="line">        .ok_or(anyhow!(&quot;&#123;res&#125;&quot;))?</span><br><span class="line">        .first()</span><br><span class="line">        .unwrap()[&quot;dst&quot;]</span><br><span class="line">        .clone();</span><br><span class="line"></span><br><span class="line">    Ok(trans_result)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 签名方法，参考百度翻译API文档</span><br><span class="line">fn sign(q: &amp;str) -&gt; String &#123;</span><br><span class="line">    let str = format!(&quot;&#123;&#125;&#123;&#125;10086&#123;&#125;&quot;, &amp;*APP_ID, q, &amp;*APP_KEY);</span><br><span class="line">    let digest = md5::compute(str);</span><br><span class="line">    format!(&quot;&#123;:x&#125;&quot;, digest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="然后再实现批量调用"><a href="#然后再实现批量调用" class="headerlink" title="然后再实现批量调用"></a>然后再实现批量调用</h3><p>起初，我设想采用for循环逐个调用的方式实现功能，但这种方式未能充分利用Tokio框架提供的高并发特性。这一思考受到了TypeScript编程经验的影响，在TypeScript中，Promise会在定义后立即执行，而Rust语言中的Future则不同，它们仅在遇到await表达式时才会真正执行其异步操作。因此，为了适应Rust及Tokio的异步编程模型，我们需要采取更恰当的方式来调度并发任务以发挥其优势。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码pub async fn run&lt;P: AsRef&lt;Path&gt;&gt;(</span><br><span class="line">    url: &amp;str,</span><br><span class="line">    target_field: &amp;str,</span><br><span class="line">    path: P,</span><br><span class="line">    from: &amp;str,</span><br><span class="line">    to: &amp;str,</span><br><span class="line">    field: Option&lt;&amp;str&gt;,</span><br><span class="line">) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">    let custom_nodes: Value = CLIENT.get(url).send().await?.json().await?;</span><br><span class="line">    let nodes = if field.is_some() &#123;</span><br><span class="line">        &amp;custom_nodes[field.unwrap()]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &amp;custom_nodes</span><br><span class="line">    &#125;;</span><br><span class="line">    // 前面都不重要，只需要知道nodes就是要翻译的数据数组</span><br><span class="line">    let nodes = nodes.as_array().ok_or(anyhow!(&quot;&#123;nodes:#?&#125;&quot;))?;</span><br><span class="line"></span><br><span class="line">    let mut new_nodes = nodes.clone();</span><br><span class="line">    let time = std::time::Instant::now();</span><br><span class="line"></span><br><span class="line">    for node in new_nodes.iter_mut() &#123;</span><br><span class="line">        let src = node[target_field]</span><br><span class="line">            .as_str()</span><br><span class="line">            .ok_or(anyhow!(&quot;no description&quot;))?;</span><br><span class="line"></span><br><span class="line">        let zh = match trans(src, from, to).await &#123;</span><br><span class="line">            Ok(zh) =&gt; zh,</span><br><span class="line">            Err(e) =&gt; &#123;</span><br><span class="line">                error!(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                return Err(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        info!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, src, zh);</span><br><span class="line">        node[format!(&quot;&#123;to&#125;_&#123;target_field&#125;&quot;)] = zh;</span><br><span class="line">        warn!(&quot;one task time:&#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 将数据写入文件中</span><br><span class="line">    info!(&quot;all time: &#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    let file = std::fs::File::create(&amp;path)?;</span><br><span class="line">    serde_json::to_writer_pretty(file, &amp;new_nodes)?;</span><br><span class="line">    info!(&quot;write to &#123;&#125;&quot;, path.as_ref().display().to_string());</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第二版本，使用join-all来批量执行"><a href="#第二版本，使用join-all来批量执行" class="headerlink" title="第二版本，使用join_all来批量执行"></a>第二版本，使用join_all来批量执行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码pub async fn run2&lt;P: AsRef&lt;Path&gt;&gt;(</span><br><span class="line">    url: &amp;str,</span><br><span class="line">    target_field: &amp;str,</span><br><span class="line">    path: P,</span><br><span class="line">    from: &amp;str,</span><br><span class="line">    to: &amp;str,</span><br><span class="line">    field: Option&lt;&amp;str&gt;,</span><br><span class="line">) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">    let custom_nodes: Value = CLIENT.get(url).send().await?.json().await?;</span><br><span class="line">    let nodes = if field.is_some() &#123;</span><br><span class="line">        &amp;custom_nodes[field.unwrap()]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &amp;custom_nodes</span><br><span class="line">    &#125;;</span><br><span class="line">    // 前面都不重要，只需要知道nodes就是要翻译的数据数组</span><br><span class="line">    let nodes = nodes.as_array().ok_or(anyhow!(&quot;&#123;nodes:#?&#125;&quot;))?;</span><br><span class="line"></span><br><span class="line">    let mut new_nodes = nodes.clone();</span><br><span class="line">    let time = std::time::Instant::now();</span><br><span class="line">		</span><br><span class="line">  	// 这里使用map转换成异步任务，但还没执行</span><br><span class="line">    let tasks = new_nodes.iter_mut().map(|node| async &#123;</span><br><span class="line">        let src = node[target_field]</span><br><span class="line">            .as_str()</span><br><span class="line">            .ok_or(anyhow!(&quot;no description&quot;))?;</span><br><span class="line"></span><br><span class="line">        let zh = match trans(src, from, to).await &#123;</span><br><span class="line">            Ok(zh) =&gt; zh,</span><br><span class="line">            Err(e) =&gt; &#123;</span><br><span class="line">                error!(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                return Err(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        info!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, src, zh);</span><br><span class="line">        node[format!(&quot;&#123;to&#125;_&#123;target_field&#125;&quot;)] = zh;</span><br><span class="line">        warn!(&quot;one task time:&#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">        Ok(())</span><br><span class="line">    &#125;);</span><br><span class="line">  	</span><br><span class="line">  	// 使用futures::future::join_all来批量执行这些任务  	</span><br><span class="line">    join_all(tasks).await;</span><br><span class="line">    // 将数据写入文件中</span><br><span class="line">    info!(&quot;all time: &#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    let file = std::fs::File::create(&amp;path)?;</span><br><span class="line">    serde_json::to_writer_pretty(file, &amp;new_nodes)?;</span><br><span class="line">    info!(&quot;write to &#123;&#125;&quot;, path.as_ref().display().to_string());</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里将数据转换成批量异步任务，再使用join_all来等待他们所有执行完成。</p>
<p>其实这里有更好的方法就是使用<code>futures::stream::FuturesUnordered</code>，这里为了简便就使用了join_all。</p>
<h3 id="并发限制"><a href="#并发限制" class="headerlink" title="并发限制"></a>并发限制</h3><p>在实践高并发场景时，我发现百度API存在一定的调用频率限制，即每秒允许的请求次数有限制。因此，为了避免超出限制，我不得不对并发任务进行控制。鉴于这种情况下的时间敏感性，我没有选择使用<code>tokio::sync::Semaphore</code>作为并发限制工具，而是采用了批量分时执行策略：将任务划分为多个批次，每一批次之间的执行间隔为3秒，确保每批任务在前一批次执行满3秒后才开始执行，从而符合接口调用频率要求。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码pub async fn run&lt;P: AsRef&lt;Path&gt;&gt;(</span><br><span class="line">    url: &amp;str,</span><br><span class="line">    target_field: &amp;str,</span><br><span class="line">    path: P,</span><br><span class="line">    from: &amp;str,</span><br><span class="line">    to: &amp;str,</span><br><span class="line">    field: Option&lt;&amp;str&gt;,</span><br><span class="line">) -&gt; Result&lt;()&gt; &#123;</span><br><span class="line">    let custom_nodes: Value = CLIENT.get(url).send().await?.json().await?;</span><br><span class="line">    let nodes = if field.is_some() &#123;</span><br><span class="line">        &amp;custom_nodes[field.unwrap()]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        &amp;custom_nodes</span><br><span class="line">    &#125;;</span><br><span class="line">    let nodes = nodes.as_array().ok_or(anyhow!(&quot;&#123;nodes:#?&#125;&quot;))?;</span><br><span class="line"></span><br><span class="line">    let mut new_nodes = nodes.clone();</span><br><span class="line">    let time = std::time::Instant::now();</span><br><span class="line">		// 按5个进行分批</span><br><span class="line">    for i in (0..new_nodes.len()).step_by(5) &#123;</span><br><span class="line">        let time = std::time::Instant::now();</span><br><span class="line">      	// 对边界进行限制</span><br><span class="line">        let last = std::cmp::min(i + 5, new_nodes.len());</span><br><span class="line">      </span><br><span class="line">      	// 将这5个数据转换成批量任务</span><br><span class="line">        let tasks = &amp;mut new_nodes[i..last];</span><br><span class="line">        let tasks = tasks.iter_mut().map(|node| async move &#123;</span><br><span class="line">            let src = node[target_field]</span><br><span class="line">                .as_str()</span><br><span class="line">                .ok_or(anyhow!(&quot;no description&quot;))?;</span><br><span class="line"></span><br><span class="line">            let zh = match trans(src, from, to).await &#123;</span><br><span class="line">                Ok(zh) =&gt; zh,</span><br><span class="line">                Err(e) =&gt; &#123;</span><br><span class="line">                    error!(&quot;&#123;&#125;&quot;, e);</span><br><span class="line">                    return Err(e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            info!(&quot;&#123;&#125; -&gt; &#123;&#125;&quot;, src, zh);</span><br><span class="line">            node[format!(&quot;&#123;to&#125;_&#123;target_field&#125;&quot;)] = zh;</span><br><span class="line">            Ok::&lt;(), anyhow::Error&gt;(())</span><br><span class="line">        &#125;);</span><br><span class="line">				</span><br><span class="line">      	// 使用join等待两个异步任务一起执行完成</span><br><span class="line">      	// 设置时间为3秒</span><br><span class="line">      	// 注意下面注释的实际上是等待任务执行完后再等5秒。</span><br><span class="line">      	// join_all(tasks).await;</span><br><span class="line">      	// sleep(Duration::from_secs(3);</span><br><span class="line">        join!(join_all(tasks), sleep(Duration::from_secs(3)));</span><br><span class="line">        warn!(&quot;one task time:&#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    &#125;</span><br><span class="line">    info!(&quot;all time: &#123;:?&#125;&quot;, time.elapsed());</span><br><span class="line">    let file = std::fs::File::create(&amp;path)?;</span><br><span class="line">    serde_json::to_writer_pretty(file, &amp;new_nodes)?;</span><br><span class="line">    info!(&quot;write to &#123;&#125;&quot;, path.as_ref().display().to_string());</span><br><span class="line">    Ok(())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>上面代码在我的<a href="https://github.com/yexiyue/Comfyui-Startup" target="_blank" rel="noopener">GitHub</a> <code>translate</code>目录中，如果觉得有用，请给我点个赞吧，另外也恳请您为我的仓库点个Star，谢谢客官老爷。</strong></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359084920596103206" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Rust,前端</tag>
      </tags>
  </entry>
  <entry>
    <title>消息幂等</title>
    <url>/7359086041796542498.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="背景-amp-问题"><a href="#背景-amp-问题" class="headerlink" title="背景 &amp; 问题"></a>背景 &amp; 问题</h2><p>本位柯苏远写于2024年4月18日22点15分</p>
<p>还是在公司的整个电商业务中要接入sms 短信发送功能。</p>
<p>上一篇文章地址：<a href="https://dev.newban.cn/7354929072957702144#comment">分布式锁实战 - 掘金 (juejin.cn)</a></p>
<p>这周到实际开发过程了，首先将整个需求的技术方案设计好了，然后进行开发。整个方案的设计图如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f198debdf9ff77afa45db5b5111390d4c4d20f6b63a53893d0306ac84176a28d" alt="接口幂等 (1).jpg"></p>
<p>A服务：表示每个会产生sms消息的触发点，不单单是一个服务，而是很多个。<br>B服务：对外提供一个插入消息表的接口，所有触发发送sms短信的服务点都调用这个接口。<br>C服务：是一个轮询服务，对短信表进行轮询，找到待发送的sms 短信，然后调用sms api 发送短信给客户。</p>
<p>红框部分有个问题：</p>
<blockquote>
<p>当A向B推送消息的时候，在B收到消息往数据库成功插入数据之后，当要给A服务返回成功标识的时候，由于网络问题接口超时了，A那边收到的返回就是接口超时，那么对于A服务来说我并不知道这个消息到底成功推送没有？A此时应该怎么做？如果重新推送的话可能会在数据库存入一个一模一样的消息。如果不重新推送的话，那消息可能就丢失了。<br><strong>归根结底就是由于在第一步消息推送的时候如果发送接口超时，在A服务中我不知道如何处理当前超时的消息。</strong></p>
</blockquote>
<h2 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h2><p>再次重申问题：</p>
<ol>
<li>如果推送消息接口超时，我按推送失败处理，继续推送这个消息，那么就可能往数据库插入两条一模一样的消息，导致的结果就是客户收到两条一模一样的消息。</li>
<li>如果推送消息接口超时，我按推送成功处理，不对这个消息再次推送，那么可能造成的问题就更大了，消息丢失了，这肯定不允许。</li>
</ol>
<p>既然存在两个问题，那么我们就分别想解决方案。</p>
<p>针对问题1：解决思路挺直观的，因为会往数据库插入重复数据，所以我们给每个消息一个唯一id，当这个消息插入数据库之后，这个消息唯一id也存入了，然后<strong>对这个消息唯一id字段进行设置唯一键</strong>。这样在数据库层面就避免了消息存储重复的可能。</p>
<p>针对问题2：推送接口超时，不推的话，大部分业务是接受不了的，因为消息丢了，所以我们继续推一次这个消息，不用担心会重复发送，因为在存储层面我们用了消息唯一id做唯一键。</p>
<h2 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h2><p>消息的唯一id怎么产生？</p>
<p>唯一id有很多种，用uuid，或者雪花算法都可以，我们这里用的是uuid。</p>
<p>将一个消息和一个uuid绑定的时候，当超时之后，这个消息对应的uuid要不要改？</p>
<p><strong>肯定是不能改的，改了的话，在数据库层面就会重复插入同一条消息</strong></p>
<p>那么不能改的话，当这个消息推送超时，如何解决继续用这个uuid推送？</p>
<p><strong>其实很简单，让uuid变成这个消息的一个属性，然后推送超时，将这个消息弄到一个本地的队列里去，进行重试。一定要注意，每个消息的唯一id是不会变的。</strong></p>
<h2 id="后续安排"><a href="#后续安排" class="headerlink" title="后续安排"></a>后续安排</h2><p>这个是我目前在工作中接触的第一个幂等场景，后续再看看其它幂等情况。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>消息重复发送的可能性。</li>
<li>引入消息唯一id在数据库层面做唯一索引。</li>
<li>消息推送超时，在内存进行重试，消息的唯一id是和每个消息强绑的，<strong>也就是说再重试的时候不能给消息生成新的唯一id</strong></li>
</ol>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359086041796542498" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>关于AssertionError:Torchnotc</title>
    <url>/7359086027581210660.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>你好，我是 shengjk1，多年大厂经验，努力构建 通俗易懂的、好玩的编程语言教程。 欢迎关注！你会有如下收益：</p>
<ol>
<li>了解大厂经验</li>
<li>拥有和大厂相匹配的技术等</li>
</ol>
<p>希望看什么，评论或者私信告诉我！</p>
<h1 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h1><p>最近喜欢上了 ComfyUI ，在安装的过程中，出现了</p>
<blockquote>
<p>AssertionError: Torch not compiled with CUDA enabled</p>
</blockquote>
<p>网上有很多文章都在讲怎么解决，没啥意思，本篇会视图搞懂啥是 CUDA，为 Torch 是基于 CUDA 的</p>
<h1 id="二、正文"><a href="#二、正文" class="headerlink" title="二、正文"></a>二、正文</h1><h2 id="2-1-CUDA-是什么"><a href="#2-1-CUDA-是什么" class="headerlink" title="2.1 CUDA 是什么"></a>2.1 CUDA 是什么</h2><p>全称：Compute Unified Architecture，是 Nvidia’s GPUs 上的通用处理平台。不需要顺序执行的任务，可以利用GPU中的 CUDA 实现并行计算</p>
<p>借助 C、C++ 和 Fortran 语言支持，使用 CUDA 将计算密集型任务运行到 Nvidia GPU 非常容易。 CUDA 被用于需要大量计算能力的领域，或者可以并行化并且需要高性能的场景。机器学习、医学研究和分析、物理学、超级计算、加密货币挖掘、科学建模和模拟等领域都在使用 CUDA。</p>
<h2 id="2-2-Intel-R-Lris-R）Xe-Graphics-是什么"><a href="#2-2-Intel-R-Lris-R）Xe-Graphics-是什么" class="headerlink" title="2.2 Intel(R) Lris(R）Xe Graphics 是什么"></a>2.2 Intel(R) Lris(R）Xe Graphics 是什么</h2><p>为什么介绍它呢？原因很简单，因为我使用的笔记本的显卡就是它。它是 Intel 的集成显卡。所以如果你的也是这样的。那么恭喜你。网上多数解决方案，肯定解决不了 AssertionError: Torch not compiled with CUDA enabled 。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/12ec972cc059de0986ee1cb74ce1fc183d0103ea5640dccdfd083c3a276d7204" alt></p>
<h1 id="三、AssertionError-Torch-not-compiled-with-CUDA-enabled-怎么解"><a href="#三、AssertionError-Torch-not-compiled-with-CUDA-enabled-怎么解" class="headerlink" title="三、AssertionError: Torch not compiled with CUDA enabled 怎么解"></a>三、AssertionError: Torch not compiled with CUDA enabled 怎么解</h1><h2 id="3-1-步骤1：检查GPU是否支持CUDA"><a href="#3-1-步骤1：检查GPU是否支持CUDA" class="headerlink" title="3.1 步骤1：检查GPU是否支持CUDA"></a>3.1 步骤1：检查GPU是否支持CUDA</h2><p>首先，确保你的GPU支持CUDA。你可以访问NVIDIA官网查看你的GPU是否支持CUDA。如果你的GPU不支持CUDA，那么你需要更换支持CUDA的GPU或者在CPU上运行你的PyTorch程序。</p>
<h2 id="3-2-安装支持CUDA的PyTorch版本"><a href="#3-2-安装支持CUDA的PyTorch版本" class="headerlink" title="3.2 安装支持CUDA的PyTorch版本"></a>3.2 安装支持CUDA的PyTorch版本</h2><p>如果你确定你的GPU支持CUDA，那么接下来需要安装支持CUDA的PyTorch版本。你可以从PyTorch官网下载对应你GPU型号和操作系统的安装包。在下载安装包时，请确保选择支持CUDA的版本。</p>
<h2 id="3-3-安装CUDA工具包"><a href="#3-3-安装CUDA工具包" class="headerlink" title="3.3 安装CUDA工具包"></a>3.3 安装CUDA工具包</h2><p>在安装PyTorch之前，你需要先安装CUDA工具包。你可以从NVIDIA官网下载对应你GPU型号和操作系统的CUDA工具包。安装完成后，你需要将CUDA工具包的路径添加到系统环境变量中。具体操作方法可以参考CUDA安装文档。</p>
<h2 id="3-4-重新安装PyTorch"><a href="#3-4-重新安装PyTorch" class="headerlink" title="3.4 重新安装PyTorch"></a>3.4 重新安装PyTorch</h2><p>安装好CUDA工具包后，重新安装PyTorch。按照之前下载的PyTorch安装包进行安装，确保选择与你的GPU和操作系统相匹配的版本。在安装过程中，确保勾选“Install CUDA”选项，以便将PyTorch与CUDA集成。</p>
<h2 id="3-5-验证安装"><a href="#3-5-验证安装" class="headerlink" title="3.5 验证安装"></a>3.5 验证安装</h2><p>完成以上步骤后，验证PyTorch是否正确安装了CUDA支持。打开Python终端，输入以下命令：</p>
<p>import torch</p>
<p>如果成功导入PyTorch库，那么说明你已经成功安装了支持CUDA的PyTorch版本。接下来，你可以尝试运行你的PyTorch程序，看看是否还会出现“AssertionError: Torch not compiled with CUDA enabled”错误。</p>
<h2 id="3-6-总结"><a href="#3-6-总结" class="headerlink" title="3.6 总结"></a>3.6 总结</h2><ol>
<li>如何解：<br>进入 pytorch官网，<a href="https://pytorch.org/get-started/locally/" target="_blank" rel="noopener">pytorch.org/get-started…</a> 选择合适的方式下载合适的包</li>
<li>合适选择方法，例如 inter 显卡，不要用 cuda 相关的方法：</li>
</ol>
<blockquote>
<p>torch.device(torch.cuda.current_device())</p>
</blockquote>
<h1 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h1><p>CUDA 是 Nvidia’s GPUs 上的通用处理平台，用于实现并行计算。如果出现 “AssertionError: Torch not compiled with CUDA enabled” 错误，需要检查GPU是否支持CUDA，并安装支持CUDA的PyTorch版本以及CUDA工具包，然后重新安装PyTorch进行验证。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359086027581210660" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Python,人工智能</tag>
      </tags>
  </entry>
  <entry>
    <title>systemd学习之udevudev</title>
    <url>/7359138355181043739.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="udev"><a href="#udev" class="headerlink" title="udev"></a>udev</h1><p>udev - Dynamic device management 动态地址管理</p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>udev 能够处理设备事件、管理设备文件的权限、 在 <code>/dev</code> 目录中创建额外的符号链接、重命名网络接口，等等。 内核通常仅根据设备被发现的先后顺序给设备文件命名， 因此很难在设备文件与物理硬件之间建立稳定的对应关系。 而根据设备的物理属性或配置特征创建有意义的符号链接名称或网络接口名称， 就可以在物理设备与设备文件名称之间建立稳定的对应关系。</p>
<p>udev守护进程(<a href="https://man7.org/linux/man-pages/man8/systemd-udevd.service.8.html" target="_blank" rel="noopener">systemd-udevd.service(8)</a>) 直接从内核接收设备的插入、拔出、改变状态等事件， 并根据这些事件的各种属性， 到规则库中进行匹配，以确定触发事件的设备。 被匹配成功的规则有可能提供额外的设备信息，这些信息可能会被记录到udev数据库中， 也可能会被用于创建符号链接。</p>
<p>udev处理的所有设备信息都存储在udev数据库中， 并且会发送给可能的设备事件的订阅者。 可以通过 libudev 库访问udev数据库以及设备事件源。</p>
<h2 id="规则文件"><a href="#规则文件" class="headerlink" title="规则文件"></a>规则文件</h2><blockquote>
<p>可以直接看示例，参照示例来匹配规则说明</p>
</blockquote>
<p>规则文件分别位于： 系统规则目录(<code>/usr/lib/udev/rules.d</code>)、 运行时规则目录(<code>/run/udev/rules.d</code>)、 本机规则目录(<code>/etc/udev/rules.d</code>)。 无论位于哪个目录中，所有的规则文件统一按照文件名的字典顺序处理。 对于不同目录下的同名规则文件，仅以优先级最高的目录中的那一个为准。 也就是说3个目录按照a-z的顺序： <code>/etc/</code> 的优先级最高、 <code>/run/</code> 的优先级居中、 <code>/usr/lib/</code> 的优先级最低。 如果系统管理员想要屏蔽 <code>/usr/lib/</code> 目录中的某个规则文件， 那么最佳做法是在 <code>/etc/</code> 目录中创建一个指向 <code>/dev/null</code> 的同名符号链接， 即可彻底屏蔽 <code>/usr/lib/</code> 目录中的同名文件。 注意，规则文件必须以 <code>.rules</code> 作为后缀名，否则将被忽略。</p>
<p>规则文件中以 “<code>#</code>“ 开头的行以及空行将被忽略， 其他不以 “<code>#</code>“ 开头的非空行，每行必须至少包含一个”键-值”对。 “键”有两种类型：匹配与赋值。 如果某条规则的所有匹配键的值都匹配成功，那么就表示此条规则匹配成功， 也就是此条规则中的所有赋值键都会被赋予指定的值。</p>
<p>一条匹配成功的规则可以 重命名一个网络接口、为某个设备文件添加一个软连接、运行一个指定的程序作为事件处理的一部分。</p>
<p>每条规则都是由一系列逗号分隔的”键-值”对组成。 根据操作符的不同，每个键都对应着一个唯一的操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ ls /usr/lib/udev/rules.d</span><br><span class="line">50-firmware.rules		   60-input-id.rules		     60-serial.rules	    73-special-net-names.rules	       80-net-setup-link.rules</span><br><span class="line">50-kdump-tools.rules		   60-persistent-alsa.rules	     64-btrfs.rules	    73-usb-net-by-mac.rules	       85-hdparm.rules</span><br><span class="line">50-udev-default.rules		   60-persistent-input.rules	     69-lvm-metad.rules     75-net-description.rules	       85-hwclock.rules</span><br><span class="line">55-dm.rules			   60-persistent-storage-dm.rules    70-joystick.rules	    75-persistent-net-generator.rules  90-console-setup.rules</span><br><span class="line">56-lvm.rules			   60-persistent-storage.rules	     70-mouse.rules	    75-probe_mtd.rules		       90-rdma-umad.rules</span><br><span class="line">60-block.rules			   60-persistent-storage-tape.rules  70-power-switch.rules  75-rdma-description.rules	       95-dm-notify.rules</span><br><span class="line">60-bridge-network-interface.rules  60-persistent-v4l.rules	     70-touchpad.rules	    78-sound-card.rules		       99-systemd.rules</span><br><span class="line">60-cdrom_id.rules		   60-rdma-ndd.rules		     70-uaccess.rules	    80-debian-compat.rules</span><br><span class="line">60-drm.rules			   60-rdma-persistent-naming.rules   71-seat.rules	    80-drivers.rules</span><br><span class="line">60-evdev.rules			   60-sensor.rules		     73-seat-late.rules     80-ifupdown.rules</span><br></pre></td></tr></table></figure>

<h3 id="匹配-赋值操作符"><a href="#匹配-赋值操作符" class="headerlink" title="匹配/赋值操作符"></a>匹配/赋值操作符</h3><p>匹配</p>
<ul>
<li>“<code>==</code>“：(匹配)”等于”</li>
<li>“<code>!=</code>“：(匹配)”不等于”</li>
</ul>
<p>赋值</p>
<ul>
<li>“<code>=</code>“：(赋值)为键赋予指定的值。 此键之前的值(可能是个列表)将被丢弃。</li>
<li>“<code>+=</code>“：(赋值)在键的现有值列表中增加此处指定的值。</li>
<li>“<code>-=</code>“：(赋值)在键的现有值列表中删除此处指定的值。<strong>- Added in version 217</strong></li>
<li>“<code>:=</code>“：(赋值)为键赋予指定的值，并视为最终值，也就是禁止被继续修改。<strong>- Added in version 247</strong></li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ systemd --version</span><br><span class="line">systemd 247 (247.3-7+deb11u2)</span><br><span class="line">+PAM +AUDIT +SELINUX +IMA +APPARMOR +SMACK +SYSVINIT +UTMP +LIBCRYPTSETUP +GCRYPT +GNUTLS +ACL +XZ +LZ4 +ZSTD +SECCOMP +BLKID +ELFUTILS +KMOD +IDN2 -IDN +PCRE2 default-hierarchy=unified</span><br></pre></td></tr></table></figure>

<h3 id="Values"><a href="#Values" class="headerlink" title="Values"></a>Values</h3><p>值需要用双引号包裹，例如：<code>&quot;string&quot;</code>，如果值需要使用双引号，则使用<code>\&quot;</code>，除此（<code>\&quot;</code>）之外的其他反斜杠后面的字符都不会被还原成其原始的形式。也就是说，<code>&quot;\t\n&quot;</code>会被视为4个字符：反斜杠、小写字母t、反斜杠、小写字母n。</p>
<p>字符串可以以小写字母e作为前缀（<code>e&quot;string\n&quot;</code>）来标记字符串为C风格转义字符串，参见C中的转义序列。例如，<code>e&quot;string\n&quot;</code>会被解析为7个字符：6个小写字母和一个换行符。这对于在内核驱动程序需要特殊字符时是有用的。</p>
<p>请注意，在任何字符串变体中都不允许使用<code>NUL</code>。</p>
<h3 id="Keys"><a href="#Keys" class="headerlink" title="Keys"></a>Keys</h3><p><strong>以下Keys可用于与设备属性进行匹配。其中一些键也可以与sysfs中的父设备属性匹配，而不仅仅是生成事件的设备。如果在单个规则中指定了与父设备匹配的多个键，则所有这些键都必须在同一个父设备上匹配。</strong></p>
<ul>
<li><code>ACTION</code>：匹配事件的动作。例如<code>&quot;add&quot;</code>表示插入一个设备。</li>
<li><code>DEVPATH</code>：匹配设备的路径(也就是该设备在sysfs文件系统下的相对路径)。例如：<code>/dev/sda1</code> 对应的 devpath 是<code>/sys/block/sda/sda1</code>。</li>
<li><code>KERNEL</code>：匹配设备的内核名称。”内核名称”是指设备在sysfs里的名称，也就是默认的设备文件名称，例如”sda”。</li>
<li><code>NAME</code>：匹配网络接口的名称。 仅在先前的规则中已将 NAME 键赋值的前提下，才可将此键用于匹配。</li>
<li><code>SYMLINK</code>：匹配指向节点的符号链接的名称。一旦在先前的规则中设置了SYMLINK键，就可以使用它。可能有多个符号链接；只需要一个匹配。如果操作符是”!=”，则只有在没有匹配到符号链接时，该标记才返回true。</li>
<li><code>SUBSYSTEM</code>：匹配设备所属的子系统。例如”sound”或”net”</li>
<li><code>SUBSYSTEMS</code>：沿着devpath向上搜索匹配的SUBSYSTEM名称。</li>
<li><code>DRIVER</code>：匹配设备的驱动程序名称。 仅在设备事件发生时，此设备确实正好绑定着一个驱动程序情况下，此键才会被设置</li>
<li><code>DRIVERS</code>：沿着devpath向上搜索匹配的DRIVER名称。</li>
<li><code>ATTR{filename}</code>：匹配设备在sysfs中的属性值。属性值中的尾部空白会被忽略，除非指定的值自身就包含尾部空白。大括号中的”文件”是指设备路径(devpath)下的文件。 例如，对于 <code>/dev/sda1</code> 来说，<code>ATTR{size}</code> 的含义其实是指 <code>/sys/block/sda/sda1/size</code> 文件的内容。</li>
<li><code>ATTRS{filename}</code>：沿着devpath向上搜索具有匹配sysfs属性值的设备。如果指定了多个ATTRS匹配，那么所有这些匹配都必须在同一个设备上匹配。</li>
<li><code>SYSCTL{kernel参数}</code>：匹配”内核参数”的值。所谓”内核参数”其实是指 <code>/proc/sys/</code> 中的”内核参数”。例如，可以用 <code>SYSCTL{kernel/hostname}</code> 匹配 <code>/proc/sys/kernel/hostname</code> 的值。<strong>- Added in version 240</strong></li>
<li><code>ENV{key}</code>：匹配设备的属性。可以通过 <code>udevadm info --query=property /dev/sda</code> 命令查看 /dev/sda 的所有属性，例如 “DEVTYPE”, “ID_PATH”, “SYSTEMD_WANTS” 等等。</li>
<li><code>CONST{key}</code>：匹配系统范围的常量。支持的键包括：</li>
</ul>
<pre><code>+ &quot;arch&quot;：系统的架构。有关可能的值，请参阅[systemd.unit(5)](https://man7.org/linux/man-pages/man5/systemd.unit.5.html)中的`ConditionArchitecture=values`。
+ &quot;virt&quot;：系统的虚拟化环境。有关可能的值，请参阅[systemd-detect-virt(1)](https://man7.org/linux/man-pages/man1/systemd-detect-virt.1.html)。
+ &quot;cvm&quot;：系统的保密虚拟化技术。有关可能的值，请参阅[systemd-detect-virt(1)](https://man7.org/linux/man-pages/man1/systemd-detect-virt.1.html)。未知的键将永远不会匹配。</code></pre><ul>
<li><code>TAG</code>：根据设备标签中的一个进行匹配。只要前面的规则中设置了一个TAG键，就可以使用该功能。可能有多个标签；只需要一个匹配。如果运算符是”!=”，则仅当没有标签匹配时，该标记才返回true。</li>
<li><code>TAGS</code>：沿着devpath向上搜索匹配的TAG名称。</li>
<li><code>TEST{八进制模式掩码}</code>：检测指定的文件是否存在。如果有必要，还可以额外指定一个八进制的访问模式掩码。</li>
<li><code>PROGRAM</code>：执行指定的程序并检查返回值， 如果返回值为零，则匹配成功，否则匹配失败。 设备的属性会转化为该程序的环境变量供其使用。 同时该程序的标准输出会被 自动保存在 <code>RESULT</code> 键中。注意，仅可用于执行时间很短的前台程序。 参见 <code>RUN</code></li>
<li><code>RESULT</code>：匹配最近一次 <code>PROGRAM</code> 程序的输出字符串， 必须位于 <code>PROGRAM</code> 之后(但可出现在同一条规则中)。</li>
</ul>
<p><strong>可以在用于匹配的”值”中使用shell风格的通配符， 具体说来就是：</strong></p>
<ul>
<li>“<code>*</code>“：匹配任意数量的字符(包括零个)</li>
<li>“<code>?</code>“：匹配单独一个字符</li>
<li>“<code>[]</code>“：匹配中括号内的任意一个字符。 例如 “<code>tty[SR]</code>“ 可以匹配 “<code>ttyS</code>“ 或 “<code>ttyR</code>“ 。 还可以使用 “<code>-</code>“ 符号表示一个区间。 例如 “<code>[0-9]</code>“ 可以匹配任意数字。 如果在左括号 “<code>[</code>“ 后紧接着一个 “<code>!</code>“ 则表示匹配非括号内的字符。</li>
<li>“<code>|</code>“：用于分隔两个可相互替代的匹配模式(也就是”或”的意思)。 例如 “<code>abc|x*</code>“ 的意思是匹配 “<code>abc</code>“ 或 “<code>x*</code>“</li>
</ul>
<p><strong>下面的keys可用于赋值</strong></p>
<ul>
<li><code>NAME</code>：设置网络接口的名称。参见 <a href="https://man7.org/linux/man-pages/man5/systemd.link.5.html" target="_blank" rel="noopener">systemd.link(5)</a> 以了解设置网络接口名称的高级机制。 实际上，udev 并不能直接修改设备节点的名称， 它只能为设备节点创建额外的符号链接(相当于添加了别名)。</li>
<li><code>SYMLINK</code>：设置指向此设备节点的 软连接名称。</li>
</ul>
<pre><code>+ 软连接的名字中仅允许使用下列字符： &quot;`0-9A-Za-z#+-.:=@_/`&quot; 、有效的UTF-8字符、 &quot;`\x00`&quot; 风格的十六进制编码(实际的文件名并不转码)。 其他字符将被替换为 &quot;`_`&quot; 字符。
+ 只需在多个名称之间使用空格分隔，即可一次指定多个软连接名称。 如果为多个不同的设备指定了相同的软连接， 那么实际的软连接将指向 link\_priority 值最高的设备。 如果 link\_priority 值最高的设备被移除， 那么该软连接将重新指向下一个 link\_priority 值最高的设备，以此类推。 对于未指定 link\_priority 值或者 link\_priority 值相等的设备， 它们之间的顺序是不确定的。
+ 符号连接的名称必须不能与内核的默认名称相同， 否则会得到无法预知的结果。</code></pre><ul>
<li><code>OWNER</code>, <code>GROUP</code>, `MODE：设置设备节点的属主、属组、权限。 会覆盖内置的默认值。</li>
<li><code>SECLABEL{模块}</code>：设置设备节点的Linux安全模块标签。<strong>- Added in version 209</strong></li>
<li><code>ATTR{key}</code>：应写入到事件设备的sysfs属性的数值。</li>
<li><code>SYSCTL{kernel parameter}</code>：应写入到内核参数的数值。<strong>- Added in version 220</strong></li>
<li><code>ENV{key}</code>：设置设备属性值。具有前缀”.”的属性名称既不存储在数据库中，也不导出到事件或外部工具（例如，由PROGRAM匹配键运行）。</li>
<li><code>TAG</code>：将标签附加到设备。用于过滤libudev监视功能的用户的事件，或者用于枚举带有标签的设备组。实现仅在将少量标签附加到设备时才能有效工作。仅应在具有特定设备过滤要求的上下文中使用，而不是作为通用标志。过度使用可能导致事件处理效率低下。</li>
<li><code>RUN{type}</code>：指定在处理事件的所有规则之后要执行的程序。使用”+=”将此调用添加到列表中，使用”=”或”:=”替换列表的任何先前内容。请注意，下面描述的”program”和”builtin”类型共享一个公共列表，因此使用”:=”和”=”清除列表会影响两种类型。<br>type可以是：</li>
</ul>
<pre><code>+ &quot;program&quot;：执行分配值指定的外部程序。如果没有给出绝对路径，则预期程序位于/usr/lib/udev；否则，必须指定绝对路径。如果未指定类型，则此为默认设置。
+ &quot;builtin&quot;：与&quot;program&quot;相同，但使用内置程序之一，而不是外部程序。程序名称和后续参数由空格分隔。可以使用单引号指定带有空格的参数。</code></pre><p>这仅可用于非常短暂的前台任务。长时间运行事件进程可能会阻塞此设备或依赖设备的所有进一步事件。</p>
<p>请注意，在udev规则内部不允许运行访问网络或挂载/卸载文件系统的程序，这是由于systemd-udevd.service上强制执行的默认沙箱。</p>
<p>不允许启动守护程序或其他长时间运行的进程；分叉的进程，无论是否分离，都将在事件处理完成后被无条件终止。为了从udev规则激活长时间运行的进程，提供一个服务单元，并使用SYSTEMD_WANTS设备属性从udev设备中引入它。有关详细信息，请参阅<a href="https://man7.org/linux/man-pages/man5/systemd.device.5.html" target="_blank" rel="noopener">systemd.device(5)</a>。</p>
<ul>
<li><code>LABEL</code>：设置一个可用作 GOTO 跳转目标的标签。</li>
<li><code>GOTO</code>：跳转到下一个匹配的 LABEL 标签所在的规则。</li>
<li><code>IMPORT{type}</code>：将一组变量导入为设备的属性。</li>
<li><code>OPTIONS</code>：规则与设备的选项</li>
</ul>
<pre><code>+ `link_priority=value`：指定创建符号链接时的优先级。 数值越大优先级越高。默认值是&quot;0&quot;。
+ `string_escape=none|replace`：在对设备进行命名时，如何处理设备名字中的非常规字符(比如控制字符与不安全的字符)。 none 表示不做处理，保持原样； replace 表示将这些非常规字符替换为&quot;\_&quot;(下划线)。
+ `static_node=`：将本条规则设定的权限 应用到此选项指定的静态设备节点上。 同时，如果在本规则中指定了标签(tag)， 那么还会在 `/run/udev/static_node-tags/*`tag`*` 目录中创建一个指向该静态设备节点的软连接。 注意，在 systemd-udevd 启动之前， 静态设备节点就已经由 systemd-tmpfiles 创建完成了。 创建静态设备节点时，并不要求存在对应的内核设备， 因为当这些设备节点被访问时，会触发内核模块的自动加载功能。
+ `watch`：使用文件系统的 inotify 功能监视设备节点。 当节点被打开并写入之后又被关闭， 将会触发一个&quot;设备状态已变化&quot;的事件。
+ `nowatch`：禁用针对设备节点的 inotify 监视功能。
+ `db_persist`：在事件设备的 udev 数据库项上设置 粘滞位(sticky bit)。 这样，即使调用了 **udevadm info --cleanup-db** 命令， 设备的属性也依然会保存在数据库中。 在某些情况下(例如 Device Mapper 设备)， 此选项可用于从 initramfs 切换至真实的根文件系统时，依然保持设备的状态。**- Added in version 241**
+ `log_level=level`：允许设置日志级别名称，如&quot;debug&quot;或&quot;info&quot;，或特殊值&quot;reset&quot;。当指定日志级别名称时，最大日志级别将更改为该级别。设置为&quot;reset&quot;时，则撤销先前指定的日志级别。默认情况下，它使用systemd-udevd的主进程的日志级别。此功能对于调试与特定设备相关的事件非常有用。注意，日志级别是在行时应用的
包含此规则进行处理。因此，对于调试，它建议在较早的地方指定，例如00-debug.rules的第一行：`SUBSYSTEM==&quot;net&quot;, OPTIONS=&quot;log_level=debug&quot;`。**- Added in version 248**</code></pre><p><strong><code>NAME</code>, <code>SYMLINK</code>, <code>PROGRAM</code>, <code>OWNER</code>, <code>GROUP</code>, <code>MODE</code>, <code>SECLABEL</code>, <code>RUN</code> 都支持简单的字符串替换。 <code>RUN</code> 的替换发生在 所有规则全部处理完成之后、程序将要执行之前， 因此可以使用由匹配成功的规则所设置的设备属性。 而其他键的替换发生在该键所在规则被处理完成的当时。 可用的替换标记如下：</strong></p>
<ul>
<li><code>$kernel, %k</code>：设备的内核名称</li>
<li><code>$number, %n</code>：设备在内核中的序号。例如，对于 “<code>sda3</code>“ 来说，此值为 “<code>3</code>“</li>
<li><code>$devpath, %p</code>：设备路径(devpath)。也就是该设备在sysfs文件系统下的相对路径。例如，/dev/sda1 对应的设备路径是 /block/sda/sda1 (一般对应着 /sys/block/sda/sda1 目录)。</li>
<li><code>$id, %b</code>：被 <code>SUBSYSTEMS</code>, <code>KERNELS</code>, <code>DRIVERS</code>, <code>ATTRS</code> 成功匹配到的设备的设备名称（The name of the device）</li>
<li><code>$driver</code>：被 <code>SUBSYSTEMS</code>, <code>KERNELS</code>, <code>DRIVERS</code>, <code>ATTRS</code> 成功匹配到的设备的驱动名称（The driver name of the device）</li>
<li><code>$attr{file}, %s{file}</code>：在规则匹配成功时， 设备路径(devpath)下”文件”的内容(用于表示设备的属性)。 如果该设备路径下没有此文件，则从先前 KERNELS, SUBSYSTEMS, DRIVERS, ATTRS 匹配的父设备中提取。如果”文件”是一个软连接， 则一直追踪软连接到最终的实际文件。</li>
<li><code>$env{key}, %E{key}</code>：备的属性值。例如 “DEVTYPE”, “ID_PATH”, “SYSTEMD_WANTS” 等等。[提示]可以通过 udevadm info –query=property /dev/sda 命令查看 /dev/sda 的所有属性。</li>
<li><code>$major, %M</code>：设备的主设备号</li>
<li><code>$minor, %m</code>：设备的次设备号</li>
<li><code>$result, %c</code>：外部程序 PROGRAM 的输出字符串。 可以使用 “%c{N}” 提取第N个子字符串(以空格为分隔符，从”1”开始计数)。 也可以通过 “%c{N+}”(也就是在数字后附加一个 “+”)提取 从第N个子字符串开始一直到结尾的部分。</li>
<li><code>$parent, %P</code>：父设备的节点名称</li>
<li><code>$name</code>：设备的当前名称。如果没有被任何udev规则修改， 那么等于该设备的内核名称。</li>
<li><code>$links</code>：一个空格分隔的软链接名称列表，这些软链接都指向该设备的节点。 该值仅在两种情况下存在：(1)发生”remove”事件；(2)先前的规则已对 SYMLINK 赋值。</li>
<li><code>$root, %r</code>：udev_root 的值</li>
<li><code>$sys, %S</code>：sysfs 文件系统的挂载点</li>
<li><code>$devnode, %N</code>：设备节点的名称(也就是设备文件的名称)</li>
<li><code>%%</code>：”<code>%</code>“ 自身</li>
<li><code>$$</code>：”<code>$</code>“ 自身</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>systemd-udevd.service可以从内核监测网卡状态的改变，根据事件来触发相应的操作。例如我们常用的修改网卡名称规则</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ cat /etc/udev/rules.d/70-persistent-net.rules</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;e8:eb:d3:36:b3:1a&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth0&quot;</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;e8:eb:d3:36:b3:1b&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth1&quot;</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;9c:c2:c4:0e:24:e0&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth2&quot;</span><br><span class="line">SUBSYSTEM==&quot;net&quot;, ACTION==&quot;add&quot;, DRIVERS==&quot;?*&quot;, ATTR&#123;address&#125;==&quot;9c:c2:c4:0e:24:e1&quot;, ATTR&#123;dev_id&#125;==&quot;0x0&quot;, ATTR&#123;type&#125;==&quot;1&quot;, NAME=&quot;eth3&quot;</span><br></pre></td></tr></table></figure>

<p>关键点</p>
<ul>
<li>/etc/udev/rules.d 优先级最高</li>
<li>所有带<code>==</code>都是匹配，最后的<code>=</code>才是赋值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">shell复制代码$ cat  /usr/lib/udev/rules.d/75-net-description.rules</span><br><span class="line"># do not edit this file, it will be overwritten on update</span><br><span class="line"></span><br><span class="line">ACTION==&quot;remove&quot;, GOTO=&quot;net_end&quot;</span><br><span class="line">SUBSYSTEM!=&quot;net&quot;, GOTO=&quot;net_end&quot;</span><br><span class="line"></span><br><span class="line">IMPORT&#123;builtin&#125;=&quot;net_id&quot;</span><br><span class="line"></span><br><span class="line">SUBSYSTEMS==&quot;usb&quot;, IMPORT&#123;builtin&#125;=&quot;usb_id&quot;, IMPORT&#123;builtin&#125;=&quot;hwdb --subsystem=usb&quot;</span><br><span class="line">SUBSYSTEMS==&quot;usb&quot;, GOTO=&quot;net_end&quot;</span><br><span class="line"></span><br><span class="line">SUBSYSTEMS==&quot;pci&quot;, ENV&#123;ID_BUS&#125;=&quot;pci&quot;, ENV&#123;ID_VENDOR_ID&#125;=&quot;$attr&#123;vendor&#125;&quot;, ENV&#123;ID_MODEL_ID&#125;=&quot;$attr&#123;device&#125;&quot;</span><br><span class="line">SUBSYSTEMS==&quot;pci&quot;, IMPORT&#123;builtin&#125;=&quot;hwdb --subsystem=pci&quot;</span><br><span class="line"></span><br><span class="line">LABEL=&quot;net_end&quot;</span><br></pre></td></tr></table></figure>

<p>关键点</p>
<ul>
<li>ACTION为remove、非net就跳转到net_end，啥都不做</li>
<li>IMPORT{builtin}=”net_id”：执行net_id载入变量</li>
<li>如果子系统是USB，则导入内置的”usb_id”和”hwdb –subsystem=usb”规则，并跳转到标签net_end。</li>
<li>如果子系统是PCI，则设置环境变量”ID_BUS”为”pci”，并设置”ID_VENDOR_ID”和”ID_MODEL_ID”为设备的供应商ID和设备ID。同时执行内置的”hwdb –subsystem=pci”规则。</li>
</ul>
<hr>
<p>参考：<a href="https://man7.org/linux/man-pages/man7/udev.7.html" target="_blank" rel="noopener">man7.org/linux/man-p…</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359138355181043739" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>强烈推荐，好用的时序图开源插件PlantUML！</title>
    <url>/7359138355181600795.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>每开发一个新需求，做系统设计时，<code>系统时序图</code>一般都少不了，你用的画图软件有没有给你带来一些问题呢？</p>
<h3 id="1、比如不美观，图形线条不好对齐，比如下面这个："><a href="#1、比如不美观，图形线条不好对齐，比如下面这个：" class="headerlink" title="1、比如不美观，图形线条不好对齐，比如下面这个："></a>1、比如<code>不美观</code>，图形线条<code>不好对齐</code>，比如下面这个：</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8bb57eb1ecbc58ca81fc478fd83ec6b68822f23ee25f13a1d8013f7a2398c642" alt="image.png"></p>
<p>这个图没有完全对齐，而且是我比较费劲去尽量对齐了，线条都需要自己一根根对齐，比较麻烦，画图的时间都用在对齐线条上去了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3cf69374ca4e88af7c33f07f153de51c7df5b53b2628bcc7afdf166c331a9607" alt="image.png"></p>
<h3 id="2、逻辑判断选择不好表示，比如if-else，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择"><a href="#2、逻辑判断选择不好表示，比如if-else，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择" class="headerlink" title="2、逻辑判断选择不好表示，比如if/else，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择"></a>2、<code>逻辑判断</code>选择不好表示，比如<code>if/else</code>，下面是redis两种复制模式，应该是根据配置决定的，但是没法有逻辑选择</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c61aa2f688e704ef531858561eafd8ad6f4e1e2cba59284c81ea5b5912ef84f6" alt="image.png"></p>
<h3 id="3、没有循环处理"><a href="#3、没有循环处理" class="headerlink" title="3、没有循环处理"></a>3、没有<code>循环处理</code></h3><h3 id="4、想给文字或者某个核心流程加上颜色"><a href="#4、想给文字或者某个核心流程加上颜色" class="headerlink" title="4、想给文字或者某个核心流程加上颜色"></a>4、想给文字或者某个核心流程加上<code>颜色</code></h3><h3 id="5、时序上的流程需要手动去编号，也很麻烦，比如下面的图"><a href="#5、时序上的流程需要手动去编号，也很麻烦，比如下面的图" class="headerlink" title="5、时序上的流程需要手动去编号，也很麻烦，比如下面的图"></a>5、时序上的流程需要手动去<code>编号</code>，也很麻烦，比如下面的图</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c9aa6dd65b0648080ff465db00313dfdffc3a738ae158b879e5995ddeb123522" alt="image.png"></p>
<p>今天要介绍的这个插件软件，上面的问题都可以解决。如果你也遇到了上面的问题，强烈推荐你收藏用起来，看下面画的OpenFeign负载均衡的核心时序图。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3d9e9af646e1a525b738fef4fca64f59cf0862c30c30d2213ec9d0adb9cc4aaa" alt="image.png"></p>
<h2 id="PlantUML介绍与优势"><a href="#PlantUML介绍与优势" class="headerlink" title="PlantUML介绍与优势"></a>PlantUML介绍与优势</h2><p>PlantUML是一个开源项目，官网：<code>https://plantuml.com/sequence-diagram</code></p>
<p>它既支持常用的uml图，也支持非uml图，比如思维导图，我最常用的就是<code>时序图</code>。</p>
<p>我觉得它有如下优点：</p>
<h3 id="1、语法简单，快速上手，可视化制作"><a href="#1、语法简单，快速上手，可视化制作" class="headerlink" title="1、语法简单，快速上手，可视化制作"></a>1、<code>语法简单</code>，快速上手，可视化制作</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c1985465333c43245a753847c046a0f56c7d60cae4b8e33dca94adb672739589" alt="image.png"></p>
<h3 id="2、图形线条关联是自动关联的，不需要手动关联"><a href="#2、图形线条关联是自动关联的，不需要手动关联" class="headerlink" title="2、图形线条关联是自动关联的，不需要手动关联"></a>2、图形线条关联是<code>自动关联</code>的，不需要手动关联</h3><h3 id="3、支持循环，if-else等逻辑表示"><a href="#3、支持循环，if-else等逻辑表示" class="headerlink" title="3、支持循环，if/else等逻辑表示"></a>3、支持<code>循环</code>，<code>if/else</code>等逻辑表示</h3><h3 id="4、制作的图形更美观和和谐"><a href="#4、制作的图形更美观和和谐" class="headerlink" title="4、制作的图形更美观和和谐"></a>4、制作的图形<code>更美观和和谐</code></h3><h3 id="5、修改比较容易，有些制作完成导出成图片了不好改，PlatUML可以改"><a href="#5、修改比较容易，有些制作完成导出成图片了不好改，PlatUML可以改" class="headerlink" title="5、修改比较容易，有些制作完成导出成图片了不好改，PlatUML可以改"></a>5、<code>修改比较容易</code>，有些制作完成导出成图片了不好改，PlatUML可以改</h3><h2 id="PlantUML案例"><a href="#PlantUML案例" class="headerlink" title="PlantUML案例"></a>PlantUML案例</h2><h3 id="1、声明参与者"><a href="#1、声明参与者" class="headerlink" title="1、声明参与者"></a>1、声明参与者</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/84a0a471dfd1f0fdb8a009541314b2aabece4bd881a8425c9419eaf328df21af" alt="image.png"></p>
<h3 id="2、发送消息和返回消息"><a href="#2、发送消息和返回消息" class="headerlink" title="2、发送消息和返回消息"></a>2、发送消息和返回消息</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ffc9ec0c4f59420cf174f3f46edb5c8e5a70e445cf3276821ce8de4d6397990" alt="image.png"></p>
<h3 id="3、if-else表示"><a href="#3、if-else表示" class="headerlink" title="3、if/else表示"></a>3、if/else表示</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d40f91bd4a21d04c3397fd97aa7426dfa8634c110286dfa9791203789e47a600" alt="image.png"></p>
<h3 id="4、关键流程加颜色"><a href="#4、关键流程加颜色" class="headerlink" title="4、关键流程加颜色"></a>4、关键流程加颜色</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1fa4659a9d2bed7477a556021a7e170ad069efa2f6909979588fe8a3888f4663" alt="image.png"></p>
<h3 id="5、自动编号"><a href="#5、自动编号" class="headerlink" title="5、自动编号"></a>5、自动编号</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1cf275d56920bd439a28fa5db2c5c8fa0306b75649b436414227e67383b9ba30" alt="image.png"></p>
<p>具体的画图代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">uml复制代码autonumber</span><br><span class="line">actor 普通用户 as person</span><br><span class="line">participant 用户服务 as user</span><br><span class="line">participant 订单服务 as order</span><br><span class="line">participant 支付服务 as pay</span><br><span class="line"></span><br><span class="line">person -&gt; user:登录系统</span><br><span class="line">person&lt;--user: 登录结果</span><br><span class="line"></span><br><span class="line">alt 登录失败</span><br><span class="line">person&lt;--user: 提示失败，不可下单</span><br><span class="line">loop 用户重试</span><br><span class="line">person -&gt; user:登录系统</span><br><span class="line">person&lt;--user: 登录结果</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">else #Gold 登录成功</span><br><span class="line">person-&gt;order:下单</span><br><span class="line">person&lt;--order:下单成功</span><br><span class="line">person-&gt;pay:支付</span><br><span class="line">person&lt;--pay:支付成功</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">@enduml</span><br></pre></td></tr></table></figure>

<h2 id="PlantUML总结"><a href="#PlantUML总结" class="headerlink" title="PlantUML总结"></a>PlantUML总结</h2><p>使用 PlantUML 创建序列图非常简单。这种易用性主要归功于其语法的用户友好性，既直观又易记。</p>
<p>你如果是一个<code>新入职场</code>的朋友，掌握这个工具也能画出很<code>美观的时序图</code>，是不是会很开心呢？刚工作时候，我是比较困惑的？没有找到好的画图软件，直到知道了PlantUML,还是很好用的，不仅可以在<code>intellij idea</code>里面使用，<code>confluence</code>里面也有插件支持的，在公司办公工作中也用的到。</p>
<p>这个文章如果对你有帮助，收藏关注我们，一起学习技术干货，学习好用的工具。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d38ca2b705abf16f0c0885097dc4a5024f7c8a24068d140b97628406dbac4ec6" alt="image.png"></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359138355181600795" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,程序员,前端</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析 1 内存分配思想引入</title>
    <url>/6925217843055165454.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
</blockquote>
<ol>
<li><h1 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h1></li>
</ol>
<p>本期内容比较硬核，非常全面，涉及到了设计思想到实现原理以及源码，并且还给出了相应的日志以及监控方式，如果有不清楚或者有疑问的地方，欢迎留言。</p>
<p>其中涉及到的设计思想主要为个人理解，实现原理以及源码解析也是个人整理，如果有不准确的地方，非常欢迎指正！提前感谢~~</p>
<ol start="2">
<li><h1 id="分配内存实现思路"><a href="#分配内存实现思路" class="headerlink" title="分配内存实现思路"></a>分配内存实现思路</h1></li>
</ol>
<p>我们经常会 new 一个对象，这个对象是需要占用空间的，第一次 new 一个对象占用的空间如 <strong>图00</strong> 所示，</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3b5daddb2bca239b59812f7757056c90b7a9acbd59a5a09b54df65c5c291dec6" alt="MetaSpace"></p>
<p>我们这里先只关心堆内部的存储，元空间中的存储，我们会在另一个系列详细讨论。堆内部的存储包括对象头，对象体以及内存对齐填充，那么这块空间是如何分配的呢？</p>
<p>首先，对象所需的内存，在对象的类被解析加载进入元空间之后，就可以在分配内存<strong>创建前计算出来</strong>。假设现在我们自己来设计堆内存分配，一种最简单的实现方式就是线性分配，也被称为撞针分配（bump-the-pointer）。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/315504e700a3e6e74fa0b6dfb95b0eca5012ff9e887e1da32e126307e6a8e154" alt="image"></p>
<p>每次需要分配内存时，先计算出需要的内存大小，然后 <strong>CAS 更新</strong>如 <strong>图01</strong> 中所示的内存分配指针，标记分配的内存。但是内存一般不是这么整齐的，可能有些内存在分配有些内存就被释放回收了。所以一般不会只靠撞针分配。一种思路是在撞针分配的基础上，加上一个 FreeList。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3c6570392d0f749ed50a3911b015af86d68b470fa67d5a31ca4557c9c24d717f" alt="image"></p>
<p>简单的实现是将释放的对象内存加入 FreeList，下次分配对象的时候，<strong>优先从 FreeList 中寻找合适的内存大小进行分配</strong>，之后再在主内存中撞针分配。</p>
<p>这样虽然一定程度上解决了问题，但是目前大多数应用是多线程的，所以内存分配是多线程的，都从主内存中分配，CAS 更新重试过于频繁导致效率低下。目前的应用，一般根据不同业务区分了不同的线程池，在这种情况下，<strong>一般每个线程分配内存的特性是比较稳定的</strong>。这里的比较稳定指的是，每次分配对象的大小，每轮 GC 分配区间内的分配对象的个数以及总大小。所以，我们可以考虑每个线程分配内存后，就将这块内存保留起来，用于下次分配，这样就不用每次从主内存中分配了。如果能估算每轮 GC 内每个线程使用的内存大小，则可以提前分配好内存给线程，这样就更能提高分配效率。这种内存分配的实现方式，在 JVM 中就是 TLAB （Thread Local Allocate Buffer）。</p>
<ol start="3">
<li><h1 id="JVM-对象堆内存分配流程简述"><a href="#JVM-对象堆内存分配流程简述" class="headerlink" title="JVM 对象堆内存分配流程简述"></a>JVM 对象堆内存分配流程简述</h1></li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c9ac09ceb37d45f3af8bd3841dbe28a5838551389b1d393fdd2c6e643c151b8f" alt="image"></p>
<p>我们这里不考虑<strong>栈上分配</strong>，这些会在 JIT 的章节详细分析，我们这里<strong>考虑的是无法栈上分配需要共享的对象</strong>。</p>
<p>对于 HotSpot JVM 实现，所有的 GC 算法的实现都是一种对于堆内存的管理，也就是都实现了一种堆的抽象，它们都实现了接口 CollectedHeap。当分配一个对象堆内存空间时，在 CollectedHeap 上首先都会检查是否启用了 TLAB，如果启用了，则会尝试 TLAB 分配；如果当前线程的 TLAB 大小足够，那么从线程当前的 TLAB 中分配；如果不够，但是当前 TLAB 剩余空间小于<strong>最大浪费空间限制（这是一个动态的值，我们后面会详细分析）</strong>，则从堆上（一般是 Eden 区） 重新申请一个新的 TLAB 进行分配。否则，直接在 TLAB 外进行分配。TLAB 外的分配策略，不同的 GC 算法不同。例如G1：</p>
<ul>
<li>如果是 Humongous 对象（对象在超过 Region 一半大小的时候），直接在 Humongous 区域分配（老年代的连续区域）。</li>
<li>根据 Mutator 状况在当前分配下标的 Region 内分配</li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925217843055165454" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）｜</title>
    <url>/6925217498723778568.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol>
<li><h1 id="观前提醒"><a href="#观前提醒" class="headerlink" title="观前提醒"></a>观前提醒</h1></li>
</ol>
<p>本期内容比较硬核，非常全面，涉及到了设计思想到实现原理以及源码，并且还给出了相应的日志以及监控方式，如果有不清楚或者有疑问的地方，欢迎留言。</p>
<p>其中涉及到的设计思想主要为个人理解，实现原理以及源码解析也是个人整理，如果有不准确的地方，非常欢迎指正！提前感谢~~</p>
<ol start="2">
<li><h1 id="分配内存实现思路"><a href="#分配内存实现思路" class="headerlink" title="分配内存实现思路"></a>分配内存实现思路</h1></li>
</ol>
<p>我们经常会 new 一个对象，这个对象是需要占用空间的，第一次 new 一个对象占用的空间如 <strong>图00</strong> 所示，</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/90537c083e3f58c79bc90ee3c3bb96d5d50a844667f33f518da500d16e38ecb7" alt="MetaSpace"></p>
<p>我们这里先只关心堆内部的存储，元空间中的存储，我们会在另一个系列详细讨论。堆内部的存储包括对象头，对象体以及内存对齐填充，那么这块空间是如何分配的呢？</p>
<p>首先，对象所需的内存，在对象的类被解析加载进入元空间之后，就可以在分配内存<strong>创建前计算出来</strong>。假设现在我们自己来设计堆内存分配，一种最简单的实现方式就是线性分配，也被称为撞针分配（bump-the-pointer）。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/15b78a9b7e183b83349ad18986016b7fbd2d58cdbe947cf2d76b74e94669013e" alt="image"></p>
<p>每次需要分配内存时，先计算出需要的内存大小，然后 <strong>CAS 更新</strong>如 <strong>图01</strong> 中所示的内存分配指针，标记分配的内存。但是内存一般不是这么整齐的，可能有些内存在分配有些内存就被释放回收了。所以一般不会只靠撞针分配。一种思路是在撞针分配的基础上，加上一个 FreeList。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e21d7a2f89372097ece3922b6faf76cc11313ff4252cc9213b219fcb4f8864f5" alt="image"></p>
<p>简单的实现是将释放的对象内存加入 FreeList，下次分配对象的时候，<strong>优先从 FreeList 中寻找合适的内存大小进行分配</strong>，之后再在主内存中撞针分配。</p>
<p>这样虽然一定程度上解决了问题，但是目前大多数应用是多线程的，所以内存分配是多线程的，都从主内存中分配，CAS 更新重试过于频繁导致效率低下。目前的应用，一般根据不同业务区分了不同的线程池，在这种情况下，<strong>一般每个线程分配内存的特性是比较稳定的</strong>。这里的比较稳定指的是，每次分配对象的大小，每轮 GC 分配区间内的分配对象的个数以及总大小。所以，我们可以考虑每个线程分配内存后，就将这块内存保留起来，用于下次分配，这样就不用每次从主内存中分配了。如果能估算每轮 GC 内每个线程使用的内存大小，则可以提前分配好内存给线程，这样就更能提高分配效率。这种内存分配的实现方式，在 JVM 中就是 TLAB （Thread Local Allocate Buffer）。</p>
<ol start="3">
<li><h1 id="JVM-对象堆内存分配流程简述"><a href="#JVM-对象堆内存分配流程简述" class="headerlink" title="JVM 对象堆内存分配流程简述"></a>JVM 对象堆内存分配流程简述</h1></li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/acc2e0ebedf8267f4caca4474b60f533e38db592195da4618ba2e215878a49ec" alt="image"></p>
<p>我们这里不考虑<strong>栈上分配</strong>，这些会在 JIT 的章节详细分析，我们这里<strong>考虑的是无法栈上分配需要共享的对象</strong>。</p>
<p>对于 HotSpot JVM 实现，所有的 GC 算法的实现都是一种对于堆内存的管理，也就是都实现了一种堆的抽象，它们都实现了接口 CollectedHeap。当分配一个对象堆内存空间时，在 CollectedHeap 上首先都会检查是否启用了 TLAB，如果启用了，则会尝试 TLAB 分配；如果当前线程的 TLAB 大小足够，那么从线程当前的 TLAB 中分配；如果不够，但是当前 TLAB 剩余空间小于<strong>最大浪费空间限制（这是一个动态的值，我们后面会详细分析）</strong>，则从堆上（一般是 Eden 区） 重新申请一个新的 TLAB 进行分配。否则，直接在 TLAB 外进行分配。TLAB 外的分配策略，不同的 GC 算法不同。例如G1：</p>
<ul>
<li>如果是 Humongous 对象（对象在超过 Region 一半大小的时候），直接在 Humongous 区域分配（老年代的连续区域）。</li>
<li>根据 Mutator 状况在当前分配下标的 Region 内分配</li>
</ul>
<ol start="4">
<li><h1 id="TLAB-的生命周期"><a href="#TLAB-的生命周期" class="headerlink" title="TLAB 的生命周期"></a>TLAB 的生命周期</h1></li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/44df3516065bb48d2b9626ace86286a67525275475aa8b119f9fcae5dd625ea0" alt="image"></p>
<p>TLAB 是线程私有的，<strong>线程初始化的时候</strong>，会创建并初始化 TLAB。同时，在 <strong>GC 扫描对象发生之后，线程第一次尝试分配对象的时候</strong>，也会创建并初始化 TLAB。 TLAB 生命周期停止（TLAB 声明周期停止不代表内存被回收，只是代表这个 TLAB 不再被这个线程私有管理）在：</p>
<ul>
<li>当前 TLAB 不够分配，并且剩余空间小于<strong>最大浪费空间限制</strong>，那么这个 TLAB 会被退回 Eden，重新申请一个新的</li>
<li>发生 GC 的时候，TLAB 被回收。</li>
</ul>
<ol start="5">
<li><h1 id="TLAB-要解决的问题以及带来的问题与解决方案的思考"><a href="#TLAB-要解决的问题以及带来的问题与解决方案的思考" class="headerlink" title="TLAB 要解决的问题以及带来的问题与解决方案的思考"></a>TLAB 要解决的问题以及带来的问题与解决方案的思考</h1></li>
</ol>
<p>TLAB 要解决的问题很明显，<strong>尽量避免从堆上直接分配内存从而避免频繁的锁争用。</strong></p>
<p>引入 TLAB 之后，TLAB 的设计上，也有很多值得考虑的问题。</p>
<h2 id="5-1-引入-TLAB-后，会有内存孔隙问题，还可能影响-GC-扫描性能"><a href="#5-1-引入-TLAB-后，会有内存孔隙问题，还可能影响-GC-扫描性能" class="headerlink" title="5.1. 引入 TLAB 后，会有内存孔隙问题，还可能影响 GC 扫描性能"></a>5.1. 引入 TLAB 后，会有内存孔隙问题，还可能影响 GC 扫描性能</h2><p>出现孔隙的情况：</p>
<ul>
<li>当前 TLAB 不够分配时，如果剩余空间小于<strong>最大浪费空间限制</strong>，那么这个 TLAB 会被退回 Eden，重新申请一个新的。这个剩余空间就会成为孔隙。</li>
<li>当发生 GC 的时候，TLAB 没有用完，没有分配的内存也会成为孔隙。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ae95647e70f44906b154fd7d696d1fe414a04fccb77e026020f0dbefd99b0488" alt="image"></p>
<p>如果不管这些孔隙，由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，那么会影响 GC 扫描效率。所以 TLAB 回归 Eden 的时候，<strong>会将剩余可用的空间用一个 dummy object 填充满</strong>。如果填充<strong>已经确认会被回收的对象</strong>，也就是 dummy object， GC 会直接标记之后跳过这块内存，增加扫描效率。但是同时，由于需要填充这个 dummy object，所以需要<strong>预留出这个对象的对象头的空间</strong>。</p>
<h2 id="5-2-某个线程在一轮-GC-内分配的内存并不稳定"><a href="#5-2-某个线程在一轮-GC-内分配的内存并不稳定" class="headerlink" title="5.2. 某个线程在一轮 GC 内分配的内存并不稳定"></a>5.2. 某个线程在一轮 GC 内分配的内存并不稳定</h2><p>如果我们能提前知道在这一轮内每个线程会分配多少内存，那么我们可以直接提前分配好。但是，这简直是痴人说梦。每个线程在每一轮 GC 的分配情况可能都是不一样的：</p>
<ul>
<li><strong>不同的线程业务场景不同导致分配对象大小不同</strong>。我们一般会按照业务区分不同的线程池，做好线程池隔离。对于用户请求，每次分配的对象可能比较小。对于后台分析请求，每次分配的对象相对大一些。</li>
<li><strong>不同时间段内线程压力并不均匀</strong>。业务是有高峰有低谷的，高峰时间段内肯定分配对象更多。</li>
<li><strong>同一时间段同一线程池内的线程的业务压力也不一定不能做到很均匀</strong>。很可能只有几个线程很忙，其他线程很闲。</li>
</ul>
<p>所以，综合考虑以上情况，我们应该这么实现 TLAB：</p>
<ul>
<li>不能一下子就给一个线程申请一个比较大的 TLAB，而是考虑<strong>这个线程 TLAB 分配满之后再申请新的</strong>，这样更加灵活。</li>
<li><strong>每次申请 TLAB 的大小是变化</strong>的，并不是固定的。</li>
<li><strong>每次申请 TLAB 的大小需要考虑当前 GC 轮次内会分配对象的线程的个数期望</strong></li>
<li><strong>每次申请 TLAB 的大小需要考虑所有线程期望 TLAB 分配满重新申请新的 TLAB 次数</strong></li>
</ul>
<ol start="6">
<li><h1 id="JVM-中的期望计算-EMA"><a href="#JVM-中的期望计算-EMA" class="headerlink" title="JVM 中的期望计算 EMA"></a>JVM 中的期望计算 EMA</h1></li>
</ol>
<p>在上面提到的 TLAB 大小设计的时候，我们经常提到期望。这个期望是根据历史数据计算得出的，也就是<strong>每次输入采样值，根据历史采样值得出最新的期望值</strong>。不仅 TLAB 用到了这种期望计算，GC 和 JIT 等等 JVM 机制中都用到了。这里我们来看一种 TLAB 中经常用到的 <strong>EMA（Exponential Moving Average 指数平均数）</strong> 算法：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b5ce31805e30009aa4510e0257ae26642f80b33b5bf7007bc55b65ad7a8f7ad1" alt="image"></p>
<p>EMA 算法的核心在于设置合适的<strong>最小权重</strong>，我们假设一个场景：首先采样100个 100（算法中的前 100 个是为了排除不稳定的干扰，我们这里直接忽略前 100 个采样），之后采样 50 个 2，最后采样 50 个 200，对于不同的<strong>最小权重</strong>，来看一下变化曲线。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e653f4900c3c4200fd5be2a212f85fb38dbf1350a19b8e98e11f355e87afbdc9" alt="image"></p>
<p>可以看出，<strong>最小权重越大</strong>，变化得越快，受<strong>历史数据影响越小</strong>。根据应用设置合适的<strong>最小权重</strong>，可以让你的期望更加理想。</p>
<p>这块对应的源代码：<a href="https://github.com/openjdk/jdk/blob/jdk-17+7/src/hotspot/share/gc/shared/gcUtil.cpp" target="_blank" rel="noopener"><code>gcUtil.hpp</code></a> 的 <code>AdaptiveWeightedAverage</code> 类。</p>
<ol start="7">
<li><h1 id="TLAB-相关的-JVM-参数"><a href="#TLAB-相关的-JVM-参数" class="headerlink" title="TLAB 相关的 JVM 参数"></a>TLAB 相关的 JVM 参数</h1></li>
</ol>
<blockquote>
<p>这里仅仅是列出来，并附上简介，看不懂没关系，之后会有详细分析，帮助你理解每一个参数。等你理解后，这个小章节就是你的工具书啦~~ 以下参数以及默认值基于 <strong>OpenJDK 17</strong></p>
</blockquote>
<h2 id="7-1-TLABStats（已过期）"><a href="#7-1-TLABStats（已过期）" class="headerlink" title="7.1. TLABStats（已过期）"></a>7.1. TLABStats（已过期）</h2><p>从 Java 12 开始已过期，目前已经没有相关的逻辑了。之前是用于 TLAB 统计数据从而更好地伸缩 TLAB 但是性能消耗相对较大，但是现在主要通过 EMA 计算了。</p>
<h2 id="7-2-UseTLAB"><a href="#7-2-UseTLAB" class="headerlink" title="7.2. UseTLAB"></a>7.2. UseTLAB</h2><p><strong>说明</strong>：是否启用 TLAB，默认是启用的。</p>
<p><strong>默认</strong>：true</p>
<p><strong>举例</strong>：如果想关闭：<code>-XX:-UseTLAB</code></p>
<h2 id="7-3-ZeroTLAB"><a href="#7-3-ZeroTLAB" class="headerlink" title="7.3. ZeroTLAB"></a>7.3. ZeroTLAB</h2><p><strong>说明</strong>：是否将新创建的 TLAB 内的所有字节归零。我们创建一个类的时候，类的 field 是有默认值的，例如 boolean 是 false，int 是 0 等等，实现的方式就是对分配好的内存空间赋 0。设置 ZeroTLAB 为 true <strong>代表在 TLAB 申请好的时候就赋 0</strong>，否则会在分配对象并初始化的时候赋 0.讲道理，<strong>由于 TLAB 分配的时候会涉及到 Allocation Prefetch 优化 CPU 缓存，在 TLAB 分配好之后立刻更新赋 0 对于 CPU 缓存应该是更友好的</strong>，并且，如果 TLAB 没有用满，填充的 dummy object 其实依然是 0 数组，相当于大部分不用改。这么看来，开启应该更好。但是ZeroTLAB 默认还是不开启的。</p>
<p><strong>默认</strong>：false</p>
<p><strong>举例</strong>：<code>-XX:+ZeroTLAB</code></p>
<h2 id="7-4-ResizeTLAB"><a href="#7-4-ResizeTLAB" class="headerlink" title="7.4. ResizeTLAB"></a>7.4. ResizeTLAB</h2><p><strong>说明</strong>：TLAB 是否是可变的，默认为是，也就是会根据线程历史分配数据相关 EMA 计算出每次期望 TLAB 大小并以这个大小为准申请 TLAB。</p>
<p><strong>默认</strong>：true</p>
<p><strong>举例</strong>：如果想关闭：<code>-XX:-ResizeTLAB</code></p>
<h2 id="7-5-TLABSize"><a href="#7-5-TLABSize" class="headerlink" title="7.5. TLABSize"></a>7.5. TLABSize</h2><p><strong>说明</strong>：初始 TLAB 大小。单位是字节</p>
<p><strong>默认</strong>：0， 0 就是不主动设置 TLAB 初始大小，而是通过 JVM 自己计算每一个线程的初始大小</p>
<p><strong>举例</strong>：<code>-XX:TLABSize=65536</code></p>
<h2 id="7-6-MinTLABSize"><a href="#7-6-MinTLABSize" class="headerlink" title="7.6. MinTLABSize"></a>7.6. MinTLABSize</h2><p><strong>说明</strong>：最小 TLAB 大小。单位是字节</p>
<p><strong>默认</strong>：2048</p>
<p><strong>举例</strong>：<code>-XX:TLABSize=4096</code></p>
<h2 id="7-7-TLABAllocationWeight"><a href="#7-7-TLABAllocationWeight" class="headerlink" title="7.7. TLABAllocationWeight"></a>7.7. TLABAllocationWeight</h2><p><strong>说明</strong>： TLAB 初始大小计算和线程数量有关，但是线程是动态创建销毁的。所以需要基于历史线程个数推测接下来的线程个数来计算 TLAB 大小。一般 JVM 内像这种预测函数都采用了 EMA 。<strong>这个参数就是 图06 中的最小权重</strong>，权重越高，最近的数据占比影响越大。TLAB 重新计算大小是根据分配比例，分配比例也是采用了 EMA 算法，最小权重也是 TLABAllocationWeight</p>
<p><strong>默认</strong>：35</p>
<p><strong>举例</strong>：<code>-XX:TLABAllocationWeight=70</code></p>
<h2 id="7-8-TLABWasteTargetPercent"><a href="#7-8-TLABWasteTargetPercent" class="headerlink" title="7.8. TLABWasteTargetPercent"></a>7.8. TLABWasteTargetPercent</h2><p><strong>说明</strong>：TLAB 的大小计算涉及到了 Eden 区的大小以及可以浪费的比率。<strong>TLAB 浪费</strong>指的是上面提到的重新申请新的 TLAB 的时候老的 TLAB 没有分配的空间。这个参数其实就是 TLAB 浪费占用 Eden 的百分比，这个参数的作用会在接下来的原理说明内详细说明</p>
<p><strong>默认</strong>：1</p>
<p><strong>举例</strong>：<code>-XX:TLABWasteTargetPercent=10</code></p>
<h2 id="7-9-TLABRefillWasteFraction"><a href="#7-9-TLABRefillWasteFraction" class="headerlink" title="7.9. TLABRefillWasteFraction"></a>7.9. TLABRefillWasteFraction</h2><p><strong>说明</strong>： 初始<strong>最大浪费空间限制</strong>计算参数，初始<strong>最大浪费空间限制</strong> = 当前期望 TLAB 大小 / TLABRefillWasteFraction</p>
<p><strong>默认</strong>：64</p>
<p><strong>举例</strong>：<code>-XX:TLABRefillWasteFraction=32</code></p>
<h2 id="7-10-TLABWasteIncrement"><a href="#7-10-TLABWasteIncrement" class="headerlink" title="7.10. TLABWasteIncrement"></a>7.10. TLABWasteIncrement</h2><p><strong>说明</strong>： <strong>最大浪费空间限制并不是不变的</strong>，在发生 TLAB 缓慢分配的时候（也就是当前 TLAB 空间不足以分配的时候），会增加最大浪费空间限制。这个参数就是 TLAB 缓慢分配时允许的 TLAB 浪费增量。单位不是字节，而是 <code>MarkWord</code> 个数，也就是 Java 堆的内存最小单元，64 位虚拟机的情况下，<code>MarkWord</code> 大小为 8 字节。</p>
<p><strong>默认</strong>：4</p>
<p><strong>举例</strong>：<code>-XX:TLABWasteIncrement=4</code></p>
<h1 id="8-TLAB-基本流程"><a href="#8-TLAB-基本流程" class="headerlink" title="8.TLAB 基本流程"></a>8.TLAB 基本流程</h1><h2 id="8-0-如何设计每个线程的-TLAB-大小"><a href="#8-0-如何设计每个线程的-TLAB-大小" class="headerlink" title="8.0. 如何设计每个线程的 TLAB 大小"></a>8.0. 如何设计每个线程的 TLAB 大小</h2><p>之前我们提到了引入 TLAB 要面临的问题以及解决方式，根据这些我们可以这么设计 TLAB。</p>
<p>首先，TLAB 的初始大小，应该和每个 GC 内需要对象分配的线程个数相关。但是，要分配的线程个数并不一定是稳定的，可能这个时间段线程数多，下个阶段线程数就不那么多了，所以，<strong>需要用 EMA 的算法采集每个 GC 内需要对象分配的线程个数来计算这个个数期望</strong>。</p>
<p>接着，我们最理想的情况下，是每个 GC 内，所有用来分配对象的内存都处于对应线程的 TLAB 中。每个 GC 内用来分配对象的内存从 JVM 设计上来讲，其实就是 Eden 区大小。在 <strong>最理想的情况</strong>下，最好只有<strong>Eden 区满了的时候才会 GC</strong>，不会有其他原因导致的 GC，这样是最高效的情况。Eden 区被用光，如果全都是 TLAB 内分配，也就是 <strong>Eden 区被所有线程的 TLAB 占满了</strong>，这样分配是最快的。</p>
<p>然后，每轮 GC 分配内存的线程个数以及大小是不一定的，如果一下子分配一大块会造成浪费，如果太小则会频繁从 Eden 申请 TLAB，降低效率。这个大小比较难以控制，但是我们可以限制<strong>每个线程究竟在一轮 GC 内，最多从 Eden 申请多少次 TLAB</strong>，这样对于用户来说更好控制。</p>
<p>最后，每个线程分配的内存大小，在每轮 GC 并不一定稳定，只用初始大小来指导之后的 TLAB 大小，显然不够。我们换个思路，每个线程分配的内存和历史有一定关系因此我们可以从历史分配中推测，所以<strong>每个线程也需要采用 EMA 的算法采集这个线程每次 GC 分配的内存</strong>，用于指导下次期望的 TLAB 的大小。</p>
<p>综上所述，我们可以得出这样一个<strong>近似的 TLAB 计算公式</strong>：</p>
<p>每个线程 TLAB 初始大小 = <code>Eden区大小</code> / (<code>线程单个 GC 轮次内最多从 Eden 申请多少次 TLAB</code> * <code>当前 GC 分配线程个数 EMA</code>)</p>
<p>GC 后，重新计算 TLAB 大小 = <code>Eden区大小</code> / (<code>线程单个 GC 轮次内最多从 Eden 申请多少次 TLAB</code> * <code>当前 GC 分配线程个数 EMA</code>)</p>
<p>接下来，我们来详细分析 TLAB 的整个生命周期的每个流程。</p>
<h2 id="8-1-TLAB-初始化"><a href="#8-1-TLAB-初始化" class="headerlink" title="8.1. TLAB 初始化"></a>8.1. TLAB 初始化</h2><p><strong>线程初始化的时候</strong>，如果 JVM 启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则会初始化 TLAB，在发生对象分配时，会根据<strong>期望大小</strong>申请 TLAB 内存。同时，在 <strong>GC 扫描对象发生之后，线程第一次尝试分配对象的时候</strong>，也会重新申请 TLAB 内存。我们先只关心初始化，初始化的流程图如 <strong>图08</strong> 所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fc7ce1ad1bc1292f3ed944e2c03d8b84065f4f700cb0b7beb7d3ce429ca39b00" alt="image"></p>
<p>初始化时候会计算 TLAB 初始<strong>期望大小</strong>。这涉及到了 <strong>TLAB 大小的限制</strong>：</p>
<ul>
<li><strong>TLAB 的最小大小</strong>：通过<code>MinTLABSize</code>指定</li>
<li><strong>TLAB 的最大大小</strong>：不同的 GC 中不同，<strong>G1 GC 中为大对象（humongous object）大小</strong>，也就是 G1 region 大小的一半。因为开头提到过，在 G1 GC 中，大对象不能在 TLAB 分配，而是老年代。<strong>ZGC 中为页大小的 8 分之一</strong>，类似的在大部分情况下 <strong>Shenandoah GC 也是每个 Region 大小的 8 分之一</strong>。他们都是期望至少有 8 分之 7 的区域是不用退回的减少选择 Cset 的时候的扫描复杂度。对于<strong>其他的 GC，则是 int 数组的最大大小</strong>，这个和之前提到的<strong>填充 dummy object 有关</strong>，后面会提到详细流程。</li>
</ul>
<p><strong>之后的流程里面，无论何时，TLAB 的大小都会在这个 TLAB 的最小大小 到 TLAB 的最大大小 的范围内，为了避免啰嗦，我们不会再强调这个限制<del>~</del>！！！</strong> <strong>之后的流程里面，无论何时，TLAB 的大小都会在这个 TLAB 的最小大小 到 TLAB 的最大大小 的范围内，为了避免啰嗦，我们不会再强调这个限制<del>~</del>！！！</strong> <strong>之后的流程里面，无论何时，TLAB 的大小都会在这个 TLAB 的最小大小 到 TLAB 的最大大小 的范围内，为了避免啰嗦，我们不会再强调这个限制<del>~</del>！！！</strong> 重要的事情说三遍~</p>
<p><strong>TLAB 期望大小（desired size）</strong> 在初始化的时候会计算 TLAB 期望大小，之后再 GC 等操作回收掉 TLAB 需要重计算这个期望大小。根据这个期望大小，TLAB 在申请空间的时候每次申请都会以这个期望大小作为基准的空间作为 TLAB 分配空间。</p>
<h3 id="8-1-1-TLAB-初始期望大小计算"><a href="#8-1-1-TLAB-初始期望大小计算" class="headerlink" title="8.1.1. TLAB 初始期望大小计算"></a>8.1.1. TLAB 初始期望大小计算</h3><p>如 <strong>图08</strong> 所示，如果指定了 <strong>TLABSize</strong>，就用这个大小作为初始<strong>期望大小</strong>。如果没有指定，则按照如下的公式进行计算：</p>
<p><code>堆给TLAB的空间总大小</code>/(<code>当前有效分配线程个数期望</code>*<code>重填次数配置</code>)</p>
<ol>
<li><strong>堆给 TLAB 的空间总大小</strong>：堆上能有多少空间分配给 TLAB，不同的 GC 算法不一样，但是<strong>大多数 GC 算法的实现都是 Eden 区大小</strong>，例如：<ol>
<li>传统的已经弃用的 Parallel Scanvage 中，就是 Eden 区大小。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp" target="_blank" rel="noopener">parallelScavengeHeap.cpp</a></li>
<li>默认的G1 GC 中是 （YoungList 区域个数减去 Survivor 区域个数） * 区域大小，其实就是 Eden 区大小。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener">g1CollectedHeap.cpp</a></li>
<li>ZGC 中是 Page 剩余空间大小，Page 类似于 Eden 区，是大部分对象分配的区域。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/z/zHeap.cpp" target="_blank" rel="noopener">zHeap.cpp</a></li>
<li>Shenandoah GC 中是 FreeSet 的大小，也是类似于 Eden 的概念。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp" target="_blank" rel="noopener">shenandoahHeap.cpp</a></li>
</ol>
</li>
<li><strong>当前有效分配线程个数期望</strong>：这是一个全局 EMA，EMA 是什么之前已经说明了，是一种计算期望的方式。有效分配线程个数 EMA 的最小权重是 TLABAllocationWeight。有效分配线程个数 EMA 在有线程进行第一次有效对象分配的时候进行采集，在 TLAB 初始化的时候读取这个值计算 TLAB 期望大小。</li>
<li><strong>TLAB 重填次数配置（refills time）</strong>：根据 TLABWasteTargetPercent 计算的次数，公式为。TLABWasteTargetPercent 的意义其实是限制<strong>最大浪费空间限制</strong>，为何重填次数与之相关后面会详细分析。</li>
</ol>
<h3 id="8-1-2-TLAB-初始分配比例计算"><a href="#8-1-2-TLAB-初始分配比例计算" class="headerlink" title="8.1.2. TLAB 初始分配比例计算"></a>8.1.2. TLAB 初始分配比例计算</h3><p>如 <strong>图08</strong> 所示，接下来会计算TLAB 初始分配比例。</p>
<p>线程私有<strong>分配比例 EMA</strong>：与<strong>有效分配线程个数 EMA</strong>对应，<strong>有效分配线程个数 EMA</strong>是对于全局来说，每个线程应该占用多大的 TLAB 的描述，而<strong>分配比例 EMA</strong> 相当于对于当前线程应该占用的总 TLAB 空间的大小的一种动态控制。</p>
<p>初始化的时候，分配比例其实就是等于 <code>1/当前有效分配线程个数</code>。<strong>图08</strong> 的公式，代入之前的计算 TLAB 期望大小的公式，消参简化之后就是<code>1/当前有效分配线程个数</code>。这个值作为初始值，采集如线程私有的<strong>分配比例 EMA</strong>。</p>
<h3 id="8-1-3-清零线程私有统计数据"><a href="#8-1-3-清零线程私有统计数据" class="headerlink" title="8.1.3. 清零线程私有统计数据"></a>8.1.3. 清零线程私有统计数据</h3><p>这些采集数据会用于之后的当前线程的分配比例的计算与采集，从而影响之后的当前线程 TLAB 期望大小。</p>
<h2 id="8-2-TLAB-分配"><a href="#8-2-TLAB-分配" class="headerlink" title="8.2. TLAB 分配"></a>8.2. TLAB 分配</h2><p>TLAB 分配流程如 <strong>图09</strong> 所示。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/67b492051502434bbe04ba496cc2ef0e16f4438fbd1d9d7177b99bb66789bb80" alt="image"></p>
<h3 id="8-2-1-从线程当前-TLAB-分配"><a href="#8-2-1-从线程当前-TLAB-分配" class="headerlink" title="8.2.1. 从线程当前 TLAB 分配"></a>8.2.1. 从线程当前 TLAB 分配</h3><p>如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则首先从线程当前 TLAB 分配内存，如果分配成功则返回，否则根据当前 TLAB 剩余空间与当前<strong>最大浪费空间限制</strong>大小进行不同的分配策略。在下一个流程，就会提到这个限制究竟是什么。</p>
<h3 id="8-2-2-重新申请-TLAB-分配"><a href="#8-2-2-重新申请-TLAB-分配" class="headerlink" title="8.2.2. 重新申请 TLAB 分配"></a>8.2.2. 重新申请 TLAB 分配</h3><p>如果当前 TLAB 剩余空间大于当前<strong>最大浪费空间限制</strong>(根据 <strong>图08</strong> 的流程，我们知道这个初始值为 <strong>期望大小/TLABRefillWasteFraction</strong>)，直接在堆上分配。否则，重新申请一个 TLAB 分配。 为什么需要最大浪费空间呢？</p>
<p>当重新分配一个 TLAB 的时候，原有的 TLAB 可能还有空间剩余。原有的 TLAB 被退回堆之前，需要填充好 dummy object。由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，如果填充已经确认会被回收的对象，也就是 dummy object， <strong>GC 会直接标记之后跳过这块内存，增加扫描效率</strong>。反正这块内存已经属于 TLAB，其他线程在下次扫描结束前是无法使用的。这个 dummy object 就是 int 数组。为了一定能有填充 dummy object 的空间，<strong>一般 TLAB 大小都会预留一个 dummy object 的 header 的空间</strong>，也是一个 <code>int[]</code> 的 header，所以 TLAB 的大小不能超过int 数组的最大大小，否则无法用 dummy object 填满未使用的空间。</p>
<p>但是，填充 dummy 也造成了空间的浪费，这种浪费不能太多，所以通过<strong>最大浪费空间限制</strong>来限制这种浪费。</p>
<p>新的 TLAB 大小，取如下<strong>两个值中较小</strong>的那个：</p>
<ul>
<li>当前堆剩余给 TLAB 可分配的空间，大部分 GC 的实现其实就是对应的 Eden 区剩余大小：<ul>
<li>传统的已经弃用的 Parallel Scanvage 中，就是 Eden 区剩余大小。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp" target="_blank" rel="noopener">parallelScavengeHeap.cpp</a></li>
<li>默认的G1 GC 中是当前 Region 中剩余大小，其实就是将 Eden 分区了。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener">g1CollectedHeap.cpp</a></li>
<li>ZGC 中是 Page 剩余空间大小，Page 类似于 Eden 区，是大部分对象分配的区域。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/z/zHeap.cpp" target="_blank" rel="noopener">zHeap.cpp</a></li>
<li>Shenandoah GC 中是 FreeSet 的剩余大小，也是类似于 Eden 的概念。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp" target="_blank" rel="noopener">shenandoahHeap.cpp</a></li>
</ul>
</li>
<li><strong>TLAB 期望大小</strong> + 当前需要分配的空间大小</li>
</ul>
<p>当分配出来 TLAB 之后，根据 ZeroTLAB 配置，决定是否将每个字节赋 0。在创建对象的时候，本来也要对每个字段赋初始值，大部分字段初始值都是 0，并且，在 TLAB 返还到堆时，剩余空间填充的也是 int[] 数组，里面都是 0。所以其实可以提前填充好。并且，TLAB 刚分配出来的时候，赋 0 也能利用好 Allocation prefetch 的机制适应 CPU 缓存行（Allocation prefetch 的机制会在另一个系列说明），所以可以通过打开 ZeroTLAB 来在分配 TLAB 空间之后立刻赋 0。</p>
<h3 id="8-2-3-直接从堆上分配"><a href="#8-2-3-直接从堆上分配" class="headerlink" title="8.2.3. 直接从堆上分配"></a>8.2.3. 直接从堆上分配</h3><p>直接从堆上分配是最慢的分配方式。一种情况就是，如果当前 TLAB 剩余空间大于当前<strong>最大浪费空间限制</strong>，直接在堆上分配。并且，还会增加当前最大浪费空间限制，<strong>每次有这样的分配就会增加 TLABWasteIncrement 的大小</strong>，这样在一定次数的直接堆上分配之后，当前最大浪费空间限制一直增大会导致当前 TLAB 剩余空间小于当前<strong>最大浪费空间限制</strong>，从而申请新的 TLAB 进行分配。</p>
<h2 id="8-3-GC-时-TLAB-回收与重计算期望大小"><a href="#8-3-GC-时-TLAB-回收与重计算期望大小" class="headerlink" title="8.3. GC 时 TLAB 回收与重计算期望大小"></a>8.3. GC 时 TLAB 回收与重计算期望大小</h2><p>相关流程如 <strong>图10</strong> 所示，在 GC 前与 GC 后，都会对 TLAB 做一些操作。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/01dbc52d1e86db52b2985770129b833b76de5a6ecd1936800c663217f81be0a6" alt="image"></p>
<h3 id="8-3-1-GC-前的操作"><a href="#8-3-1-GC-前的操作" class="headerlink" title="8.3.1. GC 前的操作"></a>8.3.1. GC 前的操作</h3><p>在 GC 前，如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则需要将所有线程的 TLAB 填充 dummy Object 退还给堆，并计算并采样一些东西用于以后的 TLAB 大小计算。</p>
<p>首先为了保证本次计算具有参考意义，需要先判断是否堆上 TLAB 空间被用了一半以上，假设不足，那么认为本轮 GC 的数据没有参考意义。如果被用了一半以上，那么计算新的分配比例，<strong>新的分配比例 = 线程本轮 GC 分配空间的大小 / 堆上所有线程 TLAB 使用的空间</strong>，这么计算主要因为分配比例描述的是当前线程占用堆上所有给 TLAB 的空间的比例，每个线程不一样，通过这个比例动态控制不同业务线程的 TLAB 大小。</p>
<p><strong>线程本轮 GC 分配空间的大小</strong>包含 TLAB 中分配的和 TLAB 外分配的，从 <strong>图8、图9、图10</strong> 流程图中对于<strong>线程记录中的线程分配空间大小</strong>的记录就能看出，读取出线程分配空间大小减去上一轮 GC 结束时线程分配空间大小就是<strong>线程本轮 GC 分配空间的大小</strong>。</p>
<p>最后，将当前 TLAB 填充好 dummy object 之后，返还给堆。</p>
<h3 id="8-3-2-GC-后的操作"><a href="#8-3-2-GC-后的操作" class="headerlink" title="8.3.2. GC 后的操作"></a>8.3.2. GC 后的操作</h3><p>如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），以及 TLAB 大小可变（默认是启用的， 可以通过 <code>-XX:-ResizeTLAB</code> 关闭），那么在 GC 后会重新计算每个线程 TLAB 的期望大小，<strong>新的期望大小 = 堆给TLAB的空间总大小 * 当前分配比例 EMA / 重填次数配置</strong>。然后会<strong>重置最大浪费空间限制</strong>，为当前 <strong>期望大小 / TLABRefillWasteFraction</strong>。</p>
<ol start="9">
<li><h1 id="OpenJDK-HotSpot-TLAB-相关源代码分析"><a href="#OpenJDK-HotSpot-TLAB-相关源代码分析" class="headerlink" title="OpenJDK HotSpot TLAB 相关源代码分析"></a>OpenJDK HotSpot TLAB 相关源代码分析</h1></li>
</ol>
<blockquote>
<p>如果这里看的比较吃力，可以直接看第 10 章，热门 Q&amp;A，里面有很多大家常问的问题</p>
</blockquote>
<h2 id="9-1-TLAB-类构成"><a href="#9-1-TLAB-类构成" class="headerlink" title="9.1. TLAB 类构成"></a>9.1. TLAB 类构成</h2><p>线程初始化的时候，如果 JVM 启用了 TLAB（默认是启用的， 可以通过 -XX:-UseTLAB 关闭），则会初始化 TLAB。</p>
<p>TLAB 包括如下几个 field （HeapWord* 可以理解为堆中的内存地址）： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码//静态全局变量</span><br><span class="line">static size_t   _max_size;                          // 所有 TLAB 的最大大小</span><br><span class="line">  static int      _reserve_for_allocation_prefetch;   // CPU 缓存优化 Allocation Prefetch 的保留空间，这里先不用关心</span><br><span class="line">  static unsigned _target_refills;                    //每个 GC 周期内期望的重填次数</span><br><span class="line"></span><br><span class="line">//以下是 TLAB 的主要构成 field</span><br><span class="line">HeapWord* _start;                              // TLAB 起始地址，表示堆内存地址都用 HeapWord* </span><br><span class="line">HeapWord* _top;                                // 上次分配的内存地址</span><br><span class="line">HeapWord* _end;                                // TLAB 结束地址</span><br><span class="line">size_t    _desired_size;                       // TLAB 大小 包括保留空间，表示内存大小都需要通过 size_t 类型，也就是实际字节数除以 HeapWordSize 的值</span><br><span class="line">size_t    _refill_waste_limit;                 // TLAB最大浪费空间，剩余空间不足分配浪费空间限制。在TLAB剩余空间不足的时候，根据这个值决定分配策略，如果浪费空间大于这个值则直接在 Eden 区分配，如果小于这个值则将当前 TLAB 放回 Eden 区管理并从 Eden 申请新的 TLAB 进行分配。 </span><br><span class="line">AdaptiveWeightedAverage _allocation_fraction;  // 当前 TLAB 分配比例 EMA</span><br><span class="line"></span><br><span class="line">//以下是我们这里不用太关心的 field</span><br><span class="line">HeapWord* _allocation_end;                    // TLAB 真正可以用来分配内存的结束地址，这个是 _end 结束地址排除保留空间（预留给 dummy object 的对象头空间）</span><br><span class="line">HeapWord* _pf_top;                            // Allocation Prefetch CPU 缓存优化机制相关需要的参数，这里先不用考虑</span><br><span class="line">size_t    _allocated_before_last_gc;          // 这个用于计算 图10 中的线程本轮 GC 分配空间的大小，记录上次 GC 时，线程分配的空间大小</span><br><span class="line">unsigned  _number_of_refills;                 // 线程分配内存数据采集相关，TLAB 剩余空间不足分配次数</span><br><span class="line">unsigned  _fast_refill_waste;                 // 线程分配内存数据采集相关，TLAB 快速分配浪费，快速分配就是直接在 TLAB 分配，这个在现在 JVM 中已经用不到了</span><br><span class="line">unsigned  _slow_refill_waste;                 // 线程分配内存数据采集相关，TLAB 慢速分配浪费，慢速分配就是重填一个 TLAB 分配</span><br><span class="line">unsigned  _gc_waste;                          // 线程分配内存数据采集相关，gc浪费</span><br><span class="line">unsigned  _slow_allocations;                  // 线程分配内存数据采集相关，TLAB 慢速分配计数 </span><br><span class="line">size_t    _allocated_size;                    // 分配的内存大小</span><br><span class="line">size_t    _bytes_since_last_sample_point;     // JVM TI 采集指标相关 field，这里不用关心</span><br></pre></td></tr></table></figure>

<h2 id="9-2-TLAB-初始化"><a href="#9-2-TLAB-初始化" class="headerlink" title="9.2. TLAB 初始化"></a>9.2. TLAB 初始化</h2><p>首先是 JVM 启动的时候，全局 TLAB 需要初始化： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::startup_initialization() &#123;</span><br><span class="line">  //初始化，也就是归零统计数据</span><br><span class="line">  ThreadLocalAllocStats::initialize();</span><br><span class="line"></span><br><span class="line">  // 假设平均下来，GC 扫描的时候，每个线程当前的 TLAB 都有一半的内存被浪费，这个每个线程使用内存的浪费的百分比率（也就是 TLABWasteTargetPercent），也就是等于（注意，仅最新的那个 TLAB 有浪费，之前 refill 退回的假设是没有浪费的）：1/2 * (每个 epoch 内每个线程期望 refill 次数) * 100</span><br><span class="line">  //那么每个 epoch 内每个线程 refill 次数配置就等于 50 / TLABWasteTargetPercent， 默认也就是 50 次。</span><br><span class="line">  _target_refills = 100 / (2 * TLABWasteTargetPercent);</span><br><span class="line">  // 但是初始的 _target_refills 需要设置最多不超过 2 次来减少 VM 初始化时候 GC 的可能性</span><br><span class="line">  _target_refills = MAX2(_target_refills, 2U);</span><br><span class="line"></span><br><span class="line">//如果 C2 JIT 编译存在并启用，则保留 CPU 缓存优化 Allocation Prefetch 空间，这个这里先不用关心，会在别的章节讲述</span><br><span class="line">#ifdef COMPILER2</span><br><span class="line">  if (is_server_compilation_mode_vm()) &#123;</span><br><span class="line">    int lines =  MAX2(AllocatePrefetchLines, AllocateInstancePrefetchLines) + 2;</span><br><span class="line">    _reserve_for_allocation_prefetch = (AllocatePrefetchDistance + AllocatePrefetchStepSize * lines) /</span><br><span class="line">                                       (int)HeapWordSize;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  // 初始化 main 线程的 TLAB</span><br><span class="line">  guarantee(Thread::current()-&gt;is_Java_thread(), &quot;tlab initialization thread not Java thread&quot;);</span><br><span class="line">  Thread::current()-&gt;tlab().initialize();</span><br><span class="line">  log_develop_trace(gc, tlab)(&quot;TLAB min: &quot; SIZE_FORMAT &quot; initial: &quot; SIZE_FORMAT &quot; max: &quot; SIZE_FORMAT,</span><br><span class="line">                               min_size(), Thread::current()-&gt;tlab().initial_desired_size(), max_size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程维护自己的 TLAB，同时每个线程的 TLAB 大小不一。TLAB 的大小主要由 Eden 的大小，线程数量，还有线程的对象分配速率决定。 在 Java 线程开始运行时，会先分配 TLAB： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/runtime/thread.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/runtime/thread.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码void JavaThread::run() &#123;</span><br><span class="line">  // initialize thread-local alloc buffer related fields</span><br><span class="line">  this-&gt;initialize_tlab();</span><br><span class="line">  //剩余代码忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配 TLAB 其实就是调用 ThreadLocalAllocBuffer 的 initialize 方法。 <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/runtime/thread.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/runtime/thread.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void initialize_tlab() &#123;</span><br><span class="line">    //如果没有通过 -XX:-UseTLAB 禁用 TLAB，则初始化TLAB</span><br><span class="line">    if (UseTLAB) &#123;</span><br><span class="line">      tlab().initialize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Thread-Local Allocation Buffer (TLAB) support</span><br><span class="line">ThreadLocalAllocBuffer&amp; tlab()                 &#123;</span><br><span class="line">  return _tlab; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalAllocBuffer _tlab;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalAllocBuffer 的 initialize 方法初始化 TLAB 的上面提到的我们要关心的各种 field：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::initialize() &#123;</span><br><span class="line">  //设置初始指针，由于还没有从 Eden 分配内存，所以这里都设置为 NULL</span><br><span class="line">  initialize(NULL,                    // start</span><br><span class="line">             NULL,                    // top</span><br><span class="line">             NULL);                   // end</span><br><span class="line">  //计算初始期望大小，并设置</span><br><span class="line">  set_desired_size(initial_desired_size());</span><br><span class="line">  //所有 TLAB 总大小，不同的 GC 实现有不同的 TLAB 容量， 一般是 Eden 区大小</span><br><span class="line">  //例如 G1 GC，就是等于 (_policy-&gt;young_list_target_length() - _survivor.length()) * HeapRegion::GrainBytes，可以理解为年轻代减去Survivor区，也就是Eden区</span><br><span class="line">  size_t capacity = Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize;</span><br><span class="line">  //计算这个线程的 TLAB 期望占用所有 TLAB 总体大小比例</span><br><span class="line">  //TLAB 期望占用大小也就是这个 TLAB 大小乘以期望 refill 的次数</span><br><span class="line">  float alloc_frac = desired_size() * target_refills() / (float) capacity;</span><br><span class="line">  //记录下来，用于计算 EMA</span><br><span class="line">  _allocation_fraction.sample(alloc_frac);</span><br><span class="line">  //计算初始 refill 最大浪费空间，并设置</span><br><span class="line">  //如前面原理部分所述，初始大小就是 TLAB 的大小（_desired_size） / TLABRefillWasteFraction</span><br><span class="line">  set_refill_waste_limit(initial_refill_waste_limit());</span><br><span class="line">  //重置统计</span><br><span class="line">  reset_statistics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-1-初始期望大小是如何计算的呢？"><a href="#9-2-1-初始期望大小是如何计算的呢？" class="headerlink" title="9.2.1. 初始期望大小是如何计算的呢？"></a>9.2.1. 初始期望大小是如何计算的呢？</h3><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//计算初始大小</span><br><span class="line">size_t ThreadLocalAllocBuffer::initial_desired_size() &#123;</span><br><span class="line">  size_t init_sz = 0;</span><br><span class="line">  //如果通过 -XX:TLABSize 设置了 TLAB 大小，则用这个值作为初始期望大小</span><br><span class="line">  //表示堆内存占用大小都需要用占用几个 HeapWord 表示，所以用TLABSize / HeapWordSize</span><br><span class="line">  if (TLABSize &gt; 0) &#123;</span><br><span class="line">    init_sz = TLABSize / HeapWordSize;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //获取当前epoch内线程数量期望，这个如之前所述通过 EMA 预测</span><br><span class="line">    unsigned int nof_threads = ThreadLocalAllocStats::allocating_threads_avg();</span><br><span class="line">    //不同的 GC 实现有不同的 TLAB 容量，Universe::heap()-&gt;tlab_capacity(thread()) 一般是 Eden 区大小</span><br><span class="line">    //例如 G1 GC，就是等于 (_policy-&gt;young_list_target_length() - _survivor.length()) * HeapRegion::GrainBytes，可以理解为年轻代减去Survivor区，也就是Eden区</span><br><span class="line">    //整体大小等于 Eden区大小/(当前 epcoh 内会分配对象期望线程个数 * 每个 epoch 内每个线程 refill 次数配置)</span><br><span class="line">    //target_refills已经在 JVM 初始化所有 TLAB 全局配置的时候初始化好了</span><br><span class="line">    init_sz  = (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize) /</span><br><span class="line">                      (nof_threads * target_refills());</span><br><span class="line">    //考虑对象对齐，得出最后的大小</span><br><span class="line">    init_sz = align_object_size(init_sz);</span><br><span class="line">  &#125;</span><br><span class="line">  //保持大小在  min_size() 还有 max_size() 之间</span><br><span class="line">  //min_size主要由 MinTLABSize 决定</span><br><span class="line">  init_sz = MIN2(MAX2(init_sz, min_size()), max_size());</span><br><span class="line">  return init_sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最小大小由 MinTLABSize 决定，需要表示为 HeapWordSize，并且考虑对象对齐，最后的 alignment_reserve 是 dummy object 填充的对象头大小（这里先不考虑 JVM 的 CPU 缓存 prematch，我们会在其他章节详细分析）。</span><br><span class="line">static size_t min_size()                       &#123; </span><br><span class="line">    return align_object_size(MinTLABSize / HeapWordSize) + alignment_reserve(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-2-TLAB-最大大小是怎样决定的呢？"><a href="#9-2-2-TLAB-最大大小是怎样决定的呢？" class="headerlink" title="9.2.2. TLAB 最大大小是怎样决定的呢？"></a>9.2.2. TLAB 最大大小是怎样决定的呢？</h3><p>不同的 GC 方式，有不同的方式：</p>
<p><strong>G1 GC 中为大对象（humongous object）大小</strong>，也就是 G1 region 大小的一半：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码// For G1 TLABs should not contain humongous objects, so the maximum TLAB size</span><br><span class="line">// must be equal to the humongous object limit.</span><br><span class="line">size_t G1CollectedHeap::max_tlab_size() const &#123;</span><br><span class="line">  return align_down(_humongous_object_threshold_in_words, MinObjAlignment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ZGC 中为页大小的 8 分之一</strong>，类似的在大部分情况下 S<strong>henandoah GC 也是每个 Region 大小的 8 分之一</strong>。他们都是期望至少有 8 分之 7 的区域是不用退回的减少选择 Cset 的时候的扫描复杂度: <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/z/zHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/z/zHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码const size_t      ZObjectSizeLimitSmall         = ZPageSizeSmall / 8;</span><br></pre></td></tr></table></figure>

<p>对于<strong>其他的 GC，则是 int 数组的最大大小</strong>，这个和为了填充 dummy object 表示 TLAB 的空区域有关。这个原因之前已经说明了。</p>
<h2 id="9-3-TLAB-分配内存"><a href="#9-3-TLAB-分配内存" class="headerlink" title="9.3. TLAB 分配内存"></a>9.3. TLAB 分配内存</h2><p>当 new 一个对象时，需要调用<code>instanceOop InstanceKlass::allocate_instance(TRAPS)</code> <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/oops/instanceKlass.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/oops/instanceKlass.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码instanceOop InstanceKlass::allocate_instance(TRAPS) &#123;</span><br><span class="line">  bool has_finalizer_flag = has_finalizer(); // Query before possible GC</span><br><span class="line">  int size = size_helper();  // Query before forming handle.</span><br><span class="line"></span><br><span class="line">  instanceOop i;</span><br><span class="line"></span><br><span class="line">  i = (instanceOop)Universe::heap()-&gt;obj_allocate(this, size, CHECK_NULL);</span><br><span class="line">  if (has_finalizer_flag &amp;&amp; !RegisterFinalizersAtInit) &#123;</span><br><span class="line">    i = register_finalizer(i, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心就是<code>heap()-&gt;obj_allocate(this, size, CHECK_NULL)</code>从堆上面分配内存： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/collectedHeap.inline.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/collectedHeap.inline.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码inline oop CollectedHeap::obj_allocate(Klass* klass, int size, TRAPS) &#123;</span><br><span class="line">  ObjAllocator allocator(klass, size, THREAD);</span><br><span class="line">  return allocator.allocate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用全局的 <code>ObjAllocator</code> 实现进行对象内存分配： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/memAllocator.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/memAllocator.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码oop MemAllocator::allocate() const &#123;</span><br><span class="line">  oop obj = NULL;</span><br><span class="line">  &#123;</span><br><span class="line">    Allocation allocation(*this, &amp;obj);</span><br><span class="line">    //分配堆内存，继续看下面一个方法</span><br><span class="line">    HeapWord* mem = mem_allocate(allocation);</span><br><span class="line">    if (mem != NULL) &#123;</span><br><span class="line">      obj = initialize(mem);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // The unhandled oop detector will poison local variable obj,</span><br><span class="line">      // so reset it to NULL if mem is NULL.</span><br><span class="line">      obj = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">HeapWord* MemAllocator::mem_allocate(Allocation&amp; allocation) const &#123;</span><br><span class="line">  //如果使用了 TLAB，则从 TLAB 分配，分配代码继续看下面一个方法</span><br><span class="line">  if (UseTLAB) &#123;</span><br><span class="line">    HeapWord* result = allocate_inside_tlab(allocation);</span><br><span class="line">    if (result != NULL) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //否则直接从 tlab 外分配</span><br><span class="line">  return allocate_outside_tlab(allocation);</span><br><span class="line">&#125;</span><br><span class="line">HeapWord* MemAllocator::allocate_inside_tlab(Allocation&amp; allocation) const &#123;</span><br><span class="line">  assert(UseTLAB, &quot;should use UseTLAB&quot;);</span><br><span class="line"></span><br><span class="line">  //从当前线程的 TLAB 分配内存，TLAB 快分配</span><br><span class="line">  HeapWord* mem = _thread-&gt;tlab().allocate(_word_size);</span><br><span class="line">  //如果没有分配失败则返回</span><br><span class="line">  if (mem != NULL) &#123;</span><br><span class="line">    return mem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //如果分配失败则走 TLAB 慢分配，需要 refill 或者直接从 Eden 分配</span><br><span class="line">  return allocate_inside_tlab_slow(allocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-1-TLAB-快分配"><a href="#9-3-1-TLAB-快分配" class="headerlink" title="9.3.1. TLAB 快分配"></a>9.3.1. TLAB 快分配</h3><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码inline HeapWord* ThreadLocalAllocBuffer::allocate(size_t size) &#123;</span><br><span class="line">  //验证各个内存指针有效，也就是 _top 在 _start 和 _end 范围内</span><br><span class="line">  invariants();</span><br><span class="line">  HeapWord* obj = top();</span><br><span class="line">  //如果空间足够，则分配内存</span><br><span class="line">  if (pointer_delta(end(), obj) &gt;= size) &#123;</span><br><span class="line">    set_top(obj + size);</span><br><span class="line">    invariants();</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-2-TLAB-慢分配"><a href="#9-3-2-TLAB-慢分配" class="headerlink" title="9.3.2. TLAB 慢分配"></a>9.3.2. TLAB 慢分配</h3><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/memAllocator.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/memAllocator.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation&amp; allocation) const &#123;</span><br><span class="line">  HeapWord* mem = NULL;</span><br><span class="line">  ThreadLocalAllocBuffer&amp; tlab = _thread-&gt;tlab();</span><br><span class="line"></span><br><span class="line">  // 如果 TLAB 剩余空间大于 最大浪费空间，则记录并让最大浪费空间递增</span><br><span class="line">  if (tlab.free() &gt; tlab.refill_waste_limit()) &#123;</span><br><span class="line">    tlab.record_slow_allocation(_word_size);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //重新计算 TLAB 大小</span><br><span class="line">  size_t new_tlab_size = tlab.compute_size(_word_size);</span><br><span class="line">  //TLAB 放回 Eden 区</span><br><span class="line">  tlab.retire_before_allocation();</span><br><span class="line">  </span><br><span class="line">  if (new_tlab_size == 0) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算最小大小</span><br><span class="line">  size_t min_tlab_size = ThreadLocalAllocBuffer::compute_min_size(_word_size);</span><br><span class="line">  //分配新的 TLAB 空间，并在里面分配对象</span><br><span class="line">  mem = Universe::heap()-&gt;allocate_new_tlab(min_tlab_size, new_tlab_size, &amp;allocation._allocated_tlab_size);</span><br><span class="line">  if (mem == NULL) &#123;</span><br><span class="line">    assert(allocation._allocated_tlab_size == 0,</span><br><span class="line">           &quot;Allocation failed, but actual size was updated. min: &quot; SIZE_FORMAT</span><br><span class="line">           &quot;, desired: &quot; SIZE_FORMAT &quot;, actual: &quot; SIZE_FORMAT,</span><br><span class="line">           min_tlab_size, new_tlab_size, allocation._allocated_tlab_size);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(allocation._allocated_tlab_size != 0, &quot;Allocation succeeded but actual size not updated. mem at: &quot;</span><br><span class="line">         PTR_FORMAT &quot; min: &quot; SIZE_FORMAT &quot;, desired: &quot; SIZE_FORMAT,</span><br><span class="line">         p2i(mem), min_tlab_size, new_tlab_size);</span><br><span class="line">  //如果启用了 ZeroTLAB 这个 JVM 参数，则将对象所有字段置零值</span><br><span class="line">  if (ZeroTLAB) &#123;</span><br><span class="line">    // ..and clear it.</span><br><span class="line">    Copy::zero_to_words(mem, allocation._allocated_tlab_size);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // ...and zap just allocated object.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //设置新的 TLAB 空间为当前线程的 TLAB</span><br><span class="line">  tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);</span><br><span class="line">  //返回分配的对象内存地址</span><br><span class="line">  return mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-1-TLAB最大浪费空间"><a href="#9-3-2-1-TLAB最大浪费空间" class="headerlink" title="9.3.2.1 TLAB最大浪费空间"></a>9.3.2.1 TLAB最大浪费空间</h4><p>TLAB最大浪费空间 <code>_refill_waste_limit</code> 初始值为 TLAB 大小除以 TLABRefillWasteFraction：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码size_t initial_refill_waste_limit()            &#123; return desired_size() / TLABRefillWasteFraction; &#125;</span><br></pre></td></tr></table></figure>

<p>每次慢分配，调用<code>record_slow_allocation(size_t obj_size)</code>记录慢分配的同时，增加 TLAB 最大浪费空间的大小：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::record_slow_allocation(size_t obj_size) &#123;</span><br><span class="line">  //每次慢分配，_refill_waste_limit 增加 refill_waste_limit_increment，也就是 TLABWasteIncrement</span><br><span class="line">  set_refill_waste_limit(refill_waste_limit() + refill_waste_limit_increment());</span><br><span class="line">  _slow_allocations++;</span><br><span class="line">  log_develop_trace(gc, tlab)(&quot;TLAB: %s thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;</span><br><span class="line">                              &quot; obj: &quot; SIZE_FORMAT</span><br><span class="line">                              &quot; free: &quot; SIZE_FORMAT</span><br><span class="line">                              &quot; waste: &quot; SIZE_FORMAT,</span><br><span class="line">                              &quot;slow&quot;, p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),</span><br><span class="line">                              obj_size, free(), refill_waste_limit());</span><br><span class="line">&#125;</span><br><span class="line">//refill_waste_limit_increment 就是 JVM 参数 TLABWasteIncrement</span><br><span class="line">static size_t refill_waste_limit_increment()   &#123; return TLABWasteIncrement; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-2-重新计算-TLAB-大小"><a href="#9-3-2-2-重新计算-TLAB-大小" class="headerlink" title="9.3.2.2. 重新计算 TLAB 大小"></a>9.3.2.2. 重新计算 TLAB 大小</h4><p>重新计算会取 当前堆剩余给 TLAB 可分配的空间 和 <strong>TLAB 期望大小 + 当前需要分配的空间大小</strong> 中的小的那个：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码inline size_t ThreadLocalAllocBuffer::compute_size(size_t obj_size) &#123;</span><br><span class="line">  //获取当前堆剩余给 TLAB 可分配的空间</span><br><span class="line">  const size_t available_size = Universe::heap()-&gt;unsafe_max_tlab_alloc(thread()) / HeapWordSize;</span><br><span class="line">  //取 TLAB 可分配的空间 和 TLAB 期望大小 + 当前需要分配的空间大小 以及 TLAB 最大大小中的小的那个</span><br><span class="line">  size_t new_tlab_size = MIN3(available_size, desired_size() + align_object_size(obj_size), max_size());</span><br><span class="line"></span><br><span class="line">  // 确保大小大于 dummy obj 对象头</span><br><span class="line">  if (new_tlab_size &lt; compute_min_size(obj_size)) &#123;</span><br><span class="line">    log_trace(gc, tlab)(&quot;ThreadLocalAllocBuffer::compute_size(&quot; SIZE_FORMAT &quot;) returns failure&quot;,</span><br><span class="line">                        obj_size);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  log_trace(gc, tlab)(&quot;ThreadLocalAllocBuffer::compute_size(&quot; SIZE_FORMAT &quot;) returns &quot; SIZE_FORMAT,</span><br><span class="line">                      obj_size, new_tlab_size);</span><br><span class="line">  return new_tlab_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-3-当前-TLAB-放回堆"><a href="#9-3-2-3-当前-TLAB-放回堆" class="headerlink" title="9.3.2.3. 当前 TLAB 放回堆"></a>9.3.2.3. 当前 TLAB 放回堆</h4><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//在TLAB慢分配被调用，当前 TLAB 放回堆</span><br><span class="line">void ThreadLocalAllocBuffer::retire_before_allocation() &#123;</span><br><span class="line">  //将当前 TLAB 剩余空间大小加入慢分配浪费空间大小</span><br><span class="line">  _slow_refill_waste += (unsigned int)remaining();</span><br><span class="line">  //执行 TLAB 退还给堆，这个在后面 GC 的时候还会被调用用于将所有的线程的 TLAB 退回堆</span><br><span class="line">  retire();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于 TLAB 慢分配，stats 为空</span><br><span class="line">//对于 GC 的时候调用，stats 用于记录每个线程的数据</span><br><span class="line">void ThreadLocalAllocBuffer::retire(ThreadLocalAllocStats* stats) &#123;</span><br><span class="line">  </span><br><span class="line">  if (stats != NULL) &#123;</span><br><span class="line">    accumulate_and_reset_statistics(stats);</span><br><span class="line">  &#125;</span><br><span class="line">  //如果当前 TLAB 有效</span><br><span class="line">  if (end() != NULL) &#123;</span><br><span class="line">    invariants();</span><br><span class="line">    //将用了的空间记录如线程分配对象大小记录</span><br><span class="line">    thread()-&gt;incr_allocated_bytes(used_bytes());</span><br><span class="line">    //填充dummy object</span><br><span class="line">    insert_filler();</span><br><span class="line">    //清空当前 TLAB 指针</span><br><span class="line">    initialize(NULL, NULL, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-GC-相关-TLAB-操作"><a href="#9-4-GC-相关-TLAB-操作" class="headerlink" title="9.4. GC 相关 TLAB 操作"></a>9.4. GC 相关 TLAB 操作</h2><h3 id="9-4-1-GC-前"><a href="#9-4-1-GC-前" class="headerlink" title="9.4.1. GC 前"></a>9.4.1. GC 前</h3><p>不同的 GC 可能实现不一样，但是 TLAB 操作的时机是基本一样的，这里以 G1 GC 为例，在真正 GC 前：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void G1CollectedHeap::gc_prologue(bool full) &#123;</span><br><span class="line">  //省略其他代码</span><br><span class="line"></span><br><span class="line">  // Fill TLAB&apos;s and such</span><br><span class="line">  &#123;</span><br><span class="line">    Ticks start = Ticks::now();</span><br><span class="line">    //确保堆内存是可以解析的</span><br><span class="line">    ensure_parsability(true);</span><br><span class="line">    Tickspan dt = Ticks::now() - start;</span><br><span class="line">    phase_times()-&gt;record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);</span><br><span class="line">  &#125;</span><br><span class="line">  //省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为何要确保堆内存是可以解析的呢？这样有利于更快速的扫描堆上对象。确保内存可以解析里面做了什么呢？其实主要就是退还每个线程的 TLAB 以及填充 dummy object。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void CollectedHeap::ensure_parsability(bool retire_tlabs) &#123;</span><br><span class="line">  //真正的 GC 肯定发生在安全点上，这个在后面安全点章节会详细说明</span><br><span class="line">  assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),</span><br><span class="line">         &quot;Should only be called at a safepoint or at start-up&quot;);</span><br><span class="line"></span><br><span class="line">  ThreadLocalAllocStats stats;</span><br><span class="line">  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next();) &#123;</span><br><span class="line">    BarrierSet::barrier_set()-&gt;make_parsable(thread);</span><br><span class="line">    //如果全局启用了 TLAB</span><br><span class="line">    if (UseTLAB) &#123;</span><br><span class="line">      //如果指定要回收，则回收 TLAB</span><br><span class="line">      if (retire_tlabs) &#123;</span><br><span class="line">        //回收 TLAB，调用  9.3.2.3. 当前 TLAB 放回堆 提到的 retire 方法</span><br><span class="line">        thread-&gt;tlab().retire(&amp;stats);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //当前如果不回收，则将 TLAB 填充 Dummy Object 利于解析</span><br><span class="line">        thread-&gt;tlab().make_parsable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stats.publish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-2-GC-后"><a href="#9-4-2-GC-后" class="headerlink" title="9.4.2. GC 后"></a>9.4.2. GC 后</h3><p>不同的 GC 可能实现不一样，但是 TLAB 操作的时机是基本一样的，这里以 G1 GC 为例，在 GC 后：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a> <code>_desired_size</code>是什么时候变得呢？怎么变得呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码void G1CollectedHeap::gc_epilogue(bool full) &#123;</span><br><span class="line">    //省略其他代码</span><br><span class="line">    resize_all_tlabs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/collectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/collectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void CollectedHeap::resize_all_tlabs() &#123;</span><br><span class="line">  //需要在安全点，GC 会处于安全点的</span><br><span class="line">  assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),</span><br><span class="line">         &quot;Should only resize tlabs at safepoint&quot;);</span><br><span class="line">  //如果 UseTLAB 和 ResizeTLAB 都是打开的（默认就是打开的）</span><br><span class="line">  if (UseTLAB &amp;&amp; ResizeTLAB) &#123;</span><br><span class="line">    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) &#123;</span><br><span class="line">      //重新计算每个线程 TLAB 期望大小</span><br><span class="line">      thread-&gt;tlab().resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新计算每个线程 TLAB 期望大小： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::resize() &#123;</span><br><span class="line">  assert(ResizeTLAB, &quot;Should not call this otherwise&quot;);</span><br><span class="line">  //根据 _allocation_fraction 这个 EMA 采集得出平均数乘以Eden区大小，得出 TLAB 当前预测占用内存比例</span><br><span class="line">  size_t alloc = (size_t)(_allocation_fraction.average() *</span><br><span class="line">                          (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize));</span><br><span class="line">  //除以目标 refill 次数就是新的 TLAB 大小，和初始化时候的计算方法差不多</span><br><span class="line">  size_t new_size = alloc / _target_refills;</span><br><span class="line">  //保证在 min_size 还有 max_size 之间</span><br><span class="line">  new_size = clamp(new_size, min_size(), max_size());</span><br><span class="line"></span><br><span class="line">  size_t aligned_new_size = align_object_size(new_size);</span><br><span class="line"></span><br><span class="line">  log_trace(gc, tlab)(&quot;TLAB new size: thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;</span><br><span class="line">                      &quot; refills %d  alloc: %8.6f desired_size: &quot; SIZE_FORMAT &quot; -&gt; &quot; SIZE_FORMAT,</span><br><span class="line">                      p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),</span><br><span class="line">                      _target_refills, _allocation_fraction.average(), desired_size(), aligned_new_size);</span><br><span class="line">  //设置新的 TLAB 大小</span><br><span class="line">  set_desired_size(aligned_new_size);</span><br><span class="line">  //重置 TLAB 最大浪费空间</span><br><span class="line">  set_refill_waste_limit(initial_refill_waste_limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li><h1 id="TLAB-流程常见问题-Q-amp-A"><a href="#TLAB-流程常见问题-Q-amp-A" class="headerlink" title="TLAB 流程常见问题 Q&amp;A"></a>TLAB 流程常见问题 Q&amp;A</h1></li>
</ol>
<blockquote>
<p>这里我会持续更新的，解决大家的各种疑问</p>
</blockquote>
<h2 id="10-1-为何-TLAB-在退还给堆的时候需要填充-dummy-object"><a href="#10-1-为何-TLAB-在退还给堆的时候需要填充-dummy-object" class="headerlink" title="10.1. 为何 TLAB 在退还给堆的时候需要填充 dummy object"></a>10.1. 为何 TLAB 在退还给堆的时候需要填充 dummy object</h2><p>主要保证 GC 的时候扫描高效。由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，如果填充已经确认会被回收的对象，也就是 dummy object， GC 会直接标记之后跳过这块内存，增加扫描效率。反正这块内存已经属于 TLAB，其他线程在下次扫描结束前是无法使用的。这个 dummy object 就是 int 数组。为了一定能有填充 dummy object 的空间，<strong>一般 TLAB 大小都会预留一个 dummy object 的 header 的空间</strong>，也是一个 <code>int[]</code> 的 header，所以 TLAB 的大小不能超过int 数组的最大大小，否则无法用 dummy object 填满未使用的空间。</p>
<h2 id="10-2-为何-TLAB-需要最大浪费空间限制"><a href="#10-2-为何-TLAB-需要最大浪费空间限制" class="headerlink" title="10.2. 为何 TLAB 需要最大浪费空间限制"></a>10.2. 为何 TLAB 需要最大浪费空间限制</h2><p>当重新分配一个 TLAB 的时候，原有的 TLAB 可能还有空间剩余。原有的 TLAB 被退回堆之前，需要填充好 dummy object。这样导致这块内存无法分配对象，所示被称为“浪费”。如果不限制，遇到 TLAB 剩余空间不足的情况就会重新申请，导致分配效率降低，大部分空间被 dummy object 占满了，导致 GC 更加频繁。</p>
<h2 id="10-3-为何-TLAB-重填次数配置-等于-100-2-TLABWasteTargetPercent"><a href="#10-3-为何-TLAB-重填次数配置-等于-100-2-TLABWasteTargetPercent" class="headerlink" title="10.3. 为何 TLAB 重填次数配置 等于 100 / (2 * TLABWasteTargetPercent)"></a>10.3. 为何 TLAB 重填次数配置 等于 100 / (2 * TLABWasteTargetPercent)</h2><p>TLABWasteTargetPercent 描述了<strong>初始最大浪费空间配置占 TLAB 的比例</strong></p>
<p>首先，最理想的情况就是尽量让所有对象在 TLAB 内分配，也就是 TLAB 可能要占满 Eden。 在下次 GC 扫描前，退回 Eden 的内存别的线程是不能用的，因为剩余空间已经填满了 <strong>dummy object</strong>。所以所有线程使用内存大小就是 <strong><code>下个 epcoh 内会分配对象期望线程个数 * 每个 epoch 内每个线程 refill 次数配置</code></strong>，对象一般都在 Eden 区由某个线程分配，也就所有线程使用内存大小就最好是整个 Eden。但是这种情况太过于理想，总会有内存被填充了 <strong>dummy object</strong>而造成了浪费，因为 GC 扫描随时可能发生。假设平均下来，GC 扫描的时候，每个线程当前的 TLAB 都有一半的内存被浪费，这个每个线程使用内存的浪费的百分比率（也就是 <strong>TLABWasteTargetPercent</strong>），也就是等于（注意，仅最新的那个 TLAB 有浪费，之前 <strong>refill 退回的假设是没有浪费的</strong>）：</p>
<p><code>1/2 * (每个 epoch 内每个线程期望 refill 次数) * 100</code></p>
<p>那么<strong>每个 epoch 内每个线程 refill 次数配置</strong>就等于 <code>50 / TLABWasteTargetPercent</code>， 默认也就是 50 次。</p>
<h2 id="10-4-为何考虑-ZeroTLAB"><a href="#10-4-为何考虑-ZeroTLAB" class="headerlink" title="10.4. 为何考虑 ZeroTLAB"></a>10.4. 为何考虑 ZeroTLAB</h2><p>当分配出来 TLAB 之后，根据 ZeroTLAB 配置，决定是否将每个字节赋 0。在 TLAB 申请时，由于申请 TLAB 都发生在对象分配的时候，也就是这块内存会<strong>立刻被使用</strong>，并修改赋值。操作内存，涉及到 CPU 缓存行，如果是多核环境，还会涉及到 CPU 缓存行 false sharing，为了优化，JVM 在这里做了 Allocation Prefetch，简单理解就是分配 TLAB 的时候，会尽量加载这块内存到 CPU 缓存，也就是在<strong>分配 TLAB 内存的时候，修改内存是最高效的</strong>。</p>
<p>在创建对象的时候，本来也要对每个字段赋初始值，大部分字段初始值都是 0，并且，在 TLAB 返还到堆时，剩余空间填充的也是 int[] 数组，里面都是 0。</p>
<p>所以，TLAB 刚分配出来的时候，赋 0 避免了后续再赋 0。也能利用好 Allocation prefetch 的机制适应 CPU 缓存行（Allocation prefetch 的机制详情会在另一个系列说明）</p>
<h2 id="10-5-为何-JVM-需要预热，为什么-Java-代码越执行越快（这里只提-TLAB-相关的，JIT，MetaSpace，GC等等其他系列会说）"><a href="#10-5-为何-JVM-需要预热，为什么-Java-代码越执行越快（这里只提-TLAB-相关的，JIT，MetaSpace，GC等等其他系列会说）" class="headerlink" title="10.5. 为何 JVM 需要预热，为什么 Java 代码越执行越快（这里只提 TLAB 相关的，JIT，MetaSpace，GC等等其他系列会说）"></a>10.5. 为何 JVM 需要预热，为什么 Java 代码越执行越快（这里只提 TLAB 相关的，JIT，MetaSpace，GC等等其他系列会说）</h2><p>根据之前的分析，每个线程的 TLAB 的大小，会根据线程分配的特性，不断变化并趋于稳定，大小主要是由分配比例 EMA 决定，但是这个采集是需要一定运行次数的。并且 EMA 的前 100 次采集默认是不够稳定的，所以 TLAB 大小也在程序一开始的时候变化频繁。当程序线程趋于稳定，运行一段时间后， 每个线程 TLAB 大小也会趋于稳定并且调整到最适合这个线程对象分配特性的大小。这样，就更接近最理想的只有 Eden 区满了才会 GC，所有 Eden 区的对象都是通过 TLAB 分配的高效分配情况。这就是 Java 代码越执行越快在 TLAB 方面的原因。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925217498723778568" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析 3 JVM EMA期望</title>
    <url>/6925217757269065736.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol start="6">
<li><h1 id="JVM-中的期望计算-EMA"><a href="#JVM-中的期望计算-EMA" class="headerlink" title="JVM 中的期望计算 EMA"></a>JVM 中的期望计算 EMA</h1></li>
</ol>
<p>在上面提到的 TLAB 大小设计的时候，我们经常提到期望。这个期望是根据历史数据计算得出的，也就是<strong>每次输入采样值，根据历史采样值得出最新的期望值</strong>。不仅 TLAB 用到了这种期望计算，GC 和 JIT 等等 JVM 机制中都用到了。这里我们来看一种 TLAB 中经常用到的 <strong>EMA（Exponential Moving Average 指数平均数）</strong> 算法：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/88e53e663bd264a627c4e576a3137ca302f3ad955e1acd72845a29d6a949e4e0" alt="image"></p>
<p>EMA 算法的核心在于设置合适的<strong>最小权重</strong>，我们假设一个场景：首先采样100个 100（算法中的前 100 个是为了排除不稳定的干扰，我们这里直接忽略前 100 个采样），之后采样 50 个 2，最后采样 50 个 200，对于不同的<strong>最小权重</strong>，来看一下变化曲线。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/11e4f7797724fd0d4599bd4cd7ff5c866972a0ac67afb5eb0179cb4d341a8183" alt="image"></p>
<p>可以看出，<strong>最小权重越大</strong>，变化得越快，受<strong>历史数据影响越小</strong>。根据应用设置合适的<strong>最小权重</strong>，可以让你的期望更加理想。</p>
<p>这块对应的源代码：<a href="https://github.com/openjdk/jdk/blob/jdk-17+7/src/hotspot/share/gc/shared/gcUtil.cpp" target="_blank" rel="noopener"><code>gcUtil.hpp</code></a> 的 <code>AdaptiveWeightedAverage</code> 类。</p>
<ol start="7">
<li><h1 id="TLAB-相关的-JVM-参数"><a href="#TLAB-相关的-JVM-参数" class="headerlink" title="TLAB 相关的 JVM 参数"></a>TLAB 相关的 JVM 参数</h1></li>
</ol>
<blockquote>
<p>这里仅仅是列出来，并附上简介，看不懂没关系，之后会有详细分析，帮助你理解每一个参数。等你理解后，这个小章节就是你的工具书啦~~ 以下参数以及默认值基于 <strong>OpenJDK 17</strong></p>
</blockquote>
<h2 id="7-1-TLABStats（已过期）"><a href="#7-1-TLABStats（已过期）" class="headerlink" title="7.1. TLABStats（已过期）"></a>7.1. TLABStats（已过期）</h2><p>从 Java 12 开始已过期，目前已经没有相关的逻辑了。之前是用于 TLAB 统计数据从而更好地伸缩 TLAB 但是性能消耗相对较大，但是现在主要通过 EMA 计算了。</p>
<h2 id="7-2-UseTLAB"><a href="#7-2-UseTLAB" class="headerlink" title="7.2. UseTLAB"></a>7.2. UseTLAB</h2><p><strong>说明</strong>：是否启用 TLAB，默认是启用的。</p>
<p><strong>默认</strong>：true</p>
<p><strong>举例</strong>：如果想关闭：<code>-XX:-UseTLAB</code></p>
<h2 id="7-3-ZeroTLAB"><a href="#7-3-ZeroTLAB" class="headerlink" title="7.3. ZeroTLAB"></a>7.3. ZeroTLAB</h2><p><strong>说明</strong>：是否将新创建的 TLAB 内的所有字节归零。我们创建一个类的时候，类的 field 是有默认值的，例如 boolean 是 false，int 是 0 等等，实现的方式就是对分配好的内存空间赋 0。设置 ZeroTLAB 为 true <strong>代表在 TLAB 申请好的时候就赋 0</strong>，否则会在分配对象并初始化的时候赋 0.讲道理，<strong>由于 TLAB 分配的时候会涉及到 Allocation Prefetch 优化 CPU 缓存，在 TLAB 分配好之后立刻更新赋 0 对于 CPU 缓存应该是更友好的</strong>，并且，如果 TLAB 没有用满，填充的 dummy object 其实依然是 0 数组，相当于大部分不用改。这么看来，开启应该更好。但是ZeroTLAB 默认还是不开启的。</p>
<p><strong>默认</strong>：false</p>
<p><strong>举例</strong>：<code>-XX:+ZeroTLAB</code></p>
<h2 id="7-4-ResizeTLAB"><a href="#7-4-ResizeTLAB" class="headerlink" title="7.4. ResizeTLAB"></a>7.4. ResizeTLAB</h2><p><strong>说明</strong>：TLAB 是否是可变的，默认为是，也就是会根据线程历史分配数据相关 EMA 计算出每次期望 TLAB 大小并以这个大小为准申请 TLAB。</p>
<p><strong>默认</strong>：true</p>
<p><strong>举例</strong>：如果想关闭：<code>-XX:-ResizeTLAB</code></p>
<h2 id="7-5-TLABSize"><a href="#7-5-TLABSize" class="headerlink" title="7.5. TLABSize"></a>7.5. TLABSize</h2><p><strong>说明</strong>：初始 TLAB 大小。单位是字节</p>
<p><strong>默认</strong>：0， 0 就是不主动设置 TLAB 初始大小，而是通过 JVM 自己计算每一个线程的初始大小</p>
<p><strong>举例</strong>：<code>-XX:TLABSize=65536</code></p>
<h2 id="7-6-MinTLABSize"><a href="#7-6-MinTLABSize" class="headerlink" title="7.6. MinTLABSize"></a>7.6. MinTLABSize</h2><p><strong>说明</strong>：最小 TLAB 大小。单位是字节</p>
<p><strong>默认</strong>：2048</p>
<p><strong>举例</strong>：<code>-XX:TLABSize=4096</code></p>
<h2 id="7-7-TLABAllocationWeight"><a href="#7-7-TLABAllocationWeight" class="headerlink" title="7.7. TLABAllocationWeight"></a>7.7. TLABAllocationWeight</h2><p><strong>说明</strong>： TLAB 初始大小计算和线程数量有关，但是线程是动态创建销毁的。所以需要基于历史线程个数推测接下来的线程个数来计算 TLAB 大小。一般 JVM 内像这种预测函数都采用了 EMA 。<strong>这个参数就是 图06 中的最小权重</strong>，权重越高，最近的数据占比影响越大。TLAB 重新计算大小是根据分配比例，分配比例也是采用了 EMA 算法，最小权重也是 TLABAllocationWeight</p>
<p><strong>默认</strong>：35</p>
<p><strong>举例</strong>：<code>-XX:TLABAllocationWeight=70</code></p>
<h2 id="7-8-TLABWasteTargetPercent"><a href="#7-8-TLABWasteTargetPercent" class="headerlink" title="7.8. TLABWasteTargetPercent"></a>7.8. TLABWasteTargetPercent</h2><p><strong>说明</strong>：TLAB 的大小计算涉及到了 Eden 区的大小以及可以浪费的比率。<strong>TLAB 浪费</strong>指的是上面提到的重新申请新的 TLAB 的时候老的 TLAB 没有分配的空间。这个参数其实就是 TLAB 浪费占用 Eden 的百分比，这个参数的作用会在接下来的原理说明内详细说明</p>
<p><strong>默认</strong>：1</p>
<p><strong>举例</strong>：<code>-XX:TLABWasteTargetPercent=10</code></p>
<h2 id="7-9-TLABRefillWasteFraction"><a href="#7-9-TLABRefillWasteFraction" class="headerlink" title="7.9. TLABRefillWasteFraction"></a>7.9. TLABRefillWasteFraction</h2><p><strong>说明</strong>： 初始<strong>最大浪费空间限制</strong>计算参数，初始<strong>最大浪费空间限制</strong> = 当前期望 TLAB 大小 / TLABRefillWasteFraction</p>
<p><strong>默认</strong>：64</p>
<p><strong>举例</strong>：<code>-XX:TLABRefillWasteFraction=32</code></p>
<h2 id="7-10-TLABWasteIncrement"><a href="#7-10-TLABWasteIncrement" class="headerlink" title="7.10. TLABWasteIncrement"></a>7.10. TLABWasteIncrement</h2><p><strong>说明</strong>： <strong>最大浪费空间限制并不是不变的</strong>，在发生 TLAB 缓慢分配的时候（也就是当前 TLAB 空间不足以分配的时候），会增加最大浪费空间限制。这个参数就是 TLAB 缓慢分配时允许的 TLAB 浪费增量。单位不是字节，而是 <code>MarkWord</code> 个数，也就是 Java 堆的内存最小单元，64 位虚拟机的情况下，<code>MarkWord</code> 大小为 8 字节。</p>
<p><strong>默认</strong>：4</p>
<p><strong>举例</strong>：<code>-XX:TLABWasteIncrement=4</code></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925217757269065736" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析 2 TLAB生命周期与</title>
    <url>/6925217911355211789.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol start="4">
<li><h1 id="TLAB-的生命周期"><a href="#TLAB-的生命周期" class="headerlink" title="TLAB 的生命周期"></a>TLAB 的生命周期</h1></li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dd86982925a97a08b4a926de29e4bde08deadc978701592cfaa21c2ec332c995" alt="image"></p>
<p>TLAB 是线程私有的，<strong>线程初始化的时候</strong>，会创建并初始化 TLAB。同时，在 <strong>GC 扫描对象发生之后，线程第一次尝试分配对象的时候</strong>，也会创建并初始化 TLAB。 TLAB 生命周期停止（TLAB 声明周期停止不代表内存被回收，只是代表这个 TLAB 不再被这个线程私有管理）在：</p>
<ul>
<li>当前 TLAB 不够分配，并且剩余空间小于<strong>最大浪费空间限制</strong>，那么这个 TLAB 会被退回 Eden，重新申请一个新的</li>
<li>发生 GC 的时候，TLAB 被回收。</li>
</ul>
<ol start="5">
<li><h1 id="TLAB-要解决的问题以及带来的问题与解决方案的思考"><a href="#TLAB-要解决的问题以及带来的问题与解决方案的思考" class="headerlink" title="TLAB 要解决的问题以及带来的问题与解决方案的思考"></a>TLAB 要解决的问题以及带来的问题与解决方案的思考</h1></li>
</ol>
<p>TLAB 要解决的问题很明显，<strong>尽量避免从堆上直接分配内存从而避免频繁的锁争用。</strong></p>
<p>引入 TLAB 之后，TLAB 的设计上，也有很多值得考虑的问题。</p>
<h2 id="5-1-引入-TLAB-后，会有内存孔隙问题，还可能影响-GC-扫描性能"><a href="#5-1-引入-TLAB-后，会有内存孔隙问题，还可能影响-GC-扫描性能" class="headerlink" title="5.1. 引入 TLAB 后，会有内存孔隙问题，还可能影响 GC 扫描性能"></a>5.1. 引入 TLAB 后，会有内存孔隙问题，还可能影响 GC 扫描性能</h2><p>出现孔隙的情况：</p>
<ul>
<li>当前 TLAB 不够分配时，如果剩余空间小于<strong>最大浪费空间限制</strong>，那么这个 TLAB 会被退回 Eden，重新申请一个新的。这个剩余空间就会成为孔隙。</li>
<li>当发生 GC 的时候，TLAB 没有用完，没有分配的内存也会成为孔隙。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ba16b37d4f721c1e922decece64ad3dafe81eb4c4e9559dc9c30113b8bfc3cf9" alt="image"></p>
<p>如果不管这些孔隙，由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，那么会影响 GC 扫描效率。所以 TLAB 回归 Eden 的时候，<strong>会将剩余可用的空间用一个 dummy object 填充满</strong>。如果填充<strong>已经确认会被回收的对象</strong>，也就是 dummy object， GC 会直接标记之后跳过这块内存，增加扫描效率。但是同时，由于需要填充这个 dummy object，所以需要<strong>预留出这个对象的对象头的空间</strong>。</p>
<h2 id="5-2-某个线程在一轮-GC-内分配的内存并不稳定"><a href="#5-2-某个线程在一轮-GC-内分配的内存并不稳定" class="headerlink" title="5.2. 某个线程在一轮 GC 内分配的内存并不稳定"></a>5.2. 某个线程在一轮 GC 内分配的内存并不稳定</h2><p>如果我们能提前知道在这一轮内每个线程会分配多少内存，那么我们可以直接提前分配好。但是，这简直是痴人说梦。每个线程在每一轮 GC 的分配情况可能都是不一样的：</p>
<ul>
<li><strong>不同的线程业务场景不同导致分配对象大小不同</strong>。我们一般会按照业务区分不同的线程池，做好线程池隔离。对于用户请求，每次分配的对象可能比较小。对于后台分析请求，每次分配的对象相对大一些。</li>
<li><strong>不同时间段内线程压力并不均匀</strong>。业务是有高峰有低谷的，高峰时间段内肯定分配对象更多。</li>
<li><strong>同一时间段同一线程池内的线程的业务压力也不一定不能做到很均匀</strong>。很可能只有几个线程很忙，其他线程很闲。</li>
</ul>
<p>所以，综合考虑以上情况，我们应该这么实现 TLAB：</p>
<ul>
<li>不能一下子就给一个线程申请一个比较大的 TLAB，而是考虑<strong>这个线程 TLAB 分配满之后再申请新的</strong>，这样更加灵活。</li>
<li><strong>每次申请 TLAB 的大小是变化</strong>的，并不是固定的。</li>
<li><strong>每次申请 TLAB 的大小需要考虑当前 GC 轮次内会分配对象的线程的个数期望</strong></li>
<li><strong>每次申请 TLAB 的大小需要考虑所有线程期望 TLAB 分配满重新申请新的 TLAB 次数</strong></li>
</ul>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925217911355211789" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析 4 TLAB 基本流程</title>
    <url>/6925218101147484167.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<h1 id="8-TLAB-基本流程"><a href="#8-TLAB-基本流程" class="headerlink" title="8.TLAB 基本流程"></a>8.TLAB 基本流程</h1><h2 id="8-0-如何设计每个线程的-TLAB-大小"><a href="#8-0-如何设计每个线程的-TLAB-大小" class="headerlink" title="8.0. 如何设计每个线程的 TLAB 大小"></a>8.0. 如何设计每个线程的 TLAB 大小</h2><p>之前我们提到了引入 TLAB 要面临的问题以及解决方式，根据这些我们可以这么设计 TLAB。</p>
<p>首先，TLAB 的初始大小，应该和每个 GC 内需要对象分配的线程个数相关。但是，要分配的线程个数并不一定是稳定的，可能这个时间段线程数多，下个阶段线程数就不那么多了，所以，<strong>需要用 EMA 的算法采集每个 GC 内需要对象分配的线程个数来计算这个个数期望</strong>。</p>
<p>接着，我们最理想的情况下，是每个 GC 内，所有用来分配对象的内存都处于对应线程的 TLAB 中。每个 GC 内用来分配对象的内存从 JVM 设计上来讲，其实就是 Eden 区大小。在 <strong>最理想的情况</strong>下，最好只有<strong>Eden 区满了的时候才会 GC</strong>，不会有其他原因导致的 GC，这样是最高效的情况。Eden 区被用光，如果全都是 TLAB 内分配，也就是 <strong>Eden 区被所有线程的 TLAB 占满了</strong>，这样分配是最快的。</p>
<p>然后，每轮 GC 分配内存的线程个数以及大小是不一定的，如果一下子分配一大块会造成浪费，如果太小则会频繁从 Eden 申请 TLAB，降低效率。这个大小比较难以控制，但是我们可以限制<strong>每个线程究竟在一轮 GC 内，最多从 Eden 申请多少次 TLAB</strong>，这样对于用户来说更好控制。</p>
<p>最后，每个线程分配的内存大小，在每轮 GC 并不一定稳定，只用初始大小来指导之后的 TLAB 大小，显然不够。我们换个思路，每个线程分配的内存和历史有一定关系因此我们可以从历史分配中推测，所以<strong>每个线程也需要采用 EMA 的算法采集这个线程每次 GC 分配的内存</strong>，用于指导下次期望的 TLAB 的大小。</p>
<p>综上所述，我们可以得出这样一个<strong>近似的 TLAB 计算公式</strong>：</p>
<p>每个线程 TLAB 初始大小 = <code>Eden区大小</code> / (<code>线程单个 GC 轮次内最多从 Eden 申请多少次 TLAB</code> * <code>当前 GC 分配线程个数 EMA</code>)</p>
<p>GC 后，重新计算 TLAB 大小 = <code>Eden区大小</code> / (<code>线程单个 GC 轮次内最多从 Eden 申请多少次 TLAB</code> * <code>当前 GC 分配线程个数 EMA</code>)</p>
<p>接下来，我们来详细分析 TLAB 的整个生命周期的每个流程。</p>
<h2 id="8-1-TLAB-初始化"><a href="#8-1-TLAB-初始化" class="headerlink" title="8.1. TLAB 初始化"></a>8.1. TLAB 初始化</h2><p><strong>线程初始化的时候</strong>，如果 JVM 启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则会初始化 TLAB，在发生对象分配时，会根据<strong>期望大小</strong>申请 TLAB 内存。同时，在 <strong>GC 扫描对象发生之后，线程第一次尝试分配对象的时候</strong>，也会重新申请 TLAB 内存。我们先只关心初始化，初始化的流程图如 <strong>图08</strong> 所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ffb5b79c29fefeeb160362d5e4c3979fdcda55d2d040de2922a17eaa8b3233da" alt="image"></p>
<p>初始化时候会计算 TLAB 初始<strong>期望大小</strong>。这涉及到了 <strong>TLAB 大小的限制</strong>：</p>
<ul>
<li><strong>TLAB 的最小大小</strong>：通过<code>MinTLABSize</code>指定</li>
<li><strong>TLAB 的最大大小</strong>：不同的 GC 中不同，<strong>G1 GC 中为大对象（humongous object）大小</strong>，也就是 G1 region 大小的一半。因为开头提到过，在 G1 GC 中，大对象不能在 TLAB 分配，而是老年代。<strong>ZGC 中为页大小的 8 分之一</strong>，类似的在大部分情况下 <strong>Shenandoah GC 也是每个 Region 大小的 8 分之一</strong>。他们都是期望至少有 8 分之 7 的区域是不用退回的减少选择 Cset 的时候的扫描复杂度。对于<strong>其他的 GC，则是 int 数组的最大大小</strong>，这个和之前提到的<strong>填充 dummy object 有关</strong>，后面会提到详细流程。</li>
</ul>
<p><strong>之后的流程里面，无论何时，TLAB 的大小都会在这个 TLAB 的最小大小 到 TLAB 的最大大小 的范围内，为了避免啰嗦，我们不会再强调这个限制<del>~</del>！！！</strong> <strong>之后的流程里面，无论何时，TLAB 的大小都会在这个 TLAB 的最小大小 到 TLAB 的最大大小 的范围内，为了避免啰嗦，我们不会再强调这个限制<del>~</del>！！！</strong> <strong>之后的流程里面，无论何时，TLAB 的大小都会在这个 TLAB 的最小大小 到 TLAB 的最大大小 的范围内，为了避免啰嗦，我们不会再强调这个限制<del>~</del>！！！</strong> 重要的事情说三遍~</p>
<p><strong>TLAB 期望大小（desired size）</strong> 在初始化的时候会计算 TLAB 期望大小，之后再 GC 等操作回收掉 TLAB 需要重计算这个期望大小。根据这个期望大小，TLAB 在申请空间的时候每次申请都会以这个期望大小作为基准的空间作为 TLAB 分配空间。</p>
<h3 id="8-1-1-TLAB-初始期望大小计算"><a href="#8-1-1-TLAB-初始期望大小计算" class="headerlink" title="8.1.1. TLAB 初始期望大小计算"></a>8.1.1. TLAB 初始期望大小计算</h3><p>如 <strong>图08</strong> 所示，如果指定了 <strong>TLABSize</strong>，就用这个大小作为初始<strong>期望大小</strong>。如果没有指定，则按照如下的公式进行计算：</p>
<p><code>堆给TLAB的空间总大小</code>/(<code>当前有效分配线程个数期望</code>*<code>重填次数配置</code>)</p>
<ol>
<li><strong>堆给 TLAB 的空间总大小</strong>：堆上能有多少空间分配给 TLAB，不同的 GC 算法不一样，但是<strong>大多数 GC 算法的实现都是 Eden 区大小</strong>，例如：<ol>
<li>传统的已经弃用的 Parallel Scanvage 中，就是 Eden 区大小。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp" target="_blank" rel="noopener">parallelScavengeHeap.cpp</a></li>
<li>默认的G1 GC 中是 （YoungList 区域个数减去 Survivor 区域个数） * 区域大小，其实就是 Eden 区大小。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener">g1CollectedHeap.cpp</a></li>
<li>ZGC 中是 Page 剩余空间大小，Page 类似于 Eden 区，是大部分对象分配的区域。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/z/zHeap.cpp" target="_blank" rel="noopener">zHeap.cpp</a></li>
<li>Shenandoah GC 中是 FreeSet 的大小，也是类似于 Eden 的概念。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp" target="_blank" rel="noopener">shenandoahHeap.cpp</a></li>
</ol>
</li>
<li><strong>当前有效分配线程个数期望</strong>：这是一个全局 EMA，EMA 是什么之前已经说明了，是一种计算期望的方式。有效分配线程个数 EMA 的最小权重是 TLABAllocationWeight。有效分配线程个数 EMA 在有线程进行第一次有效对象分配的时候进行采集，在 TLAB 初始化的时候读取这个值计算 TLAB 期望大小。</li>
<li><strong>TLAB 重填次数配置（refills time）</strong>：根据 TLABWasteTargetPercent 计算的次数，公式为。TLABWasteTargetPercent 的意义其实是限制<strong>最大浪费空间限制</strong>，为何重填次数与之相关后面会详细分析。</li>
</ol>
<h3 id="8-1-2-TLAB-初始分配比例计算"><a href="#8-1-2-TLAB-初始分配比例计算" class="headerlink" title="8.1.2. TLAB 初始分配比例计算"></a>8.1.2. TLAB 初始分配比例计算</h3><p>如 <strong>图08</strong> 所示，接下来会计算TLAB 初始分配比例。</p>
<p>线程私有<strong>分配比例 EMA</strong>：与<strong>有效分配线程个数 EMA</strong>对应，<strong>有效分配线程个数 EMA</strong>是对于全局来说，每个线程应该占用多大的 TLAB 的描述，而<strong>分配比例 EMA</strong> 相当于对于当前线程应该占用的总 TLAB 空间的大小的一种动态控制。</p>
<p>初始化的时候，分配比例其实就是等于 <code>1/当前有效分配线程个数</code>。<strong>图08</strong> 的公式，代入之前的计算 TLAB 期望大小的公式，消参简化之后就是<code>1/当前有效分配线程个数</code>。这个值作为初始值，采集如线程私有的<strong>分配比例 EMA</strong>。</p>
<h3 id="8-1-3-清零线程私有统计数据"><a href="#8-1-3-清零线程私有统计数据" class="headerlink" title="8.1.3. 清零线程私有统计数据"></a>8.1.3. 清零线程私有统计数据</h3><p>这些采集数据会用于之后的当前线程的分配比例的计算与采集，从而影响之后的当前线程 TLAB 期望大小。</p>
<h2 id="8-2-TLAB-分配"><a href="#8-2-TLAB-分配" class="headerlink" title="8.2. TLAB 分配"></a>8.2. TLAB 分配</h2><p>TLAB 分配流程如 <strong>图09</strong> 所示。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3072b4cbb3fbea679a2fecde4194014f95f1a231409bbde2eaab6b9fef9fb2ac" alt="image"></p>
<h3 id="8-2-1-从线程当前-TLAB-分配"><a href="#8-2-1-从线程当前-TLAB-分配" class="headerlink" title="8.2.1. 从线程当前 TLAB 分配"></a>8.2.1. 从线程当前 TLAB 分配</h3><p>如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则首先从线程当前 TLAB 分配内存，如果分配成功则返回，否则根据当前 TLAB 剩余空间与当前<strong>最大浪费空间限制</strong>大小进行不同的分配策略。在下一个流程，就会提到这个限制究竟是什么。</p>
<h3 id="8-2-2-重新申请-TLAB-分配"><a href="#8-2-2-重新申请-TLAB-分配" class="headerlink" title="8.2.2. 重新申请 TLAB 分配"></a>8.2.2. 重新申请 TLAB 分配</h3><p>如果当前 TLAB 剩余空间大于当前<strong>最大浪费空间限制</strong>(根据 <strong>图08</strong> 的流程，我们知道这个初始值为 <strong>期望大小/TLABRefillWasteFraction</strong>)，直接在堆上分配。否则，重新申请一个 TLAB 分配。 为什么需要最大浪费空间呢？</p>
<p>当重新分配一个 TLAB 的时候，原有的 TLAB 可能还有空间剩余。原有的 TLAB 被退回堆之前，需要填充好 dummy object。由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，如果填充已经确认会被回收的对象，也就是 dummy object， <strong>GC 会直接标记之后跳过这块内存，增加扫描效率</strong>。反正这块内存已经属于 TLAB，其他线程在下次扫描结束前是无法使用的。这个 dummy object 就是 int 数组。为了一定能有填充 dummy object 的空间，<strong>一般 TLAB 大小都会预留一个 dummy object 的 header 的空间</strong>，也是一个 <code>int[]</code> 的 header，所以 TLAB 的大小不能超过int 数组的最大大小，否则无法用 dummy object 填满未使用的空间。</p>
<p>但是，填充 dummy 也造成了空间的浪费，这种浪费不能太多，所以通过<strong>最大浪费空间限制</strong>来限制这种浪费。</p>
<p>新的 TLAB 大小，取如下<strong>两个值中较小</strong>的那个：</p>
<ul>
<li>当前堆剩余给 TLAB 可分配的空间，大部分 GC 的实现其实就是对应的 Eden 区剩余大小：<ul>
<li>传统的已经弃用的 Parallel Scanvage 中，就是 Eden 区剩余大小。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/parallel/parallelScavengeHeap.cpp" target="_blank" rel="noopener">parallelScavengeHeap.cpp</a></li>
<li>默认的G1 GC 中是当前 Region 中剩余大小，其实就是将 Eden 分区了。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener">g1CollectedHeap.cpp</a></li>
<li>ZGC 中是 Page 剩余空间大小，Page 类似于 Eden 区，是大部分对象分配的区域。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/z/zHeap.cpp" target="_blank" rel="noopener">zHeap.cpp</a></li>
<li>Shenandoah GC 中是 FreeSet 的剩余大小，也是类似于 Eden 的概念。参考：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp" target="_blank" rel="noopener">shenandoahHeap.cpp</a></li>
</ul>
</li>
<li><strong>TLAB 期望大小</strong> + 当前需要分配的空间大小</li>
</ul>
<p>当分配出来 TLAB 之后，根据 ZeroTLAB 配置，决定是否将每个字节赋 0。在创建对象的时候，本来也要对每个字段赋初始值，大部分字段初始值都是 0，并且，在 TLAB 返还到堆时，剩余空间填充的也是 int[] 数组，里面都是 0。所以其实可以提前填充好。并且，TLAB 刚分配出来的时候，赋 0 也能利用好 Allocation prefetch 的机制适应 CPU 缓存行（Allocation prefetch 的机制会在另一个系列说明），所以可以通过打开 ZeroTLAB 来在分配 TLAB 空间之后立刻赋 0。</p>
<h3 id="8-2-3-直接从堆上分配"><a href="#8-2-3-直接从堆上分配" class="headerlink" title="8.2.3. 直接从堆上分配"></a>8.2.3. 直接从堆上分配</h3><p>直接从堆上分配是最慢的分配方式。一种情况就是，如果当前 TLAB 剩余空间大于当前<strong>最大浪费空间限制</strong>，直接在堆上分配。并且，还会增加当前最大浪费空间限制，<strong>每次有这样的分配就会增加 TLABWasteIncrement 的大小</strong>，这样在一定次数的直接堆上分配之后，当前最大浪费空间限制一直增大会导致当前 TLAB 剩余空间小于当前<strong>最大浪费空间限制</strong>，从而申请新的 TLAB 进行分配。</p>
<h2 id="8-3-GC-时-TLAB-回收与重计算期望大小"><a href="#8-3-GC-时-TLAB-回收与重计算期望大小" class="headerlink" title="8.3. GC 时 TLAB 回收与重计算期望大小"></a>8.3. GC 时 TLAB 回收与重计算期望大小</h2><p>相关流程如 <strong>图10</strong> 所示，在 GC 前与 GC 后，都会对 TLAB 做一些操作。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5945de14292f5820bf2594edce439f74c87eb2fbcae97b91c57292ecf0c9fcc8" alt="image"></p>
<h3 id="8-3-1-GC-前的操作"><a href="#8-3-1-GC-前的操作" class="headerlink" title="8.3.1. GC 前的操作"></a>8.3.1. GC 前的操作</h3><p>在 GC 前，如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），则需要将所有线程的 TLAB 填充 dummy Object 退还给堆，并计算并采样一些东西用于以后的 TLAB 大小计算。</p>
<p>首先为了保证本次计算具有参考意义，需要先判断是否堆上 TLAB 空间被用了一半以上，假设不足，那么认为本轮 GC 的数据没有参考意义。如果被用了一半以上，那么计算新的分配比例，<strong>新的分配比例 = 线程本轮 GC 分配空间的大小 / 堆上所有线程 TLAB 使用的空间</strong>，这么计算主要因为分配比例描述的是当前线程占用堆上所有给 TLAB 的空间的比例，每个线程不一样，通过这个比例动态控制不同业务线程的 TLAB 大小。</p>
<p><strong>线程本轮 GC 分配空间的大小</strong>包含 TLAB 中分配的和 TLAB 外分配的，从 <strong>图8、图9、图10</strong> 流程图中对于<strong>线程记录中的线程分配空间大小</strong>的记录就能看出，读取出线程分配空间大小减去上一轮 GC 结束时线程分配空间大小就是<strong>线程本轮 GC 分配空间的大小</strong>。</p>
<p>最后，将当前 TLAB 填充好 dummy object 之后，返还给堆。</p>
<h3 id="8-3-2-GC-后的操作"><a href="#8-3-2-GC-后的操作" class="headerlink" title="8.3.2. GC 后的操作"></a>8.3.2. GC 后的操作</h3><p>如果启用了 TLAB（默认是启用的， 可以通过 <code>-XX:-UseTLAB</code> 关闭），以及 TLAB 大小可变（默认是启用的， 可以通过 <code>-XX:-ResizeTLAB</code> 关闭），那么在 GC 后会重新计算每个线程 TLAB 的期望大小，<strong>新的期望大小 = 堆给TLAB的空间总大小 * 当前分配比例 EMA / 重填次数配置</strong>。然后会<strong>重置最大浪费空间限制</strong>，为当前 <strong>期望大小 / TLABRefillWasteFraction</strong>。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925218101147484167" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析 6 TLAB 相关热门</title>
    <url>/6925218189395787783.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol start="10">
<li><h1 id="TLAB-流程常见问题-Q-amp-A"><a href="#TLAB-流程常见问题-Q-amp-A" class="headerlink" title="TLAB 流程常见问题 Q&amp;A"></a>TLAB 流程常见问题 Q&amp;A</h1></li>
</ol>
<blockquote>
<p>这里我会持续更新的，解决大家的各种疑问</p>
</blockquote>
<h2 id="10-1-为何-TLAB-在退还给堆的时候需要填充-dummy-object"><a href="#10-1-为何-TLAB-在退还给堆的时候需要填充-dummy-object" class="headerlink" title="10.1. 为何 TLAB 在退还给堆的时候需要填充 dummy object"></a>10.1. 为何 TLAB 在退还给堆的时候需要填充 dummy object</h2><p>主要保证 GC 的时候扫描高效。由于 TLAB 仅线程内知道哪些被分配了，在 GC 扫描发生时返回 Eden 区，如果不填充的话，外部并不知道哪一部分被使用哪一部分没有，需要做额外的检查，如果填充已经确认会被回收的对象，也就是 dummy object， GC 会直接标记之后跳过这块内存，增加扫描效率。反正这块内存已经属于 TLAB，其他线程在下次扫描结束前是无法使用的。这个 dummy object 就是 int 数组。为了一定能有填充 dummy object 的空间，<strong>一般 TLAB 大小都会预留一个 dummy object 的 header 的空间</strong>，也是一个 <code>int[]</code> 的 header，所以 TLAB 的大小不能超过int 数组的最大大小，否则无法用 dummy object 填满未使用的空间。</p>
<h2 id="10-2-为何-TLAB-需要最大浪费空间限制"><a href="#10-2-为何-TLAB-需要最大浪费空间限制" class="headerlink" title="10.2. 为何 TLAB 需要最大浪费空间限制"></a>10.2. 为何 TLAB 需要最大浪费空间限制</h2><p>当重新分配一个 TLAB 的时候，原有的 TLAB 可能还有空间剩余。原有的 TLAB 被退回堆之前，需要填充好 dummy object。这样导致这块内存无法分配对象，所示被称为“浪费”。如果不限制，遇到 TLAB 剩余空间不足的情况就会重新申请，导致分配效率降低，大部分空间被 dummy object 占满了，导致 GC 更加频繁。</p>
<h2 id="10-3-为何-TLAB-重填次数配置-等于-100-2-TLABWasteTargetPercent"><a href="#10-3-为何-TLAB-重填次数配置-等于-100-2-TLABWasteTargetPercent" class="headerlink" title="10.3. 为何 TLAB 重填次数配置 等于 100 / (2 * TLABWasteTargetPercent)"></a>10.3. 为何 TLAB 重填次数配置 等于 100 / (2 * TLABWasteTargetPercent)</h2><p>TLABWasteTargetPercent 描述了<strong>初始最大浪费空间配置占 TLAB 的比例</strong></p>
<p>首先，最理想的情况就是尽量让所有对象在 TLAB 内分配，也就是 TLAB 可能要占满 Eden。 在下次 GC 扫描前，退回 Eden 的内存别的线程是不能用的，因为剩余空间已经填满了 <strong>dummy object</strong>。所以所有线程使用内存大小就是 <strong><code>下个 epcoh 内会分配对象期望线程个数 * 每个 epoch 内每个线程 refill 次数配置</code></strong>，对象一般都在 Eden 区由某个线程分配，也就所有线程使用内存大小就最好是整个 Eden。但是这种情况太过于理想，总会有内存被填充了 <strong>dummy object</strong>而造成了浪费，因为 GC 扫描随时可能发生。假设平均下来，GC 扫描的时候，每个线程当前的 TLAB 都有一半的内存被浪费，这个每个线程使用内存的浪费的百分比率（也就是 <strong>TLABWasteTargetPercent</strong>），也就是等于（注意，仅最新的那个 TLAB 有浪费，之前 <strong>refill 退回的假设是没有浪费的</strong>）：</p>
<p><code>1/2 * (每个 epoch 内每个线程期望 refill 次数) * 100</code></p>
<p>那么<strong>每个 epoch 内每个线程 refill 次数配置</strong>就等于 <code>50 / TLABWasteTargetPercent</code>， 默认也就是 50 次。</p>
<h2 id="10-4-为何考虑-ZeroTLAB"><a href="#10-4-为何考虑-ZeroTLAB" class="headerlink" title="10.4. 为何考虑 ZeroTLAB"></a>10.4. 为何考虑 ZeroTLAB</h2><p>当分配出来 TLAB 之后，根据 ZeroTLAB 配置，决定是否将每个字节赋 0。在 TLAB 申请时，由于申请 TLAB 都发生在对象分配的时候，也就是这块内存会<strong>立刻被使用</strong>，并修改赋值。操作内存，涉及到 CPU 缓存行，如果是多核环境，还会涉及到 CPU 缓存行 false sharing，为了优化，JVM 在这里做了 Allocation Prefetch，简单理解就是分配 TLAB 的时候，会尽量加载这块内存到 CPU 缓存，也就是在<strong>分配 TLAB 内存的时候，修改内存是最高效的</strong>。</p>
<p>在创建对象的时候，本来也要对每个字段赋初始值，大部分字段初始值都是 0，并且，在 TLAB 返还到堆时，剩余空间填充的也是 int[] 数组，里面都是 0。</p>
<p>所以，TLAB 刚分配出来的时候，赋 0 避免了后续再赋 0。也能利用好 Allocation prefetch 的机制适应 CPU 缓存行（Allocation prefetch 的机制详情会在另一个系列说明）</p>
<h2 id="10-5-为何-JVM-需要预热，为什么-Java-代码越执行越快（这里只提-TLAB-相关的，JIT，MetaSpace，GC等等其他系列会说）"><a href="#10-5-为何-JVM-需要预热，为什么-Java-代码越执行越快（这里只提-TLAB-相关的，JIT，MetaSpace，GC等等其他系列会说）" class="headerlink" title="10.5. 为何 JVM 需要预热，为什么 Java 代码越执行越快（这里只提 TLAB 相关的，JIT，MetaSpace，GC等等其他系列会说）"></a>10.5. 为何 JVM 需要预热，为什么 Java 代码越执行越快（这里只提 TLAB 相关的，JIT，MetaSpace，GC等等其他系列会说）</h2><p>根据之前的分析，每个线程的 TLAB 的大小，会根据线程分配的特性，不断变化并趋于稳定，大小主要是由分配比例 EMA 决定，但是这个采集是需要一定运行次数的。并且 EMA 的前 100 次采集默认是不够稳定的，所以 TLAB 大小也在程序一开始的时候变化频繁。当程序线程趋于稳定，运行一段时间后， 每个线程 TLAB 大小也会趋于稳定并且调整到最适合这个线程对象分配特性的大小。这样，就更接近最理想的只有 Eden 区满了才会 GC，所有 Eden 区的对象都是通过 TLAB 分配的高效分配情况。这就是 Java 代码越执行越快在 TLAB 方面的原因。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925218189395787783" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析 5 TLAB 源代码全</title>
    <url>/6925218236208250887.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol start="9">
<li><h1 id="OpenJDK-HotSpot-TLAB-相关源代码分析"><a href="#OpenJDK-HotSpot-TLAB-相关源代码分析" class="headerlink" title="OpenJDK HotSpot TLAB 相关源代码分析"></a>OpenJDK HotSpot TLAB 相关源代码分析</h1></li>
</ol>
<blockquote>
<p>如果这里看的比较吃力，可以直接看第 10 章，热门 Q&amp;A，里面有很多大家常问的问题</p>
</blockquote>
<h2 id="9-1-TLAB-类构成"><a href="#9-1-TLAB-类构成" class="headerlink" title="9.1. TLAB 类构成"></a>9.1. TLAB 类构成</h2><p>线程初始化的时候，如果 JVM 启用了 TLAB（默认是启用的， 可以通过 -XX:-UseTLAB 关闭），则会初始化 TLAB。</p>
<p>TLAB 包括如下几个 field （HeapWord* 可以理解为堆中的内存地址）： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码//静态全局变量</span><br><span class="line">static size_t   _max_size;                          // 所有 TLAB 的最大大小</span><br><span class="line">  static int      _reserve_for_allocation_prefetch;   // CPU 缓存优化 Allocation Prefetch 的保留空间，这里先不用关心</span><br><span class="line">  static unsigned _target_refills;                    //每个 GC 周期内期望的重填次数</span><br><span class="line"></span><br><span class="line">//以下是 TLAB 的主要构成 field</span><br><span class="line">HeapWord* _start;                              // TLAB 起始地址，表示堆内存地址都用 HeapWord* </span><br><span class="line">HeapWord* _top;                                // 上次分配的内存地址</span><br><span class="line">HeapWord* _end;                                // TLAB 结束地址</span><br><span class="line">size_t    _desired_size;                       // TLAB 大小 包括保留空间，表示内存大小都需要通过 size_t 类型，也就是实际字节数除以 HeapWordSize 的值</span><br><span class="line">size_t    _refill_waste_limit;                 // TLAB最大浪费空间，剩余空间不足分配浪费空间限制。在TLAB剩余空间不足的时候，根据这个值决定分配策略，如果浪费空间大于这个值则直接在 Eden 区分配，如果小于这个值则将当前 TLAB 放回 Eden 区管理并从 Eden 申请新的 TLAB 进行分配。 </span><br><span class="line">AdaptiveWeightedAverage _allocation_fraction;  // 当前 TLAB 分配比例 EMA</span><br><span class="line"></span><br><span class="line">//以下是我们这里不用太关心的 field</span><br><span class="line">HeapWord* _allocation_end;                    // TLAB 真正可以用来分配内存的结束地址，这个是 _end 结束地址排除保留空间（预留给 dummy object 的对象头空间）</span><br><span class="line">HeapWord* _pf_top;                            // Allocation Prefetch CPU 缓存优化机制相关需要的参数，这里先不用考虑</span><br><span class="line">size_t    _allocated_before_last_gc;          // 这个用于计算 图10 中的线程本轮 GC 分配空间的大小，记录上次 GC 时，线程分配的空间大小</span><br><span class="line">unsigned  _number_of_refills;                 // 线程分配内存数据采集相关，TLAB 剩余空间不足分配次数</span><br><span class="line">unsigned  _fast_refill_waste;                 // 线程分配内存数据采集相关，TLAB 快速分配浪费，快速分配就是直接在 TLAB 分配，这个在现在 JVM 中已经用不到了</span><br><span class="line">unsigned  _slow_refill_waste;                 // 线程分配内存数据采集相关，TLAB 慢速分配浪费，慢速分配就是重填一个 TLAB 分配</span><br><span class="line">unsigned  _gc_waste;                          // 线程分配内存数据采集相关，gc浪费</span><br><span class="line">unsigned  _slow_allocations;                  // 线程分配内存数据采集相关，TLAB 慢速分配计数 </span><br><span class="line">size_t    _allocated_size;                    // 分配的内存大小</span><br><span class="line">size_t    _bytes_since_last_sample_point;     // JVM TI 采集指标相关 field，这里不用关心</span><br></pre></td></tr></table></figure>

<h2 id="9-2-TLAB-初始化"><a href="#9-2-TLAB-初始化" class="headerlink" title="9.2. TLAB 初始化"></a>9.2. TLAB 初始化</h2><p>首先是 JVM 启动的时候，全局 TLAB 需要初始化： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::startup_initialization() &#123;</span><br><span class="line">  //初始化，也就是归零统计数据</span><br><span class="line">  ThreadLocalAllocStats::initialize();</span><br><span class="line"></span><br><span class="line">  // 假设平均下来，GC 扫描的时候，每个线程当前的 TLAB 都有一半的内存被浪费，这个每个线程使用内存的浪费的百分比率（也就是 TLABWasteTargetPercent），也就是等于（注意，仅最新的那个 TLAB 有浪费，之前 refill 退回的假设是没有浪费的）：1/2 * (每个 epoch 内每个线程期望 refill 次数) * 100</span><br><span class="line">  //那么每个 epoch 内每个线程 refill 次数配置就等于 50 / TLABWasteTargetPercent， 默认也就是 50 次。</span><br><span class="line">  _target_refills = 100 / (2 * TLABWasteTargetPercent);</span><br><span class="line">  // 但是初始的 _target_refills 需要设置最多不超过 2 次来减少 VM 初始化时候 GC 的可能性</span><br><span class="line">  _target_refills = MAX2(_target_refills, 2U);</span><br><span class="line"></span><br><span class="line">//如果 C2 JIT 编译存在并启用，则保留 CPU 缓存优化 Allocation Prefetch 空间，这个这里先不用关心，会在别的章节讲述</span><br><span class="line">#ifdef COMPILER2</span><br><span class="line">  if (is_server_compilation_mode_vm()) &#123;</span><br><span class="line">    int lines =  MAX2(AllocatePrefetchLines, AllocateInstancePrefetchLines) + 2;</span><br><span class="line">    _reserve_for_allocation_prefetch = (AllocatePrefetchDistance + AllocatePrefetchStepSize * lines) /</span><br><span class="line">                                       (int)HeapWordSize;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">  // 初始化 main 线程的 TLAB</span><br><span class="line">  guarantee(Thread::current()-&gt;is_Java_thread(), &quot;tlab initialization thread not Java thread&quot;);</span><br><span class="line">  Thread::current()-&gt;tlab().initialize();</span><br><span class="line">  log_develop_trace(gc, tlab)(&quot;TLAB min: &quot; SIZE_FORMAT &quot; initial: &quot; SIZE_FORMAT &quot; max: &quot; SIZE_FORMAT,</span><br><span class="line">                               min_size(), Thread::current()-&gt;tlab().initial_desired_size(), max_size());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个线程维护自己的 TLAB，同时每个线程的 TLAB 大小不一。TLAB 的大小主要由 Eden 的大小，线程数量，还有线程的对象分配速率决定。 在 Java 线程开始运行时，会先分配 TLAB： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/runtime/thread.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/runtime/thread.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码void JavaThread::run() &#123;</span><br><span class="line">  // initialize thread-local alloc buffer related fields</span><br><span class="line">  this-&gt;initialize_tlab();</span><br><span class="line">  //剩余代码忽略</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分配 TLAB 其实就是调用 ThreadLocalAllocBuffer 的 initialize 方法。 <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/runtime/thread.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/runtime/thread.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void initialize_tlab() &#123;</span><br><span class="line">    //如果没有通过 -XX:-UseTLAB 禁用 TLAB，则初始化TLAB</span><br><span class="line">    if (UseTLAB) &#123;</span><br><span class="line">      tlab().initialize();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Thread-Local Allocation Buffer (TLAB) support</span><br><span class="line">ThreadLocalAllocBuffer&amp; tlab()                 &#123;</span><br><span class="line">  return _tlab; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalAllocBuffer _tlab;</span><br></pre></td></tr></table></figure>

<p>ThreadLocalAllocBuffer 的 initialize 方法初始化 TLAB 的上面提到的我们要关心的各种 field：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::initialize() &#123;</span><br><span class="line">  //设置初始指针，由于还没有从 Eden 分配内存，所以这里都设置为 NULL</span><br><span class="line">  initialize(NULL,                    // start</span><br><span class="line">             NULL,                    // top</span><br><span class="line">             NULL);                   // end</span><br><span class="line">  //计算初始期望大小，并设置</span><br><span class="line">  set_desired_size(initial_desired_size());</span><br><span class="line">  //所有 TLAB 总大小，不同的 GC 实现有不同的 TLAB 容量， 一般是 Eden 区大小</span><br><span class="line">  //例如 G1 GC，就是等于 (_policy-&gt;young_list_target_length() - _survivor.length()) * HeapRegion::GrainBytes，可以理解为年轻代减去Survivor区，也就是Eden区</span><br><span class="line">  size_t capacity = Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize;</span><br><span class="line">  //计算这个线程的 TLAB 期望占用所有 TLAB 总体大小比例</span><br><span class="line">  //TLAB 期望占用大小也就是这个 TLAB 大小乘以期望 refill 的次数</span><br><span class="line">  float alloc_frac = desired_size() * target_refills() / (float) capacity;</span><br><span class="line">  //记录下来，用于计算 EMA</span><br><span class="line">  _allocation_fraction.sample(alloc_frac);</span><br><span class="line">  //计算初始 refill 最大浪费空间，并设置</span><br><span class="line">  //如前面原理部分所述，初始大小就是 TLAB 的大小（_desired_size） / TLABRefillWasteFraction</span><br><span class="line">  set_refill_waste_limit(initial_refill_waste_limit());</span><br><span class="line">  //重置统计</span><br><span class="line">  reset_statistics();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-1-初始期望大小是如何计算的呢？"><a href="#9-2-1-初始期望大小是如何计算的呢？" class="headerlink" title="9.2.1. 初始期望大小是如何计算的呢？"></a>9.2.1. 初始期望大小是如何计算的呢？</h3><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//计算初始大小</span><br><span class="line">size_t ThreadLocalAllocBuffer::initial_desired_size() &#123;</span><br><span class="line">  size_t init_sz = 0;</span><br><span class="line">  //如果通过 -XX:TLABSize 设置了 TLAB 大小，则用这个值作为初始期望大小</span><br><span class="line">  //表示堆内存占用大小都需要用占用几个 HeapWord 表示，所以用TLABSize / HeapWordSize</span><br><span class="line">  if (TLABSize &gt; 0) &#123;</span><br><span class="line">    init_sz = TLABSize / HeapWordSize;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    //获取当前epoch内线程数量期望，这个如之前所述通过 EMA 预测</span><br><span class="line">    unsigned int nof_threads = ThreadLocalAllocStats::allocating_threads_avg();</span><br><span class="line">    //不同的 GC 实现有不同的 TLAB 容量，Universe::heap()-&gt;tlab_capacity(thread()) 一般是 Eden 区大小</span><br><span class="line">    //例如 G1 GC，就是等于 (_policy-&gt;young_list_target_length() - _survivor.length()) * HeapRegion::GrainBytes，可以理解为年轻代减去Survivor区，也就是Eden区</span><br><span class="line">    //整体大小等于 Eden区大小/(当前 epcoh 内会分配对象期望线程个数 * 每个 epoch 内每个线程 refill 次数配置)</span><br><span class="line">    //target_refills已经在 JVM 初始化所有 TLAB 全局配置的时候初始化好了</span><br><span class="line">    init_sz  = (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize) /</span><br><span class="line">                      (nof_threads * target_refills());</span><br><span class="line">    //考虑对象对齐，得出最后的大小</span><br><span class="line">    init_sz = align_object_size(init_sz);</span><br><span class="line">  &#125;</span><br><span class="line">  //保持大小在  min_size() 还有 max_size() 之间</span><br><span class="line">  //min_size主要由 MinTLABSize 决定</span><br><span class="line">  init_sz = MIN2(MAX2(init_sz, min_size()), max_size());</span><br><span class="line">  return init_sz;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//最小大小由 MinTLABSize 决定，需要表示为 HeapWordSize，并且考虑对象对齐，最后的 alignment_reserve 是 dummy object 填充的对象头大小（这里先不考虑 JVM 的 CPU 缓存 prematch，我们会在其他章节详细分析）。</span><br><span class="line">static size_t min_size()                       &#123; </span><br><span class="line">    return align_object_size(MinTLABSize / HeapWordSize) + alignment_reserve(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-2-2-TLAB-最大大小是怎样决定的呢？"><a href="#9-2-2-TLAB-最大大小是怎样决定的呢？" class="headerlink" title="9.2.2. TLAB 最大大小是怎样决定的呢？"></a>9.2.2. TLAB 最大大小是怎样决定的呢？</h3><p>不同的 GC 方式，有不同的方式：</p>
<p><strong>G1 GC 中为大对象（humongous object）大小</strong>，也就是 G1 region 大小的一半：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码// For G1 TLABs should not contain humongous objects, so the maximum TLAB size</span><br><span class="line">// must be equal to the humongous object limit.</span><br><span class="line">size_t G1CollectedHeap::max_tlab_size() const &#123;</span><br><span class="line">  return align_down(_humongous_object_threshold_in_words, MinObjAlignment);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>ZGC 中为页大小的 8 分之一</strong>，类似的在大部分情况下 S<strong>henandoah GC 也是每个 Region 大小的 8 分之一</strong>。他们都是期望至少有 8 分之 7 的区域是不用退回的减少选择 Cset 的时候的扫描复杂度: <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shenandoah/shenandoahHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码MaxTLABSizeWords = MIN2(ShenandoahElasticTLAB ? RegionSizeWords : (RegionSizeWords / 8), HumongousThresholdWords);</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/z/zHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/z/zHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码const size_t      ZObjectSizeLimitSmall         = ZPageSizeSmall / 8;</span><br></pre></td></tr></table></figure>

<p>对于<strong>其他的 GC，则是 int 数组的最大大小</strong>，这个和为了填充 dummy object 表示 TLAB 的空区域有关。这个原因之前已经说明了。</p>
<h2 id="9-3-TLAB-分配内存"><a href="#9-3-TLAB-分配内存" class="headerlink" title="9.3. TLAB 分配内存"></a>9.3. TLAB 分配内存</h2><p>当 new 一个对象时，需要调用<code>instanceOop InstanceKlass::allocate_instance(TRAPS)</code> <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/oops/instanceKlass.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/oops/instanceKlass.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码instanceOop InstanceKlass::allocate_instance(TRAPS) &#123;</span><br><span class="line">  bool has_finalizer_flag = has_finalizer(); // Query before possible GC</span><br><span class="line">  int size = size_helper();  // Query before forming handle.</span><br><span class="line"></span><br><span class="line">  instanceOop i;</span><br><span class="line"></span><br><span class="line">  i = (instanceOop)Universe::heap()-&gt;obj_allocate(this, size, CHECK_NULL);</span><br><span class="line">  if (has_finalizer_flag &amp;&amp; !RegisterFinalizersAtInit) &#123;</span><br><span class="line">    i = register_finalizer(i, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line">  return i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其核心就是<code>heap()-&gt;obj_allocate(this, size, CHECK_NULL)</code>从堆上面分配内存： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/collectedHeap.inline.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/collectedHeap.inline.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码inline oop CollectedHeap::obj_allocate(Klass* klass, int size, TRAPS) &#123;</span><br><span class="line">  ObjAllocator allocator(klass, size, THREAD);</span><br><span class="line">  return allocator.allocate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用全局的 <code>ObjAllocator</code> 实现进行对象内存分配： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/memAllocator.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/memAllocator.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码oop MemAllocator::allocate() const &#123;</span><br><span class="line">  oop obj = NULL;</span><br><span class="line">  &#123;</span><br><span class="line">    Allocation allocation(*this, &amp;obj);</span><br><span class="line">    //分配堆内存，继续看下面一个方法</span><br><span class="line">    HeapWord* mem = mem_allocate(allocation);</span><br><span class="line">    if (mem != NULL) &#123;</span><br><span class="line">      obj = initialize(mem);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // The unhandled oop detector will poison local variable obj,</span><br><span class="line">      // so reset it to NULL if mem is NULL.</span><br><span class="line">      obj = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">HeapWord* MemAllocator::mem_allocate(Allocation&amp; allocation) const &#123;</span><br><span class="line">  //如果使用了 TLAB，则从 TLAB 分配，分配代码继续看下面一个方法</span><br><span class="line">  if (UseTLAB) &#123;</span><br><span class="line">    HeapWord* result = allocate_inside_tlab(allocation);</span><br><span class="line">    if (result != NULL) &#123;</span><br><span class="line">      return result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  //否则直接从 tlab 外分配</span><br><span class="line">  return allocate_outside_tlab(allocation);</span><br><span class="line">&#125;</span><br><span class="line">HeapWord* MemAllocator::allocate_inside_tlab(Allocation&amp; allocation) const &#123;</span><br><span class="line">  assert(UseTLAB, &quot;should use UseTLAB&quot;);</span><br><span class="line"></span><br><span class="line">  //从当前线程的 TLAB 分配内存，TLAB 快分配</span><br><span class="line">  HeapWord* mem = _thread-&gt;tlab().allocate(_word_size);</span><br><span class="line">  //如果没有分配失败则返回</span><br><span class="line">  if (mem != NULL) &#123;</span><br><span class="line">    return mem;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //如果分配失败则走 TLAB 慢分配，需要 refill 或者直接从 Eden 分配</span><br><span class="line">  return allocate_inside_tlab_slow(allocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-1-TLAB-快分配"><a href="#9-3-1-TLAB-快分配" class="headerlink" title="9.3.1. TLAB 快分配"></a>9.3.1. TLAB 快分配</h3><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码inline HeapWord* ThreadLocalAllocBuffer::allocate(size_t size) &#123;</span><br><span class="line">  //验证各个内存指针有效，也就是 _top 在 _start 和 _end 范围内</span><br><span class="line">  invariants();</span><br><span class="line">  HeapWord* obj = top();</span><br><span class="line">  //如果空间足够，则分配内存</span><br><span class="line">  if (pointer_delta(end(), obj) &gt;= size) &#123;</span><br><span class="line">    set_top(obj + size);</span><br><span class="line">    invariants();</span><br><span class="line">    return obj;</span><br><span class="line">  &#125;</span><br><span class="line">  return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-2-TLAB-慢分配"><a href="#9-3-2-TLAB-慢分配" class="headerlink" title="9.3.2. TLAB 慢分配"></a>9.3.2. TLAB 慢分配</h3><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/memAllocator.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/memAllocator.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码HeapWord* MemAllocator::allocate_inside_tlab_slow(Allocation&amp; allocation) const &#123;</span><br><span class="line">  HeapWord* mem = NULL;</span><br><span class="line">  ThreadLocalAllocBuffer&amp; tlab = _thread-&gt;tlab();</span><br><span class="line"></span><br><span class="line">  // 如果 TLAB 剩余空间大于 最大浪费空间，则记录并让最大浪费空间递增</span><br><span class="line">  if (tlab.free() &gt; tlab.refill_waste_limit()) &#123;</span><br><span class="line">    tlab.record_slow_allocation(_word_size);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //重新计算 TLAB 大小</span><br><span class="line">  size_t new_tlab_size = tlab.compute_size(_word_size);</span><br><span class="line">  //TLAB 放回 Eden 区</span><br><span class="line">  tlab.retire_before_allocation();</span><br><span class="line">  </span><br><span class="line">  if (new_tlab_size == 0) &#123;</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 计算最小大小</span><br><span class="line">  size_t min_tlab_size = ThreadLocalAllocBuffer::compute_min_size(_word_size);</span><br><span class="line">  //分配新的 TLAB 空间，并在里面分配对象</span><br><span class="line">  mem = Universe::heap()-&gt;allocate_new_tlab(min_tlab_size, new_tlab_size, &amp;allocation._allocated_tlab_size);</span><br><span class="line">  if (mem == NULL) &#123;</span><br><span class="line">    assert(allocation._allocated_tlab_size == 0,</span><br><span class="line">           &quot;Allocation failed, but actual size was updated. min: &quot; SIZE_FORMAT</span><br><span class="line">           &quot;, desired: &quot; SIZE_FORMAT &quot;, actual: &quot; SIZE_FORMAT,</span><br><span class="line">           min_tlab_size, new_tlab_size, allocation._allocated_tlab_size);</span><br><span class="line">    return NULL;</span><br><span class="line">  &#125;</span><br><span class="line">  assert(allocation._allocated_tlab_size != 0, &quot;Allocation succeeded but actual size not updated. mem at: &quot;</span><br><span class="line">         PTR_FORMAT &quot; min: &quot; SIZE_FORMAT &quot;, desired: &quot; SIZE_FORMAT,</span><br><span class="line">         p2i(mem), min_tlab_size, new_tlab_size);</span><br><span class="line">  //如果启用了 ZeroTLAB 这个 JVM 参数，则将对象所有字段置零值</span><br><span class="line">  if (ZeroTLAB) &#123;</span><br><span class="line">    // ..and clear it.</span><br><span class="line">    Copy::zero_to_words(mem, allocation._allocated_tlab_size);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // ...and zap just allocated object.</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //设置新的 TLAB 空间为当前线程的 TLAB</span><br><span class="line">  tlab.fill(mem, mem + _word_size, allocation._allocated_tlab_size);</span><br><span class="line">  //返回分配的对象内存地址</span><br><span class="line">  return mem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-1-TLAB最大浪费空间"><a href="#9-3-2-1-TLAB最大浪费空间" class="headerlink" title="9.3.2.1 TLAB最大浪费空间"></a>9.3.2.1 TLAB最大浪费空间</h4><p>TLAB最大浪费空间 <code>_refill_waste_limit</code> 初始值为 TLAB 大小除以 TLABRefillWasteFraction：<a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码size_t initial_refill_waste_limit()            &#123; return desired_size() / TLABRefillWasteFraction; &#125;</span><br></pre></td></tr></table></figure>

<p>每次慢分配，调用<code>record_slow_allocation(size_t obj_size)</code>记录慢分配的同时，增加 TLAB 最大浪费空间的大小：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::record_slow_allocation(size_t obj_size) &#123;</span><br><span class="line">  //每次慢分配，_refill_waste_limit 增加 refill_waste_limit_increment，也就是 TLABWasteIncrement</span><br><span class="line">  set_refill_waste_limit(refill_waste_limit() + refill_waste_limit_increment());</span><br><span class="line">  _slow_allocations++;</span><br><span class="line">  log_develop_trace(gc, tlab)(&quot;TLAB: %s thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;</span><br><span class="line">                              &quot; obj: &quot; SIZE_FORMAT</span><br><span class="line">                              &quot; free: &quot; SIZE_FORMAT</span><br><span class="line">                              &quot; waste: &quot; SIZE_FORMAT,</span><br><span class="line">                              &quot;slow&quot;, p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),</span><br><span class="line">                              obj_size, free(), refill_waste_limit());</span><br><span class="line">&#125;</span><br><span class="line">//refill_waste_limit_increment 就是 JVM 参数 TLABWasteIncrement</span><br><span class="line">static size_t refill_waste_limit_increment()   &#123; return TLABWasteIncrement; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-2-重新计算-TLAB-大小"><a href="#9-3-2-2-重新计算-TLAB-大小" class="headerlink" title="9.3.2.2. 重新计算 TLAB 大小"></a>9.3.2.2. 重新计算 TLAB 大小</h4><p>重新计算会取 当前堆剩余给 TLAB 可分配的空间 和 <strong>TLAB 期望大小 + 当前需要分配的空间大小</strong> 中的小的那个：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.inline.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码inline size_t ThreadLocalAllocBuffer::compute_size(size_t obj_size) &#123;</span><br><span class="line">  //获取当前堆剩余给 TLAB 可分配的空间</span><br><span class="line">  const size_t available_size = Universe::heap()-&gt;unsafe_max_tlab_alloc(thread()) / HeapWordSize;</span><br><span class="line">  //取 TLAB 可分配的空间 和 TLAB 期望大小 + 当前需要分配的空间大小 以及 TLAB 最大大小中的小的那个</span><br><span class="line">  size_t new_tlab_size = MIN3(available_size, desired_size() + align_object_size(obj_size), max_size());</span><br><span class="line"></span><br><span class="line">  // 确保大小大于 dummy obj 对象头</span><br><span class="line">  if (new_tlab_size &lt; compute_min_size(obj_size)) &#123;</span><br><span class="line">    log_trace(gc, tlab)(&quot;ThreadLocalAllocBuffer::compute_size(&quot; SIZE_FORMAT &quot;) returns failure&quot;,</span><br><span class="line">                        obj_size);</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line">  log_trace(gc, tlab)(&quot;ThreadLocalAllocBuffer::compute_size(&quot; SIZE_FORMAT &quot;) returns &quot; SIZE_FORMAT,</span><br><span class="line">                      obj_size, new_tlab_size);</span><br><span class="line">  return new_tlab_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-3-2-3-当前-TLAB-放回堆"><a href="#9-3-2-3-当前-TLAB-放回堆" class="headerlink" title="9.3.2.3. 当前 TLAB 放回堆"></a>9.3.2.3. 当前 TLAB 放回堆</h4><p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//在TLAB慢分配被调用，当前 TLAB 放回堆</span><br><span class="line">void ThreadLocalAllocBuffer::retire_before_allocation() &#123;</span><br><span class="line">  //将当前 TLAB 剩余空间大小加入慢分配浪费空间大小</span><br><span class="line">  _slow_refill_waste += (unsigned int)remaining();</span><br><span class="line">  //执行 TLAB 退还给堆，这个在后面 GC 的时候还会被调用用于将所有的线程的 TLAB 退回堆</span><br><span class="line">  retire();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//对于 TLAB 慢分配，stats 为空</span><br><span class="line">//对于 GC 的时候调用，stats 用于记录每个线程的数据</span><br><span class="line">void ThreadLocalAllocBuffer::retire(ThreadLocalAllocStats* stats) &#123;</span><br><span class="line">  </span><br><span class="line">  if (stats != NULL) &#123;</span><br><span class="line">    accumulate_and_reset_statistics(stats);</span><br><span class="line">  &#125;</span><br><span class="line">  //如果当前 TLAB 有效</span><br><span class="line">  if (end() != NULL) &#123;</span><br><span class="line">    invariants();</span><br><span class="line">    //将用了的空间记录如线程分配对象大小记录</span><br><span class="line">    thread()-&gt;incr_allocated_bytes(used_bytes());</span><br><span class="line">    //填充dummy object</span><br><span class="line">    insert_filler();</span><br><span class="line">    //清空当前 TLAB 指针</span><br><span class="line">    initialize(NULL, NULL, NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-4-GC-相关-TLAB-操作"><a href="#9-4-GC-相关-TLAB-操作" class="headerlink" title="9.4. GC 相关 TLAB 操作"></a>9.4. GC 相关 TLAB 操作</h2><h3 id="9-4-1-GC-前"><a href="#9-4-1-GC-前" class="headerlink" title="9.4.1. GC 前"></a>9.4.1. GC 前</h3><p>不同的 GC 可能实现不一样，但是 TLAB 操作的时机是基本一样的，这里以 G1 GC 为例，在真正 GC 前：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void G1CollectedHeap::gc_prologue(bool full) &#123;</span><br><span class="line">  //省略其他代码</span><br><span class="line"></span><br><span class="line">  // Fill TLAB&apos;s and such</span><br><span class="line">  &#123;</span><br><span class="line">    Ticks start = Ticks::now();</span><br><span class="line">    //确保堆内存是可以解析的</span><br><span class="line">    ensure_parsability(true);</span><br><span class="line">    Tickspan dt = Ticks::now() - start;</span><br><span class="line">    phase_times()-&gt;record_prepare_tlab_time_ms(dt.seconds() * MILLIUNITS);</span><br><span class="line">  &#125;</span><br><span class="line">  //省略其他代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为何要确保堆内存是可以解析的呢？这样有利于更快速的扫描堆上对象。确保内存可以解析里面做了什么呢？其实主要就是退还每个线程的 TLAB 以及填充 dummy object。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void CollectedHeap::ensure_parsability(bool retire_tlabs) &#123;</span><br><span class="line">  //真正的 GC 肯定发生在安全点上，这个在后面安全点章节会详细说明</span><br><span class="line">  assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),</span><br><span class="line">         &quot;Should only be called at a safepoint or at start-up&quot;);</span><br><span class="line"></span><br><span class="line">  ThreadLocalAllocStats stats;</span><br><span class="line">  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next();) &#123;</span><br><span class="line">    BarrierSet::barrier_set()-&gt;make_parsable(thread);</span><br><span class="line">    //如果全局启用了 TLAB</span><br><span class="line">    if (UseTLAB) &#123;</span><br><span class="line">      //如果指定要回收，则回收 TLAB</span><br><span class="line">      if (retire_tlabs) &#123;</span><br><span class="line">        //回收 TLAB，调用  9.3.2.3. 当前 TLAB 放回堆 提到的 retire 方法</span><br><span class="line">        thread-&gt;tlab().retire(&amp;stats);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        //当前如果不回收，则将 TLAB 填充 Dummy Object 利于解析</span><br><span class="line">        thread-&gt;tlab().make_parsable();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  stats.publish();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-4-2-GC-后"><a href="#9-4-2-GC-后" class="headerlink" title="9.4.2. GC 后"></a>9.4.2. GC 后</h3><p>不同的 GC 可能实现不一样，但是 TLAB 操作的时机是基本一样的，这里以 G1 GC 为例，在 GC 后：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/g1/g1CollectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/g1/g1CollectedHeap.cpp</code></a> <code>_desired_size</code>是什么时候变得呢？怎么变得呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码void G1CollectedHeap::gc_epilogue(bool full) &#123;</span><br><span class="line">    //省略其他代码</span><br><span class="line">    resize_all_tlabs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/collectedHeap.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/collectedHeap.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void CollectedHeap::resize_all_tlabs() &#123;</span><br><span class="line">  //需要在安全点，GC 会处于安全点的</span><br><span class="line">  assert(SafepointSynchronize::is_at_safepoint() || !is_init_completed(),</span><br><span class="line">         &quot;Should only resize tlabs at safepoint&quot;);</span><br><span class="line">  //如果 UseTLAB 和 ResizeTLAB 都是打开的（默认就是打开的）</span><br><span class="line">  if (UseTLAB &amp;&amp; ResizeTLAB) &#123;</span><br><span class="line">    for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thread = jtiwh.next(); ) &#123;</span><br><span class="line">      //重新计算每个线程 TLAB 期望大小</span><br><span class="line">      thread-&gt;tlab().resize();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新计算每个线程 TLAB 期望大小： <a href="https://github.com/openjdk/jdk/blob/jdk-17%2B7/src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/gc/shared/threadLocalAllocBuffer.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码void ThreadLocalAllocBuffer::resize() &#123;</span><br><span class="line">  assert(ResizeTLAB, &quot;Should not call this otherwise&quot;);</span><br><span class="line">  //根据 _allocation_fraction 这个 EMA 采集得出平均数乘以Eden区大小，得出 TLAB 当前预测占用内存比例</span><br><span class="line">  size_t alloc = (size_t)(_allocation_fraction.average() *</span><br><span class="line">                          (Universe::heap()-&gt;tlab_capacity(thread()) / HeapWordSize));</span><br><span class="line">  //除以目标 refill 次数就是新的 TLAB 大小，和初始化时候的计算方法差不多</span><br><span class="line">  size_t new_size = alloc / _target_refills;</span><br><span class="line">  //保证在 min_size 还有 max_size 之间</span><br><span class="line">  new_size = clamp(new_size, min_size(), max_size());</span><br><span class="line"></span><br><span class="line">  size_t aligned_new_size = align_object_size(new_size);</span><br><span class="line"></span><br><span class="line">  log_trace(gc, tlab)(&quot;TLAB new size: thread: &quot; INTPTR_FORMAT &quot; [id: %2d]&quot;</span><br><span class="line">                      &quot; refills %d  alloc: %8.6f desired_size: &quot; SIZE_FORMAT &quot; -&gt; &quot; SIZE_FORMAT,</span><br><span class="line">                      p2i(thread()), thread()-&gt;osthread()-&gt;thread_id(),</span><br><span class="line">                      _target_refills, _allocation_fraction.average(), desired_size(), aligned_new_size);</span><br><span class="line">  //设置新的 TLAB 大小</span><br><span class="line">  set_desired_size(aligned_new_size);</span><br><span class="line">  //重置 TLAB 最大浪费空间</span><br><span class="line">  set_refill_waste_limit(initial_refill_waste_limit());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925218236208250887" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析(额外加菜) 8 通过</title>
    <url>/6925218412893306894.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol start="12">
<li><h1 id="监控-TLAB-慢分配与-TLAB-外分配-JFR-相关事件解析"><a href="#监控-TLAB-慢分配与-TLAB-外分配-JFR-相关事件解析" class="headerlink" title="监控 TLAB 慢分配与 TLAB 外分配 - JFR 相关事件解析"></a>监控 TLAB 慢分配与 TLAB 外分配 - JFR 相关事件解析</h1></li>
</ol>
<p>我们可以通过 JFR 来监控 TLAB 慢分配或者 TLAB 外分配事件。也就是<code>jdk.ObjectAllocationOutsideTLAB</code>与<code>jdk.ObjectAllocationInNewTLAB</code>这两个事件。</p>
<p><code>jdk.ObjectAllocationOutsideTLAB</code> 和 <code>jdk.ObjectAllocationInNewTLAB</code> 这两个事件在<a href="https://github.com/openjdk/jdk/blob/master/src/jdk.jfr/share/conf/jfr/default.jfc" target="_blank" rel="noopener"><code>default.jfc</code></a>中( JFR 默认事件采集配置)是没有开启采集的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码&lt;event name=&quot;jdk.ObjectAllocationInNewTLAB&quot;&gt;</span><br><span class="line">  &lt;setting name=&quot;enabled&quot;&gt;false&lt;/setting&gt;</span><br><span class="line">  &lt;setting name=&quot;stackTrace&quot;&gt;true&lt;/setting&gt;</span><br><span class="line">&lt;/event&gt;</span><br><span class="line"></span><br><span class="line">&lt;event name=&quot;jdk.ObjectAllocationOutsideTLAB&quot;&gt;</span><br><span class="line">  &lt;setting name=&quot;enabled&quot;&gt;false&lt;/setting&gt;</span><br><span class="line">  &lt;setting name=&quot;stackTrace&quot;&gt;true&lt;/setting&gt;</span><br><span class="line">&lt;/event&gt;</span><br></pre></td></tr></table></figure>

<p>一般的，采集这两个事件，是需要连着堆栈一起采集，但是无法通过持续时间（因为这个事件没有持续时间这一概念）限制采集哪些，也就是只要开启就是全部采集，所以<strong>不建议长期开启这个采集</strong>。而是通过一些其他的监控项，<strong>按照需要，动态开启这个采集一段时间</strong>，之后关闭并 dump 出 JFR 文件用于分析。</p>
<p>那么一般根据什么指标判断呢？一般的，<strong>当 Young GC 过于频繁时</strong>，我们就要考虑是不是由于 TLAB 造成很多空间被浪费导致 GC 频繁了。至于如果采集 Young GC 频率从而动态开启，这个会在后面的<strong>动态监控</strong>章节详细说明。</p>
<p>我们还用上面的程序，根据之前的日志，对于 1KB 的对象，应该有两次 <code>jdk.ObjectAllocationInNewTLAB</code> 事件，第一次是线程第一次申请 TLAB，第二次是在分配第 512 个对象的时候，TLAB 剩余空间不足，同时剩余空间小于最大浪费空间限制，所以申请新的 TLAB 分配。对于 1KB 的分配，没有发生 <code>jdk.ObjectAllocationOutsideTLAB</code>。对于 100KB 的对象分配，在第五次分配时，TLAB 剩余空间不足，但是剩余空间大于最大浪费空间限制，直接在 Eden 区分配，同时将最大浪费空间限制增加 4。在第 114 次对象分配时，最大浪费空间限制达到了剩余空间，所以申请新的 TLAB 分配。所以对于 100KB 对象的 200 次分配里面，<code>jdk.ObjectAllocationInNewTLAB</code>也只有两次。</p>
<p>同时由于开启了 JFR，导致 TLAB 可能会被占用一部分，所以<strong>上面说的这些次数可能不太准确</strong>，不过没关系，大体上应该是对的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码//对于字节数组对象头占用16字节</span><br><span class="line">private static final int BYTE_ARRAY_OVERHEAD = 16;</span><br><span class="line">//我们要测试的对象大小是100kb</span><br><span class="line">private static final int OBJECT_SIZE = 100 * 1024;</span><br><span class="line">//需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[]全部会被省略，只剩最后一次的</span><br><span class="line">public static byte[] tmp;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    WhiteBox whiteBox = WhiteBox.getWhiteBox();</span><br><span class="line">    //初始化 JFR 记录</span><br><span class="line">    Recording recording = new Recording();</span><br><span class="line">    //启用 jdk.ObjectAllocationOutsideTLAB 事件监控</span><br><span class="line">    recording.enable(&quot;jdk.ObjectAllocationOutsideTLAB&quot;);</span><br><span class="line">    recording.enable(&quot;jdk.ObjectAllocationInNewTLAB&quot;);</span><br><span class="line">    // JFR 记录启动</span><br><span class="line">    recording.start();</span><br><span class="line"></span><br><span class="line">    //强制 fullGC 防止接下来程序发生 GC</span><br><span class="line">    //同时可以区分出初始化带来的其他线程的TLAB相关的日志</span><br><span class="line">    whiteBox.fullGC();</span><br><span class="line">    //分配对象，大小1KB</span><br><span class="line">    for (int i = 0; i &lt; 512; ++i) &#123;</span><br><span class="line">        tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">    &#125;</span><br><span class="line">    //强制 fullGC，回收所有 TLAB</span><br><span class="line">    whiteBox.fullGC();</span><br><span class="line">    //分配对象，大小100KB</span><br><span class="line">    for (int i = 0; i &lt; 200; ++i) &#123;</span><br><span class="line">        tmp = new byte[OBJECT_SIZE * 100 - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">    &#125;</span><br><span class="line">    whiteBox.fullGC();</span><br><span class="line"></span><br><span class="line">    //将 JFR 记录 dump 到一个文件</span><br><span class="line">    Path path = new File(new File(&quot;.&quot;).getAbsolutePath(), &quot;recording-&quot; + recording.getId() + &quot;-pid&quot; + ProcessHandle.current().pid() + &quot;.jfr&quot;).toPath();</span><br><span class="line">    recording.dump(path);</span><br><span class="line">    int countOf1KBObjectAllocationInNewTLAB = 0;</span><br><span class="line">    int countOf100KBObjectAllocationInNewTLAB = 0;</span><br><span class="line">    int countOf1KBObjectAllocationOutsideTLAB = 0;</span><br><span class="line">    int countOf100KBObjectAllocationOutsideTLAB = 0;</span><br><span class="line">    //读取文件中的所有 JFR 事件</span><br><span class="line">    for (RecordedEvent event : RecordingFile.readAllEvents(path)) &#123;</span><br><span class="line">        //获取分配的对象的类型</span><br><span class="line">        String className = event.getString(&quot;objectClass.name&quot;);</span><br><span class="line"></span><br><span class="line">        if (</span><br><span class="line">            //确保分配类型是 byte[]</span><br><span class="line">                BYTE_ARRAY_CLASS_NAME.equalsIgnoreCase(className)</span><br><span class="line">        ) &#123;</span><br><span class="line">            RecordedFrame recordedFrame = event.getStackTrace().getFrames().get(0);</span><br><span class="line">            //同时必须是咱们这里的main方法分配的对象，并且是Java堆栈中的main方法</span><br><span class="line">            if (recordedFrame.isJavaFrame()</span><br><span class="line">                    &amp;&amp; &quot;main&quot;.equalsIgnoreCase(recordedFrame.getMethod().getName())</span><br><span class="line">            ) &#123;</span><br><span class="line">                //获取分配对象大小</span><br><span class="line">                long allocationSize = event.getLong(&quot;allocationSize&quot;);</span><br><span class="line">                //统计各种事件个数</span><br><span class="line">                if (&quot;jdk.ObjectAllocationOutsideTLAB&quot;.equalsIgnoreCase(event.getEventType().getName())) &#123;</span><br><span class="line">                    if (allocationSize == 102400) &#123;</span><br><span class="line">                        countOf100KBObjectAllocationOutsideTLAB++;</span><br><span class="line">                    &#125; else if (allocationSize == 1024) &#123;</span><br><span class="line">                        countOf1KBObjectAllocationOutsideTLAB++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else if (&quot;jdk.ObjectAllocationInNewTLAB&quot;.equalsIgnoreCase(event.getEventType().getName())) &#123;</span><br><span class="line">                    if (allocationSize == 102400) &#123;</span><br><span class="line">                        countOf100KBObjectAllocationInNewTLAB++;</span><br><span class="line">                    &#125; else if (allocationSize == 1024) &#123;</span><br><span class="line">                        countOf1KBObjectAllocationInNewTLAB++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; else &#123;</span><br><span class="line">                    throw new Exception(&quot;unexpected size of TLAB event&quot;);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(&quot;countOf1KBObjectAllocationInNewTLAB: &quot; + countOf1KBObjectAllocationInNewTLAB);</span><br><span class="line">    System.out.println(&quot;countOf100KBObjectAllocationInNewTLAB: &quot; + countOf100KBObjectAllocationInNewTLAB);</span><br><span class="line">    System.out.println(&quot;countOf1KBObjectAllocationOutsideTLAB: &quot; + countOf1KBObjectAllocationOutsideTLAB);</span><br><span class="line">    System.out.println(&quot;countOf100KBObjectAllocationOutsideTLAB: &quot; + countOf100KBObjectAllocationOutsideTLAB);</span><br><span class="line">    //阻塞程序，保证所有日志输出完</span><br><span class="line">    Thread.currentThread().join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出应该近似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码//省略其他事件的详细信息，这里每种挑一个展示</span><br><span class="line">jdk.ObjectAllocationInNewTLAB &#123;</span><br><span class="line">  startTime = 13:07:51.681</span><br><span class="line">  objectClass = byte[] (classLoader = bootstrap)</span><br><span class="line">  allocationSize = 1.0 kB</span><br><span class="line">  tlabSize = 478.2 kB</span><br><span class="line">  eventThread = &quot;main&quot; (javaThreadId = 1)</span><br><span class="line">  stackTrace = [</span><br><span class="line">    com.github.hashjang.jfr.test.TestAllocOutsideTLAB.main(String[]) line: 96</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">jdk.ObjectAllocationInNewTLAB &#123;</span><br><span class="line">  startTime = 13:07:51.777</span><br><span class="line">  objectClass = byte[] (classLoader = bootstrap)</span><br><span class="line">  allocationSize = 100.0 kB</span><br><span class="line">  tlabSize = 512.0 kB</span><br><span class="line">  eventThread = &quot;main&quot; (javaThreadId = 1)</span><br><span class="line">  stackTrace = [</span><br><span class="line">    com.github.hashjang.jfr.test.TestAllocOutsideTLAB.main(String[]) line: 102</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jdk.ObjectAllocationOutsideTLAB &#123;</span><br><span class="line">  startTime = 13:07:51.784</span><br><span class="line">  objectClass = byte[] (classLoader = bootstrap)</span><br><span class="line">  allocationSize = 100.0 kB</span><br><span class="line">  eventThread = &quot;main&quot; (javaThreadId = 1)</span><br><span class="line">  stackTrace = [</span><br><span class="line">    com.github.hashjang.jfr.test.TestAllocOutsideTLAB.main(String[]) line: 102</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line">//省略其他事件的详细信息，这里每种挑一个展示</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">countOf1KBObjectAllocationInNewTLAB: 2</span><br><span class="line">countOf100KBObjectAllocationInNewTLAB: 2</span><br><span class="line">countOf1KBObjectAllocationOutsideTLAB: 0</span><br><span class="line">countOf100KBObjectAllocationOutsideTLAB: 190</span><br></pre></td></tr></table></figure>

<p>可以看出<code>jdk.ObjectAllocationInNewTLAB</code>包含：</p>
<ul>
<li>开始时间：<code>startTime = 13:07:51.784</code></li>
<li>分配对象类型：<code>objectClass = byte[] (classLoader = bootstrap)</code></li>
<li>分配大小：<code>allocationSize = 100.0 kB</code></li>
<li>新的 TLAB 大小：<code>tlabSize = 512.0 kB</code></li>
<li>线程：<code>eventThread = &quot;main&quot; (javaThreadId = 1)</code></li>
<li>堆栈</li>
</ul>
<p><code>jdk.ObjectAllocationOutsideTLAB</code>包含：</p>
<ul>
<li>开始时间：<code>startTime = 13:07:51.784</code></li>
<li>分配对象类型：<code>objectClass = byte[] (classLoader = bootstrap)</code></li>
<li>分配大小：<code>allocationSize = 100.0 kB</code></li>
<li>线程：<code>eventThread = &quot;main&quot; (javaThreadId = 1)</code></li>
<li>堆栈</li>
</ul>
<p>我们一般通过 JMC 查看 JFR 监控的文件，通过事件查看器就可以查看其中的事件，可以参考我的另一系列：<a href="http://" target="_blank" rel="noopener">JFR 全解</a></p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925218412893306894" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM TLAB 分析(额外加菜) 7 TLA</title>
    <url>/6925218324183777288.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<blockquote>
<p>今天，又是干货满满的一天。这是全网最硬核 JVM 系列的开篇，首先从 TLAB 开始。由于文章很长，每个人阅读习惯不同，所以特此拆成单篇版和多篇版</p>
</blockquote>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 JVM TLAB 分析（单篇版不包含额外加菜）</a></li>
<li><a href="https://dev.newban.cn/6925217843055165454">全网最硬核 JVM TLAB 分析 1. 内存分配思想引入</a></li>
<li><a href="https://dev.newban.cn/6925217911355211789">全网最硬核 JVM TLAB 分析 2. TLAB生命周期与带来的问题思考</a></li>
<li><a href="https://dev.newban.cn/6925217757269065736">全网最硬核 JVM TLAB 分析 3. JVM EMA期望算法与TLAB相关JVM启动参数</a></li>
<li><a href="https://dev.newban.cn/6925218101147484167">全网最硬核 JVM TLAB 分析 4. TLAB 基本流程全分析</a></li>
<li><a href="https://dev.newban.cn/6925218236208250887">全网最硬核 JVM TLAB 分析 5. TLAB 源代码全解析</a></li>
<li><a href="https://dev.newban.cn/6925218189395787783">全网最硬核 JVM TLAB 分析 6. TLAB 相关热门Q&amp;A汇总</a></li>
<li><a href="https://dev.newban.cn/6925218324183777288">全网最硬核 JVM TLAB 分析(额外加菜) 7. TLAB 相关 JVM 日志解析</a></li>
<li><a href="https://dev.newban.cn/6925218412893306894">全网最硬核 JVM TLAB 分析(额外加菜) 8. 通过 JFR 监控 TLAB</a></li>
</ul>
</blockquote>
<ol start="11">
<li><h1 id="TLAB-相关-JVM-日志解析"><a href="#TLAB-相关-JVM-日志解析" class="headerlink" title="TLAB 相关 JVM 日志解析"></a>TLAB 相关 JVM 日志解析</h1></li>
</ol>
<h2 id="11-1-准备-Java-WhiteBox-API"><a href="#11-1-准备-Java-WhiteBox-API" class="headerlink" title="11.1. 准备 Java WhiteBox API"></a>11.1. 准备 Java WhiteBox API</h2><p>首先需要准备好<strong>Java WhiteBox API</strong></p>
<h2 id="11-1-1-什么是-WhiteBox-API"><a href="#11-1-1-什么是-WhiteBox-API" class="headerlink" title="11.1.1. 什么是 WhiteBox API"></a>11.1.1. 什么是 WhiteBox API</h2><p>WhiteBox API 是 HotSpot VM 自带的白盒测试工具，将内部的很多核心机制的 API 暴露出来，用于白盒测试 JVM，压测 JVM 特性，以及辅助学习理解 JVM 并调优参数。WhiteBox API 是 Java 7 引入的，目前 Java 8 LTS 以及 Java 11 LTS（其实是 Java 9+ 以后的所有版本，这里只关心 LTS 版本，Java 9 引入了模块化所以 WhiteBox API 有所变化）都是有的。但是默认这个 API 并没有编译在 JDK 之中，但是他的实现是编译在了 JDK 里面了。所以如果想用这个 API，需要用户自己编译需要的 API，并加入 Java 的 BootClassPath 并启用 WhiteBox API。</p>
<h2 id="11-1-2-WhiteBox-API-如何实现的"><a href="#11-1-2-WhiteBox-API-如何实现的" class="headerlink" title="11.1.2. WhiteBox API 如何实现的"></a>11.1.2. WhiteBox API 如何实现的</h2><p>WhiteBox API 是一个 Java 类，<strong>位于 JDK 的测试包中，默认没有编译进标准发行版的 JDK 中</strong>。</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/test/lib/sun/hotspot/WhiteBox.java" target="_blank" rel="noopener"><code>test/lib/sun/hotspot/WhiteBox.java</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package sun.hotspot;</span><br><span class="line">public class WhiteBox &#123;</span><br><span class="line">  //仅举两个例子，省略其他 api 以及代码</span><br><span class="line">  // Force Young GC</span><br><span class="line">  public native void youngGC();</span><br><span class="line">  // Force Full GC</span><br><span class="line">  public native void fullGC();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，其实里面的所有 API 都是 <strong>JNI 调用</strong>，具体实现是：</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/share/prims/whitebox.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/prims/whitebox.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))</span><br><span class="line">  Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);</span><br><span class="line">  Universe::heap()-&gt;collect(GCCause::_wb_full_gc);</span><br><span class="line">#if INCLUDE_G1GC</span><br><span class="line">  if (UseG1GC) &#123;</span><br><span class="line">    // Needs to be cleared explicitly for G1</span><br><span class="line">    Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);</span><br><span class="line">  &#125;</span><br><span class="line">#endif // INCLUDE_G1GC</span><br><span class="line">WB_END</span><br><span class="line"></span><br><span class="line">WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))</span><br><span class="line">  Universe::heap()-&gt;collect(GCCause::_wb_young_gc);</span><br><span class="line">WB_END</span><br><span class="line"></span><br><span class="line">&#123;CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC &#125;,</span><br><span class="line">&#123;CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC &#125;,</span><br><span class="line"></span><br><span class="line">//省略其他代码</span><br></pre></td></tr></table></figure>

<p>可以看出，JNI 调用实现直接调用了底层 JVM 的相关接口，相当于把 JVM 的一些关键机制暴露出来，用于白盒测试。但是如之前所说，JDK 发行版没有包括 test 下的测试代码，也就是 WhiteBox API 所在的 jar 包并没有打进默认的 JDK 中。这就需要我们自己编译一下这个代码。</p>
<h2 id="11-1-3-什么是-BootClassPath"><a href="#11-1-3-什么是-BootClassPath" class="headerlink" title="11.1.3. 什么是 BootClassPath"></a>11.1.3. 什么是 BootClassPath</h2><p>Java 内有三种不同的类加载器：<strong>应用类加载器</strong>（application classloader），<strong>扩展类加载器</strong>（extension classloader）还有<strong>根类加载器</strong>（bootstrap classloader）</p>
<ul>
<li><strong>应用类加载器</strong>，加载我们classpath目录下的所有类文件</li>
<li><strong>扩展类加载器</strong>，加载标准 Java 类库扩展的类，就是你的jre目录下的/lib/ext目录下的所有类</li>
<li><strong>根类加载器</strong>（bootstrap classloader），扫描 <strong>BootClassPath</strong> 下的 标准 Java 类库的类加载器。标准 Java 类库限制了一些包路径的类，必须通过<strong>根类加载器</strong>加载。</li>
</ul>
<p>对于 WhiteBox API，由于是他的包为<code>sun.hotspot</code>，普通的类加载器是不能加载这个包路径的类的，需要通过<strong>根类加载器</strong>加载。</p>
<h2 id="11-1-4-怎么指定-BootClassPath"><a href="#11-1-4-怎么指定-BootClassPath" class="headerlink" title="11.1.4. 怎么指定 BootClassPath"></a>11.1.4. 怎么指定 BootClassPath</h2><p>在 Java 8，通过 <code>-Xbootclasspath:</code> 或者 <code>-Xbootclasspath/p:</code>指定，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码-Xbootclasspath:/home/project/whitebox.jar</span><br><span class="line">-Xbootclasspath/p:/home/project/whitebox.jar</span><br></pre></td></tr></table></figure>

<p>在 Java 9 之后的版本，这两个参数已经过期了，需要改成<code>-Xbootclasspath/a:</code>，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码-Xbootclasspath/a:/home/project/whitebox.jar</span><br></pre></td></tr></table></figure>

<p>否则会报错<code>-Xbootclasspath is no longer a supported option.</code></p>
<p>这里对应的 JDK 源码是： <a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/arguments.cpp" target="_blank" rel="noopener"><code>src/hotspot/share/runtime/arguments.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码// -bootclasspath:</span><br><span class="line">&#125; else if (match_option(option, &quot;-Xbootclasspath:&quot;, &amp;tail)) &#123;</span><br><span class="line">    jio_fprintf(defaultStream::output_stream(),</span><br><span class="line">      &quot;-Xbootclasspath is no longer a supported option.\n&quot;);</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">// -bootclasspath/a:</span><br><span class="line">&#125; else if (match_option(option, &quot;-Xbootclasspath/a:&quot;, &amp;tail)) &#123;</span><br><span class="line">  //将参数添加到 bootclasspath 中</span><br><span class="line">  Arguments::append_sysclasspath(tail);</span><br><span class="line">// -bootclasspath/p:</span><br><span class="line">&#125; else if (match_option(option, &quot;-Xbootclasspath/p:&quot;, &amp;tail)) &#123;</span><br><span class="line">    jio_fprintf(defaultStream::output_stream(),</span><br><span class="line">      &quot;-Xbootclasspath/p is no longer a supported option.\n&quot;);</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-1-5-使用-WhiteBox-API"><a href="#11-1-5-使用-WhiteBox-API" class="headerlink" title="11.1.5. 使用 WhiteBox API"></a>11.1.5. 使用 WhiteBox API</h2><p><strong>1. 编译 WhiteBox API</strong></p>
<p>将<code>https://github.com/openjdk/jdk/tree/master/test/lib</code>路径下的<code>sun</code>目录取出，编译成一个 jar 包，名字假设是 <code>whitebox.jar</code></p>
<p><strong>2. 编写测试程序</strong></p>
<p>将 <code>whitebox.jar</code> 添加到你的项目依赖，之后写代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        WhiteBox whiteBox = WhiteBox.getWhiteBox();</span><br><span class="line">        //获取 ReservedCodeCacheSize 这个 JVM flag 的值</span><br><span class="line">        Long reservedCodeCacheSize = whiteBox.getUintxVMFlag(&quot;ReservedCodeCacheSize&quot;);</span><br><span class="line">        System.out.println(reservedCodeCacheSize);</span><br><span class="line">        //打印堆内存各项指标</span><br><span class="line">        whiteBox.printHeapSizes();</span><br><span class="line">        //执行full GC</span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        </span><br><span class="line">        //保持进程不退出，保证日志打印完整</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 启动程序查看效果</strong></p>
<p>使用启动参数 <code>-Xbootclasspath/a:/home/project/whitebox.jar -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -Xlog:gc</code> 启动程序。其中前三个 Flag 表示启用 WhiteBox API，最后一个表示打印 GC info 级别的日志到控制台。</p>
<p>我的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码[0.025s][info][gc] Using G1</span><br><span class="line">251658240</span><br><span class="line">Minimum heap 8388608 Initial heap 268435456 Maximum heap 4276092928 Space alignment 2097152 Heap alignment 2097152</span><br><span class="line">[0.899s][info][gc] GC(0) Pause Full (WhiteBox Initiated Full GC) 5M-&gt;0M(20M) 45.183ms</span><br></pre></td></tr></table></figure>

<p>至此，我们就准备好了 WhiteBox 调试环境</p>
<h2 id="11-2-测试-TLAB-查看日志"><a href="#11-2-测试-TLAB-查看日志" class="headerlink" title="11.2. 测试 TLAB 查看日志"></a>11.2. 测试 TLAB 查看日志</h2><p>编写测试代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码//对于字节数组对象头占用16字节</span><br><span class="line">private static final int BYTE_ARRAY_OVERHEAD = 16;</span><br><span class="line">//我们要测试的对象大小是100kb</span><br><span class="line">private static final int OBJECT_SIZE = 100 * 1024;</span><br><span class="line">//需要使用静态field，而不是方法内本地变量，否则编译后循环内的new byte[]全部会被省略，只剩最后一次的</span><br><span class="line">public static byte[] tmp;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">        WhiteBox whiteBox = WhiteBox.getWhiteBox();</span><br><span class="line">        //强制 fullGC 防止接下来程序发生 GC</span><br><span class="line">        //同时可以区分出初始化带来的其他线程的TLAB相关的日志</span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        //分配对象，大小1KB</span><br><span class="line">        for (int i = 1; i &lt; 512; ++i) &#123;</span><br><span class="line">            tmp = new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">        &#125;</span><br><span class="line">        //强制 fullGC，回收所有 TLAB</span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        //分配对象，大小100KB</span><br><span class="line">        for (int i = 1; i &lt; 500; ++i) &#123;</span><br><span class="line">            tmp = new byte[OBJECT_SIZE * 100 - BYTE_ARRAY_OVERHEAD];</span><br><span class="line">        &#125;</span><br><span class="line">        whiteBox.fullGC();</span><br><span class="line">        //阻塞程序，保证所有日志输出完</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>之后，我们以如下的启动参数（前三个启动参数是我们前面章节提到的启用 WhiteBox API 需要的参数）启动这个程序，查看日志（关于日志配置，请参考之前的章节）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码-Xbootclasspath/a:./jdk-white-box-17.0-SNAPSHOT.jar</span><br><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+WhiteBoxAPI</span><br><span class="line">-Xms512m</span><br><span class="line">-Xmx512m</span><br><span class="line">-XX:+UseTLAB</span><br><span class="line">-Xlog:gc+tlab=trace</span><br><span class="line">-Xlog:gc</span><br></pre></td></tr></table></figure>

<p>可以看到下面类似的日志，我们来根据代码分析下，首先是运行到第一个 fullGC 结束之前的所有日志，首先是 JVM 启动的时候会输出用的是什么 GC 的日志，这里是默认的 G1：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码[0.022s][info][gc] Using G1</span><br></pre></td></tr></table></figure>

<p>还会输出 TLAB 的通用配置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码[0.030s][trace][gc,tlab] TLAB min: 328 initial: 60293 max: 65536</span><br></pre></td></tr></table></figure>

<p>也就是这里 TLAB 最小为 328 MarkWordSize，初始为 60293 MarkWordSize，最大为 65536 MarkWordSize。默认的 64位 JVM 的 MarkWordSize 为 8 字节，也就是堆内存 8 字节对齐。</p>
<p>然后，由于 JVM 启动时，默认会初始化很多线程，包括：</p>
<ul>
<li><strong>main 线程</strong>：执行 main 方法的线程</li>
<li><strong>Attach listener 线程</strong>：Attach Listener 线程是负责接收到外部的命令，而对该命令进行执行的并且把结果返回给发送者。通常我们会用一些命令去要求jvm给我们一些反馈信息，如：java -version、jmap、jstack等等。 如果该线程在jvm启动的时候没有初始化，那么，则会在用户第一次执行jvm命令时，得到启动。</li>
<li><strong>Signal Dispatcher线程</strong>：Attach Listener线程的职责是接收外部jvm命令，当命令接收成功后，会交给signal dispather 线程去进行分发到各个不同的模块处理命令，并且返回处理结果。 signal dispather线程也是在第一次接收外部jvm命令时，进行初始化工作。</li>
<li><strong>Reference Handler 线程</strong>：JVM在创建main线程后就创建Reference Handler线程，它主要用于处理引用对象本身（软引用、弱引用、虚引用）的垃圾回收问题 。</li>
<li><strong>Finalizer线程</strong>：这个线程也是在main线程之后创建的，主要用于在垃圾收集前，调用对象的finalize()方法。</li>
<li><strong>DestroyJavaVM线程</strong>：执行main()的线程在main执行完后调用JNI中的 jni_DestroyJavaVM() 方法唤起DestroyJavaVM 线程，它将在虚拟机中所有其它非守护线程全部结束后销毁虚拟机。</li>
</ul>
<p>在运行过程中，根据你的JIT编译配置，GC参数，还会有：</p>
<ul>
<li><strong>CompilerThread 线程</strong>：JIT编译相关线程，主要是负责 C1 C2 即时编译以及 OSR（On stack Replacement） 替换等任务</li>
<li><strong>GC 相关线程</strong>：执行GC任务的线程</li>
</ul>
<p>除了这些之外，Java 8 之后 ForkJoinPool 还会创建一个默认大小为 cpu 核数 -1 的线程池：<strong>CommonForkJoinPool</strong>，是用来处理 ParallelStream 的默认线程池还有 Future 框架 CompletableFuture 的默认线程池。</p>
<p>这些线程中的一部分会在 JVM 初始化的时候创建一些对象使用，那么就肯定会涉及到 TLAB，所以会有如下日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码[0.042s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(2) returns 65536</span><br><span class="line">[0.042s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     1024KB refills: 1 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.155s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(25) returns 65536</span><br><span class="line">[0.155s][trace][gc,tlab] TLAB: fill thread: 0x000002a60028e900 [id: 15380] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     1024KB refills: 1 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.340s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(2) returns 256</span><br><span class="line">[0.340s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     2048KB refills: 2 waste  0.1% gc: 0B slow: 576B fast: 0B</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//省略其他线程的 TLAB 日志，这里 23480 是 Main 线程。读者可以通过程序输出日志中执行循环分配对象的线程 TLAB 日志判断哪一个是 Main 线程</span><br></pre></td></tr></table></figure>

<p>其中，<code>[0.042s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(2) returns 65536</code>的对应的就是调用了<code>compute_size</code>计算初始 TLAB 大小，传入的 2 就是当前这个线程分配的对象所需的大小（MarkWordSize），计算出初始大小为 65536，因为 MarkWordSize = 8 所以 就是 65536*8=524288 字节，也就是 512 KB。下一行日志，代表这个线程初始化申请一块内存作为 TLAB 了，<code>[0.042s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0 refill waste: 8192B alloc: 1.00000 1024KB refills: 1 waste 0.0% gc: 0B slow: 0B fast: 0B</code>，这个 TLAB 的信息包括：</p>
<ul>
<li>线程号 <code>0x000002a66a471710 [id: 12916]</code></li>
<li>期望大小，就是刚刚计算出来的 512KB：<code>desired_size: 512KB</code></li>
<li>慢分配次数，就是不在当前 TLAB 直接分配的分配次数：<code>slow allocs: 0</code></li>
<li>当前浪费空间限制，也就是重新申请 TLAB 造成的浪费限制大小，refill waste: 8192B，也就是最多能浪费 8192 字节</li>
<li>当前 _allocation_fraction 相关信息，<code>alloc: 1.00000 1024KB</code>，代表当前 _allocation_fraction 是 1.00000，TLAB 一共用了 1024 KB</li>
<li>发生 refills 重新申请 TLAB 的次数：<code>refills: 1</code></li>
<li>浪费比例：<code>waste 0.0%</code></li>
<li>GC 回收造成的浪费大小：<code>gc: 0B</code></li>
<li>慢<code>refill</code>造成的浪费：<code>slow: 0B</code></li>
<li>快<code>refill</code>造成的浪费：<code>fast: 0B</code></li>
</ul>
<p>我们这里来计算下<strong>为何当前浪费空间为 8192 字节</strong>，也就是 8KB。TLABRefillWasteFraction 我们并没有修改，也就是默认的 64，那么初始的最大浪费空间 = TLAB 大小 / TLABRefillWasteFraction，也就是 512KB / 64 = 8KB</p>
<p>第一次强制 FullGC 之后，看到如下相关日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码//首先输出了每一个线程的当前 TLAB 的信息</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 15 waste  7.1% gc: 360616B slow: 13880B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a60028d180 [id: 24604] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a60028e900 [id: 15380] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 1 waste 99.9% gc: 524008B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a6002dc380 [id: 10316] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600319040 [id: 3856] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a60031a1f0 [id: 16808] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600326970 [id: 292] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600328620 [id: 10932] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a60032ac90 [id: 14528] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 1 waste 99.8% gc: 521328B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600343ec0 [id: 20040] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600ca03f0 [id: 14304] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600e157e0 [id: 24148] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 1 waste 60.9% gc: 1248B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600f17090 [id: 13736] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 1 waste 99.9% gc: 523976B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a600f0e850 [id: 19208] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 1 waste 99.9% gc: 521688B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a601381710 [id: 9804] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a6013aef00 [id: 23640] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a6013f7650 [id: 1860] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a601ad77b0 [id: 17292] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 1 waste 99.9% gc: 521752B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a601971200 [id: 17448] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a601972220 [id: 11844] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.915s][trace][gc,tlab] GC(0) TLAB: gc thread: 0x000002a601705560 [id: 7832] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     8192KB refills: 0 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">//GC TLAB 统计</span><br><span class="line">[0.915s][debug][gc,tlab] GC(0) TLAB totals: thrds: 7  refills: 21 max: 15 slow allocs: 0 max 0 waste: 38.0% gc: 2974616B max: 524008B slow: 13880B max: 13880B fast: 0B max: 0B</span><br><span class="line">//每个线程 TLAB 期望大小的变化</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a66a471710 [id: 12916] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a60028d180 [id: 24604] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a60028e900 [id: 15380] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a6002dc380 [id: 10316] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600319040 [id: 3856] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a60031a1f0 [id: 16808] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600326970 [id: 292] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600328620 [id: 10932] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a60032ac90 [id: 14528] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600343ec0 [id: 20040] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600ca03f0 [id: 14304] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600e157e0 [id: 24148] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600f17090 [id: 13736] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a600f0e850 [id: 19208] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a601381710 [id: 9804] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a6013aef00 [id: 23640] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a6013f7650 [id: 1860] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a601ad77b0 [id: 17292] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a601971200 [id: 17448] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a601972220 [id: 11844] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">[0.980s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a601705560 [id: 7832] refills 50  alloc: 1.000000 desired_size: 65536 -&gt; 65536</span><br><span class="line">//GC 信息</span><br><span class="line">[0.980s][info ][gc     ] GC(0) Pause Full (WhiteBox Initiated Full GC) 7M-&gt;0M(512M) 65.162ms</span><br></pre></td></tr></table></figure>

<p>首先是输出了每一个线程的当前 TLAB 的信息。与前面发生 refill 分配 TLAB 时相似。只不过多了 GC 全局序号，从 0 开始， <code>GC(0)</code> 代表的就是第一次 GC 相关的日志 然后是 GC TLAB 统计：<code>[0.915s][debug][gc,tlab] GC(0) TLAB totals: thrds: 7 refills: 21 max: 15 slow allocs: 0 max 0 waste: 38.0% gc: 2974616B max: 524008B slow: 13880B max: 13880B fast: 0B max: 0B</code>：</p>
<ul>
<li>一共有7个线程用了 TLAB：<code>thrds: 7</code>，也就是前面带 <code>GC(0)</code> 的 TLAB 信息日志中，只有 7 个线程的 refills 是大于 0 的。</li>
<li>本次 GC 所有线程 refills 的次数 <code>refills: 21</code></li>
<li>历史最大的某次 GC 内 refills 的次数 <code>max: 15</code></li>
<li>本次 GC 所有线程慢分配的次数 <code>slow allocs: 0</code></li>
<li>历史最大的某次 GC 内慢分配的次数 <code>max: 0</code></li>
<li>本次 GC 所有线程 TLAB 内存浪费比例 <code>waste: 38.0%</code></li>
<li>各种浪费内存大小：`gc: 2974616B max: 524008B slow: 13880B max: 13880B fast: 0B max: 0B``</li>
</ul>
<p>接着打印了每个线程 TLAB 期望大小的变化：<code>[0.979s][trace][gc,tlab] GC(0) TLAB new size: thread: 0x000002a66a471710 [id: 12916] refills 50 alloc: 1.000000 desired_size: 65536 -&gt; 65536</code>，这里还是 MarkWordSize 而不是实际字节大小。 最后是本次 GC 信息：<code>[0.980s][info ][gc ] GC(0) Pause Full (WhiteBox Initiated Full GC) 7M-&gt;0M(512M) 65.162ms</code>，代表是 FullGC，并且是 WhiteBox 触发的，堆内存使用从 7M 回收到了 0M，堆内存总大小是 512M，一共停顿时间是 65.162 ms。</p>
<p>之后我们的程序申请了 512 个大小为 1KB 的对象。为何<code>new byte[OBJECT_SIZE - BYTE_ARRAY_OVERHEAD]</code>大小是 1KB 呢？因为数组对象头默认是 16 字节，所以再加上 1012 个 byte 就是 1KB。循环结束后，输出了下面两行日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码[0.989s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(128) returns 65536</span><br><span class="line">[0.989s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     1024KB refills: 1 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[0.989s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(128) returns 65536</span><br><span class="line">[0.989s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     1024KB refills: 2 waste  0.1% gc: 0B slow: 1024B fast: 0B</span><br></pre></td></tr></table></figure>

<p>可以看出是发生了两次 refill，第一次是线程第一次创建对象时申请的，第二次是申请到第 512 个对象，TLAB 大小是 512 KB，之前的 511KB 已经被占用了，根据前一篇的 TLAB 原理分析，我们知道由于需要填充 dummy objects 所以要保留一个数组对象头的大小，所以<strong>剩下可分配的空间其实不足 1KB</strong>，所以需要 refill。并且，<strong>浪费的空间（1KB）小于当前浪费空间限制（8KB），所以可以重新申请新的 TLAB 进行分配</strong>。</p>
<p>然后我们的程序在 FullGC 之后，继续申请了 200 个大小为 100KB 的大对象。这里我们忽略 GC 相关日志，只看分配对象的时候产生的日志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码[3036.734s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(12800) returns 65536</span><br><span class="line">[3036.734s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 0  refill waste: 8192B alloc: 1.00000     1024KB refills: 1 waste  0.0% gc: 0B slow: 0B fast: 0B</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1028</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1032</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1036</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1040</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1044</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1048</span><br><span class="line">//省略中间分配日志。。。</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1452</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1456</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1460</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1464</span><br><span class="line">[3047.279s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(12800) returns 65536</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 110  refill waste: 11712B alloc: 1.00000    13312KB refills: 2 waste  1.2% gc: 0B slow: 12288B fast: 0B</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1028</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1032</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1036</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1040</span><br><span class="line">//省略中间分配日志。。。</span><br><span class="line">[3047.281s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1340</span><br></pre></td></tr></table></figure>

<p>100KB 的对象，换算成 <strong>MarkWordSize 就是 12800</strong>，对应日志：<code>[3036.734s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(12800) returns 65536</code>，本次计算 TLAB 大小依然是 65536 MarkWordSize，也就是 512KB。在分配<strong>第五个</strong>对象开始， TLAB 的剩余内存就不够了。但是初始最大浪费空间是 8KB，所以只能直接在 Eden 区分配，并根据 <code>TLABWasteIncrement</code>（默认为 4） 设置的值递增最大浪费空间，也就是每次递增 4 * MarkWordSize 也就是 32 字节。体现在了日志:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1028</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1032</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1036</span><br><span class="line">[3047.276s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1040</span><br></pre></td></tr></table></figure>

<p>可以看出，每次 TLAB 外分配都让<strong>最大浪费空间限制加 4</strong>。当剩余空间小于最大浪费空间限制时，线程 <strong>refill 申请了一块新的 TLAB</strong> 进行分配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1456</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1460</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: slow thread: 0x000002a66a471710 [id: 12916] obj: 12800 free: 1464 waste: 1464</span><br><span class="line">[3047.279s][trace][gc,tlab] ThreadLocalAllocBuffer::compute_size(12800) returns 65536</span><br><span class="line">[3047.279s][trace][gc,tlab] TLAB: fill thread: 0x000002a66a471710 [id: 12916] desired_size: 512KB slow allocs: 110  refill waste: 11712B alloc: 1.00000    13312KB refills: 2 waste  1.2% gc: 0B slow: 12288B fast: 0B</span><br></pre></td></tr></table></figure>

<p>至此，我们就分析了基本所有 TLAB 相关的日志。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/6925218324183777288" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>硬核 - Java 随机数相关 API 的演进与思考（上）</title>
    <url>/7051386828913377316.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>本系列将 Java 17 之前的随机数 API 以及 Java 17 之后的统一 API 都做了比较详细的说明，并且将随机数的特性以及实现思路也做了一些简单的分析，帮助大家明白为何会有这么多的随机数算法，以及他们的设计思路是什么。</p>
</blockquote>
<blockquote>
<p>本系列会分为两篇，第一篇讲述 Java 随机数算法的演变思路以及底层原理与考量，之后介绍 Java 17 之前的随机算法 API 以及测试性能，第二篇详细分析 Java 17 之后的随机数生成器算法以及 API 和底层实现类以及他们的属性，性能以及使用场景，如何选择随机算法等等，并对 Java 的随机数对于 Java 的一些未来特性的适用进行展望</p>
</blockquote>
<p><strong>这是第一篇</strong>。</p>
<h1 id="如何生成随机数"><a href="#如何生成随机数" class="headerlink" title="如何生成随机数"></a>如何生成随机数</h1><p>我们一般使用随机数生成器的时候，都认为随机数生成器（Pseudo Random Number Generator， PRNG）是一个黑盒：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/51c27cb20abc344520c88d36e7cca18af3f812e31e4c63ef930bcb8f05b1e45f" alt="image"></p>
<p>这个黑盒的产出，一般是一个数字。假设是一个 int 数字。<strong>这个结果可以转化成各种我们想要的类型</strong>，例如：如果我们想要的的其实是一个 long，那我们可以取两次，其中一次的结果作为高 32 位，另一次结果作为低 32 位，组成一个 long（boolean，byte，short，char 等等同理，取一次，取其中某几位作为结果）。如果我们想要的是一个浮点型数字，那么我们可以根据 IEEE 标准组合多次取随机 int 然后取其中某几位组合成浮点型数字的整数位以及小数位。</p>
<p><strong>如果要限制范围</strong>，最简单的方式是将结果取余 + 偏移实现。例如我们想取范围在 1 ~ 100 之间，那么我们就将结果先对 99 取余，然后取绝对值，然后 +1 即可。当然，由于取余操作是一个性能消耗比较高的操作，最简单的优化即检查这个数字 N 与 N-1 取与运算，如果等于 0 即这个书是 2 的 n 次方（2 的 n 次方 2 进制表示一定是 100000 这样的，减去 1 之后 为 011111，取与肯定是 0）；对于 2 的 n 次方取余相当于对 2 的 n 次方减一取与运算。这是一个简单的优化， 实际的优化要比这个复杂多。</p>
<p>初始化这个黑盒的时候，<strong>一般采用一个 SEED 进行初始化</strong>，这个 SEED 的来源可能多种多样，这个我们先按下不表，先来看一些这个黑盒中的一些算法。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0dda0953370ee2712c9d63f757e395f9696b91c4f53dd67957837a0c8caa6d13" alt="image"></p>
<h2 id="线性同余算法"><a href="#线性同余算法" class="headerlink" title="线性同余算法"></a>线性同余算法</h2><p>首先是最常见的随机数算法：<strong>线性同余</strong>（Linear Congruential Generator）。即根据当前 Seed 乘以一个系数 A，然后加上一个偏移 B，最后按照 C 进行取余（限制整体在一定范围内，这样才能选择出合适的 A 和 B，为什么要这么做后面会说），得出随机数，然后这个随机数作为下次随机的种子，即：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码X(n+1) = ( A * X(n) + B ) % C</span><br></pre></td></tr></table></figure>

<p>这种算法的优势在于，实现简单，并且性能算是比较好的。 <strong>A，B 取值必须精挑细算，让在 C 范围内的所有数字都是等可能的出现的</strong>。例如一个极端的例子就是 A = 2， B = 2， C = 10，那么 1，3，5，7，9 这些奇数在后续都不可能出现。为了能计算出一个合适的 A 和 B，要限制 C 在一个比较可控的范围内。一般为了计算效率，将 C 限制为 2 的 n 次方。这样取余运算就可以优化为取与运算。<strong>不过好在，数学大师们已经将这些值（也就是魔法数）找到了</strong>，我们直接用就好了。</p>
<p>这种算法生成的随机序列，是确定的，例如 X 下一个是 Y， Y 下一个是 Z，这可以理解成一个确定环（loop）。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7bf7549dd73b52612cc5857348acc3bb7bdbc0431106cbcfb0ec63ce586d6a33" alt="image">。</p>
<p><strong>这个环的大小，即 Period</strong>。由于 Period 足够大，初始 SEED 一般也是每次不一样的，这样近似做到了随机。但是，假设我们需要多个随机数生成器的时候，就比较麻烦了，因为我们虽然能保证每个随机生成器的初始 SEED 不一样，但是在这种算法下，无法保证某个随机数生成器的初始 SEED 就是另一个随机数生成器初始 SEED 的下一个（或者很短步骤内的） SEED。举个例子，假设某个随机数生成器的初始 SEED 是 X，另一个是 Z，<strong>虽然 X 和 Z 可能看上去差距很大，但是他们在这个算法的随机序列中仅隔了一个 Y。这样的不同的随机数生成器，效果不好</strong>。</p>
<p>那么<strong>如何能保证不同的随机数生成器之间间隔比较大呢</strong>？也就是，我们能通过<strong>简单计算</strong>（而不是计算 100w 次从而调到 100w 次之后的随机数）直接使另一个随机数生成器的初始 SEED 与当前这个的初始 SEED，间隔一个比较大的数，这种性质叫做<strong>可跳跃性</strong>。 <strong>基于线性反馈移位寄存器算法的 Xoshiro 算法</strong>给我们提供了一种<strong>可跳跃的随机数算法</strong>。</p>
<h2 id="线性反馈移位寄存器算法"><a href="#线性反馈移位寄存器算法" class="headerlink" title="线性反馈移位寄存器算法"></a>线性反馈移位寄存器算法</h2><p>线性反馈移位寄存器（Linear feedback shift register，LFSR）是指给定前一状态的输出，将该输出的线性函数再用作输入的移位寄存器。异或运算是最常见的单比特线性函数：对寄存器的某些位进行异或操作后作为输入，再对寄存器中的每个 bit 进行整体移位。</p>
<p>但是如何选择这些 Bit，是一门学问，目前比较常见的实现是 XorShift 算法以及在此基础上进一步优化的<br>Xoshiro 的相关算法。Xoshiro 算法是一种比较新的优化随机数算法，计算很简单并且性能优异。同时实现了可跳跃性。</p>
<p>这种算法是<strong>可跳跃的</strong>。假设我们要生成两个差距比较大的随机数生成器，我们可以使用一个随机初始 SEED 创建一个随机数生成器，然后利用算法的跳跃操作，直接生成一个间隔比较大的 SEED 作为另一个随机数生成器的初始 SEED。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/22d660e50da66e04cbbf2722bba39c5f862c97b5b29fcab1d7fbfeeb11986dda" alt="image"></p>
<p>还有一点比较有意思的是，<strong>线性同余算法并不可逆</strong>，我们只能通过 X(n) 推出 X(n + 1)，而不能根据 X(n + 1) 直接推出 X(n)。这个操作对应的业务例如随机播放歌单，上一首下一首，我们不需要记录整个歌单，而是仅根据当前的随机数就能知道。<strong>线性反馈移位寄存器算法能实现可逆</strong>。</p>
<p>线性反馈移位寄存器算法在生成不同的随机序列生成器也有局限性，即它们还是来自于同一个环，即使通过跳跃操作让不同的随机数生成器都间隔开了，但是如果压力不够均衡，随着时间的推移，它们还是有可能 SEED，又变成一样的了。那么有没有<strong>那种能生成不同随机序列环的随机算法呢</strong>？</p>
<h2 id="DotMix-算法"><a href="#DotMix-算法" class="headerlink" title="DotMix 算法"></a>DotMix 算法</h2><p>DotMix 算法提供了另一种思路，即给定一个初始 SEED，设置一个固定步长 M，每次随机，将这个 SEED 加上步长 M，经过一个 HASH 函数，将这个值散列映射到一个 HASH 值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码X(n+1) = HASH(X(n) + M)</span><br></pre></td></tr></table></figure>

<p>这个算法对于 HASH 算法的要求比较高，重点要求 HASH 算法针对输入的一点改变则造成输出大幅度改变。基于 DotMix 算法的 SplitMix 算法使用的即 MurMurHash3 算法，这个即 Java 8 引入的 <code>SplittableRandom</code> 的底层原理。</p>
<p>这种算法好在，我们很容易能明确<strong>两个不同参数的随机生成器他们的生成序列是不同的</strong>，例如一个生成的随机序列是 1，4，3，7，… 另一个生成的是 1，5，3，2。这点正是线性同余算法无法做到的，他的序列无论怎么修改 SEED 也是确定的，而我们有不能随意更改算法中的 A、B、C 的值，因为可能会导致无法遍历到所有数字，这点之前已经说过了。Xoshiro 也是同理。而 SplitMix 算法不用担心，我们指定不同的 SEED 以及不同的步长 M 就可以保证生成的序列是不同的。这种<strong>可以生成不同序列的性质</strong>，称为<strong>可拆分性</strong></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8b0bd6bad4e535d56c151e078d7222db73c8330f684680697a140a7e181e24ea" alt="image"></p>
<p>这也是 <code>SplittableRandom</code> 比 <code>Random</code> （Random 基于线性同余）更适合多线程的原因：</p>
<ul>
<li>假设多线程使用同一个 <code>Random</code>，保证了序列的随机性，但是有 CompareAndSet 新 seed 的性能损失。</li>
<li>假设每个线程使用 SEED 相同的 <code>Random</code>，则每个线程生成的随机序列相同。</li>
<li>假设每个线程使用 SEED 不相同的 <code>Random</code>，但是我们不能保证一个 <code>Random</code> 的 SEED 是否是另一个 <code>Random</code> SEED 的下一个结果（或者是很短步长以内的结果），这种情况下如果线程压力不均匀（线程池在比较闲的时候，其实只有一部分线程在工作，这些线程很可能他们私有的 Random 来到和其他线程同一个 SEED 的位置），某些线程也会有相同的随机序列。</li>
</ul>
<p>使用 <code>SplittableRandom</code> 只要直接使用接口 <code>split</code> 就能给不同线程<strong>分配一个参数不同</strong>的 <code>SplittableRandom</code> ，并且参数不同基本就可以保证生成不了相同序列。</p>
<h2 id="思考：我们如何生成-Period-大于生成数字容量的随机序列呢？"><a href="#思考：我们如何生成-Period-大于生成数字容量的随机序列呢？" class="headerlink" title="思考：我们如何生成 Period 大于生成数字容量的随机序列呢？"></a>思考：我们如何生成 Period 大于生成数字容量的随机序列呢？</h2><p>最简单的做法，我们将两个 Period 等于容量的序列通过轮询合并在一起，这样就得到了 <code>Period = 容量 + 容量</code> 的序列：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/63b53cf9ec2fcf69fae3ff757cd8b55317a66476815ef2191f9911a2201b98e3" alt="image"></p>
<p>我们还可以直接记录两个序列的结果，然后将两个序列的结果用某种运算，例如异或或者散列操作拼到一起。这样，<code>Period = 容量 * 容量</code>。</p>
<p>如果我们想扩展更多，都可以通过以上办法拼接。用一定的操作拼接不同算法的序列，我们可以得到每种算法的随机优势。 Java 17 引入的 LXM 算法就是一个例子。</p>
<h2 id="LXM-算法"><a href="#LXM-算法" class="headerlink" title="LXM 算法"></a>LXM 算法</h2><p>这是在 Java 17 中引入的算法 LXM 算法（L 即线性同余，X 即 Xoshiro，M 即 MurMurHash）的实现较为简单，结合线性同余算法和 Xoshiro 算法，之后通过 MurMurHash 散列，例如：</p>
<ul>
<li>L34X64M：即使用一个 32 位的数字保存线性同余的结果，两个 32 位的数字保存 Xoshiro 算法的结果，使用 MurMurHash 散列合并这些结果到一个 64 位数字。</li>
<li>L128X256M：即使用两个 64 位的数字保存线性同余的结果，4 个 64 位的数字保存 Xoshiro 算法的结果，使用 MurMurHash 散列合并这些结果到一个 64 位数字。</li>
</ul>
<p>LXM 算法通过 MurMurhash 实现了分割性，没有保留 Xoshiro 的跳跃性。</p>
<h2 id="SEED-的来源"><a href="#SEED-的来源" class="headerlink" title="SEED 的来源"></a>SEED 的来源</h2><p>由于 JDK 中所有的随机算法都是基于上一次输入的，<strong>如果我们使用固定 SEED 那么生成的随机序列也一定是一样的</strong>。这样在安全敏感的场景，不够合适，官方对于 <code>cryptographically secure</code> 的定义是，要求 SEED 必须是不可预知的，产生非确定性输出。</p>
<p>在 Linux 中，会采集用户输入，系统中断等系统运行数据，生成随机种子放入池中，程序可以读取这个池子获取一个随机数。但是这个池子是采集一定数据后才会生成，大小有限，并且它的随机分布肯定不够好，所以我们不能直接用它来做随机数，而是用它来做我们的随机数生成器的种子。这个池子在 Linux 中被抽象为两个文件，这两个文件他们分别是：<code>/dev/random</code> 和 <code>/dev/urandom</code>。一个是必须采集一定熵的数据才放开从池子里面取否则阻塞，另一个则是不管是否采集够直接返回现有的。</p>
<p>在 Linux 4.8 之前：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/10db4d5e434d1cf7d01266cf55c2372c5e3b63c126567d6bcf2b8af37ade05e7" alt="image"></p>
<p>在 Linux 4.8 之后：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/efb3c81c6caed661789a581d6fc84ce2e404a74c051d8391c0a13e8bb2fac088" alt="image"></p>
<p>在熵池不够用的时候，<strong><code>file:/dev/random</code>会阻塞</strong>，<strong><code>file:/dev/urandom</code>不会</strong>。对于我们来说，<code>/dev/urandom</code> 一般就够用，所以一般<strong>通过<code>-Djava.security.egd=file:/dev/./urandom</code>设置 JVM 启动参数</strong>，使用 urandom 来减少阻塞。</p>
<p>我们也可以通过<strong>业务中的一些特性，来定时重新设置所有 Random 的 SEED 来进一步增加被破解的难度</strong>，例如，每小时用过去一小时的活跃用户数量 * 下单数量作为新的 SEED。</p>
<h2 id="测试随机算法随机性"><a href="#测试随机算法随机性" class="headerlink" title="测试随机算法随机性"></a>测试随机算法随机性</h2><p>以上算法实现的都是伪随机，即<strong>当前随机数结果与上一次是强相关的关系</strong>。事实上目前基本所有<strong>快速的随机算法，都是这样的</strong>。</p>
<p>并且就算我们让 SEED 足够隐秘，但是如果我们知道算法，还是可以通过当前的随机输出，推测出下一个随机输出。或者算法未知，但是能从几次随机结果反推出算法从而推出之后的结果。</p>
<p>针对这种伪随机算法，需要验证算法生成的随机数满足一些特性，例如：</p>
<ul>
<li><strong>period 尽可能长</strong>：a full cycle 或者 period 指的是随机序列将所有可能的随机结果都遍历过一遍，同时结果回到初始 seed 需要的结果个数。这个 period 要尽可能的长一些。</li>
<li><strong>平均分布</strong>（equidistribution），生成的随机数的每个可能结果，在一个 Period 内要尽可能保证每种结果的出现次数是相同的。否则，会影响在某些业务的使用，例如抽奖这种业务，我们需要保证概率要准。</li>
<li><strong>复杂度测试</strong>：生成的随机序列是否够复杂，不会有那种有规律的数字序列，例如等比数列，等差数列等等。</li>
<li><strong>安全性测试</strong>：很难通过比较少的结果反推出这个随机算法。</li>
</ul>
<p>目前，已经有很多框架工具用来针对某个算法生成的随机序列进行测试，评价随机序列结果，验证算法的随机性，常用的包括：</p>
<ul>
<li>testU01 随机性测试：<a href="https://github.com/umontreal-simul/TestU01-2009/" target="_blank" rel="noopener">github.com/umontreal-s…</a></li>
<li>NIST 随机性测试：<a href="https://nvlpubs.nist.gov/nistpubs/legacy/sp/nistspecialpublication800-22r1a.pdf" target="_blank" rel="noopener">nvlpubs.nist.gov/nistpubs/le…</a></li>
<li>DieHarder Suite 随机性测试</li>
</ul>
<p>Java 中内置的随机算法，基本都通过了 <strong>testU01 的大部分测试</strong>。目前，上面提到过的优化算法都或多或少的暴露出一些随机性问题。目前， <strong>Java 17 中的 LXM 算法是随机性测试中表现最好的</strong>。<strong>注意是随机性表现，而不是性能</strong>。</p>
<h2 id="Java-中涉及到的所有随机算法（不包括-SecureRandom）"><a href="#Java-中涉及到的所有随机算法（不包括-SecureRandom）" class="headerlink" title="Java 中涉及到的所有随机算法（不包括 SecureRandom）"></a>Java 中涉及到的所有随机算法（不包括 SecureRandom）</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0a97fe48246e6b5ee09d618d1dde0ac8faef7744333f562108e783c39afb7ed5" alt="image"></p>
<ul>
<li>Linear Congruential generator: <a href="https://doi.org/10.1093%2Fcomjnl%2F1.2.83" target="_blank" rel="noopener">doi.org/10.1093%2Fc…</a></li>
<li>Linear-feedback shift register: <a href="https://www.ams.org/journals/mcom/1965-19-090/S0025-5718-1965-0184406-1/S0025-5718-1965-0184406-1.pdf" target="_blank" rel="noopener">www.ams.org/journals/mc…</a></li>
<li>XORShift: <a href="https://doi.org/10.18637%2Fjss.v008.i14" target="_blank" rel="noopener">doi.org/10.18637%2F…</a></li>
<li>Xoroshiro128+: <a href="https://arxiv.org/abs/1805.01407" target="_blank" rel="noopener">arxiv.org/abs/1805.01…</a></li>
<li>LXM: <a href="https://dl.packetstormsecurity.net/papers/general/Google_Chrome_3.0_Beta_Math.random_vulnerability.pdf" target="_blank" rel="noopener">dl.packetstormsecurity.net/papers/gene…</a></li>
<li>SplitMix: <a href="http://gee.cs.oswego.edu/dl/papers/oopsla14.pdf" target="_blank" rel="noopener">gee.cs.oswego.edu/dl/papers/o…</a></li>
</ul>
<h2 id="为什么我们在实际业务应用中很少考虑随机安全性问题"><a href="#为什么我们在实际业务应用中很少考虑随机安全性问题" class="headerlink" title="为什么我们在实际业务应用中很少考虑随机安全性问题"></a>为什么我们在实际业务应用中很少考虑随机安全性问题</h2><p>主要因为，我们一般做了负载均衡多实例部署，还有多线程。一般每个线程使用不同初始 SEED 的 Random 实例（例如 ThreadLocalRandom）。并且一个随机敏感业务，例如抽奖，单个用户一般都会限制次数，所以很难采集够足够的结果反推出算法以及下一个结果，而且你还需要和其他用户一起抽。然后，我们一般会限制随机数范围，而不是使用原始的随机数，这就更大大增加了反解的难度。最后，我们也可以定时使用业务的一些实时指标定时设置我们的 SEED，例如：，每小时用过去一小时的（活跃用户数量 * 下单数量）作为新的 SEED。</p>
<p>所以，一般现实业务中，我们很少会用 SecureRandom。如果我们想初始 SEED 让编写程序的人也不能猜出来（时间戳也能猜出来），可以指定随机类的初始 SEED 源，通过 JVM 参数 <code>-Djava.util.secureRandomSeed=true</code>。这个对于所有 Java 中的随机数生成器都有效（例如，Random，SplittableRandom，ThreadLocalRandom 等等）</p>
<p>对应源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码static &#123;</span><br><span class="line">        String sec = VM.getSavedProperty(&quot;java.util.secureRandomSeed&quot;);</span><br><span class="line">        if (Boolean.parseBoolean(sec)) &#123;</span><br><span class="line">            //初始 SEED 从 SecureRandom 中取</span><br><span class="line">            // SecureRandom 的 SEED 源，在 Linux 中即我们前面提到的环境变量 java.security.egd 指定的 /dev/random 或者 /dev/urandom</span><br><span class="line">            byte[] seedBytes = java.security.SecureRandom.getSeed(8);</span><br><span class="line">            long s = (long)seedBytes[0] &amp; 0xffL;</span><br><span class="line">            for (int i = 1; i &lt; 8; ++i)</span><br><span class="line">                s = (s &lt;&lt; 8) | ((long)seedBytes[i] &amp; 0xffL);</span><br><span class="line">            seeder.set(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>所以，针对我们的业务，<strong>我们一般只关心算法的性能以及随机性中的平均性</strong>，而通过测试的算法，一般随机性都没啥大问题，所以<strong>我们只主要关心性能即可</strong>。</p>
<p>针对安全性敏感的业务，像是 SSL 加密，生成加密随机散列这种，则需要考虑更高的安全随机性。这时候才考虑使用 SecureRandom。SecureRandom 的实现中，随机算法更加复杂且涉及了一些加密思想，<strong>我们这里就不关注这些 Secure 的 Random 的算法了</strong>。</p>
<h1 id="Java-17-之前一般如何生成随机数以及对应的随机算法"><a href="#Java-17-之前一般如何生成随机数以及对应的随机算法" class="headerlink" title="Java 17 之前一般如何生成随机数以及对应的随机算法"></a>Java 17 之前一般如何生成随机数以及对应的随机算法</h1><p>首先放出算法与实现类的对应关系：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/524acba8ce343c9baa817b7f425e1d2402dd2cd35ad16149703c3911b82bbce2" alt="image"></p>
<h2 id="使用-JDK-的-API"><a href="#使用-JDK-的-API" class="headerlink" title="使用 JDK 的 API"></a>使用 JDK 的 API</h2><p><strong>1.使用 <code>java.util.Random</code> 和基于它的 API</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码Random random = new Random();</span><br><span class="line">random.nextInt();</span><br></pre></td></tr></table></figure>

<p><strong><code>Math.random()</code> 底层也是基于 Random</strong></p>
<p><code>java.lang.Math</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public static double random() &#123;</span><br><span class="line">    return RandomNumberGeneratorHolder.randomNumberGenerator.nextDouble();</span><br><span class="line">&#125;</span><br><span class="line">private static final class RandomNumberGeneratorHolder &#123;</span><br><span class="line">    static final Random randomNumberGenerator = new Random();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Random</code> 本身是<strong>设计成线程安全</strong>的，因为 SEED 是 Atomic 的并且随机只是 CAS 更新这个 SEED：</p>
<p><code>java.util.Random</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码protected int next(int bits) &#123;</span><br><span class="line">    long oldseed, nextseed;</span><br><span class="line">    AtomicLong seed = this.seed;</span><br><span class="line">    do &#123;</span><br><span class="line">        oldseed = seed.get();</span><br><span class="line">        nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">    &#125; while (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">    return (int)(nextseed &gt;&gt;&gt; (48 - bits));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>同时也看出，Random 是基于线性同余算法的</strong></p>
<p><strong>2.使用 <code>java.util.SplittableRandom</code> 和基于它的 API</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码SplittableRandom splittableRandom = new SplittableRandom();</span><br><span class="line">splittableRandom.nextInt();</span><br></pre></td></tr></table></figure>

<p>前面的分析我们提到了，<strong>SplittableRandom 基于 SplitMix 算法实现</strong>，即给定一个初始 SEED，设置一个固定步长 M，每次随机，将这个 SEED 加上步长 M，经过一个 HASH 函数（这里是 MurMurHash3），将这个值散列映射到一个 HASH 值。</p>
<p><code>SplittableRandom</code> <strong>本身不是线程安全的</strong>：<br><code>java.util.SplittableRandom</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码public int nextInt() &#123;</span><br><span class="line">    return mix32(nextSeed());</span><br><span class="line">&#125;   </span><br><span class="line">private long nextSeed() &#123;</span><br><span class="line">    //这里非线程安全</span><br><span class="line">    return seed += gamma;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong><code>ThreadLocalRandom</code> 基于 <code>SplittableRandom</code> 实现</strong>，我们在多线程环境下使用 <code>ThreadLocalRandom</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码ThreadLocalRandom.current().nextInt();</span><br></pre></td></tr></table></figure>

<p><code>SplittableRandom</code> 可以通过 split 方法返回一个参数全新，随机序列特性差异很大的新的 <code>SplittableRandom</code>，我们可以将他们用于不同的线程生成随机数，这在 parallel Stream 中非常常见：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码IntStream.range(0, 1000)</span><br><span class="line">    .parallel()</span><br><span class="line">    .map(index -&gt; usersService.getUsersByGood(index))</span><br><span class="line">    .map(users -&gt; users.get(splittableRandom.split().nextInt(users.size())))</span><br><span class="line">    .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>但是由于没有做<strong>对齐性填充以及其他一些多线程性能优化的东西</strong>，导致其多线程环境下的性能表现还是比基于 <code>SplittableRandom</code> 的 <code>ThreadLocalRandom</code> 要差。</p>
<p><strong>3. 使用 <code>java.security.SecureRandom</code> 生成安全性更高的随机数</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码SecureRandom drbg = SecureRandom.getInstance(&quot;DRBG&quot;);</span><br><span class="line">drbg.nextInt();</span><br></pre></td></tr></table></figure>

<p>一般这种算法，基于加密算法实现，计算更加复杂，性能也比较差，只有安全性非常敏感的业务才会使用，一般业务（例如抽奖）这些是不会使用的。</p>
<h2 id="测试性能"><a href="#测试性能" class="headerlink" title="测试性能"></a>测试性能</h2><p>单线程测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码Benchmark                                      Mode  Cnt          Score          Error  Units</span><br><span class="line">TestRandom.testDRBGSecureRandomInt            thrpt   50     940907.223 ±    11505.342  ops/s</span><br><span class="line">TestRandom.testDRBGSecureRandomIntWithBound   thrpt   50     992789.814 ±    71312.127  ops/s</span><br><span class="line">TestRandom.testRandomInt                      thrpt   50  106491372.544 ±  8881505.674  ops/s</span><br><span class="line">TestRandom.testRandomIntWithBound             thrpt   50   99009878.690 ±  9411874.862  ops/s</span><br><span class="line">TestRandom.testSplittableRandomInt            thrpt   50  295631145.320 ± 82211818.950  ops/s</span><br><span class="line">TestRandom.testSplittableRandomIntWithBound   thrpt   50  190550282.857 ± 17108994.427  ops/s</span><br><span class="line">TestRandom.testThreadLocalRandomInt           thrpt   50  264264886.637 ± 67311258.237  ops/s</span><br><span class="line">TestRandom.testThreadLocalRandomIntWithBound  thrpt   50  162884175.411 ± 12127863.560  ops/s</span><br></pre></td></tr></table></figure>

<p>多线程测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码Benchmark                                      Mode  Cnt          Score           Error  Units</span><br><span class="line">TestRandom.testDRBGSecureRandomInt            thrpt   50    2492896.096 ±     19410.632  ops/s</span><br><span class="line">TestRandom.testDRBGSecureRandomIntWithBound   thrpt   50    2478206.361 ±    111106.563  ops/s</span><br><span class="line">TestRandom.testRandomInt                      thrpt   50  345345082.968 ±  21717020.450  ops/s</span><br><span class="line">TestRandom.testRandomIntWithBound             thrpt   50  300777199.608 ±  17577234.117  ops/s</span><br><span class="line">TestRandom.testSplittableRandomInt            thrpt   50  465579146.155 ±  25901118.711  ops/s</span><br><span class="line">TestRandom.testSplittableRandomIntWithBound   thrpt   50  344833166.641 ±  30676425.124  ops/s</span><br><span class="line">TestRandom.testThreadLocalRandomInt           thrpt   50  647483039.493 ± 120906932.951  ops/s</span><br><span class="line">TestRandom.testThreadLocalRandomIntWithBound  thrpt   50  467680021.387 ±  82625535.510  ops/s</span><br></pre></td></tr></table></figure>

<p>结果和我们之前说明的预期基本一致，多线程环境下 <code>ThreadLocalRandom</code> 的性能最好。单线程环境下 <code>SplittableRandom</code> 和 <code>ThreadLocalRandom</code> 基本接近，性能要好于其他的。<code>SecureRandom</code> 和其他的相比性能差了几百倍。</p>
<p>测试代码如下（<strong>注意虽然 Random 和 SecureRandom 都是线程安全的，但是为了避免 compareAndSet 带来的性能衰减过多，还是用了 ThreadLocal</strong>。）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package prng;</span><br><span class="line"></span><br><span class="line">import java.security.NoSuchAlgorithmException;</span><br><span class="line">import java.security.SecureRandom;</span><br><span class="line">import java.util.Random;</span><br><span class="line">import java.util.SplittableRandom;</span><br><span class="line">import java.util.concurrent.ThreadLocalRandom;</span><br><span class="line"></span><br><span class="line">import org.openjdk.jmh.annotations.Benchmark;</span><br><span class="line">import org.openjdk.jmh.annotations.BenchmarkMode;</span><br><span class="line">import org.openjdk.jmh.annotations.Fork;</span><br><span class="line">import org.openjdk.jmh.annotations.Measurement;</span><br><span class="line">import org.openjdk.jmh.annotations.Mode;</span><br><span class="line">import org.openjdk.jmh.annotations.Scope;</span><br><span class="line">import org.openjdk.jmh.annotations.State;</span><br><span class="line">import org.openjdk.jmh.annotations.Threads;</span><br><span class="line">import org.openjdk.jmh.annotations.Warmup;</span><br><span class="line">import org.openjdk.jmh.infra.Blackhole;</span><br><span class="line">import org.openjdk.jmh.runner.Runner;</span><br><span class="line">import org.openjdk.jmh.runner.RunnerException;</span><br><span class="line">import org.openjdk.jmh.runner.options.Options;</span><br><span class="line">import org.openjdk.jmh.runner.options.OptionsBuilder;</span><br><span class="line"></span><br><span class="line">//测试指标为吞吐量</span><br><span class="line">@BenchmarkMode(Mode.Throughput)</span><br><span class="line">//需要预热，排除 jit 即时编译以及 JVM 采集各种指标带来的影响，由于我们单次循环很多次，所以预热一次就行</span><br><span class="line">@Warmup(iterations = 1)</span><br><span class="line">//线程个数</span><br><span class="line">@Threads(10)</span><br><span class="line">@Fork(1)</span><br><span class="line">//测试次数，我们测试50次</span><br><span class="line">@Measurement(iterations = 50)</span><br><span class="line">//定义了一个类实例的生命周期，所有测试线程共享一个实例</span><br><span class="line">@State(value = Scope.Benchmark)</span><br><span class="line">public class TestRandom &#123;</span><br><span class="line">	ThreadLocal&lt;Random&gt; random = ThreadLocal.withInitial(Random::new);</span><br><span class="line">	ThreadLocal&lt;SplittableRandom&gt; splittableRandom = ThreadLocal.withInitial(SplittableRandom::new);</span><br><span class="line">	ThreadLocal&lt;SecureRandom&gt; drbg = ThreadLocal.withInitial(() -&gt; &#123;</span><br><span class="line">		try &#123;</span><br><span class="line">			return SecureRandom.getInstance(&quot;DRBG&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (NoSuchAlgorithmException e) &#123;</span><br><span class="line">			throw new IllegalArgumentException(e);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testRandomInt(Blackhole blackhole) throws Exception &#123;</span><br><span class="line">		blackhole.consume(random.get().nextInt());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testRandomIntWithBound(Blackhole blackhole) throws Exception &#123;</span><br><span class="line">		//注意不取 2^n 这种数字，因为这种数字一般不会作为实际应用的范围，但是底层针对这种数字有优化</span><br><span class="line">		blackhole.consume(random.get().nextInt(1, 100));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testSplittableRandomInt(Blackhole blackhole) throws Exception &#123;</span><br><span class="line">		blackhole.consume(splittableRandom.get().nextInt());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testSplittableRandomIntWithBound(Blackhole blackhole) throws Exception &#123;</span><br><span class="line">		//注意不取 2^n 这种数字，因为这种数字一般不会作为实际应用的范围，但是底层针对这种数字有优化</span><br><span class="line">		blackhole.consume(splittableRandom.get().nextInt(1, 100));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testThreadLocalRandomInt(Blackhole blackhole) throws Exception &#123;</span><br><span class="line">		blackhole.consume(ThreadLocalRandom.current().nextInt());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testThreadLocalRandomIntWithBound(Blackhole blackhole) throws Exception &#123;</span><br><span class="line">		//注意不取 2^n 这种数字，因为这种数字一般不会作为实际应用的范围，但是底层针对这种数字有优化</span><br><span class="line">		blackhole.consume(ThreadLocalRandom.current().nextInt(1, 100));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testDRBGSecureRandomInt(Blackhole blackhole) &#123;</span><br><span class="line">		blackhole.consume(drbg.get().nextInt());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Benchmark</span><br><span class="line">	public void testDRBGSecureRandomIntWithBound(Blackhole blackhole) &#123;</span><br><span class="line">		//注意不取 2^n 这种数字，因为这种数字一般不会作为实际应用的范围，但是底层针对这种数字有优化</span><br><span class="line">		blackhole.consume(drbg.get().nextInt(1, 100));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public static void main(String[] args) throws RunnerException &#123;</span><br><span class="line">		Options opt = new OptionsBuilder().include(TestRandom.class.getSimpleName()).build();</span><br><span class="line">		new Runner(opt).run();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>微信搜索“我的编程喵”关注公众号，每日一刷，轻松提升技术，斩获各种offer</strong></p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7051386828913377316" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 1从 Native Me</title>
    <url>/7225871227743043644.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol>
<li><h1 id="从-Native-Memory-Tracking-说起"><a href="#从-Native-Memory-Tracking-说起" class="headerlink" title="从 Native Memory Tracking 说起"></a>从 Native Memory Tracking 说起</h1></li>
</ol>
<p>JVM 内存究竟包括哪些，可能网上众说纷纭。我们这里由官方提供的一个查看 JVM 内存占用的工具引入，即 Native Memory Tracking。不过要注意的一点是，这个只能监控 JVM 原生申请的内存大小，如果是通过 JDK 封装的系统 API 申请的内存，是统计不到的，例如 Java JDK 中的 DirectBuffer 以及 MappedByteBuffer 这两个（当然，对于这两个，我们后面也有其他的办法去看到当前使用的大小。当然xigao dog 啥都不会）。以及如果你自己封装 JNI 调用系统调用去申请内存，<strong>都是 Native Memory Tracking 无法涵盖的</strong>。这点要注意。</p>
<h2 id="1-1-Native-Memory-Tracking-的开启"><a href="#1-1-Native-Memory-Tracking-的开启" class="headerlink" title="1.1. Native Memory Tracking 的开启"></a>1.1. Native Memory Tracking 的开启</h2><p>Native Memory Tracking 主要是用来通过<strong>在 JVM 向系统申请内存的时候进行埋点实现的</strong>。注意，这个埋点，并不是完全没有消耗的，我们后面会看到。由于需要埋点，并且 JVM 中申请内存的地方很多，这个埋点是有不小消耗的，这个 Native Memory Tracking 默认是不开启的，<strong>并且无法动态开启</strong>（因为这是埋点采集统计的，如果可以动态开启那么没开启的时候的内存分配没有记录无法知晓，所以无法动态开启），目前只能通过在启动 JVM 的时候通过启动参数开启。即通过 <code>-XX:NativeMemoryTracking</code> 开启：</p>
<ul>
<li><code>-XX:NativeMemoryTracking=off</code>:这是默认值，即关闭 Native Memory Tracking</li>
<li><code>-XX:NativeMemoryTracking=summary</code>: 开启 Native Memory Tracking，但是仅仅按照各个 JVM 子系统去统计内存占用情况</li>
<li><code>-XX:NativeMemoryTracking=detail</code>:开启 Native Memory Tracking，从每次 JVM 中申请内存的不同调用路径的维度去统计内存占用情况。注意，开启 detail 比开启 summary 的消耗要大不少，因为 detail 每次都要解析 CallSite 分辨调用位置。我们一般用不到这么详细的内容，除非是 JVM 开发。只有洗稿狗才会开启这个配置导致线上崩溃而自己又很懵。</li>
</ul>
<p>开启之后，我们可以通过 jcmd 命令去查看 Native Memory Tracking 的信息，即<code>jcmd &lt;pid&gt; VM.native_memory</code>：</p>
<ul>
<li><code>jcmd &lt;pid&gt; VM.native_memory</code>或者<code>jcmd &lt;pid&gt; VM.native_memory summary</code>：两者是等价的，即<strong>查看 Native Memory Tracking 的 summary 信息</strong>。默认单位是 KB，可以指定单位为其他，例如 <code>jcmd &lt;pid&gt; VM.native_memory summary scale=MB</code></li>
<li><code>jcmd &lt;pid&gt; VM.native_memory detail</code>：<strong>查看 Native Memory Tracking 的 detail 信息</strong>，包括 summary 信息，以及按照虚拟内存映射分组的内存使用信息，还有按照不同 CallSite 调用分组的内存使用情况。默认单位是 KB，可以指定单位为其他，例如 <code>jcmd &lt;pid&gt; VM.native_memory detail scale=MB</code></li>
</ul>
<h2 id="1-2-Native-Memory-Tracking-的使用"><a href="#1-2-Native-Memory-Tracking-的使用" class="headerlink" title="1.2. Native Memory Tracking 的使用"></a>1.2. Native Memory Tracking 的使用</h2><p>对于我们这些 Java 开发以及 JVM 使用者而言（对于抄袭狗是没有好果汁吃的），我们只关心并且查看 Native Memory Tracking 的 summary 信息即可，detail 信息一般是供 JVM 开发人员使用的，我们不用太关心，我们后面的分析也只会涉及 Native Memory Tracking 的 summary 部分。</p>
<p>一般地，只有遇到问题的时候，我们才会考虑开启 Native Memory Tracking，并且在定位出问题后，我们想把它关闭，可以通过 <code>jcmd &lt;pid&gt; VM.native_memory shutdown</code> 进行关闭并清理掉之前 Native Memory tracking 使用的埋点以及占用的内存。如前面所述，我们无法动态开启 Native Memory tracking，所以只要动态关闭了，这个进程就无法再开启了。</p>
<p>jcmd 本身提供了简单的对比功能，例如：</p>
<ol>
<li>使用 <code>jcmd &lt;pid&gt; VM.native_memory baseline</code> 记录当前内存占用信息</li>
<li>之后过一段时间 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 会输出当前 Native Memory Tracking 的 summary 信息，如果与第一步 baseline 的有差异，会在对应位将差异输出</li>
</ol>
<p>但是这个工具本身比较粗糙，我们有时候并不知道何时调用 <code>jcmd &lt;pid&gt; VM.native_memory summary.diff</code> 合适，因为我们不确定什么时候会有我们想看到的内存使用过大的问题。所以我们一般做成一种持续监控的方式</p>
<h2 id="1-3-Native-Memory-Tracking-的-summary-信息每部分含义"><a href="#1-3-Native-Memory-Tracking-的-summary-信息每部分含义" class="headerlink" title="1.3. Native Memory Tracking 的 summary 信息每部分含义"></a>1.3. Native Memory Tracking 的 summary 信息每部分含义</h2><p>以下是一个 Native Memory Tracking 的示例输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Total: reserved=10575644KB, committed=443024KB</span><br><span class="line">-                 Java Heap (reserved=8323072KB, committed=192512KB)</span><br><span class="line">                            (mmap: reserved=8323072KB, committed=192512KB) </span><br><span class="line"> </span><br><span class="line">-                     Class (reserved=1050202KB, committed=10522KB)</span><br><span class="line">                            (classes #15409)</span><br><span class="line">                            (  instance classes #14405, array classes #1004)</span><br><span class="line">                            (malloc=1626KB #33495) </span><br><span class="line">                            (mmap: reserved=1048576KB, committed=8896KB) </span><br><span class="line">                            (  Metadata:   )</span><br><span class="line">                            (    reserved=57344KB, committed=57216KB)</span><br><span class="line">                            (    used=56968KB)</span><br><span class="line">                            (    waste=248KB =0.43%)</span><br><span class="line">                            (  Class space:)</span><br><span class="line">                            (    reserved=1048576KB, committed=8896KB)</span><br><span class="line">                            (    used=8651KB)</span><br><span class="line">                            (    waste=245KB =2.75%)</span><br><span class="line"> </span><br><span class="line">-                    Thread (reserved=669351KB, committed=41775KB)</span><br><span class="line">                            (thread #653)</span><br><span class="line">                            (stack: reserved=667648KB, committed=40072KB)</span><br><span class="line">                            (malloc=939KB #3932) </span><br><span class="line">                            (arena=764KB #1304)</span><br><span class="line"> </span><br><span class="line">-                      Code (reserved=50742KB, committed=17786KB)</span><br><span class="line">                            (malloc=1206KB #9495) </span><br><span class="line">                            (mmap: reserved=49536KB, committed=16580KB) </span><br><span class="line"> </span><br><span class="line">-                        GC (reserved=370980KB, committed=69260KB)</span><br><span class="line">                            (malloc=28516KB #8340) </span><br><span class="line">                            (mmap: reserved=342464KB, committed=40744KB) </span><br><span class="line"> </span><br><span class="line">-                  Compiler (reserved=159KB, committed=159KB)</span><br><span class="line">                            (malloc=29KB #813) </span><br><span class="line">                            (arena=131KB #3)</span><br><span class="line"> </span><br><span class="line">-                  Internal (reserved=1373KB, committed=1373KB)</span><br><span class="line">                            (malloc=1309KB #6135) </span><br><span class="line">                            (mmap: reserved=64KB, committed=64KB) </span><br><span class="line"> </span><br><span class="line">-                     Other (reserved=12348KB, committed=12348KB)</span><br><span class="line">                            (malloc=12348KB #14) </span><br><span class="line"> </span><br><span class="line">-                    Symbol (reserved=18629KB, committed=18629KB)</span><br><span class="line">                            (malloc=16479KB #445877) </span><br><span class="line">                            (arena=2150KB #1)</span><br><span class="line"> </span><br><span class="line">-    Native Memory Tracking (reserved=8426KB, committed=8426KB)</span><br><span class="line">                            (malloc=325KB #4777) </span><br><span class="line">                            (tracking overhead=8102KB)</span><br><span class="line"> </span><br><span class="line">-        Shared class space (reserved=12032KB, committed=12032KB)</span><br><span class="line">                            (mmap: reserved=12032KB, committed=12032KB) </span><br><span class="line"> </span><br><span class="line">-               Arena Chunk (reserved=187KB, committed=187KB)</span><br><span class="line">                            (malloc=187KB) </span><br><span class="line"> </span><br><span class="line">-                   Tracing (reserved=32KB, committed=32KB)</span><br><span class="line">                            (arena=32KB #1)</span><br><span class="line"> </span><br><span class="line">-                   Logging (reserved=5KB, committed=5KB)</span><br><span class="line">                            (malloc=5KB #216) </span><br><span class="line"> </span><br><span class="line">-                 Arguments (reserved=31KB, committed=31KB)</span><br><span class="line">                            (malloc=31KB #90) </span><br><span class="line"> </span><br><span class="line">-                    Module (reserved=403KB, committed=403KB)</span><br><span class="line">                            (malloc=403KB #2919) </span><br><span class="line"> </span><br><span class="line">-                 Safepoint (reserved=8KB, committed=8KB)</span><br><span class="line">                            (mmap: reserved=8KB, committed=8KB) </span><br><span class="line"> </span><br><span class="line">-           Synchronization (reserved=56KB, committed=56KB)</span><br><span class="line">                            (malloc=56KB #789) </span><br><span class="line"> </span><br><span class="line">-            Serviceability (reserved=1KB, committed=1KB)</span><br><span class="line">                            (malloc=1KB #18) </span><br><span class="line"> </span><br><span class="line">-                 Metaspace (reserved=57606KB, committed=57478KB)</span><br><span class="line">                            (malloc=262KB #180) </span><br><span class="line">                            (mmap: reserved=57344KB, committed=57216KB) </span><br><span class="line"> </span><br><span class="line">-      String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">                            (malloc=1KB #8)</span><br></pre></td></tr></table></figure>

<p>我们接下来将上面的信息按不同子系统分别简单分析下其含义：</p>
<p><strong>1.Java堆内存</strong>，所有 Java 对象分配占用内存的来源，由 JVM GC 管理回收，这是我们在第三章会重点分析的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码    //堆内存占用，reserve 了 8323072KB，当前 commit 了 192512KB 用于实际使用</span><br><span class="line">    Java Heap (reserved=8323072KB, committed=192512KB) </span><br><span class="line">        //堆内存都是通过 mmap 系统调用方式分配的</span><br><span class="line">        (mmap: reserved=8323072KB, committed=192512KB)</span><br><span class="line">        //chao xi 可耻</span><br></pre></td></tr></table></figure>

<p><strong>2.元空间</strong>，JVM 将类文件加载到内存中用于后续使用占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类以及相关元素。对应的 Java 反射类 Class 还是在堆内存空间中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码      //Class 是类元空间总占用，reserve 了 1050202KB，当前 commit 了 10522KB 用于实际使用</span><br><span class="line">      //总共 reserved 1050202KB = mmap reserved 1048576KB + malloc 1626KB</span><br><span class="line">      //总共 committed 10522KB = mmap committed 8896KB + malloc 1626KB</span><br><span class="line">      Class (reserved=1050202KB, committed=10522KB)</span><br><span class="line">            (classes #15409) //一共加载了 15409 个类</span><br><span class="line">            (  instance classes #14405, array classes #1004) //其中 14405 个实体类，1004 个数组类</span><br><span class="line">            (malloc=1626KB #33495) //通过 malloc 系统调用方式一共分配了 1626KB，一共调用了 33495 次 malloc</span><br><span class="line">            (mmap: reserved=1048576KB, committed=8896KB) //通过 mmap 系统调用方式 reserve 了 1048576KB，当前 commit 了 8896KB 用于实际使用</span><br><span class="line">            (  Metadata:   )//注意，MetaData 这块不属于类元空间，属于数据元空间，后面第四章会详细分析</span><br><span class="line">            (    reserved=57344KB, committed=57216KB) //数据元空间当前 reserve 了 57344KB，commit 了 57216KB 用于实际使用</span><br><span class="line">            (    used=56968KB) //但是实际从 MetaChunk 的角度去看使用，只有 56968KB 用于实际数据的分配，有 248KB 的浪费</span><br><span class="line">            (    waste=248KB =0.43%)</span><br><span class="line">            (  Class space:)</span><br><span class="line">            (    reserved=1048576KB, committed=8896KB) //类元空间当前 reserve 了 1048576KB，commit 了 8896KB 用于实际使用</span><br><span class="line">            (    used=8651KB) //但是实际从 MetaChunk 的角度去看使用，只有 8651KB 用于实际数据的分配，有 245KB 的浪费</span><br><span class="line">            (    waste=245KB =2.75%)</span><br><span class="line">            洗稿去shi</span><br><span class="line">      Shared class space (reserved=12032KB, committed=12032KB) //共享类空间，当前 reserve 了 12032KB，commit 了 12032KB 用于实际使用，这块其实属于上面 Class 的一部分</span><br><span class="line">            (mmap: reserved=12032KB, committed=12032KB) </span><br><span class="line">      Module (reserved=403KB, committed=403KB) //加载并记录模块占用空间，当前 reserve 了 403KB，commit 了 403KB 用于实际使用</span><br><span class="line">            (malloc=403KB #2919) </span><br><span class="line">      Metaspace (reserved=57606KB, committed=57478KB) //等价于上面 Class 中的 MetaChunk（除了 malloc 的部分），当前 reserve 了 57606KB，commit 了 57478KB 用于实际使用</span><br><span class="line">            (malloc=262KB #180) </span><br><span class="line">            (mmap: reserved=57344KB, committed=57216KB)</span><br></pre></td></tr></table></figure>

<p><strong>3.C++ 字符串即符号(Symbol)占用空间</strong>，前面加载类的时候，其实里面有很多字符串信息（注意不是 Java 字符串，是 JVM 层面 C++ 字符串），不同类的字符串信息可能会重复（维护原创打死潮汐犬）。所以统一放入符号表(Symbol table)复用。元空间中保存的是针对符号表中符号的引用。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Symbol (reserved=18629KB, committed=18629KB)</span><br><span class="line">(malloc=16479KB #445877) //通过 malloc 系统调用方式一共分配了 16479KB，一共调用了 445877 次 malloc</span><br><span class="line">(arena=2150KB #1) //通过 arena 系统调用方式一共分配了 2150KB，一共调用了 1 次 arena</span><br></pre></td></tr></table></figure>

<p><strong>4.线程占用内存</strong>，主要是每个线程的线程栈，我们也只会主要分析线程栈占用空间（在第五章），其他的管理线程占用的空间很小，可以忽略不计。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码//总共 reserve 了 669351KB，commit 了 41775KB</span><br><span class="line">Thread (reserved=669351KB, committed=41775KB)</span><br><span class="line">    (thread #653)//当前线程数量是 653</span><br><span class="line">    (stack: reserved=667648KB, committed=40072KB) //线程栈占用的空间：我们没有指定 Xss，默认是 1MB，所以 reserved 是 653 * 1024 = 667648KB，当前 commit 了 40072KB 用于实际使用</span><br><span class="line">    (malloc=939KB #3932) //通过 malloc 系统调用方式一共分配了 939KB，一共调用了 3932 次 malloc</span><br><span class="line">    (arena=764KB #1304)  //通过 JVM 内部 Arena 分配的内存，一共分配了 764KB，一共调用了 1304 次 Arena 分配</span><br></pre></td></tr></table></figure>

<p><strong>5.JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间</strong>，这也不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Code (reserved=50742KB, committed=17786KB)</span><br><span class="line">(malloc=1206KB #9495) </span><br><span class="line">(mmap: reserved=49536KB, committed=16580KB) </span><br><span class="line">//chao xi 直接去火葬场炒</span><br><span class="line">Compiler (reserved=159KB, committed=159KB)</span><br><span class="line">(malloc=29KB #813) </span><br><span class="line">(arena=131KB #3)</span><br></pre></td></tr></table></figure>

<p><strong>6.Arena 数据结构占用空间</strong>，我们看到 Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Arena Chunk (reserved=187KB, committed=187KB)</span><br><span class="line">(malloc=187KB)</span><br></pre></td></tr></table></figure>

<p><strong>7.JVM Tracing 占用内存</strong>，包括 JVM perf 以及 JFR 占用的空间。其中 JFR 占用的空间可能会比较大，我在我的另一个关于 JFR 的系列里面分析过 JVM 内存中占用的空间。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Tracing (reserved=32KB, committed=32KB)</span><br><span class="line">(arena=32KB #1)</span><br></pre></td></tr></table></figure>

<p><strong>8.写 JVM 日志占用的内存</strong>（<code>-Xlog</code> 参数指定的日志输出，并且 Java 17 之后引入了异步 JVM 日志<code>-Xlog:async</code>，异步日志所需的 buffer 也在这里），这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Logging (reserved=5KB, committed=5KB)</span><br><span class="line">(malloc=5KB #216)</span><br></pre></td></tr></table></figure>

<p><strong>9.JVM 参数占用内存</strong>，我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Arguments (reserved=31KB, committed=31KB)</span><br><span class="line">(malloc=31KB #90)</span><br></pre></td></tr></table></figure>

<p><strong>10.JVM 安全点占用内存</strong>，是固定的两页内存（我这里是一页是 4KB，后面第二章会分析这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化。JVM 安全点请期待本系列文章的下一系列：全网最硬核的 JVM 安全点与线程握手机制解析。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Safepoint (reserved=8KB, committed=8KB)</span><br><span class="line">(mmap: reserved=8KB, committed=8KB)</span><br></pre></td></tr></table></figure>

<p><strong>11.Java 同步机制</strong>（例如 <code>synchronized</code>，还有 AQS 的基础 <code>LockSupport</code>）底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Synchronization (reserved=56KB, committed=56KB)</span><br><span class="line">(malloc=56KB #789)</span><br></pre></td></tr></table></figure>

<p><strong>12.JVM TI 相关内存</strong>，JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。JVMTI API 是一组 C/C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。例如，可以使用 JVMTI API 开发性能分析工具、代码覆盖率工具、内存泄漏检测工具等等。这里的内存就是调用了 JVMTI API 之后 JVM 为了生成数据占用的内存。这不是本期内容的重点，我们不会详细分析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Serviceability (reserved=1KB, committed=1KB)</span><br><span class="line">(malloc=1KB #18)</span><br></pre></td></tr></table></figure>

<p><strong>13.Java 字符串去重占用内存</strong>：Java 字符串去重机制可以减少应用程序中字符串对象的内存占用。 在 Java 应用程序中，字符串常量是不可变的，并且通常被使用多次。这意味着在应用程序中可能存在大量相同的字符串对象，这些对象占用了大量的内存。Java 字符串去重机制通过在堆中共享相同的字符串对象来解决这个问题。当一个字符串对象被创建时，JVM 会检查堆中是否已经存在相同的字符串对象。如果存在，那么新的字符串对象将被舍弃，而引用被返回给现有的对象。这样就可以减少应用程序中字符串对象的数量，从而减少内存占用。 但是这个机制一直在某些 GC 下表现不佳，尤其是 G1GC 以及 ZGC 中，所以默认是关闭的，可以通过 <code>-XX:+UseStringDeduplication</code> 来启用。这不是本期内容的重点，我们不会详细分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码String Deduplication (reserved=1KB, committed=1KB)</span><br><span class="line">(malloc=1KB #8)</span><br></pre></td></tr></table></figure>

<p><strong>14.JVM GC需要的数据结构与记录信息占用的空间</strong>，这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 ZGC。其实 ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停。之后的 ZGC 优化方向就是尽量降低 CPU 消耗与内存占用，相当于提高了性价比。这不是本期内容的重点，我们不会详细分析。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码GC (reserved=370980KB, committed=69260KB)</span><br><span class="line">(malloc=28516KB #8340) </span><br><span class="line">(mmap: reserved=342464KB, committed=40744KB)</span><br></pre></td></tr></table></figure>

<p><strong>15.JVM内部(不属于其他类的占用就会归到这一类)与其他占用(不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)，不会很大</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码Internal (reserved=1373KB, committed=1373KB)</span><br><span class="line">(malloc=1309KB #6135) </span><br><span class="line">(mmap: reserved=64KB, committed=64KB) </span><br><span class="line"></span><br><span class="line">Other (reserved=12348KB, committed=12348KB)</span><br><span class="line">(malloc=12348KB #14)</span><br></pre></td></tr></table></figure>

<p><strong>16.开启 Native Memory Tracking 本身消耗的内存</strong>，这个就不用多说了吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码Native Memory Tracking (reserved=8426KB, committed=8426KB)</span><br><span class="line">(malloc=325KB #4777) </span><br><span class="line">(tracking overhead=8102KB)</span><br></pre></td></tr></table></figure>

<h2 id="1-4-Native-Memory-Tracking-的-summary-信息的持续监控"><a href="#1-4-Native-Memory-Tracking-的-summary-信息的持续监控" class="headerlink" title="1.4. Native Memory Tracking 的 summary 信息的持续监控"></a>1.4. Native Memory Tracking 的 summary 信息的持续监控</h2><p>现在 JVM 一般大部分部署在 k8s 这种云容器编排的环境中，每个 JVM 进程内存是受限的。如果超过限制，那么会触发 OOMKiller 将这个 JVM 进程杀掉。我们一般都是由于自己的 JVM 进程被 OOMKiller 杀掉，才会考虑打开 NativeMemoryTracking 去看看哪块内存占用比较多以及如何调整的。</p>
<p>OOMKiller 是积分制，并不是你的 JVM 进程一超过限制就立刻会被杀掉，而是超过的话会累积分，累积到一定程度，就可能会被 OOMKiller 杀掉。所以，我们可以通过定时输出 Native Memory Tracking 的 summary 信息，<strong>从而抓到超过内存限制的点进行分析</strong>。</p>
<p>但是，我们<strong>不能仅通过 Native Memory Tracking 的数据就判断 JVM 占用的内存</strong>，因为在后面的 JVM 内存申请与使用流程的分析我们会看到，JVM 通过 mmap 分配的大量内存都是先 reserve 再 commit 之后实际往里面写入数据的时候，才会真正分配物理内存。同时，JVM 还会动态释放一些内存，这些内存可能不会立刻被操作系统回收。Native Memory Tracking 是 JVM 认为自己向操作系统申请的内存，与实际操作系统分配的内存是有所差距的，所以我们不能只查看 Native Memory Tracking 去判断，我们还需要查看能体现真正内存占用指标。这里可以查看 linux 进程监控文件 <code>smaps_rollup</code> 看出具体的内存占用，例如 (一般不看 Rss，因为如果涉及多个虚拟地址映射同一个物理地址的话会有不准确，所以主要关注 Pss 即可，但是 Pss 更新不是实时的，但也差不多，这就可以理解为进程占用的实际物理内存)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd复制代码&gt; cat /proc/23/smaps_rollup </span><br><span class="line">689000000-fffff53a9000 ---p 00000000 00:00 0                             [rollup]</span><br><span class="line">Rss:             5870852 kB</span><br><span class="line">Pss:             5849120 kB</span><br><span class="line">Pss_Anon:        5842756 kB</span><br><span class="line">Pss_File:           6364 kB</span><br><span class="line">Pss_Shmem:             0 kB</span><br><span class="line">Shared_Clean:      27556 kB</span><br><span class="line">Shared_Dirty:          0 kB</span><br><span class="line">Private_Clean:       524 kB</span><br><span class="line">Private_Dirty:   5842772 kB</span><br><span class="line">Referenced:      5870148 kB</span><br><span class="line">Anonymous:       5842756 kB</span><br><span class="line">LazyFree:              0 kB</span><br><span class="line">AnonHugePages:         0 kB</span><br><span class="line">ShmemPmdMapped:        0 kB</span><br><span class="line">FilePmdMapped:        0 kB</span><br><span class="line">Shared_Hugetlb:        0 kB</span><br><span class="line">Private_Hugetlb:       0 kB</span><br><span class="line">Swap:                  0 kB</span><br><span class="line">SwapPss:               0 kB</span><br><span class="line">Locked:                0 kB</span><br></pre></td></tr></table></figure>

<p>笔者通过在每个 Spring Cloud 微服务进程加入下面的代码，来实现定时的进程内存监控，主要通过 smaps_rollup 查看实际的物理内存占用找到内存超限的时间点，Native Memory Tracking 查看 JVM 每块内存占用的多少，用于指导优化参数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码import lombok.extern.log4j.Log4j2;</span><br><span class="line">import org.apache.commons.io.FileUtils;</span><br><span class="line">import org.springframework.boot.context.event.ApplicationReadyEvent;</span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line"></span><br><span class="line">import java.io.BufferedReader;</span><br><span class="line">import java.io.File;</span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStreamReader;</span><br><span class="line">import java.util.List;</span><br><span class="line">import java.util.concurrent.ScheduledThreadPoolExecutor;</span><br><span class="line">import java.util.concurrent.TimeUnit;</span><br><span class="line">import java.util.concurrent.atomic.AtomicBoolean;</span><br><span class="line">import java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line">import static org.springframework.cloud.bootstrap.BootstrapApplicationListener.BOOTSTRAP_PROPERTY_SOURCE_NAME;</span><br><span class="line"></span><br><span class="line">@Log4j2</span><br><span class="line">public class MonitorMemoryRSS implements ApplicationListener&lt;ApplicationReadyEvent&gt; &#123;</span><br><span class="line">    private static final AtomicBoolean INITIALIZED = new AtomicBoolean(false);</span><br><span class="line"></span><br><span class="line">    private static final ScheduledThreadPoolExecutor sc = new ScheduledThreadPoolExecutor(1);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onApplicationEvent(ApplicationReadyEvent event) &#123;</span><br><span class="line">        if (isBootstrapContext(event)) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (INITIALIZED) &#123;</span><br><span class="line">            if (INITIALIZED.get()) &#123;</span><br><span class="line">                return;</span><br><span class="line">            &#125;</span><br><span class="line">            sc.scheduleAtFixedRate(() -&gt; &#123;</span><br><span class="line">                long pid = ProcessHandle.current().pid();</span><br><span class="line">                try &#123;</span><br><span class="line">                    //读取 smaps_rollup</span><br><span class="line">                    List&lt;String&gt; strings = FileUtils.readLines(new File(&quot;/proc/&quot; + pid + &quot;/smaps_rollup&quot;));</span><br><span class="line">                    log.info(&quot;MonitorMemoryRSS, smaps_rollup: &#123;&#125;&quot;, strings.stream().collect(Collectors.joining(&quot;\n&quot;)));</span><br><span class="line">                    //读取 Native Memory Tracking 信息</span><br><span class="line">                    Process process = Runtime.getRuntime().exec(new String[]&#123;&quot;jcmd&quot;, pid + &quot;&quot;, &quot;VM.native_memory&quot;&#125;);</span><br><span class="line">                    try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()))) &#123;</span><br><span class="line">                        log.info(&quot;MonitorMemoryRSS, native_memory: &#123;&#125;&quot;, reader.lines().collect(Collectors.joining(&quot;\n&quot;)));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; catch (IOException e) &#123;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;, 0, 30, TimeUnit.SECONDS);</span><br><span class="line">            INITIALIZED.set(true);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static boolean isBootstrapContext(ApplicationReadyEvent applicationEvent) &#123;</span><br><span class="line">        return applicationEvent.getApplicationContext().getEnvironment().getPropertySources().contains(BOOTSTRAP_PROPERTY_SOURCE_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，笔者还将这些输出抽象为 JFR 事件，效果是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/093ad74c646b6f85ccd4d0b72e4d67382e154c09f20922a27e5172f0d4d7eff3" alt="image"></p>
<h2 id="1-5-为何-Native-Memory-Tracking-中申请的内存分为-reserved-和-committed"><a href="#1-5-为何-Native-Memory-Tracking-中申请的内存分为-reserved-和-committed" class="headerlink" title="1.5. 为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed"></a>1.5. 为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</h2><p>这个会在第二章详细分析</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225871227743043644" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 4Java 堆内存大小的</title>
    <url>/7225874698906615864.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么<ol>
<li>什么时候用到元空间，以及释放时机</li>
<li>元空间保存什么</li>
</ol>
</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><h1 id="Java-堆内存相关设计"><a href="#Java-堆内存相关设计" class="headerlink" title="Java 堆内存相关设计"></a>Java 堆内存相关设计</h1></li>
</ol>
<h2 id="3-1-通用初始化与扩展流程"><a href="#3-1-通用初始化与扩展流程" class="headerlink" title="3.1. 通用初始化与扩展流程"></a>3.1. 通用初始化与扩展流程</h2><p>目前最新的 JVM，主要根据三个指标初始化堆以及扩展或缩小堆：</p>
<ul>
<li><strong>最大堆大小</strong></li>
<li><strong>最小堆大小</strong></li>
<li><strong>初始堆大小</strong></li>
</ul>
<p>不同的 GC 情况下，初始化以及扩展的流程可能在某些细节不太一样，但是，大体的思路都是：</p>
<ol>
<li>初始化阶段，reserve <strong>最大堆</strong>大小，并且 commit <strong>初始堆</strong>大小</li>
<li>在某些 GC 的某些阶段，根据上次 GC 的数据，动态扩展或者缩小堆大小，扩展就是 commit 更多，缩小就是 uncommit 一部分内存。但是，堆大小不会小于<strong>最小堆大小</strong>，也不会大于<strong>最大堆大小</strong></li>
</ol>
<h2 id="3-2-直接指定三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-的方式"><a href="#3-2-直接指定三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-的方式" class="headerlink" title="3.2. 直接指定三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)的方式"></a>3.2. 直接指定三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)的方式</h2><p>这三个指标，直接对应的 JVM 参数是：</p>
<ul>
<li><strong>最大堆大小</strong>：<code>MaxHeapSize</code>，如果没有指定的话会有默认<strong>预设值</strong>用于指导 JVM 计算这些指标的大小，下一章节会详细分析，<strong>预设值为 125MB 左右</strong>（96M*13/10）</li>
<li><strong>最小堆大小</strong>：<code>MinHeapSize</code>，默认为 0，0 代表让 JVM 自己计算，下一章节会详细分析</li>
<li><strong>初始堆大小</strong>：<code>InitialHeapSize</code>，默认为 0，0 代表让 JVM 自己计算，下一章节会详细分析</li>
</ul>
<p>对应源码是：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码#define ScaleForWordSize(x) align_down((x) * 13 / 10, HeapWordSize)</span><br><span class="line"></span><br><span class="line">product(size_t, MaxHeapSize, ScaleForWordSize(96*M),                \</span><br><span class="line">  &quot;Maximum heap size (in bytes)&quot;)                                   \</span><br><span class="line">  constraint(MaxHeapSizeConstraintFunc,AfterErgo)                   \</span><br><span class="line">product(size_t, MinHeapSize, 0,                                     \</span><br><span class="line">  &quot;Minimum heap size (in bytes); zero means use ergonomics&quot;)        \</span><br><span class="line">  constraint(MinHeapSizeConstraintFunc,AfterErgo)                   \</span><br><span class="line">product(size_t, InitialHeapSize, 0,                                 \</span><br><span class="line">  &quot;Initial heap size (in bytes); zero means use ergonomics&quot;)        \</span><br><span class="line">  constraint(InitialHeapSizeConstraintFunc,AfterErgo)               \</span><br></pre></td></tr></table></figure>

<p>我们可以通过类似于 <code>-XX:MaxHeapSize=1G</code> 这种启动参数对这三个指标进行设置，但是，我们经常看到的可能是 <code>Xmx</code> 以及 <code>Xms</code> 这两个参数设置这三个指标，这两个参数分别对应：</p>
<ul>
<li><code>Xmx</code>：对应 <strong>最大堆大小</strong> 等价于 <code>MaxHeapSize</code></li>
<li><code>Xms</code>：相当于同时设置<strong>最小堆大小</strong> <code>MinHeapSize</code> 和<strong>初始堆大小</strong> <code>InitialHeapSize</code></li>
</ul>
<p>对应的 JVM 源码是：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/runtime/arguments.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/runtime/arguments.cpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码//如果设置了 Xms</span><br><span class="line">else if (match_option(option, &quot;-Xms&quot;, &amp;tail)) &#123;</span><br><span class="line">  julong size = 0;</span><br><span class="line">  //解析 Xms 大小</span><br><span class="line">  ArgsRange errcode = parse_memory_size(tail, &amp;size, 0);</span><br><span class="line">  if (errcode != arg_in_range) &#123;</span><br><span class="line">    jio_fprintf(defaultStream::error_stream(),</span><br><span class="line">                &quot;Invalid initial heap size: %s\n&quot;, option-&gt;optionString);</span><br><span class="line">    describe_range_error(errcode);</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  //将解析的值设置到 MinHeapSize</span><br><span class="line">  if (FLAG_SET_CMDLINE(MinHeapSize, (size_t)size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  //将解析的值设置到 InitialHeapSize</span><br><span class="line">  if (FLAG_SET_CMDLINE(InitialHeapSize, (size_t)size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">//如果设置了 Xmx</span><br><span class="line">&#125; else if (match_option(option, &quot;-Xmx&quot;, &amp;tail) || match_option(option, &quot;-XX:MaxHeapSize=&quot;, &amp;tail)) &#123;</span><br><span class="line">  julong long_max_heap_size = 0;</span><br><span class="line">  //解析 Xmx 大小</span><br><span class="line">  ArgsRange errcode = parse_memory_size(tail, &amp;long_max_heap_size, 1);</span><br><span class="line">  if (errcode != arg_in_range) &#123;</span><br><span class="line">    jio_fprintf(defaultStream::error_stream(),</span><br><span class="line">                &quot;Invalid maximum heap size: %s\n&quot;, option-&gt;optionString);</span><br><span class="line">    describe_range_error(errcode);</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">  //将解析的值设置到 MaxHeapSize</span><br><span class="line">  if (FLAG_SET_CMDLINE(MaxHeapSize, (size_t)long_max_heap_size) != JVMFlag::SUCCESS) &#123;</span><br><span class="line">    return JNI_EINVAL;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后提一句，JVM 启动参数，同一个参数可以多次出现，但是只有最后一个会生效，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码java -XX:MaxHeapSize=8G -XX:MaxHeapSize=4G -XX:MaxHeapSize=8M -version</span><br></pre></td></tr></table></figure>

<p>这个命令启动的 JVM MaxHeapSize 为 8MB。由于前面提到 Xmx 与 MaxHeapSize 是等价的，所以这么写也是可以的(虽然最后 MaxHeapSize 还是 8MB)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码java -Xmx=8G -XX:MaxHeapSize=4G -XX:MaxHeapSize=8M -version</span><br></pre></td></tr></table></figure>

<h2 id="3-3-不手动指定三个指标的情况下，这三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-是如何计算的"><a href="#3-3-不手动指定三个指标的情况下，这三个指标-MinHeapSize-MaxHeapSize-InitialHeapSize-是如何计算的" class="headerlink" title="3.3. 不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的"></a>3.3. 不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</h2><p>上一章节我们提到我们可以手动指定这三个参数，如果不指定呢？JVM 会怎么计算这三个指标的大小？首先，当然，JVM 会读取 <strong>JVM 可用内存</strong>：首先 JVM 需要知道自己可用多少内存，我们称为<strong>可用内存</strong>。由此引入第一个 JVM 参数，<code>MaxRAM</code>，这个参数是用来明确指定 JVM 进程可用内存大小的，如果没有指定，JVM 会自己读取系统可用内存。这个可用内存用来指导 JVM 限制最大堆内存。后面我们会看到很多 JVM 参数与这个可用内存相关。</p>
<p>前面我们还提到了，就算没有指定 <code>MaxHeapSize</code> 或者 <code>Xmx</code>，<code>MaxHeapSize</code> 也有自己预设的一个参考值。源码中这个<strong>预设参考值</strong>为 125MB 左右（<code>96M*13/10</code>）。但是<strong>一般最后不会以这个参考值为准，JVM 初始化的时候会有很复杂的计算计算出合适的值</strong>。比如你可以在你的电脑上执行下下面的命令，可以看到类似下面的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码&gt;  java -XX:+UnlockDiagnosticVMOptions -XX:+PrintFlagsFinal -version|grep MaxHeapSize</span><br><span class="line">   size_t MaxHeapSize                              = 1572864000                                &#123;product&#125; &#123;ergonomic&#125;</span><br><span class="line">   size_t SoftMaxHeapSize                          = 1572864000                             &#123;manageable&#125; &#123;ergonomic&#125;</span><br><span class="line">openjdk version &quot;17.0.2&quot; 2022-01-18 LTS</span><br><span class="line">OpenJDK Runtime Environment Corretto-17.0.2.8.1 (build 17.0.2+8-LTS)</span><br><span class="line">OpenJDK 64-Bit Server VM Corretto-17.0.2.8.1 (build 17.0.2+8-LTS, mixed mode, sharing)</span><br></pre></td></tr></table></figure>

<p>可以看到 <code>MaxHeapSize</code> 的大小，以及它的值是通过 ergonomic 决定的。也就是非人工指定而是 JVM 自己算出来的。</p>
<p>上面提到的那个 125MB 左右的初始参考值，一般用于 JVM 计算。我们接下来就会分析这个计算流程，首先是最大堆内存 MaxHeapSize 的计算流程：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/486fc72062dd78a871cf80aaf14c598e1a4904a73281095c2346dee06dd9362f" alt="image"></p>
<p>流程中涉及了以下几个参数，还有一些已经过期的参数，会被转换成未过期的参数：</p>
<ul>
<li><code>MinRAMPercentage</code>：注意不要被名字迷惑，这个参数是在<strong>可用内存</strong>比较小的时候生效，即最大堆内存占用为<strong>可用内存</strong>的这个参数指定的百分比，默认为 50，即 50%</li>
<li><code>MaxRAMPercentage</code>：注意不要被名字迷惑，这个参数是在<strong>可用内存</strong>比较大的时候生效，即最大堆内存占用为<strong>可用内存</strong>的这个参数指定的百分比，默认为 25，即 25%</li>
<li><code>ErgoHeapSizeLimit</code>：通过自动计算，计算出的最大堆内存大小不超过这个参数指定的大小，默认为 0 即不限制</li>
<li><code>MinRAMFraction</code>: 已过期，如果配置了会转化为 <code>MinRAMPercentage</code> 换算关系是：<code>MinRAMPercentage</code> = 100.0 / <code>MinRAMFraction</code>，默认是 2</li>
<li><code>MaxRAMFraction</code>: 已过期，如果配置了会转化为 <code>MaxRAMPercentage</code> 换算关系是：<code>MaxRAMPercentage</code> = 100.0 / <code>MaxRAMFraction</code>，默认是 4</li>
</ul>
<p>对应的源码是：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">erlang复制代码product(double, MinRAMPercentage, 50.0,                             \</span><br><span class="line">  &quot;Minimum percentage of real memory used for maximum heap&quot;         \</span><br><span class="line">  &quot;size on systems with small physical memory size&quot;)                \</span><br><span class="line">  range(0.0, 100.0)                                                 \</span><br><span class="line">product(double, MaxRAMPercentage, 25.0,                             \</span><br><span class="line">  &quot;Maximum percentage of real memory used for maximum heap size&quot;)   \</span><br><span class="line">  range(0.0, 100.0)                                                 \</span><br><span class="line">product(size_t, ErgoHeapSizeLimit, 0,                               \</span><br><span class="line">  &quot;Maximum ergonomically set heap size (in bytes); zero means use &quot; \</span><br><span class="line">  &quot;MaxRAM * MaxRAMPercentage / 100&quot;)                                \</span><br><span class="line">  range(0, max_uintx)                                               \</span><br><span class="line">product(uintx, MinRAMFraction, 2,                                   \</span><br><span class="line">  &quot;Minimum fraction (1/n) of real memory used for maximum heap &quot;    \</span><br><span class="line">  &quot;size on systems with small physical memory size. &quot;               \</span><br><span class="line">  &quot;Deprecated, use MinRAMPercentage instead&quot;)                       \</span><br><span class="line">  range(1, max_uintx)                                               \</span><br><span class="line">product(uintx, MaxRAMFraction, 4,                                   \</span><br><span class="line">  &quot;Maximum fraction (1/n) of real memory used for maximum heap &quot;    \</span><br><span class="line">  &quot;size. &quot;                                                          \</span><br><span class="line">  &quot;Deprecated, use MaxRAMPercentage instead&quot;)                       \</span><br><span class="line">  range(1, max_uintx)                                               \</span><br></pre></td></tr></table></figure>

<p>然后如果我们也没有设置 <code>MinHeapSize</code> 以及 <code>InitialHeapSize</code>，也会经过下面的计算过程计算出来：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7391bdb93def1c96c3074fe8d6fe198e9416f79b601e31e94775bcdb7f79ec83" alt="image"></p>
<p>流程中涉及了以下几个参数，还有一些已经过期的参数，会被转换成未过期的参数：</p>
<ul>
<li><code>NewSize</code>：初始新生代大小，预设值为 1.3MB 左右（<code>1*13/10</code>）</li>
<li><code>OldSize</code>：老年代大小，预设值为 5.2 MB 左右（<code>4*13/10</code>）</li>
<li><code>InitialRAMPercentage</code>：初始堆内存为<strong>可用内存</strong>的这个参数指定的百分比，默认为 1.5625，即 1.5625%</li>
<li><code>InitialRAMFraction</code>: 已过期，如果配置了会转化为 <code>InitialRAMPercentage</code> 换算关系是：<code>InitialRAMPercentage</code> = 100.0 / <code>InitialRAMFraction</code></li>
</ul>
<p>对应的源码是：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/gc/shared/gc_globals.hpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码product(size_t, NewSize, ScaleForWordSize(1*M),                     \</span><br><span class="line">  &quot;Initial new generation size (in bytes)&quot;)                         \</span><br><span class="line">  constraint(NewSizeConstraintFunc,AfterErgo)                       \</span><br><span class="line">product(size_t, OldSize, ScaleForWordSize(4*M),                     \</span><br><span class="line">  &quot;Initial tenured generation size (in bytes)&quot;)                     \</span><br><span class="line">  range(0, max_uintx)                                               \</span><br><span class="line">product(double, InitialRAMPercentage, 1.5625,                       \</span><br><span class="line">  &quot;Percentage of real memory used for initial heap size&quot;)           \</span><br><span class="line">  range(0.0, 100.0)                                                 \</span><br><span class="line">product(uintx, InitialRAMFraction, 64,                              \</span><br><span class="line">  &quot;Fraction (1/n) of real memory used for initial heap size. &quot;      \</span><br><span class="line">  &quot;Deprecated, use InitialRAMPercentage instead&quot;)                   \</span><br><span class="line">  range(1, max_uintx)                                               \</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225874698906615864" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 2JVM 内存申请与使用</title>
    <url>/7225875600644407357.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><h1 id="JVM-内存申请与使用流程"><a href="#JVM-内存申请与使用流程" class="headerlink" title="JVM 内存申请与使用流程"></a>JVM 内存申请与使用流程</h1></li>
</ol>
<h2 id="2-1-Linux-下内存管理模型简述"><a href="#2-1-Linux-下内存管理模型简述" class="headerlink" title="2.1. Linux 下内存管理模型简述"></a>2.1. Linux 下内存管理模型简述</h2><p>Linux 内存管理模型不是咱们这个系列的讨论重点，我们这里只会简单提一些对于咱们这个系列需要了解到的，如果读者想要深入理解，建议大家查看 <strong>bin 神（公众号：bin 的技术小屋）的系列文章</strong>：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21&key=d9f8952995f1859ec52d8f5d9e6ab4720ffabd5403c103322ee7ec6f45279c0d6ff004df4d91e603b8da30fc862da32560064a1680e06e498f1478dedf8d24cd54abfe5bbf80610ac6a1ecfcadeceb1ce74fd27e061bc962a5e9d18c369786619a9ac7ad030b16a0f350638aed32ec61ad2c47b2df53b2fffac6419c8a55feb1&ascene=2&uin=MTQxMDM0OTkyNA%3D%3D&devicetype=Windows+11+x64&version=6308011a&exportkey=n_ChQIAhIQLReSAiPPBq%2FrjeEsvhWLGhLpAQIE97dBBAEAAAAAAPboBnzhWE0AAAAOpnltbLcz9gKNyK89dVj0LB8MByB%2BLnarvTJ9k5LjHnaHSiRCVUH6zSSXMnbZ9AQCusp6IDK5hwtnugd9Du4BG2pqPuJHPIkVIcUMia320lXFN61yM%2F%2B2MKyl86soaJUlu0zu8x69eop1Fbdi4YBaoocZrDbr%2BBuq4hsy%2BKf6ElIQw%2B6gPfQqllJ5R86pa0DoVOjdnD2bi7ZuxdMyvcOPEu3pDa5H%2FBgY1A%2BDcifqtVZlp%2B5LoJKYNhtlZg1zOS06RY15Ry0DdonN38efMsG2Req%2F&acctmode=0&pass_ticket=ywhUvrTZ0ZCaWLuvLdidNGnNwyS7T41V%2BKEL2N0td3RvwmPJ%2BZREM3Zc0lit4wDxNhALtKqF2gPCKD6sLdagzA%3D%3D&wx_header=1&fontgear=2" target="_blank" rel="noopener">一步一图带你深入理解 Linux 虚拟内存管理</a></p>
<p>CPU 是通过寻址来访问内存的，目前大部分 CPU 都是 64 位的，即寻址范围是：<code>0x0000 0000 0000 0000 ~ 0xFFFF FFFF FFFF FFFF</code>，即可以管理 16EB 的内存。但是，实际程序并不会直接通过 CPU 寻址访问到实际的物理内存，而是通过引入 MMU（Memory Management Unit 内存管理单元）与实际物理地址隔了一层<strong>虚拟内存</strong>的抽象。这样，程序申请以及访问的其实是虚拟内存地址，MMU 会将这个虚拟内存地址映射为实际的物理内存地址。同时，为了减少内存碎片，以及增加内存分配效率，在 MMU 的基础上 Linux 抽象了<strong>内存分页</strong>（Paging）的概念，将虚拟地址按固定大小分割成<strong>页</strong>（默认是 4K，如果平台支持更多更大的页大小 JVM 也是可以利用的，我们后面分析相关的 JVM 参数会看到），并在页被实际使用写入数据的时候，映射同样大小的实际的物理内存（<strong>页帧</strong>，Page Frame），或者是在物理内存不足的时候，将某些不常用的页转移到其他存储设备比如磁盘上。</p>
<p>一般系统中会有多个进程使用内存，每个进程都有<strong>自己独立的虚拟内存空间</strong>，假设我们这里有三个进程，进程 A 访问的虚拟地址可以与进程 B 和进程 C 的虚拟地址相同，那么操作系统如何区分呢？即操作系统如何将这些虚拟地址转换为物理内存。这就需要页表了，<strong>页表也是每个进程独立的</strong>，操作系统会在给进程映射物理内存用来保存用户数据的时候，<strong>将物理内存保存到进程的页表里面</strong>。然后，<strong>进程访问虚拟内存空间的时候，通过页表找到物理内存</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/37654d11a3777af74228fae3f1e0f82e3820b06df9ce1e751dcd726ff67587ec" alt="image"></p>
<p>页表如何将一个虚拟内存地址（我们需要注意一点，目前虚拟内存地址，用户空间与内核空间可以使用从 <code>0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF</code> 的地址，即 256TB），转化为物理内存的呢？下面我们举一个在 x86，64 位环境下四级页表的结构视图：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2bfce1a55955ac7570f3fa5158a3b4dda96aee30b9671d284aa1fef6e4fa40b6" alt="image"></p>
<p>在这里，页表分为四个级别：PGD（Page Global Directory），PUD（Page Upper Directory），PMD（Page Middle Directory），PTE（Page Table Entry）。每个页表，里面的页表项，保存了指向下一个级别的页表的引用，除了最后一层的 PTE 里面的页表项保存的是指向用户数据内存的指针。如何将虚拟内存地址通过页表找到对应用户数据内存从而读取数据，过程是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dfc0e1fe0e531af7d976e96cbc5534bfe53d12a5af7ceb75bdddef5fb3362079" alt="image"></p>
<ol>
<li>取虚拟地址的 <code>39 ~ 47</code> 位（因为用户空间与内核空间可以使用从 <code>0x0000 0000 0000 0000 ~ 0x0000 FFFF FFFF FFFF</code> 的地址，即 47 位以下的地址）作为 offset，在唯一的 PGD 页面根据 offset 定位到 PGD 页表项 <code>pgd_t</code></li>
<li>使用 <code>pgd_t</code> 定位到具体的 PUD 页面</li>
<li>取虚拟地址的 <code>30 ~ 38</code> 位作为 offset，在对应的 PUD 页面根据 offset 定位到 PUD 页表项 <code>pud_t</code></li>
<li>使用 <code>pud_t</code> 定位到具体的 PMD 页面</li>
<li>取虚拟地址的 <code>21 ~ 29</code> 位作为 offset，在对应的 PMD 页面根据 offset 定位到 PMD 页表项 <code>pmd_t</code></li>
<li>使用 <code>pmd_t</code> 定位到具体的 PTE 页面</li>
<li>取虚拟地址的 <code>12 ~ 20</code> 位作为 offset，在对应的 PTE 页面根据 offset 定位到 PTE 页表项 <code>pte_t</code></li>
<li>使用 <code>pte_t</code> 定位到具体的用户数据物理内存页面</li>
<li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset</li>
</ol>
<p>如果每次访问虚拟内存，都需要访问这个页表翻译成实际物理内存的话，性能太差。所以一般 CPU 里面都有一个 TLB（Translation Lookaside Buffer，翻译后备缓冲）存在，一般它属于 CPU 的 MMU 的一部分。TLB 负责缓存虚拟内存与实际物理内存的映射关系，一般 TLB 容量很小。每次访问虚拟内存，先查看 TLB 中是否有缓存，如果没有才会去页表查询。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0ec3935f83103c99deac151a367dcdebe90635cebb99c61e1768a80f26b4b630" alt="image"></p>
<p>默认情况下，TLB 缓存的 key 为地址的 <code>12 ~ 47</code> 位，value 是实际的物理内存页面。这样前面从第 1 到第 7 步就可以被替换成访问 TLB 了：</p>
<ol>
<li>取虚拟地址的 <code>12 ~ 47</code> 位作为 key，访问 TLB，定位到具体的用户数据物理内存页面。</li>
<li>使用最后的 <code>0 ~ 11</code> 位作为 offset，对应到用户数据物理内存页面的对应 offset。</li>
</ol>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/30df8d75415050ec58bb213fd64dd0fb858e6daa4f4e13e7985f75e44b51a163" alt="image"></p>
<p>TLB 一般很小，我们来看几个 CPU 中的 TLB 大小，以下图片来自于 <a href="https://www.bilibili.com/video/BV1Xx4y1j7Hu/?spm_id_from=333.999.0.0" target="_blank" rel="noopener">www.bilibili.com/video/BV1Xx…</a><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7c9f9212f26a0b9cbb071862bb17ca04c09347768b3685a531ae91ffdddf5291" alt="image"></p>
<p>我们这里不用关心 iTLB，dTLB，sTLB 分别是什么意思，只要可以看出两点即可：1. TLB 整体可以容纳个数不多；2. 页大小越大，TLB 能容纳的个数越少。但是整体看，TLB 能容纳的页大小还是增多的（比如 Nehalem 的 iTLB，页大小 4K 的时候，一共可以容纳 <code>128 * 4 = 512K</code> 的内存，页大小 2M 的时候，一共可以容纳 <code>2 * 7 = 14M</code> 的内存）。</p>
<p>JVM 中很多地方需要知道页大小，JVM 在初始化的时候，通过系统调用 <a href="https://man7.org/linux/man-pages/man3/sysconf.3.html" target="_blank" rel="noopener"><code>sysconf(_SC_PAGESIZE)</code></a> 读取出页大小，并保存下来以供后续使用。参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码    //设置全局默认页大小，通过 Linux::page_size() 可以获取全局默认页大小</span><br><span class="line">    Linux::set_page_size(sysconf(_SC_PAGESIZE));</span><br><span class="line">    if (Linux::page_size() == -1) &#123;</span><br><span class="line">        fatal(&quot;os_linux.cpp: os::init: sysconf failed (%s)&quot;,</span><br><span class="line">          os::strerror(errno));</span><br><span class="line">    &#125;</span><br><span class="line">    //将默认页大小加入可选的页大小列表，在涉及大页分配的时候有用</span><br><span class="line">    _page_sizes.add(Linux::page_size());</span><br></pre></td></tr></table></figure>

<h2 id="2-2-JVM-主要内存申请分配流程"><a href="#2-2-JVM-主要内存申请分配流程" class="headerlink" title="2.2. JVM 主要内存申请分配流程"></a>2.2. JVM 主要内存申请分配流程</h2><p><strong>第一步，JVM 的每个子系统</strong>（例如 Java 堆，元空间，JIT 代码缓存，GC 等等等等），<strong>如果需要的话，在初始化的时候首先 Reserve 要分配区域的最大限制大小的内存</strong>（这个最大大小，需要按照页大小对齐（即是页大小的整数倍），默认页大小是前面提到的 <code>Linux::page_size()</code>），例如对于 Java 堆，就是最大堆大小（通过 <code>-Xmx</code> 或者 <code>-XX:MaxHeapSize</code>限制），还有对于代码缓存，也是最大代码缓存大小（通过 <code>-XX:ReservedCodeCacheSize</code> 限制）。Reserve 的目的是在虚拟内存空间划出一块内存专门给某个区域使用，这样做的好处是：</p>
<ol>
<li>隔离每个 JVM 子系统使用的内存的虚拟空间，这样在 JVM 代码有 bug 的时候（例如发生 Segment Fault 异常），通过报错中的虚拟内存地址可以快速定位到是哪个子系统出了问题。</li>
<li>可以很方便的限制这个区域使用的最大内存大小。</li>
<li>便于管理，Reserve 不会触发操作系统分配映射实际物理内存，这个区域可以在 Reserve 的区域内按需伸缩。</li>
<li>便于一些 JIT 优化，例如我们故意将这个区域保留起来但是故意不将这个区域的虚拟内存映射物理内存，访问这块内存会造成 Segment Fault 异常。JVM 会预设 Segment Fault 异常的处理器，在处理器里面检查发生 Segment Fault 异常的内存地址属于哪个子系统的 Reserve 的区域，判断要做什么操作。后面我们会看到，null 检查抛出 <code>NullPointerException</code> 异常的优化，全局安全点，抛出 <code>StackOverflowError</code> 的实现，都和这个机制有关。</li>
</ol>
<p>在 Linux 的环境下，Reserve 通过 <a href="https://man7.org/linux/man-pages/man2/mmap.2.html" target="_blank" rel="noopener"><code>mmap(2)</code></a> 系统调用实现，参数传入 <code>prot = PROT_NONE</code>，<code>PROT_NONE</code> 代表不会使用，即不能做任何操作，包括读和写。为啥要打击抄袭，稿主被抄袭太多所以断更很久。如果 JVM 使用这块内存，会发生 Segment Fault 异常。Reserve 的源码，对应的是：</p>
<p>入口为：<a href="https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/share/runtime/os.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/share/runtime/os.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码char* os::reserve_memory(size_t bytes, bool executable, MEMFLAGS flags) &#123;</span><br><span class="line">  //调用每个操作系统实现不同的 pd_reserve_memory 函数进行 reserve</span><br><span class="line">  char* result = pd_reserve_memory(bytes, executable);</span><br><span class="line">  if (result != NULL) &#123;</span><br><span class="line">    MemTracker::record_virtual_memory_reserve(result, bytes, CALLER_PC, flags);</span><br><span class="line">  &#125;不要偷取他人的劳动成果，也不要浪费自己的时间和精力，让我们一起做一个有良知的写作者。</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应 linux 的实现是：<a href="https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/os/linux/os_linux.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/os/linux/os_linux.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码char* os::pd_reserve_memory(size_t bytes, bool exec) &#123;</span><br><span class="line">  return anon_mmap(nullptr, bytes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">static char* anon_mmap(char* requested_addr, size_t bytes) &#123;</span><br><span class="line">  const int flags = MAP_PRIVATE | MAP_NORESERVE | MAP_ANONYMOUS;</span><br><span class="line">  //这里的关键是 PROT_NONE，代表仅仅是在虚拟空间保留，不实际映射物理内存</span><br><span class="line">  //fd 传入的是 -1，因为没有实际映射文件，我们这里目的是为了分配内存，不是将某个文件映射到内存中</span><br><span class="line">  char* addr = (char*)::mmap(requested_addr, bytes, PROT_NONE, flags, -1, 0);</span><br><span class="line">  return addr == MAP_FAILED ? NULL : addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第二步，JVM 的每个子系统，按照各自的策略，通过 Commit 第一步 Reserve 的区域的一部分扩展内存（大小也一般页大小对齐的），从而向操作系统申请映射物理内存，通过 Uncommit 已经 Commit 的内存来释放物理内存给操作系统</strong>。抄袭和xigao是文化的毒瘤，是对文化创造和发展的阻碍！</p>
<p>Commit 的源码入口为：<a href="https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/share/runtime/os.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/share/runtime/os.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码bool os::commit_memory(char* addr, size_t bytes, bool executable) &#123;</span><br><span class="line">  assert_nonempty_range(addr, bytes);</span><br><span class="line">  //调用每个操作系统实现不同的 pd_commit_memory 函数进行 commit</span><br><span class="line">  bool res = pd_commit_memory(addr, bytes, executable);</span><br><span class="line">  if (res) &#123;</span><br><span class="line">    MemTracker::record_virtual_memory_commit((address)addr, bytes, CALLER_PC);</span><br><span class="line">  &#125;</span><br><span class="line">  return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应 linux 的实现是：<a href="https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/os/linux/os_linux.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+9/src/hotspot/os/linux/os_linux.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码bool os::pd_commit_memory(char* addr, size_t size, bool exec) &#123;</span><br><span class="line">  return os::Linux::commit_memory_impl(addr, size, exec) == 0;</span><br><span class="line">&#125;</span><br><span class="line">int os::Linux::commit_memory_impl(char* addr, size_t size, bool exec) &#123;</span><br><span class="line">  //这里的关键是 PROT_READ|PROT_WRITE，即申请需要读写这块内存</span><br><span class="line">  int prot = exec ? PROT_READ|PROT_WRITE|PROT_EXEC : PROT_READ|PROT_WRITE;</span><br><span class="line">  uintptr_t res = (uintptr_t) ::mmap(addr, size, prot,</span><br><span class="line">                                     MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0);</span><br><span class="line">  if (res != (uintptr_t) MAP_FAILED) &#123;</span><br><span class="line">    if (UseNUMAInterleaving) &#123;</span><br><span class="line">      numa_make_global(addr, size);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  int err = errno;  // save errno from mmap() call above</span><br><span class="line"></span><br><span class="line">  if (!recoverable_mmap_error(err)) &#123;</span><br><span class="line">    warn_fail_commit_memory(addr, size, exec, err);</span><br><span class="line">    vm_exit_out_of_memory(size, OOM_MMAP_ERROR, &quot;committing reserved memory.&quot;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Commit 内存之后，<strong>并不是操作系统会立刻分配物理内存，而是在向 Commit 的内存里面写入数据的时候，操作系统才会实际映射内存</strong>。plagiarism和洗稿是恶意抄袭他人劳动成果的行为，是对劳动价值的漠视和践踏！JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 <code>AlwaysPreTouch</code> 这个参数，这个参数我们后面会详细分析以及历史版本存在的缺陷。</p>
<p>我们再来看下为什么先 Reserve 之后 Commit 这样好 Debug。看这个例子，如果我们没有第一步 Reserve，直接是第二步 Commit，那么我们可能分配的内存是这个样子的：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c384dccf0e2936cfb9f9e12ac93ebea659caf5d352801a80295ee33faf1a0d15" alt="image"></p>
<p>假设此时，我们不小心在 JVM 中写了个 bug，导致洗稿狗没了妈，导致 MetaSpace 2 这块内存被回收了，这时候保留指向 MetaSpace 2 的内存的指针就会报 Segment Fault，但是通过 Segment Fault 里面带的地址，我们并不知道是这个地址属于哪里，除非我们有另外的内存结构保存每个子系统 Commit 内存的列表，但是这样效率太低了。如果我们先 Reserve 大块之后在里面 Commit，那么情况就不同了：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2beb14f65c9c52a78a9ec0662ea8185a7a6204d318d71bb7e824ceabd9f5513a" alt="image"></p>
<p>这样，只需要判断 Segment Fault 里面带的地址处于的范围，就能知道是哪个子系统</p>
<h3 id="2-2-1-JVM-commit-的内存与实际占用内存的差异"><a href="#2-2-1-JVM-commit-的内存与实际占用内存的差异" class="headerlink" title="2.2.1. JVM commit 的内存与实际占用内存的差异"></a>2.2.1. JVM commit 的内存与实际占用内存的差异</h3><p>前面一节我们知道了，JVM 中大块内存，基本都是先 reserve 一大块，之后 commit 其中需要的一小块，然后开始读写处理内存，在 Linux 环境下，底层基于 <code>mmap(2)</code> 实现。但是需要注意一点的是，commit 之后，内存并不是立刻被分配了物理内存，而是真正往内存中 store 东西的时候，才会真正映射物理内存，如果是 load 读取也是可能不映射物理内存的。</p>
<p>这其实是可能你平常看到但是忽略的现象，如果你使用的是 SerialGC，ParallelGC 或者 CMS GC，老年代的内存在有对象晋升到老年代之前，可能是不会映射物理内存的，虽然这块内存已经被 commit 了。并且年轻代可能也是随着使用才会映射物理内存。如果你用的是 ZGC，G1GC，或者 ShenandoahGC，那么内存用的会更激进些（主要因为分区算法划分导致内存被写入），<strong>这是你在换 GC 之后看到物理内存内存快速上涨的原因之一</strong>。JVM 有对应的参数，可以在 Commit 内存后立刻写入 0 来强制操作系统分配内存，即 <code>AlwaysPreTouch</code> 这个参数，这个参数我们后面会详细分析以及历史版本存在的缺陷。还有的差异，主要来源于在 uncommit 之后，系统可能还没有来的及将这块物理内存真正回收。</p>
<p>所以，JVM 认为自己 commit 的内存，与实际系统分配的物理内存，可能是有差异的，可能 JVM 认为自己 commit 的内存比系统分配的物理内存多，也可能少。这就是为啥 Native Memory Tracking（JVM 认为自己 commit 的内存）与实际其他系统监控中体现的物理内存使用指标对不上的原因。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225875600644407357" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 5压缩对象指针相关机制</title>
    <url>/7225874698906714168.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么<ol>
<li>什么时候用到元空间，以及释放时机</li>
<li>元空间保存什么</li>
</ol>
</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><h1 id="Java-堆内存相关设计"><a href="#Java-堆内存相关设计" class="headerlink" title="Java 堆内存相关设计"></a>Java 堆内存相关设计</h1></li>
</ol>
<h2 id="3-4-压缩对象指针相关机制-UseCompressedOops"><a href="#3-4-压缩对象指针相关机制-UseCompressedOops" class="headerlink" title="3.4. 压缩对象指针相关机制 - UseCompressedOops"></a>3.4. 压缩对象指针相关机制 - UseCompressedOops</h2><h3 id="3-4-1-压缩对象指针存在的意义"><a href="#3-4-1-压缩对象指针存在的意义" class="headerlink" title="3.4.1. 压缩对象指针存在的意义"></a>3.4.1. 压缩对象指针存在的意义</h3><p>现代机器大部分是 64 位的，JVM 也从 9 开始仅提供 64 位的虚拟机。在 JVM 中，一个对象指针，对应进程存储这个对象的虚拟内存的起始位置，也是 64 位大小：</p>
<p>我们知道，对于 32 位寻址，最大仅支持 4GB 内存的寻址，这在现在的 JVM 很可能不够用，可能仅仅堆大小就超过 4GB。所以目前对象指针一般是 64 位大小来支持大内存。但是，这相对 32 位指针寻址来说，<strong>性能上却有衰减</strong>。我们知道，CPU 仅能处理寄存器里面的数据，寄存器与内存之间，有很多层 CPU 缓存，虽然内存越来越便宜也越来越大，但是 CPU 缓存并没有变大，这就导致如果使用 64 位的指针寻址，相对于之前 32 位的，<strong>CPU 缓存能容纳的指针个数小了一倍</strong>。</p>
<p>Java 是面向对象的语言，JVM 中最多的操作，就是对对象的操作，比如 load 一个对象的字段，store 一个对象的字段，<strong>这些都离不开访问对象指针</strong>。所以 JVM 想尽可能的优化对象指针，这就引入了<strong>压缩对象指针</strong>，让对象指针在条件满足的情况下保持原来的 32 位。</p>
<p>对于 32 位的指针，假设每一个 1 代表 1 字节，那么可以描述 0~2^32-1 这 2^32 字节也就是 4 GB 的虚拟内存。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/81195cab7edf4109cfa3733a015697534ccc2f407a178377fa150f65b53b6417" alt="image"></p>
<p>如果我让每一个 1 代表 8 字节呢？也就是<strong>让这块虚拟内存是 8 字节对齐</strong>，也就是我在使用这块内存时候，最小的分配单元就是 8 字节。对于 Java 堆内存，也就是一个对象占用的空间，必须是 8 字节的整数倍，不足的话会填充到 8 字节的整数倍用于保证对齐。这样最多可以描述 2^32 * 8 字节也就是 32 GB 的虚拟内存。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f192ba6487593fd1ec6901296e050c7ea7a597b38793371cccc31a701fe97641" alt="image"></p>
<p>这就是压缩指针的原理，上面提到的相关 JVM 参数是：<code>ObjectAlignmentInBytes</code>，这个 JVM 参数表示 Java 堆中的每个对象，需要按照几字节对齐，也就是堆按照几字节对齐，<strong>值范围是 8 ~ 256，必须是 2 的 n 次方</strong>，因为 2 的 n 次方能简化很多运算，例如对于 2 的 n 次方取余数就可以简化成对于 2 的 n 次方减一取与运算，乘法和除法可以简化移位。</p>
<p>如果<strong>配置最大堆内存超过 32 GB（当 JVM 是 8 字节对齐），那么压缩指针会失效</strong>（<strong>其实不是超过 32GB，会略小于 32GB 的时候就会失效，还有其他的因素影响，下一节会讲到</strong>）。 但是，这个 32 GB 是和字节对齐大小相关的，<strong>也就是 <code>-XX:ObjectAlignmentInBytes=8</code> 配置的大小(默认为8字节，也就是 Java 默认是 8 字节对齐)</strong>。如果你配置 <code>-XX:ObjectAlignmentInBytes=16</code>，那么最大堆内存超过 64 GB 压缩指针才会失效，如果你配置 <code>-XX:ObjectAlignmentInBytes=32</code>，那么最大堆内存超过 128 GB 压缩指针才会失效.</p>
<h3 id="3-4-2-压缩对象指针与压缩类指针的关系演进"><a href="#3-4-2-压缩对象指针与压缩类指针的关系演进" class="headerlink" title="3.4.2. 压缩对象指针与压缩类指针的关系演进"></a>3.4.2. 压缩对象指针与压缩类指针的关系演进</h3><p>老版本中， <code>UseCompressedClassPointers</code> 取决于 <code>UseCompressedOops</code>，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是<strong>从 Java 15 Build 23 开始， <code>UseCompressedClassPointers</code> 已经不再依赖 <code>UseCompressedOops</code> 了</strong>，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。参考 JDK ISSUE：<a href="https://bugs.openjdk.java.net/browse/JDK-8241825" target="_blank" rel="noopener">bugs.openjdk.java.net/browse/JDK-…</a> 以及源码：</p>
<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/x86/globalDefinitions_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/x86/globalDefinitions_x86.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS EnableJVMCI</code> 在 x86 CPU 上，<code>UseCompressedClassPointers</code> 是否依赖 <code>UseCompressedOops</code> 取决于是否启用了 JVMCI，默认使用的 JVM 发布版，EnableJVMCI 都是 false</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/arm/globalDefinitions_arm.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/arm/globalDefinitions_arm.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false</code> 在 ARM CPU 上，<code>UseCompressedClassPointers</code> 不依赖 <code>UseCompressedOops</code></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/ppc/globalDefinitions_ppc.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/ppc/globalDefinitions_ppc.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false</code> 在 PPC CPU 上，<code>UseCompressedClassPointers</code> 不依赖 <code>UseCompressedOops</code></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/s390/globalDefinitions_s390.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/s390/globalDefinitions_s390.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false</code> 在 S390 CPU 上，<code>UseCompressedClassPointers</code> 不依赖 <code>UseCompressedOops</code></li>
</ul>
<h3 id="3-4-3-压缩对象指针的不同模式与寻址优化机制"><a href="#3-4-3-压缩对象指针的不同模式与寻址优化机制" class="headerlink" title="3.4.3. 压缩对象指针的不同模式与寻址优化机制"></a>3.4.3. 压缩对象指针的不同模式与寻址优化机制</h3><p>对象指针与压缩对象指针如何转化，我们先来思考一些问题。通过第二章的分析我们知道，每个进程有自己的虚拟地址空间，并且<strong>从 0 开始的一些低位空间，是给进程的一些系统调用保留的空间</strong>，例如 <code>0x0000 0000 0000 0000</code> ~ <code>0x0000 0000 0040 0000</code> 是保留区不可使用，如下图所示（本图来自于<strong>bin 神（公众号：bin 的技术小屋）的系列文章</strong>：<a href="https://mp.weixin.qq.com/s?__biz=Mzg2MzU3Mjc3Ng==&mid=2247486732&idx=1&sn=435d5e834e9751036c96384f6965b328&chksm=ce77cb4bf900425d33d2adfa632a4684cf7a63beece166c1ffedc4fdacb807c9413e8c73f298&token=1468822011&lang=zh_CN&scene=21&key=d9f8952995f1859ec52d8f5d9e6ab4720ffabd5403c103322ee7ec6f45279c0d6ff004df4d91e603b8da30fc862da32560064a1680e06e498f1478dedf8d24cd54abfe5bbf80610ac6a1ecfcadeceb1ce74fd27e061bc962a5e9d18c369786619a9ac7ad030b16a0f350638aed32ec61ad2c47b2df53b2fffac6419c8a55feb1&ascene=2&uin=MTQxMDM0OTkyNA%3D%3D&devicetype=Windows+11+x64&version=6308011a&exportkey=n_ChQIAhIQLReSAiPPBq%2FrjeEsvhWLGhLpAQIE97dBBAEAAAAAAPboBnzhWE0AAAAOpnltbLcz9gKNyK89dVj0LB8MByB%2BLnarvTJ9k5LjHnaHSiRCVUH6zSSXMnbZ9AQCusp6IDK5hwtnugd9Du4BG2pqPuJHPIkVIcUMia320lXFN61yM%2F%2B2MKyl86soaJUlu0zu8x69eop1Fbdi4YBaoocZrDbr%2BBuq4hsy%2BKf6ElIQw%2B6gPfQqllJ5R86pa0DoVOjdnD2bi7ZuxdMyvcOPEu3pDa5H%2FBgY1A%2BDcifqtVZlp%2B5LoJKYNhtlZg1zOS06RY15Ry0DdonN38efMsG2Req%2F&acctmode=0&pass_ticket=ywhUvrTZ0ZCaWLuvLdidNGnNwyS7T41V%2BKEL2N0td3RvwmPJ%2BZREM3Zc0lit4wDxNhALtKqF2gPCKD6sLdagzA%3D%3D&wx_header=1&fontgear=2" target="_blank" rel="noopener">一步一图带你深入理解 Linux 虚拟内存管理</a>）</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/413b5246c2401dc2584e0d1c78f1d4dc578bc1d1d92ad5dc91f3767ceed0135b" alt="image"></p>
<p>进程可以申请的空间，是上图所示的<strong>原生堆空间</strong>。所以，JVM 进程的虚拟内存空间，肯定不会从 <code>0x0000 0000 0000 0000</code> 开始。不同的操作系统，这个原生堆空间的起始不太一样，这里我们不关心具体的位置，我们仅知道一点：<strong>JVM 需要从虚拟内存的某一点开始申请内存，并且，需要预留出足够多的空间，给可能的一些系统调用机制使用，比如前面我们 native memory tracking 中看到的一些 malloc 内存，其实某些就在这个预留空间中分配的</strong>。一般的，JVM 会优先考虑 Java 堆的内存在原生堆分配，之后再在原生堆分配其他的，例如元空间，代码缓存空间等等。</p>
<p>JVM 在 Reserve 分配 Java 堆空间的时候，会一下子 Reserve 最大 Java 堆空间的大小，然后在此基础上 Reserve 分配其他的存储空间。之后分配 Java 对象，在 Reserve 的 Java 堆内存空间内 Commit 然后写入数据映射物理内存分配 Java 对象。根据前面说的 Java 堆大小的伸缩策略，决定继续 Commit 占用更多物理内存还是 UnCommit 释放物理内存：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7c60683a9b2c901bbf8f7d9301a3bf59ab5eed17fb24e189ddd623b5681a6e02" alt="image"></p>
<p>Java 是一个面向对象的语言，JVM 中执行最多的就是访问这些对象，<strong>在 JVM 的各种机制中，必须无时无刻考虑怎么优化访问这些对象的速度</strong>，对于压缩对象指针，JVM 就考虑了很多优化。如果我们要使用压缩对象指针，那么需要将这个 64 位的地址，转换为 32 位的地址。然后在读取压缩对象指针所指向的对象信息的时候，需要将这个 32 位的地址，解析为 64 位的地址之后寻址读取。这个转换公式，如下所示：</p>
<ol>
<li><code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li>
<li><code>压缩对象指针 = (64 位地址 - 基址) &gt;&gt; 对象对齐偏移</code></li>
</ol>
<p>基址其实就是对象地址的开始，注意，<strong>这个基址不一定是 Java 堆的开始地址</strong>，我们后面就会看到。对象对齐偏移与前面提到的 <code>ObjectAlignmentInBytes</code> 相关，例如 <code>ObjectAlignmentInBytes=8</code> 的情况下，对象对齐偏移就是 3 （因为 8 是 2 的 3 次方）。<strong>我们针对这个公式进行优化</strong>：</p>
<p>首先，我们考虑把<strong>基址和对象对齐偏移去掉</strong>，那么压缩对象指针可以直接作为对象地址使用。什么情况下可以这样呢？那么就是对象地址从 0 开始算，并且最大堆内存 + Java 堆起始位置不大于 4GB。因为这种情况下，Java 堆中对象的最大地址不会超过 4GB，那么压缩对象指针的范围可以直接表示所有 Java 堆中的对象。可以直接使用压缩对象指针作为对象实际内存地址使用。这里为啥是最大堆内存 + Java 堆起始位置不大于 4GB？因为前面的分析，我们知道进程可以申请的空间，是<strong>原生堆空间</strong>。所以，Java 堆起始位置，肯定不会从 <code>0x0000 0000 0000 0000</code> 开始。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d8f48416b25fcc10e872e59208e8ac89e2bbc971ef47b1313061cf4d9201cedd" alt="image"></p>
<p>如果最大堆内存 + Java 堆起始位置大于 4GB，第一种优化就不能用了，对象地址偏移就无法避免了。但是如果可以保证最大堆内存 + Java 堆起始位置小于 32位 * <code>ObjectAlignmentInBytes</code>，默认 <code>ObjectAlignmentInBytes=8</code> 的情况即 32GB，我们还是可以让基址等于 0，这样 <code>64 位地址 = （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/207ef89c75de03eb873f39ee17f34b5c07dc236662f047058ba0f805203e127a" alt="image"></p>
<p>但是，在<code>ObjectAlignmentInBytes=8</code> 的情况，如果最大堆内存太大，接近 32GB，想要保证最大堆内存 + Java 堆起始位置小于 32GB，那么 Java 堆起始位置其实就快接近 0 了，这显然不行。所以在最大堆内存接近 32GB 的时候，上面第二种优化也就失效了。但是我们可以让 Java 堆从一个与 32GB 地址完全不相交的地址开始，这样加法就可以优化为取或运算，即<code>64 位地址 = 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</code></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/083d84329fd13a627f6078fbf1a1961aa4e462269161a3bc6bc2cad9cc243633" alt="image"></p>
<p>最后，在<code>ObjectAlignmentInBytes=8</code> 的情况，如果用户通过 <code>HeapBaseMinAddress</code> 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是最大堆内存没有超过 32GB，那么就无法优化了，只能 <code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d3d1f812c9ca3388d10f6e131438ad4d2df328ac3c5d602c76af9e7ca85154d6" alt="image"></p>
<p>总结下，上面我们说的那四种模式，对应 JVM 中的压缩对象指针的四种模式（以下叙述基于 <code>ObjectAlignmentInBytes=8</code> 的情况，即默认情况）：</p>
<ol>
<li><strong><code>32-bit</code> 压缩指针模式</strong>：最大堆内存 + Java 堆起始位置不大于 4GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = 压缩对象指针</code></li>
<li><strong><code>Zero based</code> 压缩指针模式</strong>：最大堆内存 + Java 堆起始位置不大于 32GB（并且 Java 堆起始位置不能太小），<code>64 位地址 = （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li>
<li><strong><code>Non-zero disjoint</code> 压缩指针模式</strong>：最大堆内存不大于 32GB，由于要保证 Java 堆起始位置不能太小，最大堆内存 + Java 堆起始位置大于 32GB，<code>64 位地址 = 基址 |（压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li>
<li><strong><code>Non-zero based</code> 压缩指针模式</strong>：用户通过 <code>HeapBaseMinAddress</code> 自己指定了 Java 堆开始的地址，并且与 32GB 地址相交，并最大堆内存 + Java 堆起始位置大于 32GB，但是最大堆内存没有超过 32GB，<code>64 位地址 = 基址 + （压缩对象指针 &lt;&lt; 对象对齐偏移）</code></li>
</ol>
<h2 id="3-5-为何预留第-0-页，压缩对象指针-null-判断擦除的实现"><a href="#3-5-为何预留第-0-页，压缩对象指针-null-判断擦除的实现" class="headerlink" title="3.5. 为何预留第 0 页，压缩对象指针 null 判断擦除的实现"></a>3.5. 为何预留第 0 页，压缩对象指针 null 判断擦除的实现</h2><p>前面我们知道，JVM 中的压缩对象指针有四种模式。对于地址非从 0 开始的那两种，即 <code>Non-zero disjoint</code> 和 <code>Non-zero based</code> 这两种，堆的实际地址并不是从 <code>HeapBaseMinAddress</code> 开始，而是<strong>有一页预留下来</strong>，被称为第 0 页，这一页不映射实际内存，<strong>如果访问这一页内部的地址，会有 Segment Fault 异常</strong>。那么为什么要预留这一页呢？主要是为了 null 判断优化，实现 null 判断擦除。</p>
<p>我们都知道，Java 中如果对于一个 null 的引用变量进行成员字段或者方法的访问，会抛出 <code>NullPointerException</code>。但是，这个是如何实现的呢？我们的代码中没有明确的 null 判断，如果是 null 就抛出 <code>NullPointerException</code>，但是 JVM 还是针对 null 可以抛出 <code>NullPointerException</code> 这个 Java 异常。可以猜测出，JVM 可能在访问每个引用变量进行成员字段或者方法的时候，都会做这样一个判断：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码if (o == null) &#123;</span><br><span class="line">    throw new NullPoniterException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是，如果每次访问每个引用变量进行成员字段或者方法的时候都做这样一个判断，是很低效率的行为。所以，在解释执行的时候，可能每次访问每个引用变量进行成员字段或者方法的时候都做这样一个判断。在代码运行一定次数，进入 C1，C2 的编译优化之后，这些 null 判断可能会被擦除。可能擦除的包括：</p>
<ol>
<li>成员方法对于 this 的访问，可以将 this 的 null 判断擦除。</li>
<li>代码中明确判断了某个变量是否为 null，并且这个变量不是 volatile 的</li>
<li>前面已经有了 <code>a.something()</code> 类似的访问，并且 <code>a</code> 不是 volatile 的，后面 <code>a.somethingElse()</code> 就不用再做 null 检查了</li>
<li>等等等等…</li>
</ol>
<p>对于无法擦除的，JVM 倾向于做出一个假设，<strong>即这个变量大概率不会为 null，JIT 优化先直接将 null 判断擦除</strong>。Java 中的 null，对应压缩对象指针的值为 0：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码enum class narrowOop : uint32_t &#123; null = 0 &#125;;</span><br></pre></td></tr></table></figure>

<p>对于压缩对象指针地址为 0 的地方进行访问，实际上就是针对前面我们讨论的压缩对象指针基址进行访问，在四种模式下：</p>
<ol>
<li><strong><code>32-bit</code> 压缩指针模式</strong>：就是对于 <code>0x0000 0000 0000 0000</code> 进行访问，但是前面我们知道，<code>0x0000 0000 0000 0000</code> 是保留区域，无法访问，会有 <code>Segment Fault</code> 错误，发出 <code>SIGSEGV</code> 信号</li>
<li><strong><code>Zero based</code> 压缩指针模式</strong>：就是对于 <code>0x0000 0000 0000 0000</code> 进行访问，但是前面我们知道，<code>0x0000 0000 0000 0000</code> 是保留区域，无法访问，会有 <code>Segment Fault</code> 错误，发出 <code>SIGSEGV</code> 信号</li>
<li><strong><code>Non-zero disjoint</code> 压缩指针模式</strong>：就是对于基址进行访问，但是前面我们知道，基址 + JVM 系统页大小为仅 Reserve 但是不会 commit 的预留区域，无法访问，会有 <code>Segment Fault</code> 错误，发出 <code>SIGSEGV</code> 信号</li>
<li><strong><code>Non-zero based</code> 压缩指针模式</strong>：就是对于基址进行访问，但是前面我们知道，基址 + JVM 系统页大小为仅 Reserve 但是不会 commit 的预留区域，无法访问，会有 <code>Segment Fault</code> 错误，发出 <code>SIGSEGV</code> 信号</li>
</ol>
<p>对于<strong>非压缩对象指针的情况</strong>，更简单，非压缩对象指针 null 就是 <code>0x0000 0000 0000 0000</code>，就是对于 <code>0x0000 0000 0000 0000</code> 进行访问，但是前面我们知道，<code>0x0000 0000 0000 0000</code> 是保留区域，无法访问，会有 <code>Segment Fault</code> 错误，发出 <code>SIGSEGV</code> 信号</p>
<p>可以看出，如果 JIT 优化将 null 判断擦除，那么在真的遇到 null 的时候，会有 <code>Segment Fault</code> 错误，发出 <code>SIGSEGV</code> 信号。JVM 有对于 <code>SIGSEGV</code> 信号的处理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rust复制代码//这是在 AMD64 CPU 下的代码</span><br><span class="line">&#125; else if (</span><br><span class="line">        //如果信号是 SIGSEGV</span><br><span class="line">        sig == SIGSEGV &amp;&amp;</span><br><span class="line">        //并且是由于遇到擦除 null 判断的地方遇到 null 导致的 SIGSEGV（后面我们看到很多其他地方用到了 SIGSEGV）</span><br><span class="line">        MacroAssembler::uses_implicit_null_check(info-&gt;si_addr)</span><br><span class="line">        ) &#123;</span><br><span class="line">  // 如果是由于遇到 null 导致的 SIGSEGV，那么就需要评估下，是否要继续擦除这里的 null 判断了</span><br><span class="line">  stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JVM 不仅 null 检查擦除使用了 <code>SIGSEGV</code> 信号，还有其他地方也用到了（例如后面我们会详细分析的 <code>StackOverflowError</code> 的实现）。所以，我们需要通过判断下发生 <code>SIGSEGV</code> 信号的地址，如果地址是我们上面列出的范围，则是擦除 null 判断的地方遇到 null 导致的 <code>SIGSEGV</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码bool MacroAssembler::uses_implicit_null_check(void* address) &#123;</span><br><span class="line">  uintptr_t addr = reinterpret_cast&lt;uintptr_t&gt;(address);</span><br><span class="line">  uintptr_t page_size = (uintptr_t)os::vm_page_size();</span><br><span class="line">#ifdef _LP64</span><br><span class="line">  //如果压缩对象指针开启</span><br><span class="line">  if (UseCompressedOops &amp;&amp; CompressedOops::base() != NULL) &#123;</span><br><span class="line">    //如果存在预留页(第 0 页)，起点是基址</span><br><span class="line">    uintptr_t start = (uintptr_t)CompressedOops::base();</span><br><span class="line">    //如果存在预留页(第 0 页)，终点是基址 + 页大小</span><br><span class="line">    uintptr_t end = start + page_size;</span><br><span class="line">    //如果地址范围在第 0 页，则是擦除 null 判断的地方遇到 null 导致的 `SIGSEGV`</span><br><span class="line">    if (addr &gt;= start &amp;&amp; addr &lt; end) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">#endif</span><br><span class="line">  //如果在整个虚拟空间的第 0 页，则是擦除 null 判断的地方遇到 null 导致的 `SIGSEGV`</span><br><span class="line">  return addr &lt; page_size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们分别代入压缩对象指针的 4 种情况：</p>
<ol>
<li><strong><code>32-bit</code> 压缩指针模式</strong>：就是对于 <code>0x0000 0000 0000 0000</code> 进行访问，地址位于第 0 页，<code>uses_implicit_null_check</code> 返回 true</li>
<li><strong><code>Zero based</code> 压缩指针模式</strong>：就是对于 <code>0x0000 0000 0000 0000</code> 进行访问，地址位于第 0 页，<code>uses_implicit_null_check</code> 返回 true</li>
<li><strong><code>Non-zero disjoint</code> 压缩指针模式</strong>：就是对于基址进行访问，地址位于第 0 页，<code>uses_implicit_null_check</code> 返回 true</li>
<li><strong><code>Non-zero based</code> 压缩指针模式</strong>：就是对于基址进行访问，地址位于第 0 页，<code>uses_implicit_null_check</code> 返回 true</li>
</ol>
<p>对于<strong>非压缩对象指针的情况</strong>，更简单，非压缩对象指针 null 就是 <code>0x0000 0000 0000 0000</code>，就是对于基址进行访问，地址位于第 0 页，<code>uses_implicit_null_check</code> 返回 true</p>
<p>这样，我们知道，JIT 可能会将 null 检查擦除，通过 <code>SIGSEGV</code> 信号抛出 <code>NullPointerException</code>。但是，通过 <code>SIGSEGV</code> 信号要经过系统调用，系统调用是一个很低效的行为，我们需要尽量避免（对于抄袭狗就不不必了）。但是这里的假设就是大概率不为 null，所以使用系统调用也无所谓。但是如果一个地方经常出现 null，JIT 就会考虑不这么优化了，将代码去优化并重新编译，不再擦除 null 检查而是使用显式 null 检查抛出。</p>
<p>最后，我们知道了，要预留第 0 页，不映射内存，实际就是为了<strong>让对于基址进行访问</strong>可以触发 Segment Fault，JVM 会捕捉这个信号，查看触发这个信号的内存地址是否属于第一页，如果属于那么 JVM 就知道了这个是对象为 null 导致的。不过从前面看，我们其实只是为了不映射基址对应的地址，<strong>那为啥要保留一整页呢</strong>？这个是处于内存对齐与寻址访问速度的考量，里面映射物理内存都是以页为单位操作的，所以内存需要按页对齐。</p>
<h2 id="3-6-结合压缩对象指针与前面提到的堆内存限制的初始化的关系"><a href="#3-6-结合压缩对象指针与前面提到的堆内存限制的初始化的关系" class="headerlink" title="3.6. 结合压缩对象指针与前面提到的堆内存限制的初始化的关系"></a>3.6. 结合压缩对象指针与前面提到的堆内存限制的初始化的关系</h2><p>前面我们说明了不手动指定三个指标的情况下，这三个指标 (MinHeapSize,MaxHeapSize,InitialHeapSize) 是如何计算的，但是没有涉及压缩对象指针。如果压缩对象指针开启，那么堆内存限制的初始化之后，会根据参数确定压缩对象指针是否开启：</p>
<ol>
<li>首先，确定 Java 堆的起始位置：</li>
<li>第一步，在不同操作系统不同 CPU 环境下，<code>HeapBaseMinAddress</code> 的默认值不同，大部分环境下是 <code>2GB</code>，例如对于 Linux x86 环境，查看源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp" target="_blank" rel="noopener">github.com/openjdk/jdk…</a>：<code>define_pd_global(size_t, HeapBaseMinAddress, 2*G);</code></li>
<li>将 <code>DefaultHeapBaseMinAddress</code> 设置为 <code>HeapBaseMinAddress</code> 的默认值，即 <code>2GB</code></li>
<li>如果用户在启动参数中指定了 <code>HeapBaseMinAddress</code>，如果 <code>HeapBaseMinAddress</code> 小于 <code>DefaultHeapBaseMinAddress</code>，将 <code>HeapBaseMinAddress</code> 设置为 <code>DefaultHeapBaseMinAddress</code></li>
<li>计算压缩对象指针堆的最大堆大小：</li>
<li>读取对象对齐大小 <code>ObjectAlignmentInBytes</code> 参数的值，默认为 8</li>
<li>对 <code>ObjectAlignmentInBytes</code> 取 2 的对数，记为 <code>LogMinObjAlignmentInBytes</code></li>
<li>将 32 位左移 <code>LogMinObjAlignmentInBytes</code> 得到 <code>OopEncodingHeapMax</code> 即不考虑预留区的最大堆大小</li>
<li>如果需要预留区，即 <code>Non-Zero Based Disjoint</code> 以及 <code>Non-Zero Based</code> 这两种模式下，需要刨除掉预留区即第 0 页的大小，即 <code>OopEncodingHeapMax</code> - 第 0 页的大小</li>
<li>读取当前 JVM 配置的最大堆大小（前面我们分析了最大堆大小如何计算出来的）</li>
<li>如果 JVM 配置的最大堆小于压缩对象指针堆的最大堆大小，并且没有通过 JVM 启动参数明确关闭压缩对象指针，则开启压缩对象指针。否则，关闭压缩对象指针。你洗稿的样子真丑。</li>
<li>如果压缩对象指针关闭，根据前面分析过的是否压缩类指针强依赖压缩对象指针，如果是，关闭压缩类指针</li>
</ol>
<h2 id="3-7-使用-jol-jhsdb-JVM-日志查看压缩对象指针与-Java-堆验证我们前面的结论"><a href="#3-7-使用-jol-jhsdb-JVM-日志查看压缩对象指针与-Java-堆验证我们前面的结论" class="headerlink" title="3.7. 使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论"></a>3.7. 使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论</h2><p>引入 jol 依赖：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.openjdk.jol&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;jol-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>编写代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码package test;</span><br><span class="line"></span><br><span class="line">import org.openjdk.jol.info.ClassLayout;</span><br><span class="line"></span><br><span class="line">public class TestClass &#123;</span><br><span class="line">    //TestClass 对象仅仅包含一个字段 next（洗稿狗滚）</span><br><span class="line">    private String next = new String();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) throws InterruptedException &#123;</span><br><span class="line">        //在栈上新建一个 tt 本地变量，指向一个在堆上新建的 TestClass 对象</span><br><span class="line">        final TestClass tt = new TestClass();</span><br><span class="line">        //使用 jol 输出 tt 指向的对象的结构（抄袭不得好死）</span><br><span class="line">        System.out.println(ClassLayout.parseInstance(tt).toPrintable());</span><br><span class="line">        //无限等待，防止程序退出</span><br><span class="line">        Thread.currentThread().join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-1-验证-32-bit-压缩指针模式"><a href="#3-7-1-验证-32-bit-压缩指针模式" class="headerlink" title="3.7.1. 验证 32-bit 压缩指针模式"></a>3.7.1. 验证 <code>32-bit</code> 压缩指针模式</h3><p>接下来我们先测试第一种压缩对象指针模式（<code>32-bit</code>）的情况，即 Java 堆位于 <code>0x0000 0000 0000 0000 ~ 0x 0000 0001 0000 0000</code>（0~4GB） 之间的情况，使用下面的启动参数启动这个程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码-Xmx32M -Xlog:coops*=debug</span><br></pre></td></tr></table></figure>

<p>其中 <code>-Xlog:coops*=debug</code> 代表查看 JVM 日志中带 coops 标签的 debug 日志。这个日志会告诉你堆的起始虚拟内存位置，以及堆 reserved 的空间大小，以及 压缩对象指针的模式。</p>
<p>启动后，查看日志输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码[0.006s][debug][gc,heap,coops] Heap address: 0x00000000fe000000, size: 32 MB, Compressed Oops mode: 32-bit</span><br><span class="line">test.TestClass object internals:个人爱好钻研技术分享，请抄袭狗滚开。</span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4                    (object header: class)    0x00c01000</span><br><span class="line"> 12   4   java.lang.String TestClass.next            (object)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>第一行日志告诉我们，堆的起始位置是 <code>0x0000 0000 fe00 0000</code>，大小是 32 MB，压缩对象指针模式是 <code>32-bit</code>。其中 <code>0x0000 0000 fe00 0000</code> 加上 32 MB，结果就是 4GB <code>0x0000 0001 0000 0000</code>。可以看出之前说的 Java 堆会从界限减去最大堆大小的位置开始 reserve 的结论是对的。在这种情况下，<code>0x0000 0000 0000 0000 ~ 0x0000 0000 fdff ffff</code> 的内存就给之前所说的进程系统调用以及原生内存分配使用。</p>
<p>后面的日志是关于 jol 输出对象结构的，可以看出目前这个对象包含一个 markword (<code>0x0000000000000001</code>)，一个压缩类指针(<code>0x00c01000</code>)，以及字段 <code>next</code>。我们使用 jhsdb 看一下进程的具体虚拟内存的内容验证下</p>
<p>首先打开 jhsdb gui 模式：<code>jhsdb hsdb</code></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6c844b5f3dbd91b4e5b4c48179c0761c24ac45eae0d8ba8f0a288d926579c38f" alt="image"></p>
<p>之后 “File” -&gt; “Attach to Hotspot Process”，输入你的 JVM 进程号：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0552e1ad1ce779153d9f3a9711c03f920e3337be4a4f64140d16f678b069a2d9" alt="image"></p>
<p>成功 Attach 之后，可以看到面板上有你的 JVM 进程的所有线程，目前我们就看 main 线程即可，点击 main 线程，之后点击下图红框的按钮（查看线程栈内存）：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4d90d891d45330e554fe52f8359745872a788c85b25da3360ec8297087fed441" alt="image"></p>
<p>之后我们在 main 线程栈内存中可以找到代码中的本地变量 tt：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/892e404a23491a369d80a9e3ee3feee638cd023f9620023f4d2f726664a8f175" alt="image"></p>
<p>这里我们可以看到变量 tt 存储的值，其实就是对象的地址，我们打开 “Tools” -&gt; “Memory Viewer”，这个是进程虚拟内存查看器，可以查看内存地址的实际值。还有 “Tools” -&gt; “Inspector”，将地址转换为 JVM 的 C++ 对应对象。在这两个窗口都输入上面在 main 线程栈内存看到的本地变量 tt 的值：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d0ee34f47d2cd8198188fc99db907129dfb4d5fc6de8e970f00e8c841339f9d3" alt="image"></p>
<p>从上图我们可以看到，tt 保存的对象，对象位置，也就是对象起始地址是 <code>0x00000000ffec7450</code>，对象头是 <code>0x0000 0000 ffec 7450 ~ 0x0000 0000 ffec 7457</code>，保存的值是 <code>0x0000 0000 0000 0001</code>，这个和上面 jol 输出的一模一样。压缩类指针是 <code>0x0000 0000 ffec 7458 ~ 0x0000 0000 ffec 745b</code>，保存的值是 <code>0x00c0 1000</code>，这个和上面 jol 输出的压缩类指针地址一模一样。之后是 next 字段值，范围是 <code>0x0000 0000 ffec 745c ~ 0x0000 0000 ffec 745f</code>，保存的值是 <code>0xffec 7460</code>，对应的字符串对象实际地址也是 <code>0x0000 0000 ffec 7460</code>。可以看出，和我们之前说的 <code>32-bit</code> 模式的压缩类指针的特点一模一样。</p>
<h3 id="3-7-2-验证-Zero-based-压缩指针模式"><a href="#3-7-2-验证-Zero-based-压缩指针模式" class="headerlink" title="3.7.2. 验证 Zero based 压缩指针模式"></a>3.7.2. 验证 <code>Zero based</code> 压缩指针模式</h3><p>下一个我们尝试 <code>Zero based</code> 模式，使用参数 <code>-Xmx2050M -Xlog:coops*=debug</code> 启动程序（和你的平台相关，建议你查看下在你的平台 <code>HeapBaseMinAddress</code> 默认的大小，一般对于 x86 都是 2G，所以指定一个大于 <code>4G - 2G = 2G</code> 的最大堆内存大小的值即可），日志输出是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码[0.006s][debug][gc,heap,coops] Heap address: 0x000000077fe00000, size: 2050 MB, Compressed Oops mode: Zero based, Oop shift amount: 3                      洗稿的狗也遇到不少</span><br><span class="line">test.TestClass object internals:</span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000009 (non-biasable; age: 1)</span><br><span class="line">  8   4                    (object header: class)    0x00c01000</span><br><span class="line"> 12   4   java.lang.String TestClass.next            (object)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>这次我们发现，Java 堆从 <code>0x0000 0007 7fe0 0000</code> 开始了，如果你用 <code>0x0000 0007 7fe0 0000</code> 加上 2050 MB 就会发现正好等于 32GB，可以看出之前说的 Java 堆会从界限减去最大堆大小的位置开始 reserve 的结论是对的。</p>
<p>后面的日志是关于 jol 输出对象结构的，可以看出目前这个对象包含一个 markword(<code>0x0000000000000009</code>，由于我的程序启动后输出 jol 日志之前经过了一次 GC，所以当前值与前面一个例子的不一样)，一个压缩类指针(<code>0x00c01000</code>)，以及字段 <code>next</code>。</p>
<p>我们使用 jhsdb 看一下进程的具体虚拟内存的内容验证下目前的压缩对象指针的内容，前面的步骤与上一个例子一样，我们直接看最后的：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/92a4e291c2b3cf709a272e524334b926b7b926756df25d476fd81ead44927b36" alt="image"></p>
<p>如上图所示，tt 保存的对象，从 <code>0x0000 0007 9df7 2640</code> 开始，我们找到 next 字段，它保存的值是 <code>0xf3be ed80</code>，将其左移三位，就是 <code>0x0000 0007 9df7 6c00</code>（inspector 中显示的是帮你解压缩之后的对象地址，Memory Viewer 中是虚拟内存实际保存的值）</p>
<p>接下来我们试一下通过 <code>HeapBaseMinAddress</code> 让第一个例子也变成 <code>Zero based</code> 模式。使用下面的启动参数 <code>-Xmx32M -Xlog:coops*=debug -XX:HeapBaseMinAddress=4064M</code>，其中 <code>4064MB + 32MB = 4GB</code>，启动后可以通过日志发现模式还是 <code>32-bit</code>：<code>[0.005s][debug][gc,heap,coops] Heap address: 0x00000000fe000000, size: 32 MB, Compressed Oops mode: 32-bit</code>。其中 <code>0x00000000fe000000</code> 就是 <code>4064MB</code>，与启动参数配置的一致。使用下面的启动参数 <code>-Xmx32M -Xlog:coops*=debug -XX:HeapBaseMinAddress=4065M</code>，可以看到日志：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码[0.005s][debug][gc,heap,coops] Heap address: 0x00000000fe200000, size: 32 MB, Compressed Oops mode: Zero based, Oop shift amount: 3 </span><br><span class="line">test.TestClass object internals:</span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4                    (object header: class)    0x00c01000</span><br><span class="line"> 12   4   java.lang.String TestClass.next            (object)</span><br><span class="line">Instance size: 16 bytes chaoxi你妹啊，抄袭能给你赚几个钱，别为了这点镚子败人品了</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看模式变为 <code>Zero based</code>，堆的起始点是 <code>0x00000000fe200000</code> 等于 <code>4066MB</code>，与我们的启动参数不符，是因为这个起始位置有对齐策略导致的，与使用的 GC 也是相关的，这个等我们以后分析 GC 的时候再关心。</p>
<h3 id="3-7-3-验证-Non-zero-disjoint-压缩指针模式"><a href="#3-7-3-验证-Non-zero-disjoint-压缩指针模式" class="headerlink" title="3.7.3. 验证 Non-zero disjoint 压缩指针模式"></a>3.7.3. 验证 <code>Non-zero disjoint</code> 压缩指针模式</h3><p>接下来我们来看下一个模式 <code>Non-zero disjoint</code>，使用以下参数 <code>-Xmx31G -Xlog:coops*=debug</code> 启动程序，日志输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码[0.007s][debug][gc,heap,coops] Protected page at the reserved heap base: 0x0000001000000000 / 16777216 bytes</span><br><span class="line">[0.007s][debug][gc,heap,coops] Heap address: 0x0000001001000000, size: 31744 MB, Compressed Oops mode: Non-zero disjoint base: 0x0000001000000000, Oop shift amount: 3 </span><br><span class="line">test.TestClass object internals:</span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE </span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4                    (object header: class)    0x00c01000</span><br><span class="line"> 12   4   java.lang.String TestClass.next            (object)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到，保护页大小为 16MB（16777216 bytes）chaoxi你妹啊，抄袭能给你赚几个钱，别为了这点镚子败人品了，实际 Java 堆开始的地址是 <code>0x0000 0010 0100 0000</code>。并且，基址也不再是 0（Non-zero disjoint base，而是与 32GB 完全不相交的地址 <code>0x0000001000000000</code>），可以将加法优化为或运算。后面 jol 输出对象结构，可以看出目前这个对象包含一个 markword(<code>0x0000000000000001</code>)，一个压缩类指针(<code>0x00c01000</code>)，以及字段 <code>next</code>。</p>
<p>我们使用 jhsdb 看一下进程的具体虚拟内存的内容验证下目前的压缩对象指针的内容，前面的步骤与上一个例子一样，我们直接看最后的：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cb972a39629461f3147b7612b48589cd04610c5be2bbf421eb9935edff2f8e98" alt="image"></p>
<p>如上图所示，tt 保存的对象，从 <code>0x000000102045ab90</code> 开始，我们找到 next 字段，它保存的值是 <code>0x0408 b574</code>，将其左移三位，就是 <code>0x0000 0000 2045 aba0</code>（inspector 中显示的是帮你解压缩之后的对象地址，Memory Viewer 中是虚拟内存实际保存的值），然后对基址 ``0x0000 0010 0000 0000<code>取或运算，得到 next 指向的字符串对象的实际地址</code>0x0000 0010 2045 aba0`，计算结果与 inspector 中显示的 next 解析结果一致。</p>
<h3 id="3-7-4-验证-Non-zero-based-压缩指针模式"><a href="#3-7-4-验证-Non-zero-based-压缩指针模式" class="headerlink" title="3.7.4. 验证 Non-zero based 压缩指针模式"></a>3.7.4. 验证 <code>Non-zero based</code> 压缩指针模式</h3><p>最后，我们来看最后一种模式，即 <code>Non-zero based</code>，使用以下参数 <code>-Xmx31G -Xlog:coops*=debug -XX:HeapBaseMinAddress=2G</code> 启动程序，日志输出为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码[0.005s][debug][gc,heap,coops] Protected page at the reserved heap base: 0x0000000080000000 / 16777216 bytes</span><br><span class="line">[0.005s][debug][gc,heap,coops] Heap address: 0x0000000081000000, size: 31744 MB, Compressed Oops mode: Non-zero based: 0x0000000080000000, Oop shift amount: 3</span><br><span class="line">test.TestClass object internals:</span><br><span class="line">OFF  SZ               TYPE DESCRIPTION               VALUE</span><br><span class="line">  0   8                    (object header: mark)     0x0000000000000001 (non-biasable; age: 0)</span><br><span class="line">  8   4                    (object header: class)    0x00c01000</span><br><span class="line"> 12   4   java.lang.String TestClass.next            (object)</span><br><span class="line">Instance size: 16 bytes</span><br><span class="line">Space losses: 0 bytes internal + 0 bytes external = 0 bytes total</span><br></pre></td></tr></table></figure>

<p>可以看到，保护页大小为 16MB（16777216 bytes），实际 Java 堆开始的地址是 <code>0x0000 0000 8100 0000</code>。并且，基址也不再是 0（Non-zero based：<code>0x0000000080000000</code>）。后面 jol 输出对象结构，可以看出目前这个对象包含一个 markword(<code>0x0000000000000001</code>)，一个压缩类指针(<code>0x00c01000</code>)，以及字段 <code>next</code>。</p>
<p>我们使用 jhsdb 看一下进程的具体虚拟内存的内容验证下目前的压缩对象指针的内容，前面的步骤与上一个例子一样，我们直接看最后的：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5fa0a55e5293d89fafed4765e8ca9ead15ba0e833dbc9bbbc5cdcb51604c0384" alt="image"></p>
<p>如上图所示，tt 保存的对象，从 <code>0x00000000a0431f10</code> 开始，我们找到 next 字段，它保存的值是 <code>0x0408 63e4</code>，将其左移三位，就是 <code>0x0000 0000 2043 1f20</code>（inspector 中显示的是帮你解压缩之后的对象地址，Memory Viewer 中是虚拟内存实际保存的值），然后加上基址 ``0x0000 0000 8000 0000<code>（其实就是 2GB，是我们在</code>-XX:HeapBaseMinAddress=2G<code>指定的 ），得到 next 指向的字符串对象的实际地址</code>0x0000 0000 a043 1f20`，计算结果与 inspector 中显示的 next 解析结果一致。不要偷取他人的劳动成果</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225874698906714168" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 3大页分配 UseLar</title>
    <url>/7225875600644489277.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="2">
<li><h1 id="JVM-内存申请与使用流程"><a href="#JVM-内存申请与使用流程" class="headerlink" title="JVM 内存申请与使用流程"></a>JVM 内存申请与使用流程</h1></li>
</ol>
<h2 id="2-3-大页分配-UseLargePages"><a href="#2-3-大页分配-UseLargePages" class="headerlink" title="2.3. 大页分配 UseLargePages"></a>2.3. 大页分配 UseLargePages</h2><p>前面提到了虚拟内存需要映射物理内存才能使用，这个映射关系被保存在内存中的<strong>页表</strong>（Page Table）。现代 CPU 架构中一般有 TLB （Translation Lookaside Buffer，翻译后备缓冲，也称为页表寄存器缓冲）存在，在里面保存了经常使用的页表映射项。TLB 的大小有限，一般 TLB 如果只能容纳小于 100 个页表映射项。 我们能让程序的虚拟内存对应的页表映射项都处于 TLB 中，那么能大大提升程序性能，这就要尽量减少页表映射项的个数：<code>页表项个数 = 程序所需内存大小 / 页大小</code>。我们要么缩小程序所需内存，要么增大页大小。我们一般会考虑增加页大小，这就大页分配的由来，JVM 对于堆内存分配也支持大页分配，用于优化大堆内存的分配。那么 Linux 环境中有哪些大页分配的方式呢？</p>
<h3 id="2-3-1-Linux-大页分配方式-Huge-Translation-Lookaside-Buffer-Page-hugetlbfs"><a href="#2-3-1-Linux-大页分配方式-Huge-Translation-Lookaside-Buffer-Page-hugetlbfs" class="headerlink" title="2.3.1. Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)"></a>2.3.1. Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</h3><p>相关的 Linux 内核文档：<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt" target="_blank" rel="noopener"><code>https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</code></a></p>
<p>这是出现的比较早的大页分配方式，其实就是在之前提到的页表映射上面做文章：</p>
<p><strong>默认 4K 页大小</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4759735abec01053835828ed704c33ea3b9aae20f6c2b2cc4dfeb0346eeee842" alt="image"></p>
<p><strong>PMD 直接映射实际物理页面，页面大小为 4K * 2^9 = 2M</strong>：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/db0ce57d30b7f4e804723392cd908d7ea1c052693d70a32005dde851cefed7fb" alt="image"><br><strong>PUD 直接映射实际物理页面，页面大小为 2M * 2^9 = 1G</strong>：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1f94ce3dbf2911c2f4a5f166daa711fd1231163e195d58cfd29261eab3c25975" alt="image"></p>
<p>但是，要想使用这个特性，需要操作系统构建的时候开启 <code>CONFIG_HUGETLBFS</code> 以及 <code>CONFIG_HUGETLB_PAGE</code>。之后，大的页面通常是通过系统管理控制预先分配并放入池里面的。然后，可以通过 <code>mmap</code> 系统调用或者 <code>shmget,shmat</code> 这些 SysV 的共享内存系统调用使用大页分配方式从池中申请内存。</p>
<p>这种大页分配的方式，需要系统预设开启大页，预分配大页之外，对于代码也是有一定侵入性的，在灵活性上面查一些。但是带来的好处就是，性能表现上更加可控。另一种灵活性很强的 Transparent Huge Pages (THP) 方式，总是可能在性能表现上有一些意想不到的情况。</p>
<h3 id="2-3-2-Linux-大页分配方式-Transparent-Huge-Pages-THP"><a href="#2-3-2-Linux-大页分配方式-Transparent-Huge-Pages-THP" class="headerlink" title="2.3.2. Linux 大页分配方式 - Transparent Huge Pages (THP)"></a>2.3.2. Linux 大页分配方式 - Transparent Huge Pages (THP)</h3><p>相关的 Linux 内核文档：<a href="https://www.kernel.org/doc/Documentation/vm/transhuge.txt" target="_blank" rel="noopener"><code>https://www.kernel.org/doc/Documentation/vm/transhuge.txt</code></a></p>
<p>THP 是一种使用大页的第二种方法，它支持页面大小的自动升级和降级，这样对于用户使用代码基本没有侵入性，非常灵活。但是，前面也提到过，这种系统自己去做页面大小的升级降级，并且系统一般考虑通用性，所以在某些情况下会出现意想不到的性能瓶颈。</p>
<h3 id="2-3-3-JVM-大页分配相关参数与机制"><a href="#2-3-3-JVM-大页分配相关参数与机制" class="headerlink" title="2.3.3. JVM 大页分配相关参数与机制"></a>2.3.3. JVM 大页分配相关参数与机制</h3><p>相关的参数如下：</p>
<ul>
<li><code>UseLargePages</code>：明确指定是否开启大页分配，如果关闭，那么下面的参数就都不生效。在 linux 下默认为 false。</li>
<li><code>UseHugeTLBFS</code>：明确指定是否使用前面第一种大页分配方式 hugetlbfs 并且通过 <code>mmap</code> 系统调用分配内存。在 linux 下默认为 false。</li>
<li><code>UseSHM</code>：明确指定是否使用前面第一种大页分配方式 hugetlbfs 并且通过 <code>shmget,shmat</code> 系统调用分配内存。在 linux 下默认为 false。</li>
<li><code>UseTransparentHugePages</code>：明确指定是否使用前面第二种大页分配方式 THP。在 linux 下默认为 false。</li>
<li><code>LargePageSizeInBytes</code>：指定明确的大页的大小，仅适用于前面第一种大页分配方式 hugetlbfs，并且必须属于操作系统支持的页大小否则不生效。默认为 0，即不指定</li>
</ul>
<p>首先，需要对以上参数做一个简单的判断：如果没有指定 <code>UseLargePages</code>，那么使用对应系统的默认 <code>UseLargePages</code> 的值，在 linux 下是 false，那么就不会启用大页分配。如果启动参数明确指定 <code>UseLargePages</code> 不启用，那么也不会启用大页分配。如果读取 <code>/proc/meminfo</code> 获取默认大页大小读取不到或者为 0，则代表系统也不支大页分配，大页分配也不启用。</p>
<p>那么如果大页分配启用的话，我们需要初始化并验证大页分配参数可行性，流程是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/88df1c40728501649d404c70bf70f367e008eea4d119250994c2d30a3ae62676" alt="image"></p>
<p>首先，JVM 会读取根据当前所处的平台与系统环境读取支持的页的大小，当然，这个是针对前面第一种大页分配方式 hugetlbfs 的。在 Linux 环境下，JVM 会从 <code>/proc/meminfo</code> 读取<strong>默认的 <code>Hugepagesize</code></strong>，从 <code>/sys/kernel/mm/hugepages</code> 目录下检索<strong>所有支持的大页大小</strong>，这块可以参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os/linux/os_linux.cpp</code></a>。有关这些文件或者目录的详细信息，请参考前面章节提到的 Linux 内核文档：<a href="https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt" target="_blank" rel="noopener"><code>https://www.kernel.org/doc/Documentation/vm/hugetlbpage.txt</code></a></p>
<p>如果操作系统开启了 hugetlbfs，<code>/sys/kernel/mm/hugepages</code> 目录下的结构类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码&gt; tree /sys/kernel/mm/hugepages</span><br><span class="line"></span><br><span class="line">/sys/kernel/mm/hugepages</span><br><span class="line">├── hugepages-1048576kB</span><br><span class="line">│   ├── free_hugepages</span><br><span class="line">│   ├── nr_hugepages</span><br><span class="line">│   ├── nr_hugepages_mempolicy</span><br><span class="line">│   ├── nr_overcommit_hugepages</span><br><span class="line">│   ├── resv_hugepages</span><br><span class="line">│   └── surplus_hugepages</span><br><span class="line">└── hugepages-2048kB</span><br><span class="line">    ├── free_hugepages</span><br><span class="line">    ├── nr_hugepages</span><br><span class="line">    ├── nr_hugepages_mempolicy</span><br><span class="line">    ├── nr_overcommit_hugepages</span><br><span class="line">    ├── resv_hugepages</span><br><span class="line">    └── surplus_hugepages</span><br></pre></td></tr></table></figure>

<p>这个 <code>hugepages-1048576kB</code> 就代表支持大小为 1GB 的页，<code>hugepages-2048kB</code> 就代表支持大小为 2KB 的页。</p>
<p>如果没有设置 <code>UseHugeTLBFS</code>，也没有设置 <code>UseSHM</code>，也没有设置 <code>UseTransparentHugePages</code>，那么其实就是走默认的，默认使用 hugetlbfs 方式，不使用 THP 方式，因为如前所述， THP 在某些场景下有意想不到的性能瓶颈表现，在大型应用中，稳定性优先于峰值性能。之后，默认优先尝试 <code>UseHugeTLBFS</code>（即使用 <code>mmap</code> 系统调用通过 hugetlbfs 方式大页分配），不行的话再尝试 <code>UseSHM</code>（即使用 <code>shmget</code> 系统调用通过 hugetlbfs 方式大页分配）。这里只是验证下这些大页内存的分配方式是否可用，只有可用后面真正分配内存的时候才会采用那种可用的大页内存分配方式。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225875600644489277" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,面试</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 7元空间存储的元数据 4</title>
    <url>/7225879698952486972.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><h1 id="JVM-元空间设计"><a href="#JVM-元空间设计" class="headerlink" title="JVM 元空间设计"></a>JVM 元空间设计</h1></li>
</ol>
<h2 id="4-1-什么是元数据，为什么需要元数据"><a href="#4-1-什么是元数据，为什么需要元数据" class="headerlink" title="4.1. 什么是元数据，为什么需要元数据"></a>4.1. 什么是元数据，为什么需要元数据</h2><p>JVM 在执行 Java 应用程序时，将加载的 Java 类的许多细节记录在内存中，这些信息称为类<strong>元数据</strong>（<strong>Class MetaData</strong>）。这些元数据对于 Java 的很多灵活的语言以及虚拟机特性都是很重要的，比如动态类加载、JIT 实时编译、反射以及动态代理等等。不同的 JVM 加载类保存的内存信息是不一样的，它们通常<strong>在更低的内存占用</strong>与<strong>更快的执行速度之间进行权衡</strong>（类似于空间还是时间的权衡）。对于 OpenJDK Hotspot 使用的则是相对丰富的元数据模型来获得尽可能快的性能（时间优先，不影响速度的情况下尽量优化空间占用）。相比于 C,C++,Go 这些离线编译为可执行二进制文件的程序相比，像 JVM 这样的托管运行时动态解释执行或者编译执行的，<strong>则需要保留更多关于正在执行的代码的运行时信息</strong>。原因如下：</p>
<ol>
<li><strong>依赖类库并不是一个确定的有限集</strong>：Java 可以动态加载类，并且还有 ASM 以及 Javassist 这些工具在运行时动态定义类并加载，还有 JVMTI agent 这样的机制来动态修改类。所以，JVM 通过类元数据保存：<strong>运行时中存在哪些类，它们包含哪些方法和字段，并能够在链接加载期间动态地解析从一个类到另一个类的引用</strong>。类的链接也需要考虑类的<strong>可见性和可访问性</strong>。类元数据<strong>与类加载器相关联</strong>，同时类元数据也包括<strong>类权限和包路径以及模块信息</strong>（Java 9之后引入的模块化），以确定可访问性</li>
<li><strong>JVM 解释执行或者通过 JIT 实时编译执行 Java 代码的时候需要基于类元数据的很多信息才能执行</strong>：需要知道例如类与类之间的关系，类属性以及字段还有方法结构等等等等。例如在做强制转换的时候，需要检查类型的父子类关系确定是否可以强制转换等等。</li>
<li><strong>JVM 需要一些统计数据决定哪些代码解释执行那些代码是热点代码需要 JIT 即时编译执行</strong>。</li>
<li><strong>Java 有反射 API 供用户使用</strong>，这就需要运行时知道所有类的各种信息。洗稿也是一种侵权行为</li>
</ol>
<h2 id="4-2-什么时候用到元空间，元空间保存什么"><a href="#4-2-什么时候用到元空间，元空间保存什么" class="headerlink" title="4.2. 什么时候用到元空间，元空间保存什么"></a>4.2. 什么时候用到元空间，元空间保存什么</h2><h3 id="4-2-1-什么时候用到元空间，以及释放时机"><a href="#4-2-1-什么时候用到元空间，以及释放时机" class="headerlink" title="4.2.1. 什么时候用到元空间，以及释放时机"></a>4.2.1. 什么时候用到元空间，以及释放时机</h3><p><strong>只要发生类加载，就会用到元空间</strong>。例如我们创建一个类对象时：这个类首先会被类加载器加载，在发生类加载的时候，对应类的元数据被存入元空间。元数据分为<strong>两部分存入元空间，一部分存入了元空间的类空间另一部分存入了元空间的非类空间</strong>。堆中新建的对象的对象头中的 <code>Klass</code> 指针部分，指向元空间中 Klass，同时，Klass 中各种字段都是指针，实际对象的地址，可能在非类空间，例如实现方法多态以及 virtual call 的 vtable 与 itable 保存着方法代码地址的引用指针。非类空间中存储着比较大的元数据，例如常量池，字节码，JIT 编译后的代码等等。由于编译后的代码可能非常大，以及 JVM 对于多语言支持的扩展可能动态加载很多类，所以<strong>将 MetaSpace 的类空间与非类空间区分开</strong>。如图所示：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/78301c67a224453c4995682e097bcc00243ada8e7b5d2a7d17d47fce4dbd6579" alt="image"></p>
<p>JVM 启动参数 <code>-XX:CompressedClassSpaceSize</code> 指定的是压缩类空间大小，默认是 1G。<code>-XX:MaxMetaspaceSize</code>控制的是 MetaSpace 的总大小。这两个参数，以及 MetaSpace 更多参数，我们会在后面的章节详细解释。</p>
<p>当类加载器加载的<strong>所有类都没有任何实例</strong>，<strong>并且没有任何指向</strong>这些类对象(<code>java.lang.Class</code>)的引用，也<strong>没有指向这个类加载器</strong>的引用的时候，如果发生了 GC，这个类加载器使用的元空间就会被释放。但是这个释放并<strong>不一定是释放回操作系统，而是被标记为可以被其他类加载器使用</strong>了。</p>
<h3 id="4-2-2-元空间保存什么"><a href="#4-2-2-元空间保存什么" class="headerlink" title="4.2.2. 元空间保存什么"></a>4.2.2. 元空间保存什么</h3><p>元空间保存的<strong>数据，目前分为两大类</strong>：</p>
<ul>
<li><strong>Java 类数据</strong>：即加载的 Java 类对应 JVM 中的 Klass 对象（Klass 是 JVM 源码中的一个 c++ 类，你可以理解为类在 JVM 中的内存形式），但是这个 Klass 对象中存储的很多数据都是指针，具体的数据存储属于<strong>非 Java 类数据</strong>，<strong>一般非 Java 类数据远比 Java 类数据占用空间大</strong>。</li>
<li><strong>非 Java 类数据</strong>：即被 Klass 对象引用的一些数据，例如：类中的各种方法，注解，执行采集与统计信息等等。不要偷取他人的劳动成果，也不要浪费自己的时间和精力，让我们一起做一个有良知的写作者。</li>
</ul>
<p>如果是 64 位的 JVM 虚拟机（从 Java 9+ 开始只有 64 位的虚拟机了）并且开启了<strong>压缩类指针(-XX:+UseCompressedClassPointers，默认是开启的)，那么元空间会被划分成两部分</strong>：</p>
<ul>
<li><strong>类元空间</strong>：存储上面说的<strong>Java 类数据</strong>的空间</li>
<li><strong>数据元空间</strong>：存储上面说的<strong>非 Java 类数据</strong>的空间</li>
</ul>
<p><strong>基于是否开启了压缩类指针分为这两部分的原因</strong>是，（剽窃抄袭侵权<br>）在对象头需要保留指向 Klass 的指针，如果我们能尽量压缩这个指针的大小，那么每个对象的大小也能得到压缩，这将节省很多堆空间。在 64 位虚拟机上面，指针默认都是 64 位大小的，开启压缩类指针(<code>-XX:+UseCompressedClassPointers</code>，默认是开启的)之后，类指针变为 32 位大小，最多能指向 2^32 也就是 4G 的空间，如果我们能保持 Klass 所处的空间占用不超过这个限制的话，就能使用压缩类指针了。所以我们把 Klass 单独提取到一个单独的区域进行分配。Klass 占用的空间并不会太大，虽然对于 Java 中的每一个类都会有一个 Klass，但是占用空间的方法内容以及动态编译信息等等，具体数据都在<strong>数据元空间</strong>中存储，Klass 中大部分都是指针。基本上很少会遇到 32 位指针不够用的情况。</p>
<p>注意，老版本中， <code>UseCompressedClassPointers</code> 取决于 <code>UseCompressedOops</code>，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是<strong>从 Java 15 Build 23 开始， <code>UseCompressedClassPointers</code> 已经不再依赖 <code>UseCompressedOops</code> 了</strong>，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。参考 JDK ISSUE：<a href="https://bugs.openjdk.java.net/browse/JDK-8241825" target="_blank" rel="noopener">bugs.openjdk.java.net/browse/JDK-…</a> 以及源码：</p>
<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/x86/globalDefinitions_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/x86/globalDefinitions_x86.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS EnableJVMCI</code> 在 x86 CPU 上，<code>UseCompressedClassPointers</code> 是否依赖 <code>UseCompressedOops</code> 取决于是否启用了 JVMCI，默认使用的 JVM 发布版，EnableJVMCI 都是 false</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/arm/globalDefinitions_arm.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/arm/globalDefinitions_arm.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false</code> 在 ARM CPU 上，<code>UseCompressedClassPointers</code> 不依赖 <code>UseCompressedOops</code></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/ppc/globalDefinitions_ppc.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/ppc/globalDefinitions_ppc.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false</code> 在 PPC CPU 上，<code>UseCompressedClassPointers</code> 不依赖 <code>UseCompressedOops</code></li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/s390/globalDefinitions_s390.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/cpu/s390/globalDefinitions_s390.hpp</code></a>：<code>#define COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS false</code> 在 S390 CPU 上，<code>UseCompressedClassPointers</code> 不依赖 <code>UseCompressedOops</code></li>
</ul>
<p>在元空间分配的对象，都是调用 <code>Metaspace::allocate</code> 从元空间分配空间。调用这个方法的是 <code>MetaspaceObj</code> 的构造函数，对应源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/memory/allocation.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/memory/allocation.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码void* MetaspaceObj::operator new(size_t size, ClassLoaderData* loader_data,</span><br><span class="line">                                 size_t word_size,</span><br><span class="line">                                 MetaspaceObj::Type type, TRAPS) throw() &#123;</span><br><span class="line">  // Klass has its own operator new</span><br><span class="line">  return Metaspace::allocate(loader_data, word_size, type, THREAD);</span><br><span class="line">&#125;//你以为我想这样么？主要是抄袭狗太多</span><br><span class="line"></span><br><span class="line">void* MetaspaceObj::operator new(size_t size, ClassLoaderData* loader_data,</span><br><span class="line">                                 size_t word_size,</span><br><span class="line">                                 MetaspaceObj::Type type) throw() &#123;</span><br><span class="line">  assert(!Thread::current()-&gt;is_Java_thread(), &quot;only allowed by non-Java thread&quot;);</span><br><span class="line">  return Metaspace::allocate(loader_data, word_size, type);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>MetaspaceObj</code> 的 Operator new 方法定义了从 MetaSpace 上分配内存，即所有 <code>MetaspaceObj</code> 的子类，只要没有明确覆盖从其他地方分配，就会从 MetaSpace 分配内存。<code>MetaspaceObj</code> 的子类包括：</p>
<p><strong>位于类元空间的</strong>：</p>
<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/klass.hpp" target="_blank" rel="noopener"><code>Klass</code></a>：其实就是 Java 类的实例（每个 Java 的 class 有一个对应的对象实例，用来反射访问，这个就是那个对象实例），即 Java 对象头的类型指针指向的实例：<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/instanceKlass.hpp" target="_blank" rel="noopener"><code>InstanceKlass</code></a>：普通对象类的 Klass：<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/instanceRefKlass.hpp" target="_blank" rel="noopener"><code>InstanceRefKlass</code></a>：<code>java.lang.ref.Reference</code> 类以及子类对应的 Klass</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/instanceClassLoaderKlass.hpp" target="_blank" rel="noopener"><code>InstanceClassLoaderKlass</code></a>：Java 类加载器对应的 Klass</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/instanceMirrorKlass.hpp" target="_blank" rel="noopener"><code>InstanceMirrorKlass</code></a>：<code>java.lang.Class</code> 对应的 Klass</li>
</ul>
</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/arrayKlass.hpp" target="_blank" rel="noopener"><code>ArrayKlass</code></a>：Java 数组对应的 Klass<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/objArrayKlass.hpp" target="_blank" rel="noopener"><code>ObjArrayKlass</code></a>：普通对象数组对应的 Klass</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/typeArrayKlass.hpp" target="_blank" rel="noopener"><code>TypeArrayKlass</code></a>：原始类型数组对应的 Klass</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>位于数据元空间的</strong>：</p>
<ul>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/symbol.hpp" target="_blank" rel="noopener"><code>Symbol</code></a>：符号常量，即类中所有的符号字符串，例如类名称，方法名称，方法定义等等。</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/constantPool.hpp" target="_blank" rel="noopener"><code>ConstantPool</code></a>：运行时常量池，数据来自于类文件中的常量池。</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/ci/ciConstantPoolCache.hpp" target="_blank" rel="noopener"><code>ConstanPoolCache</code></a>：运行时常量池缓存，用于加速常量池访问</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/constMethod.hpp" target="_blank" rel="noopener"><code>ConstMethod</code></a>：类文件中的方法解析后，静态信息放入 ConstMethod，这部分信息可以理解为是不变的，例如字节码，行号，方法异常表，本地变量表，参数表等等。</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/methodCounters.hpp" target="_blank" rel="noopener"><code>MethodCounters</code></a>：方法的计数器相关数据。</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/methodData.hpp" target="_blank" rel="noopener"><code>MethodData</code></a>：方法数据采集，动态编译相关数据。例如某个方法需要采集一些指标，决定是否采用 C1 C2 动态编译优化性能。</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/method.hpp" target="_blank" rel="noopener"><code>Method</code></a>：Java 方法，包含以上 <code>ConstMethod</code>，<code>MethodCounters</code>，<code>MethodData</code> 的指针以及一些额外数据。</li>
<li><a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/share/oops/recordComponent.hpp" target="_blank" rel="noopener"><code>RecordComponent</code></a>：对应 Java 14 新特性 Record，即从 Record 中解析出的关键信息。</li>
</ul>
<p>以上这类型，我们在下一个系列<strong>全网最硬核 JVM 元空间解析中再详细说明</strong>。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879698952486972" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 10元空间分配与回收流程</title>
    <url>/7225879698952634428.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><h1 id="JVM-元空间设计"><a href="#JVM-元空间设计" class="headerlink" title="JVM 元空间设计"></a>JVM 元空间设计</h1></li>
</ol>
<h2 id="4-4-元空间分配与回收流程举例"><a href="#4-4-元空间分配与回收流程举例" class="headerlink" title="4.4. 元空间分配与回收流程举例"></a>4.4. 元空间分配与回收流程举例</h2><p>我们前面介绍了元空间的组成元素，但是没有将他们完整的串联起来，我们这里举一个简单的例子，将之前的所有元素串联起来。</p>
<p>通过前面的分析之后，我们知道元空间的主要抽象包括：</p>
<ul>
<li>全局唯一的类元空间 <code>MetaspaceContext</code>，它包括：<ul>
<li>一个 <code>VirtualSpaceList</code>，类元空间的 <code>VirtualSpaceList</code> 只有一个 <code>VirtualSpaceNode</code></li>
<li>一个 <code>ChunkManager</code></li>
</ul>
</li>
<li>全局唯一的数据元空间 <code>MetaspaceContext</code>，它包括：<ul>
<li>一个 <code>VirtualSpaceList</code>，数据元空间的 <code>VirtualSpaceList</code> 才是一个真正的 <code>VirtualSpaceNode</code> 的链表</li>
<li>一个 <code>ChunkManager</code></li>
</ul>
</li>
<li>每个类加载器都有一个独有的 <code>ClassLoaderData</code>，它包含自己独有的 <code>ClassLoaderMetaspace</code>，<code>ClassLoaderMetaspace</code> 包含：<ul>
<li>一个类元空间 <code>MetaspaceArena</code></li>
<li>一个数据元空间 <code>MetaspaceArena</code></li>
</ul>
</li>
</ul>
<p>假设我们全局只有一个类加载器，即类加载器 1，并且 <code>UseCompressedClassPointers</code> 为 <code>true</code>，那么我们可以假设当前元空间的初始结构为：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bfe593f00cab4e8f63aebc6a7a4105bd13b64811cce0ae4095c3b9b8bfa5e9df" alt="image"></p>
<p>接下来我们来看看详细的例子</p>
<h3 id="4-4-1-首先类加载器-1-需要分配-1023-字节大小的内存，属于类空间"><a href="#4-4-1-首先类加载器-1-需要分配-1023-字节大小的内存，属于类空间" class="headerlink" title="4.4.1. 首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间"></a>4.4.1. 首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f48a07bcf7f32905b4eb6e15a591d6810ecc774942bce8164a9df07a41fc5931" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.搜索 <code>FreeBlocks</code> 查看是否有可用空间，但是这是第一次分配，肯定没有。</p>
<p>4.尝试从 <code>_current_chunk</code> 分配，但是由于是第一次分配，<code>_current_chunk</code> 是 <code>NULL</code>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5116fe93061b3d5f7d01d344a29625883be89f3553ffcd768d5bc07d83758c79" alt="image"></p>
<p>5.将要分配的内存（1023 字节）按照 8 字节对齐，即 1024 字节。大于等于它的最小 <code>ChunkLevel</code> 为 12，即 <code>max_level = 12</code>。假设这个类加载器是 <code>Bootstrap ClassLoader</code>，其实是啥无所谓，我们主要是想找一个对应的 <code>ArenaGrowthPolicy</code>，根据这个 <code>ArenaGrowthPolicy</code>，第一个要申请的 <code>MeataChunk</code> 大小是 <code>256KB</code>，对应的 <code>ChunkLevel</code> 为 4，<code>preferred_level</code> 是 <code>max_level</code> 与这个之间相比小的那个，即 4。我们从类元空间的 <code>ChunkManager</code> 申请这么大的 <code>MetaChunk</code>，对应的 <code>ChunkLevel</code> 是 4</p>
<p>6.首先搜索 <code>ChunkManager</code> 的 <code>FreeChunkListVector</code>，看看是否有合适的。但是这是第一次分配，肯定没有。</p>
<p>7.尝试从类元空间的 <code>VirtualSpaceList</code> 申请 <code>RootMetaChunk</code> 用于分配。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/249c6a6c8e5cc5108bdf2f6e12718a35ff7b24b1d71f44e05c32532b68b62a26" alt="image"></p>
<p>8.从类元空间的 <code>VirtualSpaceList</code> 的唯一一个 <code>VirtualSpaceNode</code> 分配 <code>RootMetaChunk</code>，对半切分到 <code>ChunkLevel</code> 为 4 的 <code>MetaChunk</code>，返回 <code>leader</code> 的 <code>ChunkLevel</code> 为 4 的 <code>MetaChunk</code> 作为 <code>_current_chunk</code> 用于分配。分割出来剩下的 <code>ChunkLevel</code> 为 1， <code>ChunkLevel</code> 为 2， <code>ChunkLevel</code> 为 3， <code>ChunkLevel</code> 为 4 的各一个放入 <code>FreeChunkListVector</code> 中</p>
<p>9.<code>commit</code> 要分配的内存大小，如果 <code>AlwaysPreTouch</code> 是开启的，那么就会像之前我们分析 Java 堆内存那样进行 pre touch。</p>
<p>10.从 <code>_current_chunk</code> 分配内存，分配成功。</p>
<h3 id="4-4-2-然后类加载器-1-还需要分配-1023-字节大小的内存，属于类空间"><a href="#4-4-2-然后类加载器-1-还需要分配-1023-字节大小的内存，属于类空间" class="headerlink" title="4.4.2. 然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间"></a>4.4.2. 然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/71e9813587645dff8b2c1739982495bc415a44c534ce475396112488fae23424" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.搜索 <code>FreeBlocks</code> 查看是否有可用空间，目前还是没有。</p>
<p>4.尝试从 <code>_current_chunk</code> 分配，将要分配的内存（1023 字节）按照 8 字节对齐，即 1024 字节，<code>_current_chunk</code> 空间足够。</p>
<p>5.<code>commit</code> 要分配的内存大小，如果 <code>AlwaysPreTouch</code> 是开启的，那么就会像之前我们分析 Java 堆内存那样进行 pre touch。</p>
<p>6.从 <code>_current_chunk</code> 分配内存，分配成功。</p>
<h3 id="4-4-3-然后类加载器-1-需要分配-264-KB-大小的内存，属于类空间"><a href="#4-4-3-然后类加载器-1-需要分配-264-KB-大小的内存，属于类空间" class="headerlink" title="4.4.3. 然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间"></a>4.4.3. 然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/441fad4172c6d74a3496cb7a095ca438b9d6cfc4dfbccb8b10017ef668ebce3d" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.搜索 <code>FreeBlocks</code> 查看是否有可用空间，目前还是没有。</p>
<p>4.尝试从 <code>_current_chunk</code> 分配，将要分配的内存（264KB）按照 8 字节对齐，即 264KB，<code>_current_chunk</code> 空间不足，但是如果扩容一倍就足够，所以尝试扩大 <code>_current_chunk</code>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2a8512f26369103c20f33211de19c0128b6e39c3cc8953c0d3687e35a8d0fdbf" alt="image"></p>
<p>5.查看他的兄弟 <code>MetaChunk</code> 是否是空闲的，当然是，从 <code>FreeChunkListVector</code> 移除这个 <code>MetaChunk</code>，将这个兄弟 <code>MetaChunk</code> 与 <code>_current_chunk</code>。<code>_current_chunk</code> 的大小变为原来 2 倍，<code>_current_chunk</code> 的 <code>ChunkLevel</code> 减 1 之后为 3。</p>
<p>6.<code>commit</code> 要分配的内存大小，如果 <code>AlwaysPreTouch</code> 是开启的，那么就会像之前我们分析 Java 堆内存那样进行 pre touch。</p>
<p>7.从 <code>_current_chunk</code> 分配内存，分配成功。</p>
<h3 id="4-4-4-然后类加载器-1-需要分配-2-MB-大小的内存，属于类空间"><a href="#4-4-4-然后类加载器-1-需要分配-2-MB-大小的内存，属于类空间" class="headerlink" title="4.4.4. 然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间"></a>4.4.4. 然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6e0efc0a00b95f70dadb0419057e9c82dadfa776db646b9434b6cd4b51b9b945" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.搜索 <code>FreeBlocks</code> 查看是否有可用空间，目前还是没有。</p>
<p>4.尝试从 <code>_current_chunk</code> 分配，将要分配的内存（2MB）按照 8 字节对齐，即 2MB，<code>_current_chunk</code> 空间不足，扩容一倍也不够，所以就不尝试扩大 <code>_current_chunk</code> 了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3f2ff48a1f56c0ae7fcd1d12870c974d4e9a0da141a1e8e9a93db03bd8a431f5" alt="image"></p>
<p>5.要分配的大小是 2MB，大于等于它的最小 <code>ChunkLevel</code> 为 1，即 <code>max_level = 1</code>。根据 <code>ArenaGrowthPolicy</code>，下一个要申请的 <code>MeataChunk</code> 大小是 <code>256KB</code>，对应的 <code>ChunkLevel</code> 为 4，<code>preferred_level</code> 是 <code>max_level</code> 与这个之间相比小的那个，即 1。从 <code>FreeChunkListVector</code> 寻找，发现有合适的，将其作为 <code>current_chunk</code> 进行分配。</p>
<p>6.<code>commit</code> 要分配的内存大小，如果 <code>AlwaysPreTouch</code> 是开启的，那么就会像之前我们分析 Java 堆内存那样进行 pre touch。</p>
<p>7.之前的 <code>current_chunk</code> 的剩余空间大于 2 bytes，需要回收到 <code>FreeBlocks</code> 中。由于大于 33 bytes，需要放入 <code>BlockTree</code>。</p>
<p>8.从 <code>_current_chunk</code> 分配内存，分配成功。</p>
<h3 id="4-4-5-然后类加载器-1-需要分配-128KB-大小的内存，属于类空间"><a href="#4-4-5-然后类加载器-1-需要分配-128KB-大小的内存，属于类空间" class="headerlink" title="4.4.5. 然后类加载器 1 需要分配 128KB 大小的内存，属于类空间"></a>4.4.5. 然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5386712d406d6732ba37011f2b23ab4c4f75a3bccbb94c1b4352115b5cef18f1" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.将要分配的内存（128KB）按照 8 字节对齐，即 128KB。搜索 <code>FreeBlocks</code> 查看是否有可用空间，目前 <code>FreeBlocks</code> 有合适的可以分配。</p>
<p>4.<code>commit</code> 要分配的内存大小，如果 <code>AlwaysPreTouch</code> 是开启的，那么就会像之前我们分析 Java 堆内存那样进行 pre touch。</p>
<p>5.从 <code>FreeBlocks</code> 的 <code>BlockTree</code> 的节点分配内存，分配成功。为啥要打击抄袭，稿主被抄袭太多所以断更很久。</p>
<h3 id="4-4-6-新来一个类加载器-2，需要分配-1023-Bytes-大小的内存，属于类空间"><a href="#4-4-6-新来一个类加载器-2，需要分配-1023-Bytes-大小的内存，属于类空间" class="headerlink" title="4.4.6. 新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间"></a>4.4.6. 新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b439b8fc9e4a359df216e4648c4f8665136e516c053ad4f568b46fdef84e562a" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.搜索 <code>FreeBlocks</code> 查看是否有可用空间，但是这是第一次分配，肯定没有。</p>
<p>4.尝试从 <code>_current_chunk</code> 分配，但是由于是第一次分配，<code>_current_chunk</code> 是 <code>NULL</code>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a137e99bc7922ed3594f439e3950c1cb8041469bde5a8d897085e5ae6247d047" alt="image"></p>
<p>5.将要分配的内存（1023 字节）按照 8 字节对齐，即 1024 字节。大于等于它的最小 <code>ChunkLevel</code> 为 12，即 <code>max_level = 12</code>。假设这个类加载器是 <code>Bootstrap ClassLoader</code>，其实是啥无所谓，我们主要是想找一个对应的 <code>ArenaGrowthPolicy</code>。根据 <code>ArenaGrowthPolicy</code>，下一个要申请的 <code>MeataChunk</code> 大小是 <code>256KB</code>，对应的 <code>ChunkLevel</code> 为 4，<code>preferred_level</code> 是 <code>max_level</code> 与这个之间相比小的那个，即 4。</p>
<p>6.首先搜索 <code>ChunkManager</code> 的 <code>FreeChunkListVector</code>，看看是否有合适的。搜索到之前放入的 <code>ChunkLevel</code> 为 3 的。将其取出作为 <code>_current_chunk</code>。</p>
<p>7.<code>commit</code> 要分配的内存大小，如果 <code>AlwaysPreTouch</code> 是开启的，那么就会像之前我们分析 Java 堆内存那样进行 pre touch。</p>
<p>8.从 <code>_current_chunk</code> 分配内存，分配成功。</p>
<h3 id="4-4-7-然后类加载器-1-被-GC-回收掉"><a href="#4-4-7-然后类加载器-1-被-GC-回收掉" class="headerlink" title="4.4.7. 然后类加载器 1 被 GC 回收掉"></a>4.4.7. 然后类加载器 1 被 GC 回收掉</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/39e5679e7aedbc10e85289c183e3591d584f5149b010b2f3b461d0c92166a5f0" alt="image"></p>
<p>1.将类加载器 1 消耗的所有空间放回 <code>FreeBlocks</code> 中。前面分配了 1024 bytes, 1024 bytes, 264KB, 2MB 还有 128KB，这次放回 <code>BlockTree</code>，<code>BlockTree</code> 之前本身还有剩余一个 118KB。整体如图所示。</p>
<p>2.这样一来，原来 <code>MetaspaceArena</code> 中 <code>MetaChunkList</code> 管理的 <code>MetaChunk</code> 的内存全都空闲了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b57138c55add100e0a73dcbfd372abfeda16b221b2ba9e2340174bfbd71b0f81" alt="image"></p>
<ol start="3">
<li>将 <code>MetaChunkList</code> 管理的 <code>MetaChunk</code> 放回全局的 <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 中。并且放回的都是有 <code>commit</code> 过内存的，会放在每个 <code>ChunkLevel</code> 对应的 <code>MetaChunk</code> 链表的开头。</li>
</ol>
<h3 id="4-4-8-然后类加载器-2-需要分配-1-MB-大小的内存，属于类空间"><a href="#4-4-8-然后类加载器-2-需要分配-1-MB-大小的内存，属于类空间" class="headerlink" title="4.4.8. 然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间"></a>4.4.8. 然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</h3><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cda249e23e8827e966bc3a7f0e8c308eafc2916ba2a5217501b47c429d7b65cf" alt="image"></p>
<p>1~2.首先，类加载器 1 从它私有的 <code>ClassLoaderData</code> 去分配空间，由于要分配的是类元空间的，所以会从私有的类元空间的 <code>MetaspaceArena</code> 去分配空间。</p>
<p>3.搜索 <code>FreeBlocks</code> 查看是否有可用空间，目前还是没有。为啥要打击抄袭，稿主被抄袭太多所以断更很久。</p>
<p>4.尝试从 <code>_current_chunk</code> 分配，空间不足。并且 <code>_current_chunk</code> 不是 <code>leader</code>，所以就不尝试扩容了。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4056c93ff46327ad7ada7778cde2d0896a44b0768c365fe2bc5a39ed02cb70e7" alt="image"></p>
<p>5.将要分配的内存（1MB）按照 8 字节对齐，即 1MB。要分配的大小是 1MB，大于等于它的最小 <code>ChunkLevel</code> 为 2，即 <code>max_level = 2</code>。根据 <code>ArenaGrowthPolicy</code>，下一个要申请的 <code>MeataChunk</code> 大小是 <code>256KB</code>，对应的 <code>ChunkLevel</code> 为 4，<code>preferred_level</code> 是 <code>max_level</code> 与这个之间相比小的那个，即 2。从 <code>FreeChunkListVector</code> 寻找，发现有合适的，将其作为 <code>current_chunk</code> 进行分配。这个其实就是之前从类加载器 1 回收的。</p>
<p>6.因为是之前回收的，里面的内存都是 <code>committed</code> 了，所以这里就不用 <code>commit</code> 了。</p>
<p>7.之前的 <code>current_chunk</code> 的剩余空间大于 2 bytes，需要回收到 <code>FreeBlocks</code> 中。由于大于 33 bytes，需要放入 <code>BlockTree</code>。</p>
<p>8.从 <code>_current_chunk</code> 分配内存，分配成功。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879698952634428" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 6其他 Java 堆内存</title>
    <url>/7225879698952470588.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么<ol>
<li>什么时候用到元空间，以及释放时机</li>
<li>元空间保存什么</li>
</ol>
</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="3">
<li><h1 id="Java-堆内存相关设计"><a href="#Java-堆内存相关设计" class="headerlink" title="Java 堆内存相关设计"></a>Java 堆内存相关设计</h1></li>
</ol>
<h2 id="3-8-堆大小的动态伸缩"><a href="#3-8-堆大小的动态伸缩" class="headerlink" title="3.8. 堆大小的动态伸缩"></a>3.8. 堆大小的动态伸缩</h2><p>不同的 GC 堆大小动态伸缩有很大很大的差异（比如 ParallelGC 涉及 UseAdaptiveSizePolicy 启用的动态堆大小策略以及相关的 UsePSAdaptiveSurvivorSizePolicy、UseAdaptiveGenerationSizePolicyAtMinorCollection 等等等等的参数参与决定计算最新堆大小的方式以及时机），在这个系列以后的章节我们详细分析每个 GC 的时候再详细分析这些不同 GC 的动态伸缩策略。<strong>我们这里仅涉及大多数 GC 通用的堆大小伸缩涉及的参数</strong>：<code>MinHeapFreeRatio</code> 与 <code>MaxHeapFreeRatio</code>：</p>
<ul>
<li><code>MinHeapFreeRatio</code>：目标最小堆空闲比例，如果某次 GC 之后堆的某个区域（在某些 GC 是整个堆）空闲比例小于这个比例，那么就考虑将这个区域扩容。默认是 40，即默认是 40%，但是某些 GC 如果你不设置就会变成 0%。0% 代表从来不会因为没有达到目标最小堆空闲比例而扩容，配置为 0% 一般是为了堆的大小稳定。</li>
<li><code>MaxHeapFreeRatio</code>：目标最大堆空闲比例，如果某次 GC 之后堆的某个区域（在某些 GC 是整个堆）空闲比例大于这个比例，那么就考虑将这个区域缩小。默认是 70，即默认是 70%，但是某些 GC 如果你不设置就会变成 100%。100% 代表从来不会因为没有达到目标最大堆空闲比例而扩容，配置为 100% 一般是为了堆的大小稳定。</li>
<li><code>MinHeapDeltaBytes</code>：当扩容时，至少扩展多大的内存。默认是 166.4 KB（<code>128*13/10</code>）</li>
</ul>
<p>对应的源码是：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/runtime/globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/runtime/globals.hpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码product(uintx, MinHeapFreeRatio, 40, MANAGEABLE,                    \</span><br><span class="line">  &quot;The minimum percentage of heap free after GC to avoid expansion.&quot;\</span><br><span class="line">  &quot; For most GCs this applies to the old generation. In G1 and&quot;     \</span><br><span class="line">  &quot; ParallelGC it applies to the whole heap.&quot;)                      \</span><br><span class="line">  range(0, 100)                                                     \</span><br><span class="line">  constraint(MinHeapFreeRatioConstraintFunc,AfterErgo)              \</span><br><span class="line">product(uintx, MaxHeapFreeRatio, 70, MANAGEABLE,                    \</span><br><span class="line">  &quot;The maximum percentage of heap free after GC to avoid shrinking.&quot;\</span><br><span class="line">  &quot; For most GCs this applies to the old generation. In G1 and&quot;     \</span><br><span class="line">  &quot; ParallelGC it applies to the whole heap.&quot;)                      \</span><br><span class="line">  range(0, 100)                                                     \</span><br><span class="line">  constraint(MaxHeapFreeRatioConstraintFunc,AfterErgo)              \</span><br><span class="line">product(size_t, MinHeapDeltaBytes, ScaleForWordSize(128*K),         \</span><br><span class="line">  &quot;The minimum change in heap space due to GC (in bytes)&quot;)          \</span><br><span class="line">  range(0, max_uintx)                                               \</span><br></pre></td></tr></table></figure>

<p>这两个参数，在不同 GC 下的实际表现，如下：</p>
<ul>
<li><strong>SerialGC</strong>：在 SerialGC 的情况下，<code>MinHeapFreeRatio</code> 与 <code>MaxHeapFreeRatio</code> 指的仅仅是老年代的目标空闲比例，仅对老年代生效。在触发涉及老年代的 GC 的时候（其实就是 FullGC），GC 结束时，会查看（抄袭和xigao是文化的毒瘤，是对文化创造和发展的阻碍）当前老年代的空闲比例，与 <code>MinHeapFreeRatio</code> 和 <code>MaxHeapFreeRatio</code>比较 判断是否扩容或者缩小老年代的大小（这里的源码参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/serial/tenuredGeneration.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/serial/tenuredGeneration.cpp</code></a>）。</li>
<li><strong>ParallelGC</strong>：在 ParallelGC 的情况下，<code>MinHeapFreeRatio</code> 与 <code>MaxHeapFreeRatio</code> 指的是整个堆的大小。并且，如果这两个 JVM 参数没有明确指定的话，那么 <code>MinHeapFreeRatio</code> 就是 0，<code>MaxHeapFreeRatio</code> 就是 100（这里的源码参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/parallel/parallelArguments.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/parallel/parallelArguments.cpp</code></a>），相当于不会根据这两个参数调整堆大小。并且，如果 <code>UseAdaptiveSizePolicy</code> 是 false 的话，这两个参数也不会生效。</li>
<li><strong>G1GC</strong>：在 G1GC 的情况下，<code>MinHeapFreeRatio</code> 与 <code>MaxHeapFreeRatio</code> 指的是整个堆的大小。在触发涉及老年代的 GC 的时候，GC 结束时，会查看当前堆的空闲比例，与 <code>MinHeapFreeRatio</code> 和 <code>MaxHeapFreeRatio</code>比较判断是否扩容还是缩小堆，通过增加或者减少 Region 数量进行堆的扩容与缩小（这里的源码参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/g1/g1HeapSizingPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/g1/g1HeapSizingPolicy.cpp</code></a>）。</li>
<li><strong>ShenandoahGC</strong>：这三个参数不生效</li>
<li><strong>ZGC</strong>：这三个参数不生效</li>
</ul>
<h2 id="3-9-适用于长期运行并且尽量将所有可用内存被堆使用的-JVM-参数-AggressiveHeap"><a href="#3-9-适用于长期运行并且尽量将所有可用内存被堆使用的-JVM-参数-AggressiveHeap" class="headerlink" title="3.9. 适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap"></a>3.9. 适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</h2><p><code>AggressiveHeap</code> 是一种激进地让 JVM 使用当前系统的剩余内存的一种配置，开启会根据系统可用内存，自动设置堆大小等内存参数，将内存的一半分配给堆，另一半留给堆外其他的子系统占用内存，通过强制使用 ParallelGC 这种不会占用太多堆外内存的 GC 算法这种类似的思路限制堆外内存的使用（只能使用这个 GC，你指定其他 GC 的话会启动报错 <code>Error occurred during initialization of VM. Multiple garbage collectors selected</code>）。默认为 false 即不开启，可以通过 <code>-XX:+AggressiveHeap</code> 开启。</p>
<p>开启后，首先检查系统内存大小是否足够 256 MB，如果不够会报错，够得话，会计算出一个目标堆大小：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javascript复制代码目标堆大小 = Math.min(系统可用内存/2, 系统可用内存 - 160MB)</span><br></pre></td></tr></table></figure>

<p>之后，开启这个参数会强制设置以下参数：</p>
<ul>
<li><code>MaxHeapSize</code> 最大堆内存为目标堆大小</li>
<li><code>InitialHeapSize</code> 初始堆内存为目标堆大小</li>
<li><code>NewSize</code> 和 <code>MaxNewSize</code> 新生代为目标堆大小 * 八分之三</li>
<li><code>BaseFootPrintEstimate</code> 堆外内存占用大小预估为目标堆大小，用于指导一些堆外内存结构的初始化</li>
<li><code>UseLargePages</code> 为开启，使用大页内存分配，增加实际物理内存的连续性</li>
<li><code>TLABSize</code> 为 256K，即初始 TLAB 大小为 256 K，但是下面我们设置了 <code>ResizeTLAB</code> 为 false，所以 TLAB 就会保持为 256K</li>
<li><code>ResizeTLAB</code> 为 false，也就是 TLAB 大小不再随着 GC 以及分配特征的改变而改变，减少没必要的计算，反正进程要长期存在了，就在初始就指定一个比较大的 TLAB 的值。如果对 TLAB 细节感兴趣，请参考系列的第一部：全网最硬核 JVM TLAB 解析</li>
<li><code>UseParallelGC</code> 为 true，强制使用 ParallelGC</li>
<li><code>ThresholdTolerance</code> 为最大值 100，<code>ThresholdTolerance</code> 用于动态控制对象晋升到老年代需要存活过的 GC 次数，如果 <code>1 + ThresholdTolerance/100</code> * MinorGC 时间大于 MajorGC 的时间，我们就认为 MinorGC 占比过大，需要将更多对象晋升到老年代。反之，如果 <code>1 + ThresholdTolerance/100</code> * MajorGC 时间大于 MinorGC 的时间，就认为 MajorGC 时间占比过多，需要将更少的对象晋升到老年代。调整成 100 可以实现这个晋升界限基本不变保持稳定。</li>
<li><code>ScavengeBeforeFullGC</code> 设置为 false，在 FullGC 之前，先尝试执行一次 YoungGC。因为长期运行的应用，会经常 YoungGC 并晋升对象，需要 FullGC 的时候一般 YoungGC 无法回收那么多内存避免 FullGC，关闭它更有利于避免无效扫描弄脏 CPU 缓存。</li>
</ul>
<h2 id="3-10-JVM-参数-AlwaysPreTouch-的作用"><a href="#3-10-JVM-参数-AlwaysPreTouch-的作用" class="headerlink" title="3.10. JVM 参数 AlwaysPreTouch 的作用"></a>3.10. JVM 参数 AlwaysPreTouch 的作用</h2><p>在第二章的分析中，我们知道了 JVM 申请内存的流程，内存并不是在 JVM commit 一块内存之后就立刻被操作系统分配实际的物理内存的，只有真正往里面写数据的时候，才会关联实际的物理内存。所以对于 JVM 堆内存，我们也可以推测出，堆内存随着对象的分配才会关联实际的物理内存。那我们有没有办法提前强制让 committed 的内存关联实际的物理内存呢？很简单，往这些 committed 的内存中写入假数据就行了（一般是填充 0）。</p>
<p>对于不同的 GC，由于不同 GC 对于堆内存的设计不同，所以对于 AlwaysPreTouch 的处理也略有不同，在以后的系列我们详细解析每一种 GC 的时候，会详细分析每种 GC 的堆内存设计，这里我们就简单列举通用的 AlwaysPreTouch 处理。AlwaysPreTouch 打开后，所有新 commit 的堆内存，都会往里面填充 0，相当于写入空数据让 commit 的内存真正被分配。</p>
<p>不同操作系统环境下填充 0 的实现方式不太一样，但是基本思路是通过原子的方式给内存地址加 0 实现：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/runtime/os.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/runtime/os.cpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码void os::pretouch_memory(void* start, void* end, size_t page_size) &#123;</span><br><span class="line">  if (start &lt; end) &#123;</span><br><span class="line">    //对齐起始与末尾</span><br><span class="line">    char* cur = static_cast&lt;char*&gt;(align_down(start, page_size));</span><br><span class="line">    void* last = align_down(static_cast&lt;char*&gt;(end) - 1, page_size);</span><br><span class="line">    //对内存写入空数据，通过 Atomic::add</span><br><span class="line">    for ( ; true; cur += page_size) &#123;</span><br><span class="line">      Atomic::add(reinterpret_cast&lt;int*&gt;(cur), 0, memory_order_relaxed);</span><br><span class="line">      if (cur &gt;= last) break;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 linux x86 环境下，<code>Atomic::add</code> 的实现是通过 <code>xaddq</code> 加 <code>lock</code> 指令实现： <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os_cpu/linux_x86/atomic_linux_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/os_cpu/linux_x86/atomic_linux_x86.hpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码template&lt;&gt;</span><br><span class="line">template&lt;typename D, typename I&gt;</span><br><span class="line">inline D Atomic::PlatformAdd&lt;8&gt;::fetch_and_add(D volatile* dest, I add_value,</span><br><span class="line">                                               atomic_memory_order order) const &#123;</span><br><span class="line">  STATIC_ASSERT(8 == sizeof(I));</span><br><span class="line">  STATIC_ASSERT(8 == sizeof(D));</span><br><span class="line">  D old_value;</span><br><span class="line">  __asm__ __volatile__ (&quot;lock xaddq %0,(%2)&quot;</span><br><span class="line">                        : &quot;=r&quot; (old_value)</span><br><span class="line">                        : &quot;0&quot; (add_value), &quot;r&quot; (dest)</span><br><span class="line">                        : &quot;cc&quot;, &quot;memory&quot;);</span><br><span class="line">  return old_value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，如果只是串行地处理这些 <code>Atomic::add</code>，那是非常非常慢的。我们可以将要 preTouch 的内存分成不相交的区域，然后并发的填充这些不相交的内存区域，目前最新版本的 Java 都已经在各种不同的并发 GC 中实现了并发的 PreTouch，但是历史上不同 GC 出现过对于 AlwaysPreTouch 的不同问题，这里汇总下（Plagiarism真的可恶，滚开好么）：</p>
<ul>
<li><strong>ParallelGC</strong>：<ul>
<li>从 Java 16 build 21 开始，ParallelGC 才实现并发 PreTouch：<ul>
<li>Bug：<a href="https://bugs.openjdk.org/browse/JDK-8252221" target="_blank" rel="noopener"><code>https://bugs.openjdk.org/browse/JDK-8252221</code></a></li>
<li>Commit：<a href="https://github.com/openjdk/jdk/commit/9359ff03ae6b9e09e7defef148864f40e949b669" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/commit/9359ff03ae6b9e09e7defef148864f40e949b669</code></a></li>
</ul>
</li>
</ul>
</li>
<li><strong>G1GC</strong>：<ul>
<li>在 Java 9 build 45 之前，AlwaysPreTouch 对于 G1GC 不生效，这是一个 bug：<ul>
<li>Bug：<a href="https://bugs.openjdk.org/browse/JDK-8067469" target="_blank" rel="noopener"><code>https://bugs.openjdk.org/browse/JDK-8067469</code></a></li>
<li>Commit：<a href="https://github.com/openjdk/jdk/commit/f2e110fe7793b20a21f91e8ef7451814db2c8d73" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/commit/f2e110fe7793b20a21f91e8ef7451814db2c8d73</code></a></li>
</ul>
</li>
<li>从 Java 9 build 139 开始，G1GC 才实现并发 PreTouch：<ul>
<li>Bug：<a href="https://bugs.openjdk.org/browse/JDK-8157952" target="_blank" rel="noopener"><code>https://bugs.openjdk.org/browse/JDK-8157952</code></a></li>
<li>Commit：<a href="https://github.com/openjdk/jdk/commit/317f1aa044a8a71c52cfe733f1f4baf656c22c4c" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/commit/317f1aa044a8a71c52cfe733f1f4baf656c22c4c</code></a></li>
</ul>
</li>
</ul>
</li>
<li><strong>ZGC</strong>：<ul>
<li>从 Java 14 build 26 开始，ZGC 才实现并发 PreTouch：<ul>
<li>Bug：<a href="https://bugs.openjdk.org/browse/JDK-8234543" target="_blank" rel="noopener"><code>https://bugs.openjdk.org/browse/JDK-8234543</code></a></li>
<li>Commit：<a href="https://github.com/openjdk/jdk/commit/5e758d2368b58ceef5092e74d481b60867b5ab93" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/commit/5e758d2368b58ceef5092e74d481b60867b5ab93</code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="3-11-JVM-参数-UseContainerSupport-JVM-如何感知到容器内存限制"><a href="#3-11-JVM-参数-UseContainerSupport-JVM-如何感知到容器内存限制" class="headerlink" title="3.11. JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制"></a>3.11. JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</h2><p>在前面的章节我们分析了 JVM 自动计算堆大小限制，其中第一步就是 JVM 读取系统内存信息。在容器的环境下，JVM 也能感知到当前是容器环境，并且读取对应的内存限制。让 JVM 感知容器环境的相关 JVM 参数是 <code>UseContainerSupport</code>，默认值为 true，即让 JVM 感知容器的配置，相关源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/os/linux/globals_linux.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+3/src/hotspot/os/linux/globals_linux.hpp</code></a>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码product(bool, UseContainerSupport, true,                          \</span><br><span class="line">  &quot;Enable detection and runtime container configuration support&quot;) \</span><br></pre></td></tr></table></figure>

<p>这个配置默认开启，在开启的情况下，JVM 会通过下面的流程读取内存限制：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8f2390b90ea1d3d71df6af8fb93d1789b0d44465bd71c77b8849528b62442dba" alt="image"></p>
<p>可以看出，针对 Cgroup V1 与 V2 的情况，以及没有限制 pod 的 Memory limit 的情况，都考虑到了。</p>
<h2 id="3-12-SoftMaxHeapSize-用于平滑迁移更耗内存的-GC-使用"><a href="#3-12-SoftMaxHeapSize-用于平滑迁移更耗内存的-GC-使用" class="headerlink" title="3.12. SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用"></a>3.12. SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</h2><p>由于那种完并发的 GC（目标是完全无 Stop the world 暂停或者是亚毫秒暂停的 GC），例如 ZGC ，需要在堆外使用比 G1GC 以及 ParallelGC 多的多的空间（指的就是我们后面会分析到的 Native Memory Tracking 的 GC 部分占用的内存），并且由于 ZGC 这种目前是未分代的（Java 20 之后会引入分代 ZGC），导致 GC 在堆外占用的内存会更多。所以我们一般认为，在从 G1GC，或者 ParallelGC 切换到 ZGC 的时候，就算最大堆大小等各种 JVM 参数不变，JVM 也会需要更多的物理内存。但是，在实际的生产中，修改 JVM GC 是比较简单的，修改下启动参数就行了，但是给 JVM 加内存是比较困难的，因为是实际要消耗的资源。如果不修改 JVM 内存限制参数，也不加可用内存，线上可能会在换 GC 后经常出现被 OOMkiller 干掉的情况，还有剽窃狗被干掉了。</p>
<p>为了能让大家更平滑的切换 GC，以及对于线上应用，我们可能实际不一定需要用原来配置的堆大小的空间，JVM 针对 ShenandoahGC 以及 ZGC 引入了 SoftMaxHeapSize 这个参数（目前这个参数只对于这种专注于避免全局暂停的 GC 生效）。这个参数虽然默认是 0，<strong>但是如果没有指定的话，会自动设置为前文提到的 MaxHeapSize 大小</strong>。参考源码：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/shared/gc_globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/shared/gc_globals.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码product(size_t, SoftMaxHeapSize, 0, MANAGEABLE,                     \</span><br><span class="line">  &quot;Soft limit for maximum heap size (in bytes)&quot;)                    \</span><br><span class="line">  constraint(SoftMaxHeapSizeConstraintFunc,AfterMemoryInit)         \</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/shared/gcArguments.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B3/src/hotspot/share/gc/shared/gcArguments.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//如果没有设置 SoftMaxHeapSize，自动设置为前文提到的 MaxHeapSize 大小</span><br><span class="line">if (FLAG_IS_DEFAULT(SoftMaxHeapSize)) &#123;</span><br><span class="line">    FLAG_SET_ERGO(SoftMaxHeapSize, MaxHeapSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ZGC 与 ShenandoahGC 的堆设计，都有<strong>软最大大小</strong>限制的概念。这个<strong>软最大大小</strong>是随着时间与 GC 表现（例如分配速率，空闲率等）不断变化的，这两个 GC 会在堆扩展到<strong>软最大大小</strong>之后，尽量就不扩展堆大小，尽量通过激进的 GC 回收空间。只有在暂停世界都完全无法回收足够内存用以分配的时候，才会尝试扩展，这之后最大限制就到了 MaxHeapSize。SoftMaxHeapSize 会给这个<strong>软最大大小</strong>一个指导值，让<strong>软最大大小</strong>不要超过这个值。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879698952470588" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 8元空间的核心概念与设计</title>
    <url>/7225879724545835045.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><h1 id="JVM-元空间设计"><a href="#JVM-元空间设计" class="headerlink" title="JVM 元空间设计"></a>JVM 元空间设计</h1></li>
</ol>
<h2 id="4-3-元空间的核心概念与设计"><a href="#4-3-元空间的核心概念与设计" class="headerlink" title="4.3. 元空间的核心概念与设计"></a>4.3. 元空间的核心概念与设计</h2><h3 id="4-3-1-元空间的整体配置以及相关参数"><a href="#4-3-1-元空间的整体配置以及相关参数" class="headerlink" title="4.3.1. 元空间的整体配置以及相关参数"></a>4.3.1. 元空间的整体配置以及相关参数</h3><p>元空间配置相关的参数：</p>
<ul>
<li><code>MetaspaceSize</code>：初始元空间大小，也是最小元空间大小。后面元空间大小伸缩的时候，不会小于这个大小。默认是 21M。抄袭剽窃侵权<br>滚</li>
<li><code>MaxMetaspaceSize</code>：最大元空间大小，默认是无符号 int 最大值。</li>
<li><code>MinMetaspaceExpansion</code>：每次元空间大小伸缩的时候，至少改变的大小。默认是 256K。后文讲到元空间内存大小限制的时候会详细分析。</li>
<li><code>MaxMetaspaceExpansion</code>：每次元空间大小伸缩的时候，最多改变的大小。默认是 4M。后文讲到元空间内存大小限制的时候会详细分析。</li>
<li><code>MaxMetaspaceFreeRatio</code>：最大元空间空闲比例，默认是 70，即 70%。后文讲到元空间内存大小限制的时候会详细分析。</li>
<li><code>MinMetaspaceFreeRatio</code>：最小元空间空闲比例，默认是 40，即 40%。后文讲到元空间内存大小限制的时候会详细分析。</li>
<li><code>UseCompressedClassPointers</code>：前文提到过，是否开启压缩类指针。默认是开启的。老版本中， <code>UseCompressedClassPointers</code> 取决于 <code>UseCompressedOops</code>，即压缩对象指针如果没开启，那么压缩类指针也无法开启。但是<strong>从 Java 15 Build 23 开始， <code>UseCompressedClassPointers</code> 已经不再依赖 <code>UseCompressedOops</code> 了</strong>，两者在大部分情况下已经独立开来。除非在 x86 的 CPU 上面启用 JVM Compiler Interface（例如使用 GraalVM）。参考 JDK ISSUE：<a href="https://bugs.openjdk.java.net/browse/JDK-8241825" target="_blank" rel="noopener">bugs.openjdk.java.net/browse/JDK-…</a></li>
<li><code>CompressedClassSpaceSize</code>：如果启用了压缩类指针，则元空间会分为类元空间和数据元空间，否则只有数据元空间。这个参数限制类元空间的大小，范围是 1M ~ 3G。默认大小是 1G，如果指定了 <code>MaxMetaspaceSize</code>，那么为 1G 与 <code>MaxMetaspaceSize * 0.8</code> 中比较小的那个值，</li>
<li><code>CompressedClassSpaceBaseAddress</code>：类元空间起始虚拟内存地址，这个一般不指定。作用和前文分析堆内存的堆起始位置的作用差不多。</li>
<li><code>MetaspaceReclaimPolicy</code>：可以为：<code>balanced</code>, <code>aggressive</code>, 以及 <code>none</code>，需要注意一点的是 <code>none</code> 要被移除了（<a href="https://bugs.openjdk.org/browse/JDK-8302385" target="_blank" rel="noopener">bugs.openjdk.org/browse/JDK-…</a>）。默认是 <code>balanced</code>。具体主要是影响元空间底层相关的配置，下面我们会详细分析。</li>
</ul>
<p>元空间底层相关的配置包括：</p>
<ul>
<li><strong>commit 粒度 - commit_granule</strong>：通过第二章的分析我们知道，JVM 的空间一般是先 reserve， 之后 commit 之前 reserve 的空间的一部分，然后才能使用的。这个 commit 粒度代表元空间中 commit 内存的最小粒度，元空间在扩容缩容的时候最小的大小单位是 commit 粒度。</li>
<li><strong>虚拟内存空间节点内存大小 - virtual_space_node_default_word_size</strong>：这是后文我们会详细分析的 <code>VirtualSpaceNode</code> 的虚拟内存大小。大小在 64 位环境下是 64 MB。</li>
<li><strong>虚拟内存空间节点内存对齐 - virtual_space_node_reserve_alignment_words</strong>：这是后文我们会详细分析的 <code>VirtualSpaceNode</code> 的虚拟内存大小需要对齐的大小，即整体大小需要大于这个对齐大小并且是这个对齐大小整数倍。这个大小就是 <code>MetaChunk</code> 的最大大小，即 4MB。</li>
<li><strong>当前 MetaChunk 不足以分配的时候，是否尝试扩容当前 MetaChunk - enlarge_chunks_in_place</strong>：这个参数在正式 JVM 中是 true，并且不能修改。后文我们会详细分析什么是 <code>MetaChunk</code>。这里简单理解就是，元空间整体使用了和 Linux 伙伴分配算法类似的设计与抽象，其中内存分配的单元就是 Chunk，元空间中对应的就是 MetaChunk。</li>
<li><strong>分配新的 MetaChunk 的时候，是否一下子 commit MetaChunk 所有的内存 - new_chunks_are_fully_committed</strong>：后文我们会详细分析什么是 <code>MetaChunk</code>。</li>
<li><strong>在 MetaChunk 整个空间都没有使用的时候，是否将 MetaChunk 的内存全部释放回操作系统 - uncommit_free_chunks</strong>：后文我们会详细分析什么是 <code>MetaChunk</code>。</li>
</ul>
<p>从 Java 16 开始，引入了弹性元空间。老的元空间由于设计上分配粒度比较大，并且没有很好地释放空间的策略设计，所以占用可能比较大。Java 16 开始，JEP 387: Elastic Metaspace 引入了<strong>弹性元空间的设计，也是我们这里要讨论的设计</strong>。这个弹性元空间也引入了一个重要的参数 <code>-XX:MetaspaceReclaimPolicy</code>。</p>
<p><code>MetaspaceReclaimPolicy</code>：可以为：<code>balanced</code>, <code>aggressive</code>, 以及 <code>none</code>，需要注意一点的是 <code>none</code> 要被移除了（<a href="https://bugs.openjdk.org/browse/JDK-8302385" target="_blank" rel="noopener">bugs.openjdk.org/browse/JDK-…</a>），这三个配置具体影响是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/151ce8c407b46e34612bbcbef289d0a1ca6f195d946814954c68ba516eab1d30" alt="image"></p>
<h3 id="4-3-2-元空间上下文-MetaspaceContext"><a href="#4-3-2-元空间上下文-MetaspaceContext" class="headerlink" title="4.3.2. 元空间上下文 MetaspaceContext"></a>4.3.2. 元空间上下文 <code>MetaspaceContext</code></h3><p><code>MetaspaceContext</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/metaspaceContext.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/metaspaceContext.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码class MetaspaceContext : public CHeapObj&lt;mtMetaspace&gt;</span><br></pre></td></tr></table></figure>

<p>JVM 元空间，会在全局建立<strong>两个元空间上下文</strong>（<code>MetaspaceContext</code>），一个用于类元空间（我们后面称为<strong>类元空间 <code>MetaspaceContext</code></strong>），一个用于数据元空间（我们后面称为<strong>数据元空间 <code>MetaspaceContext</code></strong>）。当然，在没有启用压缩类指针的时候，只会初始化一个数据元空间 <code>MetaspaceContext</code>，不会初始化类元空间 <code>MetaspaceContext</code>，之后使用分配的时候，也只会用数据元空间 <code>MetaspaceContext</code> 进行分配。但是我们在后面讨论的时候，<strong>只会讨论开启压缩类指针的情况，因为这是默认并且常用的情况</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/062f83eb86d962fb908f435ca48d3a34595778c2f445941e180c9385baf7bc8e" alt="image"></p>
<p>每个 <code>MetaspaceContext</code> 都会对应<strong>一个独立的 <code>VirtualSpaceList</code></strong>，以及<strong>一个独立的 <code>ChunkManager</code></strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dc8ab1ddac796c20c127661de96e74f57bf6cabdc20efaf3b4a8faff5c5299ba" alt="image"></p>
<p>这个 <code>VirtualSpaceList</code> 中的每一个元素都是一个 <code>VirtualSpaceNode</code>。顾名思义，<code>VirtualSpaceNode</code> 是从操作系统申请内存，与元空间内存划分的抽象隔离的中间层抽象。<code>VirtualSpaceList</code> 负责与操作系统交互，申请或者释放内存。元空间与 <code>VirtualSpaceList</code> 交互，使用内存。</p>
<p><code>ChunkManager</code> 顾名思义，是管理所有 Chunk 的内存管理器。Chunk 这个概念经常出现在各种伙伴内存管理算法框架（Buddy Allocator）中，一般指内存管理分配的最小单元，这里的 Chunk 抽象对应的就是 <code>MetaChunk</code>。<code>ChunkManager</code> 从 <code>VirtualSpaceList</code> 上面获取一块连续比较大的内存的 <code>MetaChunk</code>（其实是 <code>RootMetaChunk</code>），然后将这个 <code>RootMetaChunk</code> 按照分配需求，连续对半分割成需要的大小，返回这个合适大小的 <code>MetaChunk</code>，剩下的分割出来的 <code>MetaChunk</code> 进入 <code>FreeChunkListVector</code> 用于下次分配 <code>MetaChunk</code> 的时候，直接返回合适的，就不再从 <code>VirtualSpaceList</code> 获取了。</p>
<p>我们接下来仔细分析 <code>VirtualSpaceList</code> 与 <code>ChunkManager</code></p>
<h3 id="4-3-3-虚拟内存空间节点列表-VirtualSpaceList"><a href="#4-3-3-虚拟内存空间节点列表-VirtualSpaceList" class="headerlink" title="4.3.3. 虚拟内存空间节点列表 VirtualSpaceList"></a>4.3.3. 虚拟内存空间节点列表 <code>VirtualSpaceList</code></h3><p><code>VirtualSpaceList</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。<strong>其实本人感觉这么设计不太合理，应该和 <code>MetaspaceContext</code> 属于同一个类别才比较合理</strong>。真正分配加载的类的占用空间的是从 <code>VirtualSpaceNode</code> 上面标记的内存分配的，这是下一小节要分析的内容。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/virtualSpaceList.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/virtualSpaceList.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码class VirtualSpaceList : public CHeapObj&lt;mtClass&gt;</span><br></pre></td></tr></table></figure>

<p>首先提一点，类元空间 <code>MetaspaceContext</code> 与数据元空间 <code>MetaspaceContext</code> 略有不同：类元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 是不可以扩展申请新的内存的，但是数据元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 是可以的。也就是说：类元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 其实只有一个 <code>VirtualSpaceNode</code>，但是数据元空间 <code>MetaspaceContext</code> 的 <code>VirtualSpaceList</code> 是一个包含多个 <code>VirtualSpaceNode</code> 的列表。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8776d471ce962b3b5879895ad3078b439717d0d403b619ec224f9dfba59d2adc" alt="image"></p>
<h3 id="4-3-4-虚拟内存空间节点-VirtualSpaceNode-与-CompressedClassSpaceSize"><a href="#4-3-4-虚拟内存空间节点-VirtualSpaceNode-与-CompressedClassSpaceSize" class="headerlink" title="4.3.4. 虚拟内存空间节点 VirtualSpaceNode 与 CompressedClassSpaceSize"></a>4.3.4. 虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></h3><p><code>VirtualSpaceNode</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。<strong>其实本人感觉这么设计不太合理，应该和 <code>MetaspaceContext</code> 属于同一个类别才比较合理</strong>。真正分配加载的类的占用空间的是从 <code>VirtualSpaceNode</code> 上面标记的内存地址分配的，<code>VirtualSpaceNode</code> 本身的空间占用只是起到描述记录作用，应该也属于元空间描述的那一类。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/virtualSpaceNode.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码class VirtualSpaceNode : public CHeapObj&lt;mtClass&gt;</span><br></pre></td></tr></table></figure>

<p><code>VirtualSpaceNode</code> 是一块连续的虚拟内存空间内存的抽象。<strong>类元空间的 <code>VirtualSpaceList</code> 只包含一个 <code>VirtualSpaceNode</code>，大小是前文提到的</strong> <code>CompressedClassSpaceSize</code>。</p>
<p><strong>数据元空间并不像类元空间或者堆内存那样</strong>，一下子 reserve 最大堆内存限制的内存，<strong>而是每次 reserve <code>VirtualSpaceNode</code> 大小</strong>。<code>VirtualSpaceNode</code> 大小在 64 位环境下是 64 MB：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/metaspaceSettings.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/metaspaceSettings.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码static const size_t _virtual_space_node_default_word_size =</span><br><span class="line">      chunklevel::MAX_CHUNK_WORD_SIZE * NOT_LP64(2) LP64_ONLY(16); // 8MB (32-bit) / 64MB (64-bit)</span><br></pre></td></tr></table></figure>

<p><code>VirtualSpaceNode</code> 通过两个数据结构来管理它维护的虚拟内存空间：</p>
<ul>
<li><code>CommitMask</code>：实际是一个位图，用于维护哪些内存被 commit 了，哪些没有，位图的标记的单位就是前文提到的 commit_granule（commit 粒度）。</li>
<li><code>RootChunkAreaLUT</code>：用于维护每个 <code>RootMetaChunk</code> 的内存分布。至于什么是 <code>RootMetaChunk</code> 在后续我们讲 <code>MetaChunk</code> 的时候会详细讲解。</li>
</ul>
<p>一个 <code>VirtualSpaceNode</code> 的主要结构如下图所示：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b9a6d012fc7fd7e6aa9d6235379b2e19f23ffa83a77f502ece7b63665dc0a79a" alt="image"></p>
<h3 id="4-3-5-MetaChunk"><a href="#4-3-5-MetaChunk" class="headerlink" title="4.3.5. MetaChunk"></a>4.3.5. <code>MetaChunk</code></h3><p><code>MetaChunk</code> 是元空间内存分配的核心抽象，其本质就是<strong>描述</strong>一块连续的虚拟内存空间。<code>MetaChunk</code> 本身只是一个描述对象，它也是直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间。这个描述对象是池化的，参考后面会分析的 <code>ChunkHeaderPool</code>。不要偷取他人的劳动成果！</p>
<p>元空间的任意分配，都是在某个 <code>MetaChunk</code> 上进行的(不要偷取他人的劳动成果！)。<code>MetaChunk</code> 有级别的概念，即 <code>ChunkLevel</code>，每个 <code>MetaChunk</code> 都有自己的 <code>ChunkLevel</code>，这个 <code>ChunkLevel</code> 主要代表了 <code>MetaChunk</code> 描述的内存空间的大小，每一个 level 都是下一个 level 大小的 2 倍：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/de6b45fd0d443d8581e24ece4f3b1752335e54cb173834d78b9ba7a01a4b370b" alt="image"></p>
<p>从 <code>VirtualSpaceNode</code> 上直接划分的 <code>MetaChunk</code> 是 <code>RootMetaChunk</code>，它的 <code>ChunkLevel</code> 为最高级别的 0，大小是 4MB，并且其中的内存只是 reserve 还没有 commit 的。</p>
<p><code>MetaChunk</code>有三个状态：</p>
<ul>
<li><code>Dead</code>：即 <code>MetaChunk</code> 只是对象被创建出来，但是没有关联描述实际的虚拟内存。后面我们会知道，<code>MetaChunk</code> 是池化可回收在利用的，<code>MetaChunk</code> 的池就是 <code>ChunkHeaderPool</code>。位于 <code>ChunkHeaderPool</code> 都还没有关联描述实际的虚拟内存，状态为 <code>Dead</code>。</li>
<li><code>Free</code>：即 <code>MetaChunk</code> 关联描述了实际的虚拟内存，但是没有被实际使用。此时，这个 <code>MetaChunk</code> 位于 <code>ChunkManager</code> 管理。</li>
<li><code>InUse</code>：即 <code>MetaChunk</code> 关联描述了实际的虚拟内存，也被实际使用了，此时，<code>MetaChunkArena</code> 管理这个 <code>MetaChunk</code> 上面的内存分配。</li>
</ul>
<h4 id="4-3-5-1-ChunkHeaderPool-池化-MetaChunk-对象"><a href="#4-3-5-1-ChunkHeaderPool-池化-MetaChunk-对象" class="headerlink" title="4.3.5.1. ChunkHeaderPool 池化 MetaChunk 对象"></a>4.3.5.1. <code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</h4><p><code>MetaChunk</code> 实际上只是一块连续的虚拟内存空间的描述类(不要偷取他人的劳动成果！)，即元数据类。由于类加载需要的大小不一，并且还经常会发生合并，切分等等，<code>MetaChunk</code> 可能有很多很多，元空间为了节省这个元数据类占用的空间，将其池化，回收再利用。这个池就是 <code>ChunkHeaderPool</code>。例如，从 <code>VirtualSpaceNode</code> 上直接划分 <code>RootMetaChunk</code> 的内存空间，会从 <code>ChunkHeaderPool</code> 申请一个 <code>MetaChunk</code> 用于描述。当两个 <code>MetaChunk</code> 的空间需要合并成一个的时候，其中一个 <code>MetaChunk</code> 其实就没有用了，会放回 <code>ChunkHeaderPool</code>，而不是直接 free 掉这个对象。</p>
<p><code>ChunkHeaderPool</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/chunkHeaderPool.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/chunkHeaderPool.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码class ChunkHeaderPool : public CHeapObj&lt;mtMetaspace&gt;</span><br></pre></td></tr></table></figure>

<p>其实从这里我们可以推测出，<code>MetaChunk</code> 本身也是直接原生堆上面分配，Native Memory Tracking 中也是属于 <code>Metaspace</code> 那一类别。</p>
<p><code>ChunkHeaderPool</code> 的结构是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fccacae028632575808712fffdba9a45b29ac786c532fa08dcb8a814b22a9b83" alt="image"></p>
<p>其实 <code>ChunkHeaderPool</code> 的机制很简单：</p>
<ul>
<li>申请 <code>MetaChunk</code> 用于描述内存：<ul>
<li>首先查看 <code>_freelist</code>，是否有之前放回的 <code>MetaChunk</code> 可以使用，如果有，就返回那个 <code>MetaChunk</code>，并从 <code>_freelist</code> 移除这个 <code>MetaChunk</code></li>
<li>如果没有，读取 <code>_current_slab</code> 指向的 <code>Slab</code>，<code>Slab</code> 核心就是一个预分配好的 <code>MetaChunk</code> 数组（大小是 128），<code>_top</code> 指的是当前使用到数组的哪一个。</li>
<li>如果 <code>_top</code> 没有到 128，返回 <code>_top</code> 代表的 <code>MetaChunk</code>，并将 <code>_top</code> 加 1。</li>
<li>如果 <code>_top</code> 到 128，创建新的 <code>Slab</code>，<code>_current_slab</code> 指向这个新的 <code>Slab</code></li>
</ul>
</li>
<li>回收 <code>MetaChunk</code>：放入 <code>_freelist</code></li>
</ul>
<h4 id="4-3-5-2-ChunkManager-管理空闲的-MetaChunk"><a href="#4-3-5-2-ChunkManager-管理空闲的-MetaChunk" class="headerlink" title="4.3.5.2. ChunkManager 管理空闲的 MetaChunk"></a>4.3.5.2. <code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></h4><p><code>ChunkManager</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Metaspace</code> 那一类别，即元空间的抽象类占用的空间。不要偷取他人的劳动成果！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码class ChunkManager : public CHeapObj&lt;mtMetaspace&gt;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/chunkManager.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/metaspace/chunkManager.hpp</code></a></p>
<p><code>ChunkManager</code> 管理已经关联内存但是还没使用（状态是 <code>Free</code>）的 <code>MetaChunk</code>。在第一次从 <code>VirtualSpaceNode</code> 上面分配 <code>RootMetaChunk</code> 的内存的时候，根据申请的内存大小，决定要将 <code>RootMetaChunk</code> 拆分到某个 <code>ChunkLevel</code> 大小之后用于当前分配，拆分出来的其他的 <code>MetaChunk</code> 还没有使用，先放入一个类似于之前 <code>ChunkHeaderPool</code> 里面的 <code>_free_list</code> 的结构，用于下次申请 <code>MetaChunk</code> 用于分配的时候，先从这个里面找，找不到之后再从 <code>VirtualSpaceNode</code> 上面尝试分配新的 <code>RootMetaChunk</code>。不要惯着cao袭的人！</p>
<p><code>ChunkManager</code> 的整体结构是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/268fc9d67381a92d6506b611687c07b5eee9719a126ed0e2cb49196ec9fce75d" alt="image"></p>
<p><code>ChunkManager</code> 主要维护一个 <code>FreeChunkListVector</code>，<code>FreeChunkListVector</code> 里面是一个 <code>FreeChunkList</code> 数组（还有xigao dog 的码）。<code>FreeChunkList</code> 是一个 <code>MetaChunk</code> 链表，链表中都是 <code>Free</code> 的 <code>MetaChunk</code>，同样 <code>ChunkLevel</code> 的 <code>MetaChunk</code> 位于同一个 <code>FreeChunkList</code> 中。<code>FreeChunkList</code> 数组以 <code>ChunkLevel</code> 为下标，这样的数据结构可以快速找到一个所需 <code>ChunkLevel</code> 的 <code>MetaChunk</code>。<code>FreeChunkList</code>这个链表其实是一个双向链表，包含头尾两个指针，如果一个 <code>MetaChunk</code> 管理的内存被 commit 了，就会放在链表头部，没有 commit 的放在链表尾部。</p>
<p><code>MetaChunk</code> 具体的分配，切分，合并流程，我们会在介绍完 <code>MetaspaceArena</code> 之后详细分析。但是，<code>MetaspaceArena</code> 和 <code>ChunkManager</code> 不一样，<code>ChunkManager</code> 是全局两个，一个属于类元空间，一个属于数据元空间，倘若没有开启压缩类指针，那么就只有一个数据元空间 <code>ChunkManager</code>，而 <code>MetaspaceArena</code> 我们后面会看到是每个 <code>ClassLoader</code> 独立私有的。所以，在讲 <code>MetaspaceArena</code> 之前，我们先要从另一个角度即 <code>ClassLoader</code> 加载类的角度出发，向下一层一层剖析到 <code>MetaspaceArena</code>。</p>
<h3 id="4-3-6-类加载的入口-SystemDictionary-与保留所有-ClassLoaderData-的-ClassLoaderDataGraph"><a href="#4-3-6-类加载的入口-SystemDictionary-与保留所有-ClassLoaderData-的-ClassLoaderDataGraph" class="headerlink" title="4.3.6. 类加载的入口 SystemDictionary 与保留所有 ClassLoaderData 的 ClassLoaderDataGraph"></a>4.3.6. 类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></h3><p>类加载的入口在全局唯一的 <code>SystemDictionary</code> 中，这里我们只是为了看一下类加载需要哪些参数，来搞清楚对应关系，不用关心细节，入口代码是：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/systemDictionary.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/systemDictionary.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码InstanceKlass* SystemDictionary::resolve_from_stream(ClassFileStream* st,</span><br><span class="line">                                                     Symbol* class_name,</span><br><span class="line">                                                     Handle class_loader,</span><br><span class="line">                                                     const ClassLoadInfo&amp; cl_info,</span><br><span class="line">                                                     TRAPS) &#123;</span><br><span class="line">  //隐藏类与普通类的加载方式不同，隐藏类是 JEP 371: Hidden Classes 引入的，Java 15 中发布的新特性</span><br><span class="line">  if (cl_info.is_hidden()) &#123;</span><br><span class="line">    return resolve_hidden_class_from_stream(st, class_name, class_loader, cl_info, CHECK_NULL);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return resolve_class_from_stream(st, class_name, class_loader, cl_info, CHECK_NULL);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，加载类需要以下参数：</p>
<ul>
<li><code>ClassFileStream* st</code>：类文件流</li>
<li><code>Symbol* class_name</code>：加载的类的名称</li>
<li><code>Handle class_loader</code>：是哪个类加载器</li>
<li><code>const ClassLoadInfo&amp; cl_info</code>：类加载器信息</li>
</ul>
<p>在加载类的时候，<code>SystemDictionary</code> 会获取类加载器的 <code>ClassLoaderData</code>，<code>ClassLoaderData</code> 是每个类加载器私有的。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/systemDictionary.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/systemDictionary.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码//通过类加载器获取对应的 `ClassLoaderData`</span><br><span class="line">ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) &#123;</span><br><span class="line">  if (create_mirror_cld) &#123;</span><br><span class="line">    return ClassLoaderDataGraph::add(class_loader, true);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    // 如果是 null，代表是 BootstrapClassLoader，使用全局的 BootstrapClassLoader 对应的 ClassLoaderData</span><br><span class="line">    return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :</span><br><span class="line">    //否则，从 ClassLoaderDataGraph 寻找或者创建 class_loader 对应的 ClassLoaderData</span><br><span class="line">                                      ClassLoaderDataGraph::find_or_create(class_loader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ClassLoaderDataGraph</code> 保存着所有的 <code>ClassLoaderData</code>，这个主要用来遍历每个类加载器，以及获取每个类加载器加载的类的信息，还有遍历类加载器加载的类，例如 <code>jcmd</code> 命令中的 <code>VM.classloaders</code> 以及 <code>VM.classloader_stats</code> 就是这么实现的。但是，我们就不纠结于 <code>ClassLoaderDataGraph</code> 的细节了，这不是咱们的重点。</p>
<h3 id="4-3-7-每个类加载器私有的-ClassLoaderData-以及-ClassLoaderMetaspace"><a href="#4-3-7-每个类加载器私有的-ClassLoaderData-以及-ClassLoaderMetaspace" class="headerlink" title="4.3.7. 每个类加载器私有的 ClassLoaderData 以及 ClassLoaderMetaspace"></a>4.3.7. 每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></h3><p><code>ClassLoaderData</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。这就很合理了，不加载类就不会有 <code>ClassLoaderData</code>。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/classLoaderData.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/classLoaderData.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码    class ClassLoaderData : public CHeapObj&lt;mtClass&gt;</span><br></pre></td></tr></table></figure>

<p>如前所述，<code>ClassLoaderData</code> 是每个类加载器私有的。<code>ClassLoaderData</code> 包含的元素众多，我们这里只关心它其中与元空间内存分配相关的，即 <code>ClassLoaderMetaspace</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/classLoaderData.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/classfile/classLoaderData.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码    ClassLoaderMetaspace * volatile _metaspace;</span><br></pre></td></tr></table></figure>

<p><code>ClassLoaderMetaspace</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/classLoaderMetaspace.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B11/src/hotspot/share/memory/classLoaderMetaspace.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码    class ClassLoaderMetaspace : public CHeapObj&lt;mtClass&gt;</span><br></pre></td></tr></table></figure>

<p><code>ClassLoaderMetaspace</code> 有不同的类型（<code>MetaspaceType</code>）：</p>
<ul>
<li><code>MetaspaceType::StandardMetaspaceType</code>：平台类加载器（Platform ClassLoader，Java 9 之前叫做 ext ClassLoader）以及应用类加载器（Application ClassLoader）的 <code>ClassLoaderMetaspace</code></li>
<li><code>MetaspaceType::BootMetaspaceType</code>：即根类加载器（Boostrap ClassLoader）的 <code>ClassLoaderMetaspace</code></li>
<li><code>MetaspaceType::ClassMirrorHolderMetaspaceType</code>：加载匿名类的类加载器的 <code>ClassLoaderMetaspace</code></li>
<li><code>MetaspaceType::ReflectionMetaspaceType</code>：反射调用的前几次通过 jni native 调用，超过一定次数会优化成生成字节码类调用。加载这些字节码类的类加载器是 <code>jdk.internal.reflect.DelegatingClassLoader</code>，这个类加载器的 <code>ClassLoaderMetaspace</code> 类型就是 <code>ReflectionMetaspaceType</code>。</li>
</ul>
<p><code>ClassLoaderMetaspace</code> 和 <code>MetaspaceContext</code> 类似，如果压缩类指针开启，那么 <code>ClassLoaderMetaspace</code> 包含一个类元空间的 <code>MetaspaceArena</code> 和一个数据元空间的 <code>MetaspaceArena</code>，否则只有一个数据元空间的 <code>MetaspaceArena</code>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c82e125f887ccac66038e7d82524ed75d39738b96e67c886a6a6fce4868d1bc9" alt="image"></p>
<h3 id="4-3-8-管理正在使用的-MetaChunk-的-MetaspaceArena"><a href="#4-3-8-管理正在使用的-MetaChunk-的-MetaspaceArena" class="headerlink" title="4.3.8. 管理正在使用的 MetaChunk 的 MetaspaceArena"></a>4.3.8. 管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></h3><p><code>MetaspaceArena</code> 本身直接原生堆上面分配，Native Memory Tracking 中属于 <code>Class</code> 那一类别，即元空间的加载类占用的空间。这也是肯定的，因为跟着类加载器存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码class MetaspaceArena : public CHeapObj&lt;mtClass&gt;</span><br></pre></td></tr></table></figure>

<p><code>MetaspaceArena</code> 结构如下所示：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9b28ac2b49b82318b63c6a3013d89685b7379d5967748e89040d0b6e0e478c76" alt="image"></p>
<p><code>MetaspaceArena</code> 包含：</p>
<ul>
<li>一个 <code>MetachunkList</code>：管理在该 <code>MetaspaceArena</code> 分配的 <code>MetaChunk</code> 的列表，列表的第一个是当前分配内存的 <code>MetaChunk</code>。</li>
<li>当前 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：在当前分配内存的 <code>MetaChunk</code> 不够分配的时候，申请新的 <code>MetaChunk</code> 的大小。</li>
<li><code>Freeblocks</code>： 在当前分配内存的 <code>MetaChunk</code> 不够分配的时候，需要分配新的 <code>MetaChunk</code>。当前的 <code>MetaChunk</code> 剩余空间放入 <code>Freeblocks</code>。</li>
</ul>
<p><code>Freeblocks</code> 包含一个 <code>BinList32</code> 和一个 <code>BlockTree</code>。大小大于 33 字节的进入 <code>BlockTree</code>，否则进入 <code>BinList32</code>。</p>
<p><code>BinList32</code> 类似于 <code>FreeChunkListVector</code>，是一个链表的数组，同样大小的内存在同一数组下标的链表。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f1cd14b404e35fd35c7eb8ce092a83fe478247cde475db777332a2f0907a0bad" alt="image"></p>
<p><code>BlockTree</code> 是一个在 <strong>Binary Search Tree</strong>（BST）的基础上，同样内存的节点在二叉树节点的后面形成链表的数据结构。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e0f903ed607b2e4706cc2d489caf00c8c5734176993338f066eb9fac84a13b9d" alt="image"></p>
<p>不同的类加载器类型的类元空间的 <code>MetaspaceArena</code> 与数据元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code> 不同：</p>
<p>1.根类加载器（Boostrap ClassLoader）的 <code>ClassLoaderMetaspace</code> 类元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code>每次增长都是申请大小为 <code>256K</code> 的 <code>MetaChunk</code></p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码    static const chunklevel_t g_sequ_boot_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_256K</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>2.根类加载器（Boostrap ClassLoader）的 <code>ClassLoaderMetaspace</code> 数据元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 的第一个 <code>MetaChunk</code> 大小为 <code>4M</code>，之后每个新 <code>MetaChunk</code> 都是 <code>1M</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码    static const chunklevel_t g_sequ_boot_non_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_4M,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_1M</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>3.平台类加载器（Platform ClassLoader，Java 9 之前叫做 ext ClassLoader）以及应用类加载器（Application ClassLoader）的 <code>ClassLoaderMetaspace</code> 类元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 的第一个 <code>MetaChunk</code> 大小为 <code>2K</code>，第二个也是 <code>2K</code>，第三个 <code>4K</code>，第四个为 <code>8K</code>，之后每个新 <code>MetaChunk</code> 都是 <code>16K</code>（不要惯着cao袭的人！）：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码    static const chunklevel_t g_sequ_standard_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_2K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_2K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_4K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_8K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_16K</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>4.平台类加载器（Platform ClassLoader，Java 9 之前叫做 ext ClassLoader）以及应用类加载器（Application ClassLoader）的 <code>ClassLoaderMetaspace</code> 数据元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 的第一个 <code>MetaChunk</code> 大小为 <code>4K</code>，第二个也是 <code>4K</code>，第三个 <code>4K</code>，第四个为 <code>8K</code>，之后每个新 <code>MetaChunk</code> 都是 <code>16K</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码    static const chunklevel_t g_sequ_standard_non_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_4K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_4K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_4K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_8K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_16K</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>5.加载匿名类的类加载器的 <code>ClassLoaderMetaspace</code> 类元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 每次增长都是申请大小为 <code>1K</code> 的 <code>MetaChunk</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码    static const chunklevel_t g_sequ_anon_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_1K,</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>6.加载匿名类的类加载器的 <code>ClassLoaderMetaspace</code> 数据元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 每次增长都是申请大小为 <code>1K</code> 的 <code>MetaChunk</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码    static const chunklevel_t g_sequ_anon_non_class[] = &#123;</span><br><span class="line">       chunklevel::CHUNK_LEVEL_1K,</span><br><span class="line">       // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>7.<code>DelegatingClassLoader</code> 的 <code>ClassLoaderMetaspace</code> 类元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 每次增长都是申请大小为 <code>1K</code> 的 <code>MetaChunk</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">arduino复制代码    static const chunklevel_t g_sequ_refl_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_1K,</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<p>8.<code>DelegatingClassLoader</code> 的 <code>ClassLoaderMetaspace</code> 数据元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 的第一个 <code>MetaChunk</code> 大小为 <code>2K</code>，之后每个新 <code>MetaChunk</code> 都是 <code>1K</code>：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArenaGrowthPolicy.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">php复制代码    static const chunklevel_t g_sequ_refl_non_class[] = &#123;</span><br><span class="line">        chunklevel::CHUNK_LEVEL_2K,</span><br><span class="line">        chunklevel::CHUNK_LEVEL_1K</span><br><span class="line">        // .. repeat last</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879724545835045" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 13JVM 线程内存设计</title>
    <url>/7225879724546113573.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="5">
<li><h1 id="JVM-线程内存设计（重点研究-Java-线程）"><a href="#JVM-线程内存设计（重点研究-Java-线程）" class="headerlink" title="JVM 线程内存设计（重点研究 Java 线程）"></a>JVM 线程内存设计（重点研究 Java 线程）</h1></li>
</ol>
<p>Java 19 中 Loom 终于 Preview 了，虚拟线程（<code>VirtualThread</code>）是我期待已久的特性，但是这里我们说的线程内存，并不是这种 虚拟线程，还是老的线程。其实新的虚拟线程，在线程内存结构上并没有啥变化，只是存储位置的变化，实际的负载线程（<code>CarrierThread</code>）还是老的线程。</p>
<p>同时，JVM 线程占用的内存分为两个部分：分别是线程栈占用内存，以及线程本身数据结构占用的内存。</p>
<h2 id="5-1-JVM-中有哪几种线程，对应线程栈相关的参数是什么"><a href="#5-1-JVM-中有哪几种线程，对应线程栈相关的参数是什么" class="headerlink" title="5.1. JVM 中有哪几种线程，对应线程栈相关的参数是什么"></a>5.1. JVM 中有哪几种线程，对应线程栈相关的参数是什么</h2><p>JVM 中有如下几类线程：</p>
<ul>
<li><strong>VM 线程</strong>：全局唯一的线程，负责执行 <code>VM Operations</code>，例如 JVM 的初始化，其中的操作大部分需要在安全点执行，即 Stop the world 的时候执行。所有的操作请参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21+17/src/hotspot/share/runtime/vmOperation.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+17/src/hotspot/share/runtime/vmOperation.hpp</code></a></li>
<li><strong>GC 线程</strong>：负责做 GC 操作的线程</li>
<li><strong>Java 线程</strong>：包括 Java 应用线程（<code>java.lang.Thread</code>），以及 <code>CodeCacheSweeper</code> 线程， <code>JVMTI</code> 的 Agent 与 Service 线程其实也是 JAva 线程。</li>
<li><strong>编译器线程</strong>： JIT 编译器的线程，有 C1 和 C2 线程(xi稿滚去shi)</li>
<li><strong>定时任务时钟线程</strong>：全局唯一的线程，即 Watcher 线程，负责计时并执行定时任务，目前 JVM 中包括的定时任务可以通过查看继承 <code>PeriodicTask</code> 的类看到，其中两个比较重要的任务是：<ul>
<li><code>StatSamplerTask</code>：定时更新采集的 JVM Performance Data（PerfData）数据， 包括 GC、类加载、运行采集等等数据，这个任务多久执行一次是通过 <code>-XX:PerfDataSamplingInterval</code> 参数控制的，默认为 50 毫秒（参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/share/runtime/globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/share/runtime/globals.hpp</code></a>）。这些数据一般通过 jstat 读取，或者通过 JMX 读取。</li>
<li><code>VMOperationTimeoutTask</code>：由于 VM 线程是单线程，执行 <code>VM Operations</code>，单个任务执行不能太久，否则会阻塞其他 <code>VM Operations</code>。所以每次执行 <code>VM Operations</code> 的时候，这个定时任务都会检查当前执行了多久，如果超过 <code>-XX:AbortVMOnVMOperationTimeoutDelay</code> 就会报警。<code>AbortVMOnVMOperationTimeoutDelay</code> 默认是 1000ms（参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/share/runtime/globals.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/share/runtime/globals.hpp</code></a>）。</li>
</ul>
</li>
<li><strong>异步日志线程</strong>：全局唯一的线程， Java 17 引入的异步 JVM 日志特性，防止因为 JVM 日志输出阻塞影响全局安全点事件导致全局暂停过长，或者 JVM 日志输出导致线程阻塞，负责异步写日志，通过 <code>-Xlog:async</code> 启用 JVM 异步日志，通过 <code>-XX:AsyncLogBufferSize=</code> 指定异步日志缓冲大小，这个大小默认是 <code>2097152</code> 即 <code>2MB</code></li>
<li><strong>JFR 采样线程</strong>：全局唯一的线程，负责采集 JFR 中的两种采样事件，一个是 <code>jdk.ExecutionSample</code>，另一个是 <code>jdk.NativeMethodSample</code>，都是采样当前正在 <code>RUNNING</code> 的线程，如果线程在执行 Java 代码，就属于 <code>jdk.ExecutionSample</code>，如果执行 native 方法，就属于 <code>jdk.NativeMethodSample</code>。</li>
</ul>
<p>相关的参数有：</p>
<ul>
<li><code>ThreadStackSize</code>：每个 <strong>Java 线程</strong>的栈大小，这个参数通过 <code>-Xss</code> 也可以指定，各种平台的默认值为：<ul>
<li>linux 平台，x86 CPU，默认为 1024 KB，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 2048 KB，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_aarch64/globals_linux_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_aarch64/globals_linux_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 0，即使用操作系统默认值（64 位虚拟机为 1024KB），参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_x86/globals_windows_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_x86/globals_windows_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 0，即使用操作系统默认值（64 位虚拟机为 1024KB），参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_aarch64/globals_windows_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_aarch64/globals_windows_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>VMThreadStackSize</code>：<strong>VM 线程</strong>，<strong>GC 线程</strong>，<strong>定时任务时钟线程</strong>，<strong>异步日志线程</strong>，<strong>JFR 采样线程</strong>的栈大小，各种平台的默认值为：<ul>
<li>linux 平台，x86 CPU，默认为 1024 KB，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 2048 KB，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_aarch64/globals_linux_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_aarch64/globals_linux_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 0，即使用操作系统默认值（64 位虚拟机为 1024KB），参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_x86/globals_windows_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_x86/globals_windows_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 0，即使用操作系统默认值（64 位虚拟机为 1024KB），参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_aarch64/globals_windows_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_aarch64/globals_windows_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>CompilerThreadStackSize</code>：<strong>编译器线程</strong>的栈大小，各种平台的默认值为：<ul>
<li>linux 平台，x86 CPU，默认为 1024 KB，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_x86/globals_linux_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 2048 KB，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_aarch64/globals_linux_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/linux_aarch64/globals_linux_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 0，即使用操作系统默认值（64 位虚拟机为 1024KB），参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_x86/globals_windows_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_x86/globals_windows_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 0，即使用操作系统默认值（64 位虚拟机为 1024KB），参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_aarch64/globals_windows_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/os_cpu/windows_aarch64/globals_windows_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>StackYellowPages</code>：后面会提到并分析的黄色区域的页大小<ul>
<li>linux 平台，x86 CPU，默认为 2 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 2 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 3 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 2 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>StackRedPages</code>：后面会提到并分析的红色区域的页大小<ul>
<li>linux 平台，x86 CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>StackShadowPages</code>：后面会提到并分析的影子区域的页大小<ul>
<li>linux 平台，x86 CPU，默认为 20 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 20 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 8 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 20 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>StackReservedPages</code>：后面会提到并分析的保留区域的页大小<ul>
<li>linux 平台，x86 CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>linux 平台，aarch CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
<li>windows 平台，x86 CPU，默认为 0 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/globals_x86.hpp</code></a></li>
<li>windows 平台，aarch CPU，默认为 1 页，参考：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/aarch64/globals_aarch64.hpp</code></a></li>
</ul>
</li>
<li><code>RestrictReservedStack</code>：默认为 true，与保留区域相关，保留区域会保护临界区代码（例如 <code>ReentrantLock</code>）在抛出 <code>StackOverflow</code> 之前先把临界区代码执行完再结束，防止临界区代码执行到一半就抛出 <code>StackOverflow</code> 导致状态不一致导致这个锁之后再也用不了了。标记临界区代码的注解是 <code>@jdk.internal.vm.annotation.ReservedStackAccess</code>。在这个配置为 true 的时候，这个注解默认只能 jdk 内部代码使用，如果你有类似于 <code>ReentrantLock</code> 这种带有临界区的代码也想保护起来，可以设置 <code>-XX:-RestrictReservedStack</code>，关闭对于 <code>@jdk.internal.vm.annotation.ReservedStackAccess</code> 的限制，这样你就可以在自己的代码中使用这个注解了。</li>
</ul>
<p>我们接下来重点分析 Java 线程栈。</p>
<h2 id="5-2-Java-线程栈内存的结构"><a href="#5-2-Java-线程栈内存的结构" class="headerlink" title="5.2. Java 线程栈内存的结构"></a>5.2. Java 线程栈内存的结构</h2><p>熟悉编译器的人应该知道激活记录（Activation Record）这个概念，它是一种数据结构，其中包含支持一次函数调用所需的所有信息。它包含该函数的所有局部变量，以及指向另一个激活记录的引用（或指针），其实你可以简单理解为，每多一次方法调用就多一个激活记录。而线程栈帧（Stack Frame），就是激活记录的实际实现。每在代码中多一次方法调用就多一个栈帧，但是这个说法并不严谨，比如，JIT 可能会内联一些方法，可能会跳过某些方法的调用等等。Java 线程的栈帧有哪几种呢，其实根据 Java 线程执行的方法有 Java 方法以及原生方法（Native）就能推测出有两种：</p>
<ul>
<li>Java 虚拟机栈帧（Java Virtual Machine Stack Frame）：用于保存 Java 方法的执行状态，包括局部变量表、操作数栈、方法出口等信息。</li>
<li>Native 方法栈帧（Native Method Stack Frame）：用于保存 Native 方法的执行状态，包括局部变量表、操作数栈、方法出口等信息。</li>
</ul>
<p>在最早的时候，Linux 还没有线程的概念，Java 自己做了一种叫做 <code>Green Thread</code> 的东西即用户态线程（与现在的虚拟线程设计差异很大，不是一个概念了），但是调度有诸多问题，所以在 Linux 有线程之后，Java 也舍弃了 <code>Green Thread</code>。Java 线程其实底层就是通过操作系统线程实现，是一一对应的关系。不过现在，虚拟线程也快要 release 了，但是这个并不是今天的重点。并且，在最早的时候，Java 线程栈与 Native 线程栈也是分开的，虽然可能都是一个线程执行的。后来，发现这样做对于 JIT 优化，以及线程栈大小限制，以及实现高效的 StackOverflow 检查都不利，所以就把 Java 线程栈与 Native 线程栈合并了，这样就只有一个线程栈了。</p>
<p>JVM 中对于线程栈可以使用的空间是限制死的。<strong>对于 Java 线程来说，这个限制是由 <code>-Xss</code> 或者 <code>-XX:ThreadStackSize</code> 来控制的</strong>，<code>-Xss</code> 或者 <code>-XX:ThreadStackSize</code> 基本等价， 一般来说，<code>-Xss</code> 或者 <code>-XX:ThreadStackSize</code> 是用来设置每个线程的栈大小的，但是更严谨的说法是，它是设置每个线程栈最大使用的内存大小，并且实际可用的大小由于保护页的存在还要小于这个值，并且设置这个值不能小于保护页需要的大小，否则没有意义。根据前面对于 JVM 其他区域的分析我们可以推测出，对于每个线程，都会先 <code>Reserve</code> 出 <code>-Xss</code> 或者 <code>-XX:ThreadStackSize</code> 大小的内存，之后随着线程占用内存升高而不断 <code>Commit</code> 内存。</p>
<p>同时我们还知道，对于一段 Java 代码，分为编译器执行，C1 执行，C2 执行三种情况，因此，一个 Java 线程的栈内存结构可能如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/807b265b8b80bde773182b8aa2c7ab62436f67027b0bc003dd9ed21fef8a1d46" alt></p>
<p>这个图片我们展示了一个比较极端的情况，线程先解释执行方法 1，之后调用并解释执行方法 2，然后调用一个可能比较热点的方法 3，方法 3 已经被 C1 优化编译，这里执行的是编译后的代码，之后调用可能更热点的方法 4，方法 4 已经被 C2 优化编译，这里执行的是编译后的代码。最后方法 4 还需要调用一个 native 方法 5。</p>
<h2 id="5-3-Java-线程如何抛出的-StackOverflowError"><a href="#5-3-Java-线程如何抛出的-StackOverflowError" class="headerlink" title="5.3. Java 线程如何抛出的 StackOverflowError"></a>5.3. Java 线程如何抛出的 StackOverflowError</h2><p>JVM 线程内存还有一些特殊的内存区域，结构如下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3a178f82e9e32eedbdb86d66714fdb51861c4d1a57fd4999a6532dd491f1f26c" alt></p>
<ul>
<li>保护区域（Guard Zone），保护区的内存没有映射物理内存，访问的话会像前面第三章提到的 <code>NullPointerException</code> 优化方式类似，即抛出 <code>SIGSEGV</code> 被 JVM 捕获，再抛出 <code>StackOverflowError</code>。保护区包括以下三种：<ul>
<li><strong>黄色区域</strong>（Yellow Zone）：大小由前面提到的 <code>-XX:StackYellowPages</code> 参数决定。如果栈扩展到了黄色区域，则发生 <code>SIGSEGV</code>，并且信号处理程序抛出 <code>StackOverflowError</code> 并继续执行当前线程。同时，这时候黄色页面会被映射分配内存，以提供一些额外的栈空间给异常抛出的代码使用，抛出异常结束后，黄色页面会重新去掉映射，变成保护区。</li>
<li><strong>红色区域</strong>（Red Zone）：大小由前面提到的 <code>-XX:StackRedPages</code> 参数决定。正常的代码只会可能到黄色区域，只有 JVM 出一些 bug 的时候会到红色区域，这个相当于最后一层保证。保留这个区域是为了出这种 bug 的时候，能有空间可以将错误信息写入 <code>hs_err_pid.log</code> 文件用于定位。</li>
<li><strong>保留区域</strong>（Reserved Zone）：大小由前面提到的 <code>-XX:StackReservedPages</code> 参数决定。在 Java 9 引入（<a href="https://openjdk.org/jeps/270" target="_blank" rel="noopener">JEP 270: Reserved Stack Areas for Critical Sections</a>）（洗稿狗的区域是细狗区），主要是为了解决 JDK 内部的临界区代码（例如<code>ReentrantLock</code>）导致 <code>StackOverflowError</code> 的时候保证内部数据结构不会处于不一致的状态导致锁无法释放或者被获取。如果没有这个区域，在 <code>ReentrantLock.lock()</code> 方法内部调用某个内部方法的时候可能会进入黄色区域，导致 <code>StackOverflowError</code>，这时候可能 <code>ReentrantLock</code> 内部的一些数据可能已经修改，抛出异常导致这些数据无法回滚让锁处于当初设计的时候没有设计的不一致状态。为了避免这个情况，引入保留区域。在执行临界区方法的时候（被 <code>@jdk.internal.vm.annotation.ReservedStackAccess</code> 注解修饰的方法），如果进入保留区域，那么保留区域会被映射内存，用于执行完临界区方法，执行完临界区方法之后，再抛出 <code>StackOverflowError</code>，并解除保留区域的映射。另外，前面我们提到过，<code>@jdk.internal.vm.annotation.ReservedStackAccess</code> 这个注解默认只能 jdk 内部代码使用，如果你有类似于 <code>ReentrantLock</code> 这种带有临界区的代码也想保护起来，可以设置 <code>-XX:-RestrictReservedStack</code>，关闭对于 <code>@jdk.internal.vm.annotation.ReservedStackAccess</code> 的限制，这样你就可以在自己的代码中使用这个注解了。</li>
</ul>
</li>
<li><strong>影子区域</strong>（Shadow Zone）：这个区域的大小由前面提到的 <code>-XX:StackShadowPages</code> 参数决定。影子区域只是抽象概念，跟在当前栈占用的顶部栈帧后面，随着顶部栈帧变化而变化。这个区域用于保证 Native 调用不会导致 <code>StackOverflowError</code>。<strong>在后面的分析我们会看到，每次调用方法前需要估算方法栈帧的占用大小，但是对于 Native 调用我们无法估算，所以我们就假设 Native 大小最大不会超过影子区域大小</strong>，在发生 <code>Native</code> 调用前，会查看当前栈帧位置加上影子区域大小是否会达到保留区域，如果达到了保留区域，那么会抛出 <code>StackOverflowError</code>，如果没有达到保留区域，那么会继续执行。这里我们可以看出，JVM 假设 Native 调用占用空间不会超过影子区域大小，JDK 中自带的 native 调用也确实是这样。如果你自己实现了 Native 方法并且会占用大量栈内存，那么你需要调整 <code>StackShadowPages</code>。</li>
</ul>
<p>我们看下源码中如何体现的这些区域，参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B18/src/hotspot/share/runtime/stackOverflow.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B18/src/hotspot/share/runtime/stackOverflow.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码size_t StackOverflow::_stack_red_zone_size = 0;</span><br><span class="line">size_t StackOverflow::_stack_yellow_zone_size = 0;</span><br><span class="line">size_t StackOverflow::_stack_reserved_zone_size = 0;</span><br><span class="line">size_t StackOverflow::_stack_shadow_zone_size = 0;</span><br><span class="line"></span><br><span class="line">void StackOverflow::initialize_stack_zone_sizes() &#123;</span><br><span class="line">  //读取虚拟机页大小，第二章我们分析过</span><br><span class="line">  size_t page_size = os::vm_page_size();</span><br><span class="line">  //目前各个平台最小页大小基本都是 4K</span><br><span class="line">  size_t unit = 4*K;</span><br><span class="line">  //使用 StackRedPages 乘以 4K 然后对虚拟机页大小进行对齐作为红色区域大小</span><br><span class="line">  assert(_stack_red_zone_size == 0, &quot;This should be called only once.&quot;);</span><br><span class="line">  _stack_red_zone_size = align_up(StackRedPages * unit, page_size);</span><br><span class="line">  //使用 StackYellowPages 乘以 4K 然后对虚拟机页大小进行对齐作为黄色区域大小</span><br><span class="line">  assert(_stack_yellow_zone_size == 0, &quot;This should be called only once.&quot;);</span><br><span class="line">  _stack_yellow_zone_size = align_up(StackYellowPages * unit, page_size);</span><br><span class="line">  //使用 StackReservedPages 乘以 4K 然后对虚拟机页大小进行对齐作为保留区域大小</span><br><span class="line">  assert(_stack_reserved_zone_size == 0, &quot;This should be called only once.&quot;);</span><br><span class="line">  _stack_reserved_zone_size = align_up(StackReservedPages * unit, page_size);</span><br><span class="line">  //使用 StackShadowPages 乘以 4K 然后对虚拟机页大小进行对齐作为保留区域大小</span><br><span class="line">  assert(_stack_shadow_zone_size == 0, &quot;This should be called only once.&quot;);</span><br><span class="line">  _stack_shadow_zone_size = align_up(StackShadowPages * unit, page_size);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-1-解释执行与编译执行时候的判断（x86为例）"><a href="#5-3-1-解释执行与编译执行时候的判断（x86为例）" class="headerlink" title="5.3.1. 解释执行与编译执行时候的判断（x86为例）"></a>5.3.1. 解释执行与编译执行时候的判断（x86为例）</h3><p><strong>我们继续针对 Java 线程进行讨论</strong>。在前面我们已经知道，Java 线程栈的大小是有限制的，如果线程栈使用的内存超过了限制，那么就会抛出 <code>StackOverflowError</code>。但是，JVM 如何知道什么时候该抛出呢？</p>
<p>首先，对于解释执行，一般没有任何优化，就是在调用方法前检查。不同的环境下的实现会有些差别，我们以 x86 cpu 为例：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/templateInterpreterGenerator_x86.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码void TemplateInterpreterGenerator::generate_stack_overflow_check(void) &#123;</span><br><span class="line">  //计算栈帧的一些元数据存储的消耗</span><br><span class="line">  const int entry_size = frame::interpreter_frame_monitor_size() * wordSize;</span><br><span class="line">  const int overhead_size =</span><br><span class="line">    -(frame::interpreter_frame_initial_sp_offset * wordSize) + entry_size;</span><br><span class="line">  //读取虚拟机页大小，第二章我们分析过</span><br><span class="line">  const int page_size = os::vm_page_size();</span><br><span class="line">  //比较当前要调用的方法的元素个数，判断与除去元数据以外一页能容纳的元素个数谁大谁小</span><br><span class="line">  Label after_frame_check;</span><br><span class="line">  __ cmpl(rdx, (page_size - overhead_size) / Interpreter::stackElementSize);</span><br><span class="line">  __ jcc(Assembler::belowEqual, after_frame_check);</span><br><span class="line">  //大于的才会进行后续的判断，因为小于一页的话，绝对可以被黄色区域限制住，因为黄色区域要与页大小对齐，因此至少一页</span><br><span class="line">  //小于一页的栈帧不会导致跳过黄色区域，只有大于的须有后续仔细判断</span><br><span class="line"></span><br><span class="line">  Label after_frame_check_pop;</span><br><span class="line">  //读取线程的 stack_overflow_limit_offset</span><br><span class="line">  //_stack_overflow_limit = stack_end() + MAX2(stack_guard_zone_size(), stack_shadow_zone_size());</span><br><span class="line">  //即栈尾 加上 保护区域 或者 阴影区域 的最大值，即有效栈尾地址</span><br><span class="line">  //其实就是当前线程栈容量顶部减去 保护区域 或者 阴影区域 的最大值的地址，即当前线程栈只能增长到这个地址</span><br><span class="line">  const Address stack_limit(thread, JavaThread::stack_overflow_limit_offset());</span><br><span class="line">  //将前面计算的栈帧元素个数大小保存在 rax</span><br><span class="line">  __ mov(rax, rdx);</span><br><span class="line">  //将栈帧的元素个数转换为字节大小，然后加上栈帧的元数据消耗</span><br><span class="line">  __ shlptr(rax, Interpreter::logStackElementSize); </span><br><span class="line">  __ addptr(rax, overhead_size);</span><br><span class="line"></span><br><span class="line">  //加上前面计算的有效栈尾地址</span><br><span class="line">  __ addptr(rax, stack_limit);</span><br><span class="line"></span><br><span class="line">  //与当前栈顶地址比较，如果当前栈顶地址大于 rax 当前值，证明没有溢出</span><br><span class="line">  __ cmpptr(rsp, rax);</span><br><span class="line">  __ jcc(Assembler::above, after_frame_check_pop);</span><br><span class="line"></span><br><span class="line">  //否则抛出 StackOverflowError 异常</span><br><span class="line">  __ jump(ExternalAddress(StubRoutines::throw_StackOverflowError_entry()));</span><br><span class="line">  __ bind(after_frame_check_pop);</span><br><span class="line">  __ bind(after_frame_check);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码的步骤大概是（plagiarism和洗稿是恶意抄袭他人劳动成果的行为，是对劳动价值的漠视和践踏！ ）：</p>
<ol>
<li>首先判断要分配的栈帧大小，是否大于一页。</li>
<li><strong>如果小于等于一页，不用检查，直接结束</strong>。因为如果小于一页，那么栈帧的元素个数一定小于一页，栈增长不会导致跳过保护区域，如果达到保护区域就会触发 <code>SIGSEGV</code> 抛出 <code>StackOverflowError</code>。因为每个保护区域如前面源代码所示，都是对虚拟机页大小进行对齐的，因此至少一页。</li>
<li>如果大于一页，则需要检查。检查当前已经使用的空间，加上栈帧占用的空间，加上保护区域与阴影区域的最大值，占用空间是否大于栈空间限制。如果大于，则抛出 <code>StackOverflowError</code> 异常。为什么是保护区域与阴影区域的最大值？阴影区域其实是我们假设的最大帧大小，最后至少要有这么多空间才一定不会导致溢出栈顶污染其他内存（当然，如之前所述，如果你自己实现一个 Native 调用并且栈帧很大，则需要修改阴影区域大小）。如果本身保护区域就比阴影区域大，那么就用保护区域的大小，就也能保证这一点。</li>
</ol>
<p>可以看出，编译执行，虽然做了一定的优化，但是还是很复杂，就算大部分栈帧应该都小于一页，但是刚开始的判断指令还是有不小的消耗。我们看看 JIT 编译后的代码，还是以 x86 cpu 为例：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/share/asm/assembler.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/share/asm/assembler.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码void AbstractAssembler::generate_stack_overflow_check(int frame_size_in_bytes) &#123;</span><br><span class="line">  //读取虚拟机页大小，第二章我们分析过</span><br><span class="line">  const int page_size = os::vm_page_size();</span><br><span class="line">  //读取影子区大小</span><br><span class="line">  int bang_end = (int)StackOverflow::stack_shadow_zone_size();</span><br><span class="line">  </span><br><span class="line">  //如果栈帧大小大于一页，那么需要将 bang_end 加上栈帧大小，之后检查每一页是否处于保护区域</span><br><span class="line">  const int bang_end_safe = bang_end;</span><br><span class="line">  if (frame_size_in_bytes &gt; page_size) &#123;</span><br><span class="line">    bang_end += frame_size_in_bytes;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  //检查每一页是否处于保护区域</span><br><span class="line">  int bang_offset = bang_end_safe;</span><br><span class="line">  while (bang_offset &lt;= bang_end) &#123;</span><br><span class="line">    bang_stack_with_offset(bang_offset);</span><br><span class="line">    bang_offset += page_size;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/macroAssembler_x86.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/cpu/x86/macroAssembler_x86.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码//检查是否处于保留区域，其实就是将 rsp - offset 的地址上的值写入 rax 上，</span><br><span class="line">//如果 rsp - offset 保护区域，那么就会触发 SIGSEGV</span><br><span class="line">void bang_stack_with_offset(int offset) &#123;</span><br><span class="line">    movl(Address(rsp, (-offset)), rax);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后执行的指令就简单多了：</p>
<ol>
<li>如果栈帧大小小于一页：只需要考虑 Native 调用是否会导致 <code>StackOverflow</code> 即可。检查当前占用位置加上影子区域大小，之后判断是否会进入保护区域即可，不用考虑当前方法栈帧占用大小，因为肯定小于一页。验证是否进入保护区域也和之前讨论过的 <code>NullPointeException</code> 的处理是类似的，就是将 rsp - offset 的地址上的值写入 rax 上，如果 rsp - offset 处于保护区域，那么就会触发 <code>SIGSEGV</code>。</li>
<li>如果栈帧大小大于一页：那么需要将当前占用位置，加上栈帧大小，加上影子区域大小，之后从当前栈帧按页检查，是否处于保护区域。因为大于一页的话，直接验证最后的位置可能会溢出到其他东西占用的内存（比如其他线程占用的内存）。</li>
</ol>
<h3 id="5-3-2-一个-Java-线程-Xss-最小能指定多大"><a href="#5-3-2-一个-Java-线程-Xss-最小能指定多大" class="headerlink" title="5.3.2. 一个 Java 线程 Xss 最小能指定多大"></a>5.3.2. 一个 Java 线程 Xss 最小能指定多大</h3><p>这个和平台是相关的，我们以 linux x86 为例子，假设没有大页分配，一页就是 4K，一个线程至少要保留如下的空间：</p>
<ul>
<li>保护区域：<ul>
<li>黄色区域：默认 2 页</li>
<li>红色区域：默认 1 页</li>
<li>保留区域：默认 1 页</li>
</ul>
</li>
<li>影子区域：默认 20 页</li>
</ul>
<p>这些加在一起是 24 页，也就是 96K。</p>
<p>同时，在 JVM 代码中也限制了，除了这些空间，每种线程的最小大小：</p>
<p><a href="https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B19/src/hotspot/os_cpu/linux_x86/os_linux_x86.cpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cpp复制代码size_t os::_compiler_thread_min_stack_allowed = 48 * K;</span><br><span class="line">size_t os::_java_thread_min_stack_allowed = 40 * K;</span><br><span class="line">size_t os::_vm_internal_thread_min_stack_allowed = 64 * K;</span><br></pre></td></tr></table></figure>

<p>所以，对于 Java 线程，至少需要 <code>40 + 96 = 136K</code> 的空间。我们试一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vbnet复制代码bash-4.2$ java -Xss1k</span><br><span class="line">The Java thread stack size specified is too small. Specify at least 136k</span><br><span class="line">Error: Could not create the Java Virtual Machine.</span><br><span class="line">Error: A fatal exception has occurred. Program will exit.</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879724546113573" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 12元空间各种监控手段</title>
    <url>/7225879731177013303.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><h1 id="JVM-元空间设计"><a href="#JVM-元空间设计" class="headerlink" title="JVM 元空间设计"></a>JVM 元空间设计</h1></li>
</ol>
<h2 id="4-6-jcmd-VM-metaspace-元空间说明、元空间相关-JVM-日志以及元空间-JFR-事件详解"><a href="#4-6-jcmd-VM-metaspace-元空间说明、元空间相关-JVM-日志以及元空间-JFR-事件详解" class="headerlink" title="4.6. jcmd VM.metaspace 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解"></a>4.6. <code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解</h2><h3 id="4-6-1-jcmd-lt-pid-gt-VM-metaspace-元空间说明"><a href="#4-6-1-jcmd-lt-pid-gt-VM-metaspace-元空间说明" class="headerlink" title="4.6.1. jcmd &lt;pid&gt; VM.metaspace 元空间说明"></a>4.6.1. <code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</h3><p>通过 <code>jcmd &lt;pid&gt; VM.metaspace</code> 命令可以查看对应 JVM 进程的元空间当前的详细使用情况，返回内容是：</p>
<p><strong>1.元空间从 <code>MetaChunk</code> 角度的使用统计信息</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码Total Usage - 1383 loaders, 33006 classes (1361 shared):</span><br><span class="line">  Non-Class: 7964 chunks,    150.83 MB capacity,  150.77 MB (&gt;99%) committed,   150.21 MB (&gt;99%) used,   562.77 KB ( &lt;1%) free,     6.65 KB ( &lt;1%) waste , deallocated: 869 blocks with 249.52 KB</span><br><span class="line">  Class: 2546 chunks,     21.00 MB capacity,   20.93 MB (&gt;99%) committed,    20.21 MB ( 96%) used,   741.42 KB (  3%) free,   216 bytes ( &lt;1%) waste , deallocated: 1057 blocks with 264.88 KB</span><br><span class="line">  Both: 10510 chunks,   171.83 MB capacity,  171.70 MB (&gt;99%) committed,   170.42 MB (&gt;99%) used,     1.27 MB ( &lt;1%) free,     6.86 KB ( &lt;1%) waste , deallocated: 1926 blocks with 514.41 KB</span><br></pre></td></tr></table></figure>

<p>意思是：</p>
<ol>
<li>一共 1383 个类加载器，加载了 33006 个类（其中 1361 个是共享类）。</li>
<li>capacity 是指 <code>MetaChunk</code> 的总容量大小（<code>Reserved</code> 内存）；committed 是指这些 <code>MetaChunk</code> 中 <code>committed</code> 的内存大小，也就是实际占用系统物理内存是这么大（虽然可能会有点细微差异，参考本篇文章的第二章）；used 是指这些 <code>MetaChunk</code> 实际使用的大小，肯定比 <code>committed</code> 的要小；free 是指剩余的大小；committed = used + free + waste；deallocated 是指回收到 <code>FreeBlocks</code> 的大小，属于 free 的一部分，另一部分就是 <code>MetaChunk</code> 中 <code>committed</code> 但是还没使用的部分；waste 是指浪费的大小（前面我们提到了什么造成的浪费，主要是搜索 <code>FreeBlocks</code> 的空间使用的时候，可能正好剩下 1 字节，就不放回了继续使用了）洗稿的狗也遇到不少</li>
<li>数据元空间使用情况：一共使用了 7964 个 <code>MetaChunk</code>，这些 <code>MetaChunk</code> 相关总容量大小是 <code>150.83 MB</code>，目前 <code>commit</code> 了 <code>150.77 MB</code>，使用了 <code>150.21 MB</code>，剩余 <code>562.77 KB</code> 可以使用，<code>6.65 KB</code> 的空间被浪费了。<code>FreeBlocks</code> 目前回收了 <code>869</code> 块内存，一共 <code>249.52 KB</code>。</li>
<li>类元空间使用情况：一共使用了 2546 个 <code>MetaChunk</code>，总容量大小是 <code>21.00 MB</code>，目前 <code>commit</code> 了 <code>20.93 MB</code>，使用了 <code>20.21 MB</code>，剩余 <code>741.42 KB</code> 可以使用，<code>216 bytes</code> 的空间被浪费了。<code>FreeBlocks</code> 目前回收了 <code>1057</code> 块内存，一共 <code>264.88 KB</code>。</li>
<li>总的元空间使用情况（类元空间 + 数据元空间的）：一共使用了 10510 个 <code>MetaChunk</code>，总容量大小是 <code>171.83 MB</code>，目前 <code>commit</code> 了 <code>171.70 MB</code>，使用了 <code>170.42 MB</code>，剩余 <code>1.27 MB</code> 可以使用，<code>6.86 KB</code> 的空间被浪费了。<code>FreeBlocks</code> 目前回收了 <code>1926</code> 块内存，一共 <code>514.41 KB</code>。</li>
</ol>
<p>前面的是从 <code>MetaChunk</code> 的角度去查看，另一个角度是从 <code>VirtualSpaceList</code> 去查看，接下来的信息就是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kotlin复制代码Virtual space:</span><br><span class="line">  Non-class space:      152.00 MB reserved,     150.81 MB (&gt;99%) committed,  19 nodes.</span><br><span class="line">      Class space:        1.00 GB reserved,      20.94 MB (  2%) committed,  1 nodes.</span><br><span class="line">             Both:        1.15 GB reserved,     171.75 MB ( 15%) committed.</span><br></pre></td></tr></table></figure>

<p>意思是：</p>
<ol>
<li>数据元空间的 <code>VirtualSpaceList</code>：总共 <code>Reserve</code> 了 <code>152.00 MB</code>，目前 <code>Commit</code> 了 <code>150.81 MB</code>，一共有 <code>19</code> 个 <code>VirtualSpaceNode</code>。这个与 <code>MetaChunk</code> 的统计信息是有差异的，<code>VirtualSpaceList</code> 的统计信息更体现元空间实际占用的，从 <code>MetaChunk</code> 角度统计的时候，将每个 <code>MetaChunk</code> 统计信息相加，会有精度损失。</li>
<li>类元空间的 <code>VirtualSpaceList</code>：总共 <code>Reserve</code> 了 <code>1.00 GB</code>，目前 <code>Commit</code> 了 <code>20.94 MB</code>，一共有 <code>1</code> 个 <code>VirtualSpaceNode</code>。</li>
<li>总的元空间的 <code>VirtualSpaceList</code>：总共 <code>Reserve</code> 了 <code>1.15 GB</code>，目前 <code>Commit</code> 了 <code>171.75 MB</code>。不要偷取他人的劳动成果，也不要浪费自己的时间和精力，让我们一起做一个有良知的写作者。</li>
</ol>
<p>接下来是每个 <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 的统计信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码Chunk freelists:</span><br><span class="line">   Non-Class:</span><br><span class="line"></span><br><span class="line">  4m: (none)</span><br><span class="line">  2m: (none)</span><br><span class="line">  1m:    2, capacity=2.00 MB, committed=0 bytes (  0%)</span><br><span class="line">512k: (none)</span><br><span class="line">256k: (none)</span><br><span class="line">128k:    2, capacity=256.00 KB, committed=0 bytes (  0%)</span><br><span class="line"> 64k: (none)</span><br><span class="line"> 32k:    2, capacity=64.00 KB, committed=0 bytes (  0%)</span><br><span class="line"> 16k: (none)</span><br><span class="line">  8k:    2, capacity=16.00 KB, committed=0 bytes (  0%)</span><br><span class="line">  4k:    2, capacity=8.00 KB, committed=0 bytes (  0%)</span><br><span class="line">  2k: (none)</span><br><span class="line">  1k:    2, capacity=2.00 KB, committed=0 bytes (  0%)</span><br><span class="line">Total word size: 2.34 MB, committed: 0 bytes (  0%)</span><br><span class="line"></span><br><span class="line">       Class:</span><br><span class="line"></span><br><span class="line">  4m: (none)</span><br><span class="line">  2m:    1, capacity=2.00 MB, committed=0 bytes (  0%)</span><br><span class="line">  1m:    1, capacity=1.00 MB, committed=0 bytes (  0%)</span><br><span class="line">512k: (none)</span><br><span class="line">256k: (none)</span><br><span class="line">128k: (none)</span><br><span class="line"> 64k: (none)</span><br><span class="line"> 32k: (none)</span><br><span class="line"> 16k: (none)</span><br><span class="line">  8k: (none)</span><br><span class="line">  4k:    1, capacity=4.00 KB, committed=0 bytes (  0%)</span><br><span class="line">  2k: (none)</span><br><span class="line">  1k: (none)</span><br><span class="line">Total word size: 3.00 MB, committed: 0 bytes (  0%)</span><br><span class="line"></span><br><span class="line">        Both:</span><br><span class="line"></span><br><span class="line">  4m: (none)</span><br><span class="line">  2m:    1, capacity=2.00 MB, committed=0 bytes (  0%)</span><br><span class="line">  1m:    3, capacity=3.00 MB, committed=0 bytes (  0%)</span><br><span class="line">512k: (none)</span><br><span class="line">256k: (none)</span><br><span class="line">128k:    2, capacity=256.00 KB, committed=0 bytes (  0%)</span><br><span class="line"> 64k: (none)</span><br><span class="line"> 32k:    2, capacity=64.00 KB, committed=0 bytes (  0%)</span><br><span class="line"> 16k: (none)</span><br><span class="line">  8k:    2, capacity=16.00 KB, committed=0 bytes (  0%)</span><br><span class="line">  4k:    3, capacity=12.00 KB, committed=0 bytes (  0%)</span><br><span class="line">  2k: (none)</span><br><span class="line">  1k:    2, capacity=2.00 KB, committed=0 bytes (  0%)</span><br><span class="line">Total word size: 5.34 MB, committed: 0 bytes (  0%)</span><br></pre></td></tr></table></figure>

<p>以上的信息可能用图片更直接一些：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/554fb41b328c9e8308e63fe58ca17858d93d9bd424c256e985fa69468cc5e382" alt></p>
<p>接下来是关于回收利用的从 <code>MetaChunk</code> 的角度去查看一些统计信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">erlang复制代码Waste (unused committed space):(percentages refer to total committed size 171.75 MB):</span><br><span class="line">        Waste in chunks in use:      6.86 KB ( &lt;1%)</span><br><span class="line">        Free in chunks in use:      1.27 MB ( &lt;1%)</span><br><span class="line">                In free chunks:      0 bytes (  0%)</span><br><span class="line">Deallocated from chunks in use:    514.41 KB ( &lt;1%) (1926 blocks)</span><br><span class="line">                       -total-:      1.78 MB (  1%)</span><br><span class="line"></span><br><span class="line">chunk header pool: 10520 items, 748.30 KB.</span><br></pre></td></tr></table></figure>

<p>包含的信息是：</p>
<ol>
<li>当前被使用的 <code>MetaChunk</code>（即存在于每个类加载器对应的 <code>MetaspaceArena</code> 中的 <code>MetaChunk</code>）中有 <code>6.86 KB</code> 的空间被浪费了。当前被使用的 <code>MetaChunk</code>（即存在于每个类加载器对应的 <code>MetaspaceArena</code> 中的 <code>MetaChunk</code>）中剩余 <code>1.27 MB</code> 可以使用。在 <code>FreeChunkListVector</code> 中没有浪费的空间，其实从前面的 <code>FreeChunkListVector</code> 的详细信息就能看出来。</li>
<li><code>FreeBlocks</code> 目前回收了 <code>1926</code> 块内存，一共 <code>514.41 KB</code>。<code>FreeBlocks</code> 里面有 <code>1926</code> 个 <code>FreeBlock</code>，一共 <code>514.41 KB</code>。</li>
<li><code>ChunkHeaderPool</code> 目前有 <code>10520</code> 个 <code>ChunkHeader</code>，一共占用 <code>748.30 KB</code>。</li>
</ol>
<p>然后是一些统计信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码Internal statistics:</span><br><span class="line"></span><br><span class="line">num_allocs_failed_limit: 24.</span><br><span class="line">num_arena_births: 2768.</span><br><span class="line">num_arena_deaths: 2.</span><br><span class="line">num_vsnodes_births: 20.</span><br><span class="line">num_vsnodes_deaths: 0.</span><br><span class="line">num_space_committed: 2746.</span><br><span class="line">num_space_uncommitted: 0.</span><br><span class="line">num_chunks_returned_to_freelist: 28.</span><br><span class="line">num_chunks_taken_from_freelist: 10515.</span><br><span class="line">num_chunk_merges: 9.</span><br><span class="line">num_chunk_splits: 6610.</span><br><span class="line">num_chunks_enlarged: 4139.</span><br><span class="line">num_purges: 2.</span><br><span class="line">num_inconsistent_stats: 0.</span><br></pre></td></tr></table></figure>

<p>包含的信息是：</p>
<ol>
<li><code>num_allocs_failed_limit</code>：元空间普通分批内存失败的次数（前文分析过详细流程），后面也有对应的 JFR 事件会分析。</li>
<li><code>num_arena_births</code>：<code>MetaspaceArena</code> 的创建次数。</li>
<li><code>num_arena_deaths</code>：<code>MetaspaceArena</code> 的销毁次数。发生于对应的类加载器被回收之后。</li>
<li><code>num_vsnodes_births</code>：<code>VirtualSpaceNode</code> 的创建次数。（根据前面的 <code>VirtualSpaceList</code> 的统计信息可以知道是 19 + 1 = 20）</li>
<li><code>num_vsnodes_deaths</code>：<code>VirtualSpaceNode</code> 的销毁次数。</li>
<li><code>num_space_committed</code>：<code>Commit</code> 内存的次数。</li>
<li><code>num_space_uncommitted</code>：<code>Uncommit</code> 内存的次数。</li>
<li><code>num_chunks_returned_to_freelist</code>：<code>MetaChunk</code> 被回收到 <code>FreeChunkListVector</code> 的次数。</li>
<li><code>num_chunks_taken_from_freelist</code>：从 <code>FreeChunkListVector</code> 中获取 <code>MetaChunk</code> 进行分配的次数。</li>
<li><code>num_chunk_merges</code>：<code>MetaChunk</code> 合并的次数。</li>
<li><code>num_chunk_splits</code>：<code>MetaChunk</code> 拆分的次数。</li>
<li><code>num_chunks_enlarged</code>：<code>MetaChunk</code> 扩容的次数。</li>
<li><code>num_purges</code>：<code>MetaspaceArena</code> 的清理次数。一般等于销毁次数。</li>
<li><code>num_inconsistent_stats</code>：不一致的统计次数。这个一般不用关心，主要是为了调试用的。</li>
</ol>
<p>最后是一些参数信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码Settings:</span><br><span class="line">MaxMetaspaceSize: unlimited</span><br><span class="line">CompressedClassSpaceSize: 1.00 GB</span><br><span class="line">Initial GC threshold: 40.00 MB</span><br><span class="line">Current GC threshold: 210.12 MB</span><br><span class="line">CDS: on</span><br><span class="line">MetaspaceReclaimPolicy: balanced</span><br><span class="line"> - commit_granule_bytes: 65536.</span><br><span class="line"> - commit_granule_words: 8192.</span><br><span class="line"> - virtual_space_node_default_size: 1048576.</span><br><span class="line"> - enlarge_chunks_in_place: 1.</span><br><span class="line"> - new_chunks_are_fully_committed: 0.</span><br><span class="line"> - uncommit_free_chunks: 1.</span><br><span class="line"> - use_allocation_guard: 0.</span><br><span class="line"> - handle_deallocations: 1.</span><br></pre></td></tr></table></figure>

<ol>
<li><code>MaxMetaspaceSize</code>：元空间最大值。默认是无限制的。这里我们也没限制。</li>
<li><code>CompressedClassSpaceSize</code>：压缩类空间大小。默认是 1 GB。这里我们也没指定，所以是默认的。</li>
<li><code>Initial GC threshold</code>：初始的元空间 GC 阈值。默认是 40 MB。这里我们也没指定，所以是默认的。</li>
<li><code>Current GC threshold</code>：当前的元空间 GC 阈值。前面我们分析过这个阈值改变的机制。</li>
<li><code>CDS</code>：是否开启了 CDS。默认开启。这个我们不用太关心，主要和 CDS 特性相关（<a href="https://openjdk.org/jeps/310" target="_blank" rel="noopener">JEP 310: Application Class-Data Sharing</a> 和 <a href="https://openjdk.org/jeps/350" target="_blank" rel="noopener">JEP 350: Dynamic CDS Archives</a>），在以后的文章会详细分析。</li>
<li>元空间 <code>MetaspaceReclaimPolicy</code> 为 <code>balanced</code></li>
<li>commit 粒度（<code>commit_granule_bytes</code>）为 65536 字节，转化单位为字之后，是 8192 字（一 word 为 8 字节）。虚拟内存空间节点内存大小（<code>virtual_space_node_default_size</code>）为 1048576 字，转化单位为字之后，是 64 MB。当前 MetaChunk 不足以分配的时候，是否尝试扩容当前 <code>MetaChunk</code>（<code>enlarge_chunks_in_place</code>）为是，新分配的 <code>MetaChunk</code> 是否一次性全部 commit（<code>new_chunks_are_fully_committed</code>）为否，是否在 <code>MetaChunk</code> 释放的时候 uncommit（<code>uncommit_free_chunks</code>）为是。以上配置都在前文分析过。最后两个配置都是 debug 配置，正式版里面都是无法修改的，我们也不用太关心这两个配置的效果，并且 <code>handle_deallocations</code> 已经在 Java 18 中移除了（<a href="https://github.com/openjdk/jdk/commit/157e1d5073e221dab084422389f68eea53974f4c" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/commit/157e1d5073e221dab084422389f68eea53974f4c</code></a>）</li>
</ol>
<h3 id="4-6-2-元空间相关-JVM-日志"><a href="#4-6-2-元空间相关-JVM-日志" class="headerlink" title="4.6.2. 元空间相关 JVM 日志"></a>4.6.2. 元空间相关 JVM 日志</h3><p>我们通过启动参数 <code>-Xlog:metaspace*=debug::utctime,level,tags</code>，查看元空间相关 JVM 日志。</p>
<p>首先，初始化 JVM 元空间的时候，会输出元空间基本参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码[2023-04-11T09:07:31.994+0000][info][metaspace] Initialized with strategy: balanced reclaim.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - commit_granule_bytes: 65536.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - commit_granule_words: 8192.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - virtual_space_node_default_size: 1048576.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - enlarge_chunks_in_place: 1.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - new_chunks_are_fully_committed: 0.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - uncommit_free_chunks: 1.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - use_allocation_guard: 0.</span><br><span class="line">[2023-04-11T09:07:31.994+0000][info][metaspace]  - handle_deallocations: 1.</span><br></pre></td></tr></table></figure>

<p>以上这几行日志的意思是：元空间 <code>MetaspaceReclaimPolicy</code> 为 <code>balanced</code>，commit 粒度（<code>commit_granule_bytes</code>）为 65536 字节，转化单位为字之后，是 8192 字（一 word 为 8 字节）。虚拟内存空间节点内存大小（<code>virtual_space_node_default_size</code>）为 1048576 字，转化单位为字之后，是 64 MB。当前 MetaChunk 不足以分配的时候，是否尝试扩容当前 <code>MetaChunk</code>（<code>enlarge_chunks_in_place</code>）为是，新分配的 <code>MetaChunk</code> 是否一次性全部 commit（<code>new_chunks_are_fully_committed</code>）为否，是否在 <code>MetaChunk</code> 释放的时候 uncommit（<code>uncommit_free_chunks</code>）为是。以上配置都在前文分析过。最后两个配置都是 debug 配置，正式版里面都是无法修改的，我们也不用太关心这两个配置的效果，并且 <code>handle_deallocations</code> 已经在 Java 18 中移除了（<a href="https://github.com/openjdk/jdk/commit/157e1d5073e221dab084422389f68eea53974f4c" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/commit/157e1d5073e221dab084422389f68eea53974f4c</code></a>）</p>
<p>接下来，初始化元空间的内存空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less复制代码[2023-04-11T09:07:32.411+0000][info ][gc,metaspace] CDS archive(s) mapped at: [0x0000000800000000-0x0000000800bde000-0x0000000800bde000), size 12443648, SharedBaseAddress: 0x0000000800000000, ArchiveRelocationMode: 0.[2023-04-11T09:07:32.411+0000][info ][gc,metaspace] Compressed class space mapped at: 0x0000000800c00000-0x0000000840c00000, reserved size: 1073741824</span><br><span class="line">[2023-04-11T09:07:32.411+0000][info ][gc,metaspace] Narrow klass base: 0x0000000800000000, Narrow klass shift: 0, Narrow klass range: 0x100000000</span><br><span class="line">[2023-04-11T09:07:32.417+0000][debug][metaspace   ] Arena @0x0000ffff807a1cc0 (non-class sm): : born.</span><br><span class="line">[2023-04-11T09:07:32.417+0000][debug][metaspace   ] Arena @0x0000ffff807a1dd0 (class sm): : born.</span><br><span class="line">[2023-04-11T09:07:32.417+0000][debug][metaspace   ] CLMS @0x0000ffff807a1c80 : born (nonclass arena: 0x0000ffff807a1cc0, class arena: 0x0000ffff807a1dd0.</span><br><span class="line">[2023-04-11T09:07:32.411+0000][debug][metaspace   ] VsListNode @0x0000ffff80784ab0 base 0x0000000800c00000 : born (word_size 134217728).</span><br><span class="line">[2023-04-11T09:07:32.417+0000][debug][metaspace   ] VsListNode @0x0000ffff807a27b0 base 0x0000ffff52800000 : born (word_size 1048576).</span><br></pre></td></tr></table></figure>

<p>这几行日志的意思是：</p>
<ol>
<li>CDS 元数据映射到内存的地址范围是 <code>[0x0000000800000000-0x0000000800bde000-0x0000000800bde000)</code>，大小为 12443648 字节，共享基地址为 <code>0x0000000800000000</code>，<code>ArchiveRelocationMode</code> 为关闭。这些信息我们不用太关心，主要和 CDS 特性相关（<a href="https://openjdk.org/jeps/310" target="_blank" rel="noopener">JEP 310: Application Class-Data Sharing</a> 和 <a href="https://openjdk.org/jeps/350" target="_blank" rel="noopener">JEP 350: Dynamic CDS Archives</a>），在以后的文章会详细分析。</li>
<li>我们这里是默认配置，所以压缩类空间是开启的，初始化压缩类空间，映射到内存的地址范围是 <code>[0x0000000800c00000-0x0000000840c00000)</code>，Reserved 内存大小为 1073741824 字节（1GB），默认压缩类空间最大大小就是 1GB。加载到压缩类空间的类的基地址为 <code>0x0000000800000000</code>（），偏移量为 0，范围为 <code>0x100000000</code>，这个前面也简单分析过。</li>
<li><code>Bootstrap ClassLoader</code> 创建了两个 <code>MetaspaceArena</code>，分别是前文分析的类元空间的 <code>MetaspaceArena</code> 和数据元空间的 <code>MetaspaceArena</code>，放入对应的 <code>ClassLoadMetaSpace</code> 中。不要偷取他人的劳动成果，也不要浪费自己的时间和精力，让我们一起做一个有良知的写作者。</li>
<li>初始化类元空间的还有数据元空间的 <code>VirtualSpaceList</code>，并分别创建并放入各自的第一个 <code>VirtualSpaceNode</code></li>
</ol>
<p>接下来开始加载类，从元空间申请内存进行分配：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码[2023-04-11T09:07:32.411+0000][debug][metaspace] ChkMgr @0x0000ffff807863d0 (class-space): requested chunk: pref_level: lv12, max_level: lv12, min committed size: 0.</span><br><span class="line">[2023-04-11T09:07:32.411+0000][debug][metaspace] VsListNode @0x0000ffff80784ab0 base 0x0000000800c00000 : new root chunk @0x0000ffff807867f0, f, base 0x0000000800c00000, level lv00.</span><br><span class="line">[2023-04-11T09:07:32.411+0000][debug][metaspace] ChkMgr @0x0000ffff807863d0 (class-space): allocated new root chunk.</span><br><span class="line">[2023-04-11T09:07:32.411+0000][debug][metaspace] ChkMgr @0x0000ffff807863d0 (class-space): splitting chunk @0x0000ffff807867f0, f, base 0x0000000800c00000, level lv00 to lv12.</span><br><span class="line">[2023-04-11T09:07:32.411+0000][debug][metaspace] ChkMgr @0x0000ffff807863d0 (class-space): handing out chunk @0x0000ffff807867f0, u, base 0x0000000800c00000, level lv12.</span><br></pre></td></tr></table></figure>

<p>这几行日志的意思分别是：</p>
<ol>
<li>加载类需要从元空间申请内存，这是第一次申请，所以各个数据结构都是空的，所以需要申请新的 <code>MetaChunk</code>，优先考虑的与最大的 <code>ChunkLevel</code> 都是 <code>12</code>，对应 1KB。本次申请发生在 <code>ChunkManager @0x0000ffff807863d0</code></li>
<li>申请新的 <code>RootMetaChunk</code>，基址 <code>0x0000000800c00000</code></li>
<li>将新的 <code>RootMetaChunk</code> 按照之前的算法拆分到 <code>ChunkLevel</code> 为 <code>12</code>，结果是 <code>MetaChunk @0x0000ffff807867f0</code>，将拆出来的其他 <code>MetaChunk</code> 放入 <code>ChunkManager @0x0000ffff807863d0</code> 的 <code>FreeListVector</code> 中</li>
</ol>
<h3 id="4-6-3-元空间-JFR-事件详解"><a href="#4-6-3-元空间-JFR-事件详解" class="headerlink" title="4.6.3. 元空间 JFR 事件详解"></a>4.6.3. 元空间 JFR 事件详解</h3><h4 id="4-6-3-1-jdk-MetaspaceSummary-元空间定时统计事件"><a href="#4-6-3-1-jdk-MetaspaceSummary-元空间定时统计事件" class="headerlink" title="4.6.3.1. jdk.MetaspaceSummary 元空间定时统计事件"></a>4.6.3.1. <code>jdk.MetaspaceSummary</code> 元空间定时统计事件</h4><p>元空间定时统计事件 <code>jdk.MetaspaceSummary</code>，包括以下属性：</p>
<ul>
<li>事件开始时间：其实就是事件发生时间</li>
<li>GC Identifier：全局 GC 的 id 标识</li>
<li>When：事件发生的时机，包括 <code>Before GC</code> 和 <code>After GC</code> 两种，分别是 GC 前和 GC 后的统计数据，可以根据 GC Identifier 对比 GC 前后的数据，看看 GC 之后元空间的使用情况.plagiarism和洗稿是恶意抄袭他人劳动成果的行为，是对劳动价值的漠视和践踏！</li>
<li>GC Threshold：GC 阈值，即前面提的 <code>_capacity_until_GC</code></li>
<li>Class:Reserved：类元空间 Reserved 的内存空间大小</li>
<li>Class:Committed：类元空间 Committed 的内存空间大小</li>
<li>Class:Used：类元空间实际保存数据使用的内存空间大小（前面的机制分析中我们会看到，Committed 的空间会比实际使用的大，主要因为类加载器回收，以及可能 <code>MetaChunk</code> 分配的时候 commit 所有内存）</li>
<li>Data:Reserved：数据元空间 Reserved 的内存空间大小</li>
<li>Data:Committed：数据元空间 Committed 的内存空间大小</li>
<li>Data:Used：数据元空间实际保存数据使用的内存空间大小</li>
<li>Total:Reserved：整个元空间 Reserved 的内存空间大小（其实就是类元空间 + 数据元空间）</li>
<li>Total:Committed：整个元空间 Committed 的内存空间大小（其实就是类元空间 + 数据元空间）</li>
<li>Total:Used：整个元空间实际保存数据使用的内存空间大小（其实就是类元空间 + 数据元空间）</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9c77546d7f64a1756b674ad049bd1a5b18322a7e1def19ba393dba8345b353ba" alt></p>
<h4 id="4-6-3-2-jdk-MetaspaceAllocationFailure-元空间分配失败事件"><a href="#4-6-3-2-jdk-MetaspaceAllocationFailure-元空间分配失败事件" class="headerlink" title="4.6.3.2. jdk.MetaspaceAllocationFailure 元空间分配失败事件"></a>4.6.3.2. <code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</h4><p>前面提到过，如果普通分配失败，那么会触发 <code>jdk.MetaspaceAllocationFailure</code> 这个 JFR 事件，大家可以监控这个事件，去调整元空间大小减少由于元空间不足触发的 GC，这个事件包括以下属性：</p>
<ul>
<li>事件开始时间：其实就是事件发生时间</li>
<li>类加载器：触发 OOM 的类加载器</li>
<li>Hidden Class Loader：是否是隐藏类加载器</li>
<li>Metadata Type：元数据类型，分为属于类元空间的以及属于数据元空间的两种类型，分别是：<code>Class</code> 和 <code>Metadata</code></li>
<li>Metaspace Object Type：元空间对象类型，包括 <code>Class</code>、<code>ConstantPool</code>、<code>Symbol</code>、<code>Method</code>、<code>Klass</code>、<code>Module</code>、<code>Package</code>、<code>Other</code></li>
<li>Size：本次分配的大小</li>
</ul>
<p>这个事件也会采集堆栈信息，用来定位分配失败的源头是哪些类的加载导致的。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/25c73a85d320cfd52c39984b165bfb6364aa6a0b545cfc4977ae191754a9d496" alt></p>
<h4 id="4-6-3-3-jdk-MetaspaceOOM-元空间-OOM-事件"><a href="#4-6-3-3-jdk-MetaspaceOOM-元空间-OOM-事件" class="headerlink" title="4.6.3.3. jdk.MetaspaceOOM 元空间 OOM 事件"></a>4.6.3.3. <code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</h4><p>前面提到过，当元空间 OOM 的时候，就会产生这个事件，这个事件包括以下属性（和 <code>jdk.MetaspaceAllocationFailure</code> 事件一样）：</p>
<ul>
<li>事件开始时间：其实就是事件发生时间</li>
<li>类加载器：触发 OOM 的类加载器</li>
<li>Hidden Class Loader：是否是隐藏类加载器</li>
<li>Metadata Type：元数据类型，分为属于类元空间的以及属于数据元空间的两种类型，分别是：<code>Class</code> 和 <code>Metadata</code></li>
<li>Metaspace Object Type：元空间对象类型，包括 <code>Class</code>、<code>ConstantPool</code>、<code>Symbol</code>、<code>Method</code>、<code>Klass</code>、<code>Module</code>、<code>Package</code>、<code>Other</code></li>
<li>Size：本次分配的大小</li>
</ul>
<p>与 <code>jdk.MetaspaceAllocationFailure</code> 事件一样，也会采集堆栈信息，用来定位 OOM 的原因。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c4c6d8d776260eb18285919fbb5dc1d02c0617903478dbe3e0682e3e9f25a6a7" alt></p>
<h4 id="4-6-3-4-jdk-MetaspaceGCThreshold-元空间-GC-阈值变化事件"><a href="#4-6-3-4-jdk-MetaspaceGCThreshold-元空间-GC-阈值变化事件" class="headerlink" title="4.6.3.4. jdk.MetaspaceGCThreshold 元空间 GC 阈值变化事件"></a>4.6.3.4. <code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</h4><p>前面我们说过，元空间的 GC 阈值（<code>_capacity_until_GC</code>）是动态调整的，这个事件就是用来记录元空间 GC 阈值变化的。这个事件包括以下属性：</p>
<ul>
<li>事件开始时间：其实就是事件发生时间</li>
<li>New Value：新的 GC 阈值</li>
<li>Old Value：旧的 GC 阈值</li>
<li>Updater：哪个机制触发的 GC 阈值修改，我们之前讨论过 <code>_capacity_until_GC</code> 有两个场景会修改：<ul>
<li>分配过程中，达到 GC 阈值，触发 GC，但是处于 GCLocker 处于锁定禁止 GC，就尝试增大 <code>_capacity_until_GC</code> 进行分配。对应的 <code>Updater</code> 是 <code>expand_and_allocate</code></li>
<li>每次 GC 之后，触发重新计算 <code>_capacity_until_GC</code>，如果有更新，就会生成这个事件，对应的 <code>Updater</code> 是 <code>compute_new_size</code></li>
</ul>
</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d59dc7f79ac8dea8e0a665061160bca4cb9ffd06f091ecb92df854861fd2f866" alt></p>
<h4 id="4-6-3-5-jdk-MetaspaceChunkFreeListSummary-元空间-Chunk-FreeList-统计事件"><a href="#4-6-3-5-jdk-MetaspaceChunkFreeListSummary-元空间-Chunk-FreeList-统计事件" class="headerlink" title="4.6.3.5. jdk.MetaspaceChunkFreeListSummary 元空间 Chunk FreeList 统计事件"></a>4.6.3.5. <code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</h4><p>这个事件在 Java 16 引入 JEP 387: Elastic Metaspace 弹性元空间的设计之后，里面的统计数据就都是 0 了，还没有实现，参考：<a href="https://bugs.openjdk.org/browse/JDK-8251342" target="_blank" rel="noopener"><code>https://bugs.openjdk.org/browse/JDK-8251342</code></a>，所以我们先不用关心。参考源码：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/share/memory/metaspaceUtils.hpp" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B17/src/hotspot/share/memory/metaspaceUtils.hpp</code></a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码// (See JDK-8251342). Implement or Consolidate.</span><br><span class="line">static MetaspaceChunkFreeListSummary chunk_free_list_summary(Metaspace::MetadataType mdtype) &#123;</span><br><span class="line">    return MetaspaceChunkFreeListSummary(0,0,0,0,0,0,0,0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/047d0c2740f989d133cf94e643fe1529b54ec6ba75a9cd8bd7eae34c2fbe1225" alt></p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879731177013303" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 9元空间内存分配流程 4</title>
    <url>/7225879724545900581.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><h1 id="JVM-元空间设计"><a href="#JVM-元空间设计" class="headerlink" title="JVM 元空间设计"></a>JVM 元空间设计</h1></li>
</ol>
<h2 id="4-3-元空间的核心概念与设计"><a href="#4-3-元空间的核心概念与设计" class="headerlink" title="4.3. 元空间的核心概念与设计"></a>4.3. 元空间的核心概念与设计</h2><h3 id="4-3-9-元空间内存分配流程"><a href="#4-3-9-元空间内存分配流程" class="headerlink" title="4.3.9. 元空间内存分配流程"></a>4.3.9. 元空间内存分配流程</h3><p>我们过一下元空间内存分配流程，我们会忽略一些 GC 相关的还有并发安全的细节，否则涉及的概念太多，一下说不过来，这些细节，会在以后的系列中详细提到。</p>
<h4 id="4-3-9-1-类加载器到-MetaSpaceArena-的流程"><a href="#4-3-9-1-类加载器到-MetaSpaceArena-的流程" class="headerlink" title="4.3.9.1. 类加载器到 MetaSpaceArena 的流程"></a>4.3.9.1. 类加载器到 <code>MetaSpaceArena</code> 的流程</h4><p>当类加载器加载类的时候，需要从对应的 <code>ClassLoaderMetaspace</code> 分配元空间进行存储。这个过程大概是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f22a0c30f7709da3e4da888b8fdcd69650784078ea28a89270257cbd94cd4917" alt="image"></p>
<p>图中有蓝色填充的方块是我们要重点分析的流程，我们先从从 MetaChunkArena 普通分配开始分析，尝试 GC 以及扩容元空间用于分配会涉及到元空间大小限制以及 GC 界限的概念，我们后面分析。这里对应的源码是：<a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace.cpp#L899" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace.cpp#L899</code></a></p>
<p>整个流程如下：</p>
<ol>
<li>首先，验证要分配的内存小于最大 <code>MetaChunk</code> 大小，即 <code>RootMetaChunk</code> 大小，即 <code>ChunkLevel</code> = 0 的大小，即 <code>4MB</code></li>
<li>然后，走普通分配流程，判断当前分配的数据类型是类元空间的还是数据元空间的，分别到类元空间的 <code>MetaSpaceArena</code> 或者数据源空间 <code>MetaSpaceArena</code> 进行分配。这是下一节我们要详细分析的。</li>
<li>如果普通分配失败，那么会触发 <code>jdk.MetaspaceAllocationFailure</code> 这个 JFR 事件，大家可以监控这个事件，去调整元空间大小减少由于元空间不足触发的 GC。触发之后，抄袭狗死全家</li>
<li>之后，尝试 GC，以及增大元空间的 GC 界限（元空间有最大大小限制，但是还有动态计算的 GC 界限，超过 GC 界限的话，第二步的普通分配也会失败）用于分配。这个流程我们后面会详细分析</li>
<li>最后，如果这样还是分配失败，那么就会抛出大名鼎鼎的 <code>java.lang.OutOfMemoryError</code>, 触发 <code>jdk.MetaspaceOOM</code> 这个 JFR 事件，这个我们也会详细分析。</li>
</ol>
<p>我们先分析第二步的普通分配流程，其他的需要后续我们分析元空间大小限制的时候详细分析。</p>
<h4 id="4-3-9-2-从-MetaChunkArena-普通分配-整体流程"><a href="#4-3-9-2-从-MetaChunkArena-普通分配-整体流程" class="headerlink" title="4.3.9.2. 从 MetaChunkArena 普通分配 - 整体流程"></a>4.3.9.2. 从 <code>MetaChunkArena</code> 普通分配 - 整体流程</h4><p>从 <code>MetaChunkArena</code> 普通分配的流程并不太复杂：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bc7cf827ca9243ecb9e3cf86fd0dc742e63033cb0c8df5888246f828839d3863" alt="image"></p>
<p>我们前面讲过 <code>MetaspaceArena</code> 的结构，如下所示：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/080c90470878b78905211af77d8d33e37b4c69ed905fcc8d29786513db308eba" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArena.cpp#L222" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArena.cpp#L222</code></a>，结合流程图，我们可以整理出一个简单的分配思路：</p>
<ol>
<li>首先，尝试从 <code>FreeBlocks</code> 中分配（第一次分配，肯定 <code>FreeBlocks</code> 里面没有可以分配的，直接进入下一分支），如果分配成功，直接返回</li>
<li>然后，尝试从 <code>current chunk</code> 分配（第一次分配肯定 <code>current chunk</code> 为 <code>NULL</code>，直接进入下一分支）：<ol>
<li><code>current chunk</code> 如果有足够的空间，并且这些空间是 committed 的或者可以 commit 成功，那么从 <code>current chunk</code> 分配。</li>
<li><code>current chunk</code> 如果没有足够的空间，尝试 <code>current chunk</code> 扩容，如果扩容成功，并且这些空间是 committed 的或者可以 commit 成功，那么从 <code>current chunk</code> 分配。</li>
<li>如果扩容失败，或者 commit 失败，直接进入下一分支</li>
</ol>
</li>
<li>前面分配失败，尝试从 <code>ChunkManager</code> 中申请一个新的 <code>MetaChunk</code>。</li>
<li>如果申请成功，则加入当前的 <code>MetaChunkList</code> 中，将 <code>current chunk</code> 指向新的 <code>MetaChunk</code>，老的 <code>current chunk</code> 的剩余空间回收到 <code>FreeBlocks</code> 中，然后从新的 <code>current chunk</code> 分配。</li>
</ol>
<p>我们接下来分析 <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</p>
<h4 id="4-3-9-3-从-MetaChunkArena-普通分配-FreeBlocks-回收老的-current-chunk-与用于后续分配的流程"><a href="#4-3-9-3-从-MetaChunkArena-普通分配-FreeBlocks-回收老的-current-chunk-与用于后续分配的流程" class="headerlink" title="4.3.9.3. 从 MetaChunkArena 普通分配 - FreeBlocks 回收老的 current chunk 与用于后续分配的流程"></a>4.3.9.3. 从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</h4><p>首先我们前面提到过：<code>Freeblocks</code> 包含一个 <code>BinList32</code> 和一个 <code>BlockTree</code>。大小大于 33 字节的进入 <code>BlockTree</code>，否则进入 <code>BinList32</code>。</p>
<p><code>BinList32</code> 类似于 <code>FreeChunkListVector</code>，是一个链表的数组，同样大小的内存在同一数组下标的链表。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c6a7ebb1d52d8cf0602c12b85fe44dc4e4801238884d320fcc9a7aaf45886622" alt="image"></p>
<p><code>BlockTree</code> 是一个在 <strong>Binary Search Tree</strong>（BST）的基础上，同样内存的节点在二叉树节点的后面形成链表的数据结构。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/64a13e923b53a5e82dbb5dc16af94d119e7560450d822c4650db77e7ed4ad21c" alt="image"></p>
<p>回收的流程十分简单，就是判断下 <code>current chunk</code> 的剩余空间，根据大小放到不同的数据结构：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/db1133a1142eb23703d6fc99dddea987959bb1fb05a50ac25b30cd0a02648480" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArena.cpp#L60" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArena.cpp#L60</code></a>：</p>
<ol>
<li>计算 <code>MetaChunk</code> 剩余的 <code>committed</code> 的空间（很简单，直接用 <code>committed</code> 的位置减去已分配到的位置）</li>
<li>判断剩余空间是否大于 <code>FreeBlocks</code> 最小内存块大小（即 <code>BinList32</code> 最小大小即 <code>2KB</code>）：对待抄袭狗不必手软</li>
<li>从 <code>MetaChunk</code> 分配剩余的 <code>committed</code> 的空间，放入 <code>FreeBlocks</code> 中</li>
<li>内存大于 <code>BinList32</code> 最大内存块大小即 <code>33KB</code>，放入 <code>BlockTree</code>，否则放入 <code>BinList32</code></li>
</ol>
<h4 id="4-3-9-4-从-MetaChunkArena-普通分配-尝试从-FreeBlocks-分配"><a href="#4-3-9-4-从-MetaChunkArena-普通分配-尝试从-FreeBlocks-分配" class="headerlink" title="4.3.9.4. 从 MetaChunkArena 普通分配 - 尝试从 FreeBlocks 分配"></a>4.3.9.4. 从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</h4><p>尝试从 <code>FreeBlocks</code> 分配即从其中的 <code>BinList32</code> 和 <code>BlockTree</code> 寻找是否有合适的内存，流程是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/907cfcac1b6b1fd932477eb95a34b9d0eec9f0e02f602f33c84e32fe6fe03da8" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/freeBlocks.cpp#L42" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/freeBlocks.cpp#L42</code></a></p>
<ol>
<li>首先判断，要分配的内存大小是否大于 <code>BinList32</code> 最大内存块大小即 <code>33KB</code>：如果大于，就从 <code>BlockTree</code> 查找不小于内存大小的最接近的内存块；如果不大于，就从 <code>BinList32</code> 查找是否有对应大小的内存块。</li>
<li>如果找到了，计算 <code>waste</code>，<code>waste = 内存块大小 - 要分配的内存大小</code>。</li>
<li>判断 <code>waste</code> 大于 <code>FreeBlocks</code> 最小内存块大小（即 <code>BinList32</code> 最小大小即 <code>2KB</code>）。如果大于，则要回收，和前面回收 <code>MetaChunk</code> 的流程一样将剩余的内存放回 <code>FreeBlocks</code>。</li>
</ol>
<h4 id="4-3-9-5-从-MetaChunkArena-普通分配-尝试扩容-current-chunk"><a href="#4-3-9-5-从-MetaChunkArena-普通分配-尝试扩容-current-chunk" class="headerlink" title="4.3.9.5. 从 MetaChunkArena 普通分配 - 尝试扩容 current chunk"></a>4.3.9.5. 从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></h4><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ad73a2106cb4bb21cb693bc9d91b6005846654f2f747ee9f4eb21199e7b83c96" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArena.cpp#L171" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/metaspaceArena.cpp#L171</code></a></p>
<ol>
<li><code>enlarge_chunks_in_place</code> 是否是 <code>true</code>，不是的话直接结束，不过前面我们说过，目前 <code>JVM</code> 是代码里写死的 <code>true</code></li>
<li>判断是否 <code>current chunk</code> 已经是 <code>RootMetaChunk</code>（代表已经不能扩容了），如果是，直接结束</li>
<li><code>current chunk</code> 已使用大小加上要分配的内存大小是否大于 <code>RootMetaChunk</code> 的大小即 <code>4MB</code>（代表已经不能扩容了），如果是，直接结束</li>
<li>找到大于 <code>current chunk</code> 已使用大小，加上要分配的内存大小的最接近的 <code>ChunkLevel</code> （记为 <code>new_level</code>）</li>
<li>判断 <code>new_level</code> 是否小于 <code>current chunk</code> 的 <code>ChunkLevel</code> 减 1，代表要扩容到的大小大于原始大小的 2 倍以上(不允许一下子扩容两倍以上)，如果是，直接结束</li>
<li><code>current chunk</code> 是否是 <code>leader</code>（这个概念后面分析到使用 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> 会提到），只有 <code>leader</code> 可以扩容，如果不是，直接结束（xigao 必死）</li>
<li>判断扩容策略中申请下一个 <code>MetaChunk</code> 的 <code>ChunkLevel</code> 是否大于 <code>current chunk</code> 的（代表新申请的比当前的小），如果是，也直接结束。我们这里强调下为啥扩容策略（<code>ArenaGrowthPolicy</code>）中申请下一个 <code>MetaChunk</code> 的 <code>ChunkLevel</code> 大于 <code>current chunk</code>（代表新申请的比当前的小）的话，我们就不扩容了。前面我们列出了各种类型的 <code>ClassLoader</code> 的不同空间的扩容策略，例如<code>DelegatingClassLoader</code> 的 <code>ClassLoaderMetaspace</code> 数据元空间的 <code>MetaspaceArena</code> 的 <code>ArenaGrowthPolicy</code>：<code>MetachunkList</code> 的第一个 <code>MetaChunk</code> 大小为 <code>2K</code>，之后每个新 <code>MetaChunk</code> 都是 <code>1K</code>。假设 <code>current chunk</code> 是第一个，这里下一个 <code>MetaChunk</code> 的 <code>ChunkLevel</code> 是 <code>1K</code> 对应的 <code>ChunkLevel</code>，大于 <code>current chunk</code> 当前的 <code>ChunkLevel</code>，所以优先申请新的，而不是扩容。之后到第二个之后，由于之后每个新的 <code>MetaChunk</code> 都是 <code>1K</code>，就会尝试扩容而不是申请新的了。</li>
<li>使用 <code>ChunkManager</code> 尝试扩容 <code>current chunk</code> 到 <code>new_level</code>。具体扩容流程，后面会分析。</li>
</ol>
<h4 id="4-3-9-6-从-MetaChunkArena-普通分配-从-ChunkManager-分配新的-MetaChunk"><a href="#4-3-9-6-从-MetaChunkArena-普通分配-从-ChunkManager-分配新的-MetaChunk" class="headerlink" title="4.3.9.6. 从 MetaChunkArena 普通分配 - 从 ChunkManager 分配新的 MetaChunk"></a>4.3.9.6. 从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></h4><p>回顾下 <code>ChunkManager</code> 结构：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/db0b778407ef40e352b6f01634def429c2bc3133df6afcd04609db53fbb01758" alt="image"></p>
<p>从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code>，首先会从 <code>FreeChunkListVector</code> 尝试搜索有没有合适的。<code>FreeChunkListVector</code> 如我们之前所述，是一个以 <code>ChunkLevel</code> 为下标的数组，每个数组都是一个 <code>MetaChunk</code> 的链表。<code>commit</code> 多的 <code>MetaChunk</code> 放在链表开头，完全没有 <code>commit</code> 的放在链表末尾。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/212bea8b0b2e3c829676936970389ad4c79d652a81e1cb483aae88e215adc713" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/chunkManager.cpp#L137" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B12/src/hotspot/share/memory/metaspace/chunkManager.cpp#L137</code></a></p>
<ol>
<li>计算两个值：<code>max_level = 大于当前申请内存大小最接近的 ChunkLevel （即新的 MetaChunk 最小多大）</code>, <code>preferred_level = &quot;根据扩容策略（ArenaGrowthPolicy）下一个 MetaChunk 多大&quot; 与 &quot;max_level&quot; 中小的那个值（也就是更大的 MetaChunk 大小）</code></li>
<li>优先搜索并使用 <code>FreeChunkListVector</code> 中那些已经 <code>commit</code> 足够内存的 <code>MetaChunk</code></li>
<li>正序遍历（即 <code>ChunkLevel</code> 从小到大，大小从大到小） <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 里面的数组 (从 <code>preferred_level</code> 到 <code>max_level</code> 与 <code>preferred_level</code> + 2 中比较小的值，即最多搜索 3 个 <code>ChunkLevel</code>，根据前面的分析我们知道 <code>ChunkLevel</code> 就是数组下标)，寻找对应的 <code>MetaChunk</code> 链表，正序遍历每个链表（我们前面提到过，<code>commit</code> 多的 <code>MetaChunk</code> 放在开头），直到找到 <code>commit</code> 大小大于申请内存大小的（chaoxi 死的更惨）</li>
<li>逆序遍历（即 <code>ChunkLevel</code> 从大到小，大小从小到大） <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 里面的数组 (从 <code>preferred_level</code> 到最大的 <code>ChunkLevel</code>，即 <code>RootMetaChunk</code> 的大小，即 4MB)，寻找对应的 <code>MetaChunk</code> 链表，正序遍历每个链表（我们前面提到过，<code>commit</code> 多的 <code>MetaChunk</code> 放在开头），直到找到 <code>commit</code> 大小大于申请内存大小的</li>
<li>正序遍历（即 <code>ChunkLevel</code> 从小到大，大小从大到小） <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 里面的数组 (从 <code>preferred_level</code> 到 <code>max_level</code>)，寻找对应的 <code>MetaChunk</code> 链表，正序遍历每个链表（我们前面提到过，<code>commit</code> 多的 <code>MetaChunk</code> 放在开头），直到找到 <code>commit</code> 大小大于申请内存大小的</li>
<li>如果搜索不到已经 <code>commit</code> 足够内存的 <code>MetaChunk</code>，就退而求其次，寻找 <code>FreeChunkListVector</code> 存在的 <code>MetaChunk</code></li>
<li>正序遍历（即 <code>ChunkLevel</code> 从小到大，大小从大到小） <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 里面的数组 (从 <code>preferred_level</code> 到 <code>max_level</code>)，寻找对应的 <code>MetaChunk</code> 链表，正序遍历每个链表，直到找到一个 <code>MetaChunk</code></li>
<li>逆序遍历（即 <code>ChunkLevel</code> 从大到小，大小从小到大） <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 里面的数组 (从 <code>preferred_level</code> 到最大的 <code>ChunkLevel</code>，即 <code>RootMetaChunk</code> 的大小，即 4MB)，寻找对应的 <code>MetaChunk</code> 链表，正序遍历每个链表，直到找到一个 <code>MetaChunk</code></li>
<li>如果前面没有找到合适的，从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>将 <code>RootMetahChunk</code> 分割成需要的 <code>ChunkLevel</code> 大小，之后将分割剩余的放入 <code>FreeChunkListVector</code>，这个过程我们接下来会详细分析</li>
<li>判断 <code>new_chunks_are_fully_committed</code> 是否为 <code>true</code>，如果为 <code>true</code> 则 <code>commit</code> 整个 <code>MetaChunk</code> 的所有内存，否则 <code>commit</code> 要分配的大小。如果 <code>commit</code> 失败了（证明可能到达元空间 GC 界限或者元空间大小上限），那么将 <code>MetaChunk</code> 退回。</li>
</ol>
<h4 id="4-3-9-7-从-MetaChunkArena-普通分配-从-ChunkManager-分配新的-MetaChunk-从-VirtualSpaceList-申请新的-RootMetaChunk"><a href="#4-3-9-7-从-MetaChunkArena-普通分配-从-ChunkManager-分配新的-MetaChunk-从-VirtualSpaceList-申请新的-RootMetaChunk" class="headerlink" title="4.3.9.7. 从 MetaChunkArena 普通分配 - 从 ChunkManager 分配新的 MetaChunk - 从 VirtualSpaceList 申请新的 RootMetaChunk"></a>4.3.9.7. 从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></h4><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/93c1c238fcb0b0e852315d9397bf65542f86dc8f325f9ff03938129a4ff80eaf" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21+13/src/hotspot/share/memory/metaspace/virtualSpaceList.cpp#L110" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21+13/src/hotspot/share/memory/metaspace/virtualSpaceList.cpp#L110</code></a></p>
<ol>
<li>首先判断当前 <code>_first_node</code> 是否有空间分配新的 <code>RootMetaChunk</code>，如果有则从 <code>_first_node</code> 上面分配新的 <code>RootMetaChunk</code></li>
<li>如果没有，判断是否可以扩展新的 <code>VirtualSpaceNode</code>（类元空间不可以，数据元空间可以），如果可以则申请 <code>Reserve</code> 新的 <code>VirtualSpaceNode</code> 作为新的 <code>_first_node</code>，之后从 <code>_first_node</code> 上面分配新的 <code>RootMetaChunk</code></li>
</ol>
<h4 id="4-3-9-8-从-MetaChunkArena-普通分配-从-ChunkManager-分配新的-MetaChunk-将-RootMetaChunk-切割成为需要的-MetaChunk"><a href="#4-3-9-8-从-MetaChunkArena-普通分配-从-ChunkManager-分配新的-MetaChunk-将-RootMetaChunk-切割成为需要的-MetaChunk" class="headerlink" title="4.3.9.8. 从 MetaChunkArena 普通分配 - 从 ChunkManager 分配新的 MetaChunk - 将 RootMetaChunk 切割成为需要的 MetaChunk"></a>4.3.9.8. 从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></h4><p>这里的流程如果用流程图容易把人绕晕，我们这里举一个例子，比如我们想要一个 <code>ChunkLevel</code> 为 3 的 <code>MetaChunk</code>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d484f07e2c7cecc3fc332f4c47c4c69588634863a3cf96f943bc91151eb9672b" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B13/src/hotspot/share/memory/metaspace/chunkManager.cpp#L78" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B13/src/hotspot/share/memory/metaspace/chunkManager.cpp#L78</code></a></p>
<p>将 <code>RootMetaChunk</code> 切割成 <code>ChunkLevel</code> 为 3 的 <code>MetaChunk</code> 的流程：</p>
<ol>
<li><code>RootMetaChunk</code> 的 <code>ChunkLevel</code> 为 0，对半分成两个 <code>ChunkLevel</code> 为 1 的，第一个为 <code>leader</code>，第二个为 <code>follower</code>。</li>
<li>将上一步的 <code>leader</code> 对半成两个 <code>ChunkLevel</code> 为 2 的，第一个为 <code>leader</code>，第二个为 <code>follower</code>。</li>
<li>将上一步的 <code>leader</code> 对半成两个 <code>ChunkLevel</code> 为 3 的，第一个为 <code>leader</code>，第二个为 <code>follower</code>。</li>
<li>将第三步的 <code>leader</code> 返回，用于分配。将第一、二、三步生成的 <code>follower</code> 放入 <code>FreeChunkListVector</code> 用于前面 <strong>4.3.9.6</strong> 章节分析的 <code>ChunkManager</code> 先从 <code>FreeChunkListVector</code> 搜索合适的 <code>MetaChunk</code> 分配。</li>
</ol>
<h4 id="4-3-9-9-MetaChunk-回收-不同情况下，-MetaChunk-如何放入-FreeChunkListVector"><a href="#4-3-9-9-MetaChunk-回收-不同情况下，-MetaChunk-如何放入-FreeChunkListVector" class="headerlink" title="4.3.9.9. MetaChunk 回收 - 不同情况下， MetaChunk 如何放入 FreeChunkListVector"></a>4.3.9.9. <code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></h4><p>我们前面主要分析的是分配，那么 <code>MetaChunk</code> 如何回收呢？从前面的流程我们很容易推测出来，其实就是放回 <code>FreeChunkListVector</code>。放回的流程如果用流程图容易把人绕晕，我们还是举例子区分不同情况。其实核心思路就是，放回的时候，尽量将 <code>MetaChunk</code> 向上合并之后放回：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9a7a9235193bf17ca624f7386d9c3692c7d6a001c0a3d3c009bbeafc1fd064e9" alt="image"></p>
<p>对应的源码是 <a href="https://github.com/openjdk/jdk/blob/jdk-21%2B13/src/hotspot/share/memory/metaspace/chunkManager.cpp#L255" target="_blank" rel="noopener"><code>https://github.com/openjdk/jdk/blob/jdk-21%2B13/src/hotspot/share/memory/metaspace/chunkManager.cpp#L255</code></a></p>
<p>这里我们有两个例子：</p>
<ol>
<li>我们有一个 <code>ChunkLevel</code> 为 3 的 <code>MetaChunk</code> 要回收，但是它不是 <code>leader</code>，不能向上合并。只有 <code>leader</code> 才会尝试向上合并。这里直接放入 <code>FreeChunkListVector</code>。</li>
<li>我们又有一个 <code>ChunkLevel</code> 为 3 的 <code>MetaChunk</code> 要回收，它是 <code>leader</code>。它会尝试向上合并。查看它的 <code>follower</code> 是否是 <code>Free</code> 的。如果是 <code>Free</code> 的，他肯定首先在 <code>ChunkManager</code> 的 <code>FreeChunkListVector</code> 中， 从 <code>FreeChunkListVector</code> 取出，与这个 <code>leader</code> 合并为一个新的 <code>ChunkLevel</code> 为 2。之后，它还是 <code>leader</code>，尝试继续合并，但是它的 <code>follower</code> 不是空闲的，就不能继续合并了。在这里停止，放入 <code>FreeChunkListVector</code>。</li>
</ol>
<h3 id="4-3-10-ClassLoaderData-回收"><a href="#4-3-10-ClassLoaderData-回收" class="headerlink" title="4.3.10. ClassLoaderData 回收"></a>4.3.10. <code>ClassLoaderData</code> 回收</h3><p>在 GC 判断一个类加载器可以回收（该类加载器加载的类没有任何对象，该类加载器的对象也没有任何强引用指向它）的时候，不会立刻回收 <code>ClassLoaderData</code>，而是对应的 <code>ClassLoaderData</code> 的 <code>is_alive()</code> 就会返回 <code>false</code>。JVM 会定期遍历 <code>ClassLoaderDataGraph</code> 遍历每个 <code>ClassLoaderData</code> 判断 <code>is_alive()</code> 是否是 <code>false</code>，如果是的话会放入待回收的链表中。之后在不同 GC 的不同阶段，遍历这个链表将 <code>ClassLoaderData</code> 回收掉。</p>
<p><code>ClassLoaderData</code> 被回收的过程如下所示：</p>
<p>`<img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f7556c4caafb48c113e8b8b625bcfba507a540a63a2cd905d5e1bc0033095fcd" alt="image"></p>
<p><code>ClassLoaderData</code> 会记录所有加载的类与相关的数据（前文提到的 <code>Klass</code> 等等对象），所以它的析构函数中会将这些加载的数据的内存全部释放到它独有的 <code>MetaSpaceArena</code> 的 <code>FreeBlocks</code> 中，这些内存就是通过之前我们分析的流程分配的，由于之前的空间都是从 <code>MetaspaceArena</code> 的 <code>MetaChunkList</code> 中的 <code>MetaChunk</code> 分配的，这样的话这些 <code>MetaChunk</code> 的空间也都不再占用了。当然，也会把前面提到的 <code>ClassLoaderData</code> 独有的数据结构释放掉，还没有利用的 <code>MetaWord</code> 放回 <code>ChunkManager</code> 中。然后，清除掉它私有的 <code>ClassLoadMetaSpace</code>。根据前文分析我们知道 <code>ClassLoaderMetaspace</code> 在开启压缩类空间的情况下包括一个类元空间的 <code>MetaspaceArena</code> 和一个数据元空间的 <code>MetaspaceArena</code>。这两个 <code>MetaspaceArena</code> 分别要清理掉。<code>MetaspaceArena</code> 的析构函数会把 <code>FreeBlocks</code> 中的每个 <code>MetaWord</code> 都放回 <code>ChunkManager</code>，注意这里包含之前 <code>ClassLoaderData</code> 放回的加载类相关数据占用的空间，最后清理掉 <code>FreeBlocks</code>。（你洗稿的样子真丑。）</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879724545900581" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 JVM 内存解析 - 11元空间分配与回收流程</title>
    <url>/7225879724546015269.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~<br>另外，本文为了避免抄袭，会在不影响阅读的情况下，在文章的随机位置放入对于抄袭和洗稿的人的“亲切”的问候。如果是正常读者看到，笔者在这里说声对不起，。如果被抄袭狗或者洗稿狗看到了，希望你能够好好反思，不要再抄袭了，谢谢。<br>今天又是干货满满的一天，这是全网最硬核 JVM 解析系列第四篇，往期精彩：</p>
<ul>
<li><a href="https://dev.newban.cn/6925217498723778568">全网最硬核 TLAB 解析</a></li>
<li><a href="https://dev.newban.cn/7051386828913377316">全网最硬核 Java 随机数解析</a></li>
<li><a href="https://dev.newban.cn/7080869319407566879">全网最硬核 Java 新内存模型解析</a></li>
</ul>
</blockquote>
<blockquote>
<p>本篇是关于 JVM 内存的详细分析。网上有很多关于 JVM 内存结构的分析以及图片，但是由于不是一手的资料亦或是人云亦云导致有很错误，造成了很多误解；并且，这里可能最容易混淆的是一边是 JVM Specification 的定义，一边是 Hotspot JVM 的实际实现，有时候人们一些部分说的是 JVM Specification，一部分说的是 Hotspot 实现，给人一种割裂感与误解。本篇主要从 Hotspot 实现出发，以 Linux x86 环境为主，紧密贴合 JVM 源码并且辅以各种 JVM 工具验证帮助大家理解 JVM 内存的结构。但是，本篇仅限于对于这些内存的用途，使用限制，相关参数的分析，有些地方可能比较深入，有些地方可能需要结合本身用这块内存涉及的 JVM 模块去说，会放在另一系列文章详细描述。最后，洗稿抄袭狗不得 house</p>
</blockquote>
<p>本篇全篇目录（以及涉及的 JVM 参数）：</p>
<ol>
<li>从 Native Memory Tracking 说起（<a href="https://dev.newban.cn/7225871227743043644">全网最硬核 JVM 内存解析 - 1.从 Native Memory Tracking 说起</a>开始）<ol>
<li>Native Memory Tracking 的开启</li>
<li>Native Memory Tracking 的使用（涉及 JVM 参数：<code>NativeMemoryTracking</code>）</li>
<li>Native Memory Tracking 的 summary 信息每部分含义</li>
<li>Native Memory Tracking 的 summary 信息的持续监控</li>
<li>为何 Native Memory Tracking 中申请的内存分为 reserved 和 committed</li>
</ol>
</li>
<li>JVM 内存申请与使用流程（<a href="https://dev.newban.cn/7225875600644407357">全网最硬核 JVM 内存解析 - 2.JVM 内存申请与使用流程</a>开始）<ol>
<li>Linux 下内存管理模型简述</li>
<li>JVM commit 的内存与实际占用内存的差异<ol>
<li>JVM commit 的内存与实际占用内存的差异</li>
</ol>
</li>
<li>大页分配 UseLargePages（<a href="https://dev.newban.cn/7225875600644489277">全网最硬核 JVM 内存解析 - 3.大页分配 UseLargePages</a>开始）<ol>
<li>Linux 大页分配方式 - Huge Translation Lookaside Buffer Page (hugetlbfs)</li>
<li>Linux 大页分配方式 - Transparent Huge Pages (THP)</li>
<li>JVM 大页分配相关参数与机制（涉及 JVM 参数：<code>UseLargePages</code>,<code>UseHugeTLBFS</code>,<code>UseSHM</code>,<code>UseTransparentHugePages</code>,<code>LargePageSizeInBytes</code>）</li>
</ol>
</li>
</ol>
</li>
<li>Java 堆内存相关设计（<a href="https://dev.newban.cn/7225874698906615864">全网最硬核 JVM 内存解析 - 4.Java 堆内存大小的确认</a>开始）<ol>
<li>通用初始化与扩展流程</li>
<li>直接指定三个指标的方式（涉及 JVM 参数：<code>MaxHeapSize</code>,<code>MinHeapSize</code>,<code>InitialHeapSize</code>,<code>Xmx</code>,<code>Xms</code>）</li>
<li>不手动指定三个指标的情况下，这三个指标(MinHeapSize,MaxHeapSize,InitialHeapSize)是如何计算的</li>
<li>压缩对象指针相关机制（涉及 JVM 参数：<code>UseCompressedOops</code>）（<a href="https://dev.newban.cn/7225874698906714168">全网最硬核 JVM 内存解析 - 5.压缩对象指针相关机制</a>开始）<ol>
<li>压缩对象指针存在的意义（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>）</li>
<li>压缩对象指针与压缩类指针的关系演进（涉及 JVM 参数：<code>UseCompressedOops</code>,<code>UseCompressedClassPointers</code>）</li>
<li>压缩对象指针的不同模式与寻址优化机制（涉及 JVM 参数：<code>ObjectAlignmentInBytes</code>,<code>HeapBaseMinAddress</code>）</li>
</ol>
</li>
<li>为何预留第 0 页，压缩对象指针 null 判断擦除的实现（涉及 JVM 参数：<code>HeapBaseMinAddress</code>）</li>
<li>结合压缩对象指针与前面提到的堆内存限制的初始化的关系（涉及 JVM 参数：<code>HeapBaseMinAddress</code>,<code>ObjectAlignmentInBytes</code>,<code>MinHeapSize</code>,<code>MaxHeapSize</code>,<code>InitialHeapSize</code>）</li>
<li>使用 jol + jhsdb + JVM 日志查看压缩对象指针与 Java 堆验证我们前面的结论<ol>
<li>验证 <code>32-bit</code> 压缩指针模式</li>
<li>验证 <code>Zero based</code> 压缩指针模式</li>
<li>验证 <code>Non-zero disjoint</code> 压缩指针模式</li>
<li>验证 <code>Non-zero based</code> 压缩指针模式</li>
</ol>
</li>
<li>堆大小的动态伸缩（涉及 JVM 参数：<code>MinHeapFreeRatio</code>,<code>MaxHeapFreeRatio</code>,<code>MinHeapDeltaBytes</code>）（<a href="https://dev.newban.cn/7225879698952470588">全网最硬核 JVM 内存解析 - 6.其他 Java 堆内存相关的特殊机制</a>开始）</li>
<li>适用于长期运行并且尽量将所有可用内存被堆使用的 JVM 参数 AggressiveHeap</li>
<li>JVM 参数 AlwaysPreTouch 的作用</li>
<li>JVM 参数 UseContainerSupport - JVM 如何感知到容器内存限制</li>
<li>JVM 参数 SoftMaxHeapSize - 用于平滑迁移更耗内存的 GC 使用</li>
</ol>
</li>
<li>JVM 元空间设计（<a href="https://dev.newban.cn/7225879698952486972">全网最硬核 JVM 内存解析 - 7.元空间存储的元数据</a>开始）<ol>
<li>什么是元数据，为什么需要元数据</li>
<li>什么时候用到元空间，元空间保存什么</li>
<li>2.1. 什么时候用到元空间，以及释放时机</li>
<li>2.2. 元空间保存什么</li>
<li>元空间的核心概念与设计（<a href="https://dev.newban.cn/7225879724545835045">全网最硬核 JVM 内存解析 - 8.元空间的核心概念与设计</a>开始）<ol>
<li>元空间的整体配置以及相关参数（涉及 JVM 参数：<code>MetaspaceSize</code>,<code>MaxMetaspaceSize</code>,<code>MinMetaspaceExpansion</code>,<code>MaxMetaspaceExpansion</code>,<code>MaxMetaspaceFreeRatio</code>,<code>MinMetaspaceFreeRatio</code>,<code>UseCompressedClassPointers</code>,<code>CompressedClassSpaceSize</code>,<code>CompressedClassSpaceBaseAddress</code>,<code>MetaspaceReclaimPolicy</code>）</li>
<li>元空间上下文 <code>MetaspaceContext</code></li>
<li>虚拟内存空间节点列表 <code>VirtualSpaceList</code></li>
<li>虚拟内存空间节点 <code>VirtualSpaceNode</code> 与 <code>CompressedClassSpaceSize</code></li>
<li><code>MetaChunk</code><ol>
<li><code>ChunkHeaderPool</code> 池化 <code>MetaChunk</code> 对象</li>
<li><code>ChunkManager</code> 管理空闲的 <code>MetaChunk</code></li>
</ol>
</li>
<li>类加载的入口 <code>SystemDictionary</code> 与保留所有 <code>ClassLoaderData</code> 的 <code>ClassLoaderDataGraph</code></li>
<li>每个类加载器私有的 <code>ClassLoaderData</code> 以及 <code>ClassLoaderMetaspace</code></li>
<li>管理正在使用的 <code>MetaChunk</code> 的 <code>MetaspaceArena</code></li>
<li>元空间内存分配流程（<a href="https://dev.newban.cn/7225879724545900581">全网最硬核 JVM 内存解析 - 9.元空间内存分配流程</a>开始）<ol>
<li>类加载器到 <code>MetaSpaceArena</code> 的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 整体流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - <code>FreeBlocks</code> 回收老的 <code>current chunk</code> 与用于后续分配的流程</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试从 <code>FreeBlocks</code> 分配</li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 尝试扩容 <code>current chunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 从 <code>VirtualSpaceList</code> 申请新的 <code>RootMetaChunk</code></li>
<li>从 <code>MetaChunkArena</code> 普通分配 - 从 <code>ChunkManager</code> 分配新的 <code>MetaChunk</code> - 将 <code>RootMetaChunk</code> 切割成为需要的 <code>MetaChunk</code></li>
<li><code>MetaChunk</code> 回收 - 不同情况下， <code>MetaChunk</code> 如何放入 <code>FreeChunkListVector</code></li>
</ol>
</li>
<li><code>ClassLoaderData</code> 回收</li>
</ol>
</li>
<li>元空间分配与回收流程举例（<a href="https://dev.newban.cn/7225879698952634428">全网最硬核 JVM 内存解析 - 10.元空间分配与回收流程举例</a>开始）<ol>
<li>首先类加载器 1 需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 还需要分配 1023 字节大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 264 KB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 2 MB 大小的内存，属于类空间</li>
<li>然后类加载器 1 需要分配 128KB 大小的内存，属于类空间</li>
<li>新来一个类加载器 2，需要分配 1023 Bytes 大小的内存，属于类空间</li>
<li>然后类加载器 1 被 GC 回收掉</li>
<li>然后类加载器 2 需要分配 1 MB 大小的内存，属于类空间</li>
</ol>
</li>
<li>元空间大小限制与动态伸缩（<a href="https://dev.newban.cn/7225879724546015269">全网最硬核 JVM 内存解析 - 11.元空间分配与回收流程举例</a>开始）<ol>
<li><code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</li>
<li>每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li><code>jcmd VM.metaspace</code> 元空间说明、元空间相关 JVM 日志以及元空间 JFR 事件详解（<a href="https://dev.newban.cn/7225879731177013303">全网最硬核 JVM 内存解析 - 12.元空间各种监控手段</a>开始）<ol>
<li><code>jcmd &lt;pid&gt; VM.metaspace</code> 元空间说明</li>
<li>元空间相关 JVM 日志</li>
<li>元空间 JFR 事件详解<ol>
<li><code>jdk.MetaspaceSummary</code> 元空间定时统计事件</li>
<li><code>jdk.MetaspaceAllocationFailure</code> 元空间分配失败事件</li>
<li><code>jdk.MetaspaceOOM</code> 元空间 OOM 事件</li>
<li><code>jdk.MetaspaceGCThreshold</code> 元空间 GC 阈值变化事件</li>
<li><code>jdk.MetaspaceChunkFreeListSummary</code> 元空间 Chunk FreeList 统计事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>JVM 线程内存设计（重点研究 Java 线程）（<a href="https://dev.newban.cn/7225879724546113573">全网最硬核 JVM 内存解析 - 13.JVM 线程内存设计</a>开始）<ol>
<li>JVM 中有哪几种线程，对应线程栈相关的参数是什么（涉及 JVM 参数：<code>ThreadStackSize</code>,<code>VMThreadStackSize</code>,<code>CompilerThreadStackSize</code>,<code>StackYellowPages</code>,<code>StackRedPages</code>,<code>StackShadowPages</code>,<code>StackReservedPages</code>,<code>RestrictReservedStack</code>）</li>
<li>Java 线程栈内存的结构</li>
<li>Java 线程如何抛出的 StackOverflowError<ol>
<li>解释执行与编译执行时候的判断（x86为例）</li>
<li>一个 Java 线程 Xss 最小能指定多大</li>
</ol>
</li>
</ol>
</li>
</ol>
<ol start="4">
<li><h1 id="JVM-元空间设计"><a href="#JVM-元空间设计" class="headerlink" title="JVM 元空间设计"></a>JVM 元空间设计</h1></li>
</ol>
<h2 id="4-5-元空间大小限制与动态伸缩"><a href="#4-5-元空间大小限制与动态伸缩" class="headerlink" title="4.5. 元空间大小限制与动态伸缩"></a>4.5. 元空间大小限制与动态伸缩</h2><p>前文我们没有提到，如何限制元空间的大小，其实就是限制 <code>commit</code> 的内存大小。元空间的限制不只是受限于我们的参数配置，并且前面我们提到了，元空间的内存回收也比较特殊，元空间的内存基本都是每个类加载器的 <code>ClassLoaderData</code> 申请并管理的，在类加载器被 GC 回收后，<code>ClassLoaderData</code> 管理的这些元空间也会被回收掉。所以，GC 是可能触发一部分元空间被回收了。所以元空间在设计的时候，还有一个动态限制 <code>_capacity_until_GC</code>，即触发 GC 的元空间占用大小。当要分配的空间导致元空间整体占用超过这个限制的时候，尝试触发 GC。这个动态限制也会在每次 GC 的时候动态扩大或者缩小。动态扩大以及缩小</p>
<p>我们先回顾下之前提过的参数配置：</p>
<ul>
<li><code>MetaspaceSize</code>：初始元空间大小，也是最小元空间大小。后面元空间大小伸缩的时候，不会小于这个大小。默认是 21M。</li>
<li><code>MaxMetaspaceSize</code>：最大元空间大小，默认是无符号 int 最大值。</li>
<li><code>MinMetaspaceExpansion</code>：每次元空间大小伸缩的时候，至少改变的大小。默认是 256K。</li>
<li><code>MaxMetaspaceExpansion</code>：每次元空间大小伸缩的时候，最多改变的大小。默认是 4M。</li>
<li><code>MaxMetaspaceFreeRatio</code>：最大元空间空闲比例，默认是 70，即 70%。</li>
<li><code>MinMetaspaceFreeRatio</code>：最小元空间空闲比例，默认是 40，即 40%。</li>
</ul>
<h3 id="4-5-1-CommitLimiter-的限制元空间可以-commit-的内存大小以及限制元空间占用达到多少就开始尝试-GC"><a href="#4-5-1-CommitLimiter-的限制元空间可以-commit-的内存大小以及限制元空间占用达到多少就开始尝试-GC" class="headerlink" title="4.5.1. CommitLimiter 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC"></a>4.5.1. <code>CommitLimiter</code> 的限制元空间可以 commit 的内存大小以及限制元空间占用达到多少就开始尝试 GC</h3><p><code>CommitLimiter</code> 是一个全局单例，用来限制元空间可以 <code>commit</code> 的内存大小。每次分配元空间 <code>commit</code> 内存的时候，都会调用 <code>CommitLimiter::possible_expansion_words</code> 方法，这个方法会检查：</p>
<ol>
<li>当前元空间已经 <code>commit</code> 的内存大小加上要分配的大小是否超过了 <code>MaxMetaspaceSize</code></li>
<li>当前元空间已经 <code>commit</code> 的内存大小加上要分配的大小是否超过了 <code>_capacity_until_GC</code>，超过了就尝试触发 GC</li>
</ol>
<p>尝试 GC 的核心逻辑是：</p>
<ol>
<li>重新尝试分配</li>
<li>如果还是分配失败，检查 <code>GCLocker</code> 是否锁定禁止 GC，如果是的话，首先尝试提高 <code>_capacity_until_GC</code> 进行分配，分配成功直接返回，否则需要阻塞等待 <code>GCLocker</code> 释放</li>
<li>如果没有锁定，尝试触发 GC，之后回到第 1 步 (这里有个小参数 <code>QueuedAllocationWarningCount</code>，如果尝试触发 GC 的次数超过这个次数，就会打印一条警告日志，当然 <code>QueuedAllocationWarningCount</code> 默认是 0，不会打印，并且触发多次 GC 也无法满足的概率比较低)</li>
</ol>
<h3 id="4-5-2-每次-GC-之后，也会尝试重新计算-capacity-until-GC"><a href="#4-5-2-每次-GC-之后，也会尝试重新计算-capacity-until-GC" class="headerlink" title="4.5.2. 每次 GC 之后，也会尝试重新计算 _capacity_until_GC"></a>4.5.2. 每次 GC 之后，也会尝试重新计算 <code>_capacity_until_GC</code></h3><p>在 JVM 初始化的时候，<code>_capacity_until_GC</code> 先会设置为 <code>MaxMetaspaceSize</code>，因为 JVM 初始化的时候会加载很多类，并且这时候要避免触发 GC。在初始化之后，将 <code>_capacity_until_GC</code> 设置为当前元空间占用大小与 <code>MetaspaceSize</code> 中比较大的那个值。同时，还会初始化一个 <code>_shrink_factor</code>，这个 <code>_shrink_factor</code> 主要是如果需要缩小元空间大小，每次缩小的比例。洗稿的狗也遇到不少</p>
<p>之后，在每次 GC 回收之后，需要重新计算新的 <code>_capacity_until_GC</code>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2a65a64a7a16707ca76e5f64ce6d0abd43e35c09205051d2799f0cce590b4f32" alt="image"></p>
<ol>
<li>读取 <code>crrent_shrink_factor = _shrink_factor</code>，统计当前元空间使用的空间 <code>used_after_gc</code>。</li>
<li>首先看是否需要扩容：<ol>
<li>先使用 <code>MinMetaspaceFreeRatio</code> 最小元空间空闲比例计算 <code>minimum_free_percentage</code> 和 <code>maximum_used_percentage</code>，看是否需要扩容。</li>
<li>计算当前元空间至少要多大 <code>minimum_desired_capacity</code>：使用当前元空间使用的空间 <code>used_after_gc</code> 除以 <code>maximum_used_percentage</code>，并且保证它不小于初始元空间大小 <code>MetaspaceSize</code>，不大于最大元空间大小 <code>MaxMetaspaceSize</code>。</li>
<li>如果当前的 <code>_capacity_until_GC</code> 小于计算的当前元空间至少要多大 <code>minimum_desired_capacity</code>，那么就查要扩容的空间是否大于等于配置 <code>MinMetaspaceExpansion</code>，以及小于等于 <code>MaxMetaspaceExpansion</code>，只有满足才会真正扩容。</li>
<li>扩容其实就是增加 <code>_capacity_until_GC</code></li>
</ol>
</li>
<li>然后看是否需要缩容：<ol>
<li>使用 <code>MaxMetaspaceFreeRatio</code> 最大元空间空闲比例计算 <code>minimum_free_percentage</code> 和 <code>maximum_used_percentage</code>，看是否需要缩容。</li>
<li>计算当前元空间至少要多大 <code>maximum_desired_capacity</code>：使用当前元空间使用的空间 <code>used_after_gc</code> 除以 <code>maximum_used_percentage</code>，并且保证它不小于初始元空间大小 <code>MetaspaceSize</code>，不大于最大元空间大小 <code>MaxMetaspaceSize</code>。</li>
<li>如果当前的 <code>_capacity_until_GC</code> 大于计算的当前元空间至少要多大 <code>maximum_desired_capacity</code>，计算 <code>shrink_bytes</code> = <code>_capacity_until_GC</code> 减去 <code>maximum_desired_capacity</code>。</li>
<li><code>_shrink_factor</code> 初始为 0，之后为 10%，之后每次翻 4 倍，直到 100%。扩容的大小为 <code>shrink_bytes</code> 乘以这个百分比</li>
<li>如果缩容大于等于配置 <code>MinMetaspaceExpansion</code>，以及小于等于 <code>MaxMetaspaceExpansion</code>，并且缩容后不会小于初始元空间大小 <code>MetaspaceSize</code>，就会缩容。</li>
<li>缩容其实就是减少 <code>_capacity_until_GC</code></li>
</ol>
</li>
</ol>
<p>我们还可以看出，如果我们设置 <code>MinMetaspaceFreeRatio</code> 为 0，那么就不会扩容，如果设置 <code>MaxMetaspaceFreeRatio</code> 为 100，那么就不会缩容。<code>_capacity_until_GC</code> 就不会因为 GC 更改。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong><br>我会经常发一些很好的各种框架的官方社区的新闻视频资料并加上个人翻译字幕到如下地址（也包括上面的公众号），欢迎关注：</p>
<ul>
<li>知乎：<a href="https://www.zhihu.com/people/zhxhash" target="_blank" rel="noopener">www.zhihu.com/people/zhxh…</a></li>
<li>B 站：<a href="https://space.bilibili.com/31359187" target="_blank" rel="noopener">space.bilibili.com/31359187</a></li>
</ul>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7225879724546015269" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,面试,Java</tag>
      </tags>
  </entry>
  <entry>
    <title>哈希表的原理及其在实际中的应用 哈希表的原理及其在实际中的应</title>
    <url>/7359490238416207910.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="哈希表的原理及其在实际中的应用"><a href="#哈希表的原理及其在实际中的应用" class="headerlink" title="哈希表的原理及其在实际中的应用"></a>哈希表的原理及其在实际中的应用</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在计算机科学中，数据结构是构建各种复杂算法和系统的基础。其中，哈希表（Hash Table）作为一种重要的数据结构，被广泛应用于实际的软件开发中。本文将深入探讨哈希表的原理，并介绍其在实际中的应用。</p>
<h2 id="什么是哈希表？"><a href="#什么是哈希表？" class="headerlink" title="什么是哈希表？"></a>什么是哈希表？</h2><p>哈希表是一种数据结构，用于存储键值对（key-value pairs）。它通过哈希函数将键映射到表中的一个位置，从而实现高效的数据访问。哈希表的特点在于，通过哈希函数计算出的位置是固定的，因此可以在常量时间内（O(1)）查找、插入和删除元素。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a03b4a8be204afaf30bb774af1afdf6c862a201eb7718c93fa8f7defea93e6fc" alt="image-20240420161555628"></p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><p>哈希函数是哈希表的核心组成部分，它接受一个键作为输入，并返回对应的哈希值（hash value）。理想情况下，哈希函数应当满足以下特性：</p>
<ol start="0">
<li>一致性：对于相同的输入，哈希函数应当始终返回相同的哈希值。</li>
<li>均匀性：哈希函数应当尽可能地将输入分散到不同的哈希值上，避免哈希冲突（collision）的发生。</li>
</ol>
<p>常见的哈希函数包括MD5、SHA-1和SHA-256等。在实际应用中，根据数据的特点和需求，可以选择合适的哈希函数。</p>
<h2 id="哈希冲突处理"><a href="#哈希冲突处理" class="headerlink" title="哈希冲突处理"></a>哈希冲突处理</h2><p>由于哈希函数的输出空间通常远小于输入空间，所以哈希冲突是不可避免的。哈希冲突指的是不同的键被映射到了相同的哈希值上。为了解决哈希冲突，常见的方法有：</p>
<ol start="0">
<li><strong>链地址法（Chaining）</strong> ：将具有相同哈希值的元素存储在同一个位置上的链表中。当发生哈希冲突时，只需在链表中进行线性查找即可。</li>
<li><strong>开放寻址法（Open Addressing）</strong> ：当发生哈希冲突时，不仅仅停留在被占用的位置，而是依次向后探测，直到找到空闲位置为止。</li>
</ol>
<h2 id="哈希表的应用"><a href="#哈希表的应用" class="headerlink" title="哈希表的应用"></a>哈希表的应用</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b6e7ea81feeedfd5729fd5a8d2a19798a992843f9d7c59f70b4a6f130ca8f56e" alt="img"></p>
<p>哈希表在实际中有着广泛的应用，其中一些典型的例子包括：</p>
<ol start="0">
<li><strong>字典</strong>：哈希表可以用于实现字典，将单词映射到对应的释义或翻译上，实现快速的单词查找功能。</li>
<li><strong>缓存</strong>：在缓存系统中，哈希表常被用来存储已经访问过的数据，以加快数据的访问速度。</li>
<li><strong>数据库索引</strong>：数据库中的索引通常使用哈希表来加速查询操作，提高数据库的性能。</li>
<li><strong>唯一性检查</strong>：在一些系统中，哈希表被用来检查数据的唯一性，例如检查用户名或电子邮件地址是否已经存在。</li>
</ol>
<h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>下面是一个简单的哈希表实现的示例代码，使用了链地址法处理哈希冲突：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class HashTable:</span><br><span class="line">    def __init__(self, size):</span><br><span class="line">        self.size = size</span><br><span class="line">        self.table = [[] for _ in range(size)]</span><br><span class="line">        </span><br><span class="line">    def _hash_function(self, key):</span><br><span class="line">        return hash(key) % self.size</span><br><span class="line">    </span><br><span class="line">    def insert(self, key, value):</span><br><span class="line">        index = self._hash_function(key)</span><br><span class="line">        self.table[index].append((key, value))</span><br><span class="line">        </span><br><span class="line">    def search(self, key):</span><br><span class="line">        index = self._hash_function(key)</span><br><span class="line">        for k, v in self.table[index]:</span><br><span class="line">            if k == key:</span><br><span class="line">                return v</span><br><span class="line">        return None</span><br><span class="line">    </span><br><span class="line">    def delete(self, key):</span><br><span class="line">        index = self._hash_function(key)</span><br><span class="line">        for i, (k, _) in enumerate(self.table[index]):</span><br><span class="line">            if k == key:</span><br><span class="line">                del self.table[index][i]</span><br><span class="line">                return</span><br></pre></td></tr></table></figure>

<p>当谈到哈希表的代码案例时，我们可以进一步展示一个简单的示例，演示如何使用哈希表来解决一个实际的问题。在这个示例中，我们将使用哈希表来实现一个电话簿，可以通过姓名快速查找对应的电话号码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码class PhoneBook:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.contacts = &#123;&#125;</span><br><span class="line">​</span><br><span class="line">    def add_contact(self, name, phone_number):</span><br><span class="line">        self.contacts[name] = phone_number</span><br><span class="line">​</span><br><span class="line">    def search_contact(self, name):</span><br><span class="line">        return self.contacts.get(name, &quot;Contact not found&quot;)</span><br><span class="line">​</span><br><span class="line">    def delete_contact(self, name):</span><br><span class="line">        if name in self.contacts:</span><br><span class="line">            del self.contacts[name]</span><br><span class="line">            print(f&quot;&#123;name&#125;&apos;s contact deleted successfully&quot;)</span><br><span class="line">        else:</span><br><span class="line">            print(f&quot;Contact &apos;&#123;name&#125;&apos; not found&quot;)</span><br><span class="line">​</span><br><span class="line"># 示例用法</span><br><span class="line">phone_book = PhoneBook()</span><br><span class="line">​</span><br><span class="line"># 添加联系人</span><br><span class="line">phone_book.add_contact(&quot;Alice&quot;, &quot;123-456-7890&quot;)</span><br><span class="line">phone_book.add_contact(&quot;Bob&quot;, &quot;456-789-0123&quot;)</span><br><span class="line">phone_book.add_contact(&quot;Charlie&quot;, &quot;789-012-3456&quot;)</span><br><span class="line">​</span><br><span class="line"># 查找联系人</span><br><span class="line">print(phone_book.search_contact(&quot;Alice&quot;))  # 输出：123-456-7890</span><br><span class="line">print(phone_book.search_contact(&quot;Dave&quot;))   # 输出：Contact not found</span><br><span class="line">​</span><br><span class="line"># 删除联系人</span><br><span class="line">phone_book.delete_contact(&quot;Bob&quot;)  # 输出：Bob&apos;s contact deleted successfully</span><br><span class="line">phone_book.delete_contact(&quot;Eve&quot;)  # 输出：Contact &apos;Eve&apos; not found</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为<code>PhoneBook</code>的类，其中包含了添加联系人、查找联系人和删除联系人等功能。使用哈希表存储联系人的姓名和电话号码，通过姓名作为键来快速查找对应的电话号码。这个示例展示了哈希表在实际应用中的便利性和效率。</p>
<p>在进一步探讨哈希表的实际应用时，让我们考虑一个更具挑战性的场景：检测重复文件。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d8a3f83c36830eaa28cf5ebfeb3e753b13c219a37d97e67e9021f6ef31c07517" alt="image-20240420161630404"></p>
<p>在许多情况下，我们需要清理磁盘上的重复文件以释放存储空间。哈希表可以帮助我们高效地解决这个问题。我们可以使用文件的哈希值作为键，在哈希表中存储文件路径，这样就可以轻松地检测到重复文件。</p>
<p>下面是一个简单的示例代码，演示了如何使用哈希表来检测重复文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码import hashlib</span><br><span class="line">import os</span><br><span class="line">​</span><br><span class="line">def file_hash(file_path):</span><br><span class="line">    &quot;&quot;&quot;计算文件的哈希值&quot;&quot;&quot;</span><br><span class="line">    hasher = hashlib.md5()</span><br><span class="line">    with open(file_path, &apos;rb&apos;) as f:</span><br><span class="line">        while True:</span><br><span class="line">            chunk = f.read(4096)</span><br><span class="line">            if not chunk:</span><br><span class="line">                break</span><br><span class="line">            hasher.update(chunk)</span><br><span class="line">    return hasher.hexdigest()</span><br><span class="line">​</span><br><span class="line">def find_duplicate_files(directory):</span><br><span class="line">    &quot;&quot;&quot;在指定目录中查找重复文件&quot;&quot;&quot;</span><br><span class="line">    duplicates = &#123;&#125;</span><br><span class="line">    for root, _, files in os.walk(directory):</span><br><span class="line">        for file in files:</span><br><span class="line">            file_path = os.path.join(root, file)</span><br><span class="line">            file_key = file_hash(file_path)</span><br><span class="line">            if file_key in duplicates:</span><br><span class="line">                duplicates[file_key].append(file_path)</span><br><span class="line">            else:</span><br><span class="line">                duplicates[file_key] = [file_path]</span><br><span class="line">​</span><br><span class="line">    # 输出重复文件</span><br><span class="line">    for key, value in duplicates.items():</span><br><span class="line">        if len(value) &gt; 1:</span><br><span class="line">            print(f&quot;Duplicate files for hash &#123;key&#125;:&quot;)</span><br><span class="line">            for file_path in value:</span><br><span class="line">                print(file_path)</span><br><span class="line">            print()</span><br><span class="line">​</span><br><span class="line"># 示例用法</span><br><span class="line">directory_to_scan = &quot;/path/to/directory&quot;</span><br><span class="line">find_duplicate_files(directory_to_scan)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们定义了两个函数：<code>file_hash</code>用于计算文件的哈希值，<code>find_duplicate_files</code>用于在指定目录中查找重复文件。</p>
<p><code>file_hash</code>函数使用MD5哈希算法计算文件的哈希值，这是一种快速而常用的哈希算法。然后，<code>find_duplicate_files</code>函数遍历指定目录中的所有文件，为每个文件计算哈希值，并将文件路径存储在哈希表中。如果哈希表中已经存在相同哈希值的文件，则将当前文件路径添加到对应的列表中。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5da3c51e84329f1b22531dae031f4ab061ab09557d965a54a62aab31868f33a6" alt="image-20240420161659075"></p>
<p>最后，我们输出所有具有重复哈希值的文件路径，从而找到重复文件。这个示例展示了哈希表在实际文件处理中的强大应用，通过哈希表的高效查找功能，我们可以快速识别和处理重复文件，节省存储空间和提高文件管理效率。</p>
<p>另一个实际应用哈希表的示例是实现一个简单的URL缩短服务。URL缩短服务将长URL转换为短URL，并提供短URL以便于在文本消息、社交媒体等场景中分享。在这个示例中，我们将使用哈希表来存储长URL与短URL之间的映射关系。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">python复制代码import hashlib</span><br><span class="line">​</span><br><span class="line">class URLShortener:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.url_map = &#123;&#125;</span><br><span class="line">​</span><br><span class="line">    def shorten_url(self, long_url):</span><br><span class="line">        &quot;&quot;&quot;将长URL转换为短URL&quot;&quot;&quot;</span><br><span class="line">        hash_code = hashlib.md5(long_url.encode()).hexdigest()[:6]</span><br><span class="line">        short_url = f&quot;http://short.url/&#123;hash_code&#125;&quot;</span><br><span class="line">        self.url_map[short_url] = long_url</span><br><span class="line">        return short_url</span><br><span class="line">​</span><br><span class="line">    def expand_url(self, short_url):</span><br><span class="line">        &quot;&quot;&quot;将短URL还原为长URL&quot;&quot;&quot;</span><br><span class="line">        return self.url_map.get(short_url, &quot;Short URL not found&quot;)</span><br><span class="line">​</span><br><span class="line"># 示例用法</span><br><span class="line">shortener = URLShortener()</span><br><span class="line">​</span><br><span class="line"># 将长URL转换为短URL</span><br><span class="line">long_url = &quot;https://www.example.com/article/how-to-build-a-url-shortener&quot;</span><br><span class="line">short_url = shortener.shorten_url(long_url)</span><br><span class="line">print(&quot;Shortened URL:&quot;, short_url)</span><br><span class="line">​</span><br><span class="line"># 将短URL还原为长URL</span><br><span class="line">original_url = shortener.expand_url(short_url)</span><br><span class="line">print(&quot;Original URL:&quot;, original_url)</span><br></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个名为<code>URLShortener</code>的类，其中包含了两个方法：<code>shorten_url</code>用于将长URL转换为短URL，<code>expand_url</code>用于将短URL还原为长URL。我们使用MD5哈希算法对长URL进行哈希处理，然后截取部分哈希值作为短URL的标识符。然后，我们将短URL与长URL之间的映射关系存储在哈希表中。</p>
<p>在示例用法中，我们首先将长URL转换为短URL，并输出转换后的短URL。然后，我们将短URL还原为长URL，并输出还原后的原始URL。这个示例演示了如何使用哈希表实现一个简单的URL缩短服务，通过哈希表快速存储和检索长URL与短URL之间的映射关系，实现了高效的URL转换功能。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ae97bc192f4632e125d4549682aa9bf99799f6cce04e4cd0c4550f81cefb265" alt="image-20240420161749464"></p>
<h2 id="分布式系统中的哈希表应用"><a href="#分布式系统中的哈希表应用" class="headerlink" title="分布式系统中的哈希表应用"></a>分布式系统中的哈希表应用</h2><p>在分布式系统中，哈希表也扮演着重要的角色。分布式哈希表通常被用来实现数据的分片和负载均衡。通过哈希函数，将数据分散存储在多个节点上，从而实现数据的分布式存储和查询。这种方式可以提高系统的扩展性和容错性，同时减轻单个节点的负载压力。</p>
<p>例如，在分布式缓存系统中，如Redis Cluster，哈希表被用来实现数据的分片和存储。通过一致性哈希算法，将数据分散存储在多个Redis节点上，从而实现了分布式缓存的高可用性和扩展性。</p>
<p>另一个例子是分布式文件系统，如Hadoop的HDFS（Hadoop Distributed File System）。HDFS使用哈希表来管理文件块的存储位置，通过哈希函数将文件块映射到不同的存储节点上，从而实现了大规模文件的分布式存储和处理。</p>
<h2 id="哈希表的性能优化"><a href="#哈希表的性能优化" class="headerlink" title="哈希表的性能优化"></a>哈希表的性能优化</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7f084bfcea7471d4c836772f862f72cad718a95f6e2ae4efc7bcc7b49329a620" alt="image-20240420161801424"></p>
<p>在实际应用中，哈希表的性能取决于哈希函数的选择、哈希冲突的处理方法以及表的装载因子等因素。为了提高哈希表的性能，可以采取一些优化策略，例如：</p>
<ul>
<li><strong>良好的哈希函数选择</strong>：选择高效的哈希函数可以减少哈希冲突的发生，提高哈希表的性能。</li>
<li><strong>合理的装载因子控制</strong>：控制哈希表的装载因子可以减少哈希冲突的概率，提高数据的存储和查询效率。</li>
<li><strong>哈希冲突处理优化</strong>：针对不同的应用场景选择合适的哈希冲突处理方法，例如在开放寻址法中使用良好的探测策略，在链地址法中优化链表的存储结构等。</li>
<li><strong>哈希表大小的动态调整</strong>：根据数据量的变化动态调整哈希表的大小，避免哈希表过度填满或过度浪费空间。</li>
</ul>
<p>通过以上优化策略，可以进一步提高哈希表在实际应用中的性能和效率。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c9ef97f2897f5d73d33e0c52e6068af23b0d31a07440131ea99b5e05fa313294" alt="image-20240420161822446"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>哈希表作为一种重要的数据结构，在实际应用中发挥着关键作用。本文深入探讨了哈希表的原理、哈希函数、哈希冲突处理以及实际应用场景。我们了解到，哈希表通过哈希函数将键映射到固定位置，实现了快速的数据存储和查询，具有常量时间复杂度的优势。在实际应用中，哈希表被广泛应用于字典、缓存、数据库索引、分布式系统等场景中，为软件开发和系统设计提供了便利和效率。</p>
<p>同时，本文还强调了哈希表在安全性方面的重要性。选择合适的哈希函数、合理的冲突处理方法以及加强安全措施，可以有效保护存储的数据不被泄露或篡改，确保系统的安全性和可靠性。</p>
<p>综上所述，哈希表在性能、效率和安全性方面都具有重要意义。通过深入理解哈希表的原理和应用，以及不断优化和加强安全措施，我们可以充分发挥哈希表的优势，为构建高效、安全和可靠的软件系统做出贡献。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359490238416207910" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>服务端接入支付宝文档解读</title>
    <url>/7359127394043969545.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这个文档类似文言文，需要解读一下才能变成人话，请听我解读</p>
<p>首先确定职责范围和边界，这是最重要的，方向不对努力白费</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9317205981618531d61a76ae61ac25e190847c47550faf91be6c90e28afead3d" alt="image.png"><br>这个图可谓是文档里最最重要的，没有之一，我在文档的犄角旮旯里找到了。</p>
<p>支付宝没有强调他的重要性，我替他强调一下</p>
<p>请看这个图，1.3，1.13，1.15是服务端要做的，除此以外的不用管，分别对应文档：app支付接口2.0文档，异步通知说明，同步通知说明</p>
<p>在这个图里，请注意1.3，他是没有网络请求的，重点强调！</p>
<p>如果你不用他的sdk，那这个文档写了和没写一样。</p>
<p>每到关键的地方，就会写着执行sdk，他还会很贴心的提供代码！代码是这么写的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码$aop-&gt;sdkExecute($request);</span><br><span class="line">alipayClient.sdkExecute(request);</span><br><span class="line">client.SdkExecute(request);</span><br><span class="line">await alipaySdk.sdkExec();</span><br></pre></td></tr></table></figure>

<p>是不是有种写了寂寞的感觉？</p>
<p>如果你不用他的sdk，其实也是有文档的，只是很隐蔽，怎么找到呢？</p>
<p>点击签名打开了一个页面告诉你签名规则，他是属于通用工具栏目里的，旁边有个栏目叫技术接入指南，里面有个开发指南，里面有个自行实现签名/自行实现验签。</p>
<p>这就需要提一下他的sdk代码了，他的sdk就做了几件事而已：签名/验签/处理证书。</p>
<p>解读一下，当文档在说sdk的时候，可以理解为他在说签名/验签</p>
<p>那自己实现一下签名/验签就是了，要什么sdk。</p>
<p>有具体的规则，有证书，签名就那么点东西，他还能玩出花样？他能</p>
<p>首先是证书，他提供了很多的文件，但是他不告诉这些文件是什么，你自己猜，我们来看看</p>
<ul>
<li>应用公钥RSA2048.txt</li>
<li>应用私钥RSA2048-敏感数据，请妥善保管.txt</li>
<li>支付宝.txt</li>
<li>alipayCertPublicKey_RSA2.crt</li>
<li>alipayRootCert.crt</li>
<li>appCertPublicKey_20210041xxxx.crt</li>
<li>CSR文件.csr</li>
</ul>
<p>在自行实现签名里，他这样说：</p>
<blockquote>
<p>需携带 <strong>应用公钥证书 SN</strong>（app_cert_sn）、<strong>支付宝根证书 SN</strong>（alipay_root_cert_sn）SN 值是通过解析 X.509 证书文件中签发机构名称（name）以及内置序列号（serialNumber），将二者拼接后的字符串计算 MD5 值获取</p>
</blockquote>
<p>支付宝根证书SN这个是确定的：alipayRootCert.crt，这个没问题，因为只有这一个文件名里带root</p>
<p>应用公钥证书SN（app_cert_sn）要靠猜了。在很多次验证之后发现他说的应用公钥匙证书是appCertPublicKey_20210041xxxx.crt</p>
<p>签发机构名称（name）这是java语言解析出来的叫name长这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码CN=Ant Financial Certification Authority Class 1 R1,OU=Certification Authority,O=Ant Financial,C=CN</span><br></pre></td></tr></table></figure>

<p>但是php语言解析出来叫issuer，长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">csharp复制代码[C] =&gt; CN</span><br><span class="line">[O] =&gt; Ant Financial</span><br><span class="line">[OU] =&gt; Certification Authority</span><br><span class="line">[CN] =&gt; Ant Financial Certification Authority Class 1 R1</span><br></pre></td></tr></table></figure>

<p>go语言解出来叫issuer，长这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码CN=Ant Financial Certification Authority Class 1 R1,OU=Certification Authority,O=Ant Financial,C=CN</span><br></pre></td></tr></table></figure>

<p>文档里用name对其他语言太不友好了，要不是看了php源码，我真不知道去哪找name</p>
<blockquote>
<p>使用各自语言对应的 SHA256WithRSA（对应 sign_type 为 RSA2）或 SHA1WithRSA（对应 sign_type 为 RSA）签名函数利用商家私钥对签名字符串进行签名，并进行 Base64 编码</p>
</blockquote>
<p>私钥在哪？看文件名毫无疑问是这个：应用私钥RSA2048-敏感数据，请妥善保管.txt，但这内容也不是私钥格式啊</p>
<p>抱歉，你需要自己处理一下格式，怎么处理？文档没有，看sdk代码</p>
<p>下一个要解释的是公钥验签，自行实现验签的时候，他是这么说的：</p>
<blockquote>
<p>使用各自语言对应的 SHA256WithRSA (对应 sign_type 为 RSA2) 或 SHA1WithRSA (对应 sign_type 为 RSA) 签名验证函数，传入待验签字段、支付宝公钥证书存放路径、签名内容(sign)，验签方法(signType)进行验签，根据返回结果判定是否验签通过。</p>
</blockquote>
<p>公钥是哪个呢？猜就完事了，经过各种试验，发现是alipayCertPublicKey_RSA2.crt</p>
<p>而且这个公钥不能直接用，需要处理一下，但是我文档不说，你看源码</p>
<p>最后一个要解释的是服务端API列表，各种支付接口，看他的文档结构，有请求参数，响应参数，还有错误码呢，文档上这样写着</p>
<blockquote>
<p>请在服务端执行支付宝SDK中sdkExecute方法，读取响应中的body()结果。</p>
</blockquote>
<p>第一反应是这是一个http请求，但是我找不到method,query,body,header,response啊，只有一个网关域名，这咋回事？？？</p>
<p>看sdk源码才知道，这根本就不是一个http请求，这就是签名而已</p>
<p>我建议支付宝文档，别总拿sdk说事，sdk毕竟封装了一次，不够直接，请直接说事。</p>
<ul>
<li>如果是签名，描述签名规则</li>
<li>如果是验证，描述验证规则</li>
<li>如果是网络请求，请给出curl</li>
<li>如果需要证书，请指明证书以及如何处理</li>
</ul>
<p>有了签名/验签规则、证书和curl，我不信还有什么说不清楚的。</p>
<p>sdk应该是辅助，有更好，没有也完全不影响。</p>
<p>接完之后，发现接入过程非常简单，和其他第三方没有什么不同，关键的地方一页纸一定能说清楚，不知道他们这么多人在写什么</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359127394043969545" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-4-19 群讨论：GraalVM 与 JVM 使用</title>
    <url>/7359479759663054875.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>以下来自本人拉的一个关于 Java 技术的讨论群。关注公众号：hashcon，私信进群拉你</p>
</blockquote>
<h1 id="GraalVM-Native-Image-的进程能否被-jps-看到？"><a href="#GraalVM-Native-Image-的进程能否被-jps-看到？" class="headerlink" title="GraalVM Native Image 的进程能否被 jps 看到？"></a>GraalVM Native Image 的进程能否被 jps 看到？</h1><p>感谢 dreamlike_ocean ( <a href="https://space.bilibili.com/8227104" target="_blank" rel="noopener">space.bilibili.com/8227104</a> )指正</p>
<p>如果编译参数里面开启了 jstat，jmx 等特性（<code>--enable-monitoring=jmxserver,jmxclient,jvmstat</code>），就能看到，没有开启就看不到。</p>
<h1 id="当前对于-GraalVM-与-JVM-的使用"><a href="#当前对于-GraalVM-与-JVM-的使用" class="headerlink" title="当前对于 GraalVM 与 JVM 的使用"></a>当前对于 GraalVM 与 JVM 的使用</h1><ol>
<li><strong>针对 Lambda 类型任务</strong>（例如不频繁的但是处理数据比较多的定时任务，如每周报表，以及临时的数据导出任务），<strong>使用 GraalVM Native Image</strong>：<ol>
<li>这种任务不适合放在常驻的微服务，浪费资源：<ol>
<li>微服务要按照这个定时任务的标准设计内存和 CPU，很长时间是不用这么多的。</li>
<li>要节约，并且放在常驻的微服务，需要定时任务启动前，以更高的内存和 CPU 重启微服务，定时任务结束后回复原来的参数重启微服务。</li>
</ol>
</li>
<li>适合放在 k8s cronjob 或者 AWS Lambda 这种服务，但是这些服务都对启动时间有很高有求，需要在一定时间内启动好并告诉容器就绪了。</li>
<li>这种的适合 GraalVM Native Image，一是对启动时间有要求，二是一般依赖的库比常驻微服务简单很多，改造起来简单很多。</li>
</ol>
</li>
<li><strong>针对常驻的微服务，还是使用 JVM</strong>：<ol>
<li><strong>针对涉及很多存储 io 连接的微服务</strong>，先不要使用 CRaC 机制，先只使用 <strong>CDS 加速类加载，然后可以考虑用 Graal JIT 替代 C2 编译器</strong>。</li>
<li><strong>针对没有很多存储 io 连接的微服务，使用 CRaC</strong>，例如 web 引擎微服务，网关微服务，广告微服务（大部分访问在本地缓存），这些正好是对于流量更敏感的微服务，需要在流量到来时，快速扩容并启动。</li>
</ol>
</li>
</ol>
<blockquote>
<p>个人简介：个人业余研究了 AI LLM 微调与 RAG，目前成果是微调了三个模型：</p>
<ol>
<li>一个模型是基于 whisper 模型的微调，使用我原来做的精翻的视频按照语句段落切分的片段，并尝试按照方言类别，以及技术类别分别尝试微调的成果。用于视频字幕识别。</li>
<li>一个模型是基于 Mistral Large 的模型的微调，识别提取视频课件的片段，辅以实际的课件文字进行识别微调。用于识别课件的片段。</li>
<li>最后一个模型是基于 Claude 3 的模型微调，使用我之前制作的翻译字幕，与 AWS、Go 社区、CNCF 生态里面的官方英文文档以及中文文档作为语料，按照内容段交叉拆分，进行微调，用于字幕翻译。</li>
</ol>
</blockquote>
<blockquote>
<p>目前，准确率已经非常高了。大家如果有想要我制作的视频，欢迎关注留言。</p>
</blockquote>
<blockquote>
<p>本人也是开源代码爱好者，贡献过很多项目的源码（Mycat 和 Java JFRUnit 的核心贡献者，贡献过 OpenJDK，Spring，Spring Cloud，Apache Bookkeeper，Apache RocketMQ，Ribbon，Lettuce、 SocketIO、Langchain4j 等项目 ），同时也是深度技术迷，编写过很多硬核的原理分析系列（JVM）。本人也有一个 Java 技术交流群，感兴趣的欢迎关注。</p>
</blockquote>
<blockquote>
<p>另外，一如即往的是，全网的所有收益，都会捐赠给希望工程，坚持靠爱与兴趣发电。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359479759663054875" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>2024-4-19 群讨论：JVM 堆外内存如何查看？ JV</title>
    <url>/7359479759662940187.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>以下来自本人拉的一个关于 Java 技术的讨论群。关注公众号：hashcon，私信进群拉你</p>
</blockquote>
<h1 id="JVM-堆外内存如何查看？"><a href="#JVM-堆外内存如何查看？" class="headerlink" title="JVM 堆外内存如何查看？"></a>JVM 堆外内存如何查看？</h1><p>参考：<a href="https://dev.newban.cn/7225871227743043644">juejin.cn/post/722587…</a></p>
<p>分为：</p>
<ol>
<li>通过 Native Memory Tracking 能看到的：<ol>
<li>Java堆内存，所有 Java 对象分配占用内存的来源</li>
<li>2.元空间，JVM 将类文件加载到内存中用于后续使用占用的空间，注意是 JVM C++ 层面的内存占用，主要包括类文件中在 JVM 解析为 C++ 的 Klass 类以及相关元素。</li>
<li>C++ 字符串即符号(Symbol)占用空间，前面加载类的时候，其实里面有很多字符串信息（注意不是 Java 字符串，是 JVM 层面 C++ 字符串），不同类的字符串信息可能会重复（</li>
<li>线程占用内存，主要是每个线程的线程栈，我们也只会主要分析线程栈占用空间（在第五章），其他的管理线程占用的空间很小，可以忽略不计。</li>
<li>JIT编译器本身占用的空间以及JIT编译器编译后的代码占用空间</li>
<li>Arena 数据结构占用空间，我们看到 Native Memory Tracking 中有很多通过 arena 分配的内存，这个就是管理 Arena 数据结构占用空间。</li>
<li>JVM Tracing 占用内存，包括 JVM perf 以及 JFR 占用的空间。</li>
<li>写 JVM 日志占用的内存（-Xlog 参数指定的日志输出，并且 Java 17 之后引入了异步 JVM 日志-Xlog:async，异步日志所需的 buffer 也在这里）</li>
<li>JVM 参数占用内存，我们需要保存并处理当前的 JVM 参数以及用户启动 JVM 的是传入的各种参数（有时候称为 flag）</li>
<li>JVM 安全点占用内存，是固定的两页内存（我这里是一页是 4KB，后面第二章会分析这个页大小与操作系统相关），用于 JVM 安全点的实现，不会随着 JVM 运行时的内存占用而变化。</li>
<li>Java 同步机制（例如 synchronized，还有 AQS 的基础 LockSupport）底层依赖的 C++ 的数据结构，系统内部的 mutex 等占用的内存。</li>
<li>JVM TI 相关内存，JVMTI 是 Java 虚拟机工具接口（Java Virtual Machine Tool Interface）的缩写。它是 Java 虚拟机（JVM）的一部分，提供了一组 API，使开发人员可以开发自己的 Java 工具和代理程序，以监视、分析和调试 Java 应用程序。JVMTI API 是一组 C/C++ 函数，可以通过 JVM TI Agent Library 和 JVM 进行交互。开发人员可以使用 JVMTI API 开发自己的 JVM 代理程序或工具，以监视和操作 Java 应用程序。</li>
<li>Java 字符串去重占用内存：Java 字符串去重机制可以减少应用程序中字符串对象的内存占用。 在 Java 应用程序中，字符串常量是不可变的，并且通常被使用多次。这意味着在应用程序中可能存在大量相同的字符串对象，这些对象占用了大量的内存。Java 字符串去重机制通过在堆中共享相同的字符串对象来解决这个问题。当一个字符串对象被创建时，JVM 会检查堆中是否已经存在相同的字符串对象。如果存在，那么新的字符串对象将被舍弃，而引用被返回给现有的对象。这样就可以减少应用程序中字符串对象的数量，从而减少内存占用。 但是这个机制一直在某些 GC 下表现不佳，尤其是 G1GC 以及 ZGC 中，所以默认是关闭的，可以通过 -XX:+UseStringDeduplication 来启用。</li>
<li>JVM GC需要的数据结构与记录信息占用的空间，这块内存可能会比较大，尤其是对于那种专注于低延迟的 GC，例如 ZGC。其实 ZGC 是一种以空间换时间的思路，提高 CPU 消耗与内存占用，但是消灭全局暂停。之后的 ZGC 优化方向就是尽量降低 CPU 消耗与内存占用，相当于提高了性价比。</li>
<li>JVM内部(不属于其他类的占用就会归到这一类)与其他占用(不是 JVM 本身而是操作系统的某些系统调用导致额外占的空间)，不会很大。但是这里会因为某些 bug 导致很大，例如：<ol>
<li><a href="https://bugs.openjdk.org/browse/JDK-8305994" target="_blank" rel="noopener">bugs.openjdk.org/browse/JDK-…</a> 。 Java 15，16 引入的 bug，17 低版本存在这个问题，21 修复的，在 17.0.8 port 回 17 的。</li>
</ol>
</li>
</ol>
</li>
<li>开启 Native Memory Tracking 本身消耗的内存</li>
<li>通过 Native Memory Tracking 看不到的：<ol>
<li>DirectBuffer：通过 <code>ByteBuffer directBuffer = ByteBuffer.allocateDirect(1024);</code> 分配的，底层基于 JNI + 系统调用，不会被 Native Memory Tracking 采集</li>
<li>MMAP Buufer：通过 <code>MappedByteBuffer mmap = fileChannel.map(FileChannel.MapMode.READ_WRITE, 0, fileChannel.size());</code> 分配的，底层基于 JNI + 系统调用，不会被 Native Memory Tracking 采集</li>
</ol>
</li>
</ol>
<p>目前，Native Memory Tracking 已经可以通过 JFR 查看（Java 22）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9cb62d780f5d141c46615634f4e3100726c3802d7dd86c2fc3cdeccb16e1bbfb" alt="image"><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fff29d246f9178acfc51fdcccaa7c06f55672da94589b6ef42a8ea8eb941aeed" alt="image"></p>
<p>查看 Native Memory Tracking 看不到的 Direct Buffer 以及 MMAP Buffer 的方式，可以通过 JMX 查看，这里给一个 Jconsole 的截图，大家通过截图的这个路径写代码访问 MBean 就能看到：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4555cc21e7fb05c747b7b50ae7ae88718f4f8c7dc80850eb136791a9bf790c1f" alt="image"></p>
<blockquote>
<p>个人简介：个人业余研究了 AI LLM 微调与 RAG，目前成果是微调了三个模型：</p>
<ol>
<li>一个模型是基于 whisper 模型的微调，使用我原来做的精翻的视频按照语句段落切分的片段，并尝试按照方言类别，以及技术类别分别尝试微调的成果。用于视频字幕识别。</li>
<li>一个模型是基于 Mistral Large 的模型的微调，识别提取视频课件的片段，辅以实际的课件文字进行识别微调。用于识别课件的片段。</li>
<li>最后一个模型是基于 Claude 3 的模型微调，使用我之前制作的翻译字幕，与 AWS、Go 社区、CNCF 生态里面的官方英文文档以及中文文档作为语料，按照内容段交叉拆分，进行微调，用于字幕翻译。</li>
</ol>
</blockquote>
<blockquote>
<p>目前，准确率已经非常高了。大家如果有想要我制作的视频，欢迎关注留言。</p>
</blockquote>
<blockquote>
<p>本人也是开源代码爱好者，贡献过很多项目的源码（Mycat 和 Java JFRUnit 的核心贡献者，贡献过 OpenJDK，Spring，Spring Cloud，Apache Bookkeeper，Apache RocketMQ，Ribbon，Lettuce、 SocketIO、Langchain4j 等项目 ），同时也是深度技术迷，编写过很多硬核的原理分析系列（JVM）。本人也有一个 Java 技术交流群，感兴趣的欢迎关注。</p>
</blockquote>
<blockquote>
<p>另外，一如即往的是，全网的所有收益，都会捐赠给希望工程，坚持靠爱与兴趣发电。</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359479759662940187" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>13 Spring AOP（一）思想及使用 1 什么是S</title>
    <url>/7359577911990517795.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><ol>
<li><h1 id="什么是Spring-AOP"><a href="#什么是Spring-AOP" class="headerlink" title="什么是Spring AOP"></a>什么是Spring AOP</h1></li>
</ol>
<p>AOP的全称是<strong>Aspect Oriented Programming</strong>，也就是<strong>面向切面编程</strong>，是一种思想。它是针对OOP(面向对象编程)的一种补充，<strong>是对某一类事情的集中处理</strong>。比如一个博客网站的登陆验证功能，在用户进行新增、编辑、删除博客等操作前都需要进行用户的登陆验证，我们在对这些业务编码时，都需要考虑一下用户的登录验证。<strong>对于这种功能统一，且使用较多的功能，就可以考虑通过AOP来统一处理了</strong>。 引入AOP的思想之后，我们在处理其他业务的时候就不需要再考虑如登录验证这样的其他功能。</p>
<p>Spring AOP是Spring公司针对AOP思想提供的一种实现方式，除了登录验证的功能之外，Spring AOP还可以实现：统一日志记录、统一返回格式设置、统一异常处理等。</p>
<ol start="2">
<li><h1 id="AOP的基本术语"><a href="#AOP的基本术语" class="headerlink" title="AOP的基本术语"></a>AOP的基本术语</h1></li>
</ol>
<h2 id="2-1-切面（Aspect）"><a href="#2-1-切面（Aspect）" class="headerlink" title="2.1 切面（Aspect）"></a>2.1 切面（Aspect）</h2><p>切面相当于AOP<strong>实现的某个功能的集合</strong>，比如说登录验证功能，切面是由切点（Pointcut）和通知（Advice）组成的</p>
<h2 id="2-2-连接点（Join-Point）"><a href="#2-2-连接点（Join-Point）" class="headerlink" title="2.2 连接点（Join Point）"></a>2.2 连接点（Join Point）</h2><p>连接点是应用执行过程中<strong>能够插入切面的一个点</strong>。比如说一个博客系统，包含许多业务，其中可以插入切面的业务都可以称为连接点。</p>
<h2 id="2-3-切点（Pointcut）"><a href="#2-3-切点（Pointcut）" class="headerlink" title="2.3 切点（Pointcut）"></a>2.3 切点（Pointcut）</h2><p>Pointcut的作用就是<strong>提供一组规则</strong>来匹配连接点（Join Point），比如说对于博客系统，它有一些url是不需要做登录验证功能的，比如注册业务，通过切点提供的这么一组规则，在不需要登录验证的地方，它就不会进行登录验证。</p>
<h2 id="2-4-通知（Advice）"><a href="#2-4-通知（Advice）" class="headerlink" title="2.4 通知（Advice）"></a>2.4 通知（Advice）</h2><p>通知是切面要完成的工作，它定义了切面的<strong>具体实现是什么、何时使用</strong>，描述了切面要完成的工作以及何时执行这个宫欧的问题。Spring切面类中，可以在方法上使用以下注解，会设置方法为通知方法，在满足条件后会通知本方法进行调用：</p>
<ul>
<li>前置通知（@Before）：在目标方法调用之前执行。</li>
<li>后置通知（@After）：在目标方法返回或抛出异常后调用。</li>
<li>返回之后通知（@AfterReturning）：在目标方法返回后调用。</li>
<li>抛异常后通知（@AfterThrowing）：在目标方法抛出异常后调用。</li>
<li>环绕通知（@Around）：通知包裹了目标方法，在被目标方法执行之前和调用之后执行自定义的行为。</li>
</ul>
<h2 id="2-5-图解"><a href="#2-5-图解" class="headerlink" title="2.5 图解"></a>2.5 图解</h2><p>以用户的登录验证为例，用图来让大家更好的理解上述定义体现的思想：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7529c58230662987783f94a3bbd9b2bf2d38bbc7d3e15adcb5a2d5706715333a" alt="Untitled Diagram.drawio-3.png"></p>
<p>接下来我们就来对面向切面编程的思想进行实现，如果看到这还是没有很理解AOP的思想的话，可以结合后面的实现代码再来看看这张图表达的意思。</p>
<ol start="3">
<li><h1 id="Spring-AOP-使用"><a href="#Spring-AOP-使用" class="headerlink" title="Spring AOP 使用"></a>Spring AOP 使用</h1></li>
</ol>
<p>Spring AOP的使用大体分为下面四步：</p>
<ol>
<li>添加 Spring AOP的依赖</li>
<li>连接点方法的编写</li>
<li>定义切面和通知</li>
<li>定义切点</li>
</ol>
<h2 id="3-1-原生Maven项目中Spring-AOP的使用"><a href="#3-1-原生Maven项目中Spring-AOP的使用" class="headerlink" title="3.1 原生Maven项目中Spring AOP的使用"></a>3.1 原生Maven项目中Spring AOP的使用</h2><p><code>Spring AOP</code>同样有两种实现方式，一种是使用xml配置的方式，一种是使用注解的方式。</p>
<p>在这里我将在原生的Maven项目中使用两种方式来实现搭乘地铁的业务，使用AOP的方式编写一个切面，并在切面里运用<strong>五种通知</strong>来实现搭乘地铁业务的<strong>安全检查（前置通知）、刷卡进出站（环绕通知）、通知异常（异常通知）、到达通知（返回后通知）、记录行程（后置通知）</strong></p>
<h3 id="3-1-1-xml方式使用Spring-AOP"><a href="#3-1-1-xml方式使用Spring-AOP" class="headerlink" title="3.1.1 xml方式使用Spring AOP"></a>3.1.1 xml方式使用Spring AOP</h3><blockquote>
<p>源码位置<a href="https://gitee.com/gcm0109/classcode_java/tree/master/java-ee/spring/spring-aop" target="_blank" rel="noopener">：spring-aop</a></p>
</blockquote>
<p><strong>1. 添加依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;5.2.9.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2. 连接点方法的编写：在<code>service</code>包下新建一个<code>SubwayService</code>来实现乘坐地铁的业务</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SubwayService &#123;</span><br><span class="line">    public void takeSubway() &#123;</span><br><span class="line">        System.out.println(&quot;乘坐地铁，行驶中...&quot;);</span><br><span class="line">        //int n = 10/0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 定义切面类和通知方法：在<code>aspect</code>包下新增一个<code>SubwayAspect</code>类，并在里面编写对应的通知方法</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SubwayAspect &#123;</span><br><span class="line">    public void securityCheckAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;前置通知：开始安全检查&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void recordAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;后置通知：记录本次行程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void expressionAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;异常通知：运行过程出现异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void swipeAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;环绕通知start：开始并刷卡进站&quot;);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;环绕通知finish：结束并刷卡出站&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void arriveDestination() &#123;</span><br><span class="line">        System.out.println(&quot;返回后通知：到达目的地&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意事项：<code>swipeAdvice()</code>是环绕通知的方法，由于其是环绕通知，因此会在连接点方法开始前和结束后的时候分别执行不同的逻辑，因此需要使用一个<code>ProceedingJoinPoint</code>的对象来对应连接点的方法，并使用<code>proceed()</code>来执行连接点方法，分别在<code>joinPoint.proceed();</code>语句执行的前后编写编写环绕通知。</p>
<p>光编写完切面和通知还没什么用，还需要在xml文件中配置才行。</p>
<p>配置<code>schema</code>路径，直接复制即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;</span><br><span class="line">       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans</span><br><span class="line">        https://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">        http://www.springframework.org/schema/context</span><br><span class="line">        https://www.springframework.org/schema/context/spring-context.xsd</span><br><span class="line">        http://www.springframework.org/schema/aop</span><br><span class="line">        https://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure>

<p>将类注册到Spring容器中，这一步不多赘述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;bean id=&quot;subwayAspect&quot; class=&quot;com.chenshu.xml_aop.aspect.SubwayAspect&quot;&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=&quot;subwayService&quot; class=&quot;com.chenshu.xml_aop.service.SubwayService&quot;&gt;&lt;/bean&gt;</span><br></pre></td></tr></table></figure>

<p>配置<code>Aspect</code>和<code>Advice</code>：</p>
<ol>
<li>在<code>&lt;beans&gt;</code>标签内添加一对<code>&lt;aop:config&gt;</code>的标签，有关aop的配置都放在这里面</li>
<li>在<code>&lt;aop:config&gt;</code>标签内添加一对<code>&lt;aop:aspect&gt;</code>标签，<code>id属性</code>的值自己定义，用于标识一个切面的<code>id</code>，<code>ref属性</code>里面的值对应前面注册入Spring的<strong>Aspect类的<code>beanid</code></strong></li>
<li>在<code>&lt;aop:aspect&gt;</code>标签内配置通知方法，不同的通知方法对应不同的标签，其中有<code>method属性</code>对应前面编写的通知方法的<strong>方法名</strong>，以及一个<code>pointcut-ref</code>来定义该通知的切点，由于我们的切点还未定义，因此这里用一个”?”替代</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;aop:config&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspect id=&quot;subwayAspect&quot; ref=&quot;subwayAspect&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;securityCheckAdvice&quot; pointcut-ref=&quot;?&quot;/&gt;</span><br><span class="line">        &lt;aop:after method=&quot;recordAdvice&quot; pointcut-ref=&quot;?&quot;/&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;expressionAdvice&quot; pointcut-ref=&quot;?&quot;/&gt;</span><br><span class="line">        &lt;aop:around method=&quot;swipeAdvice&quot; pointcut-ref=&quot;?&quot;/&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;arriveDestination&quot; pointcut-ref=&quot;?&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<p><strong>4. 编写切点：这里我们就要根据切点表达式来创建一个切点用于描述一组匹配规则</strong></p>
<h4 id="【引入】切点表达式"><a href="#【引入】切点表达式" class="headerlink" title="【引入】切点表达式"></a>【引入】切点表达式</h4><p>一个切点表达式就是形如上面<code>expression属性</code>中的内容，切点表达式中可以包括以下内容：</p>
<ul>
<li>execution(表达式前缀)</li>
<li>权限修饰符(如public、private)</li>
<li>方法返回类型(如void、String)</li>
<li>包名</li>
<li>类名</li>
<li>方法名</li>
<li>方法的参数列表</li>
</ul>
<p>下面是一些切点表达式的示例：</p>
<ul>
<li><code>execution(public * com.example.service.SomeService.*(..))</code>：匹配 <code>com.example.service.SomeService</code> 类中所有 <code>public</code> 方法。</li>
<li><code>execution(public void com.example.service.SomeService.*(..))</code>：匹配 <code>com.example.service.SomeService</code> 类中所有 <code>public void</code> 方法。</li>
<li><code>execution(* com.example.service.*.*(..))</code>：匹配 <code>com.example.service</code> 包下所有类的所有方法。</li>
<li><code>execution(* com.example.service.SomeService.*(..))</code>：匹配 <code>com.example.service.SomeService</code> 类的所有方法。</li>
<li><code>execution(* com.example.service.SomeService.*(String))</code>：匹配 <code>com.example.service.SomeService</code> 类中接受一个 <code>String</code> 类型参数的所有方法。</li>
<li><code>execution(* *(..))</code>：匹配任何类中的任何方法。</li>
</ul>
<hr>
<p>了解了切点表达式后我们就可以编写切点了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;aop:pointcut id=&quot;takeSubway&quot; expression=&quot;execution(* com.chenshu.xml_aop.service.SubwayService.takeSubway())&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>该切点的名字为<code>takeSubway</code>，切点表达式的意思是匹配<code>com.chenshu.xml_aop.service.SubwayService</code>这个类下的名为<code>takeSubway</code>且<strong>无传入参数</strong>的方法。</p>
<p>然后我们就可以在通知中填入<code>pointcut-ref属性</code>的值了，完整的aop配置如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut id=&quot;takeSubway&quot; expression=&quot;execution(* com.chenshu.xml_aop.service.SubwayService.takeSubway())&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;aop:aspect id=&quot;subwayAspect&quot; ref=&quot;subwayAspect&quot;&gt;</span><br><span class="line">        &lt;aop:before method=&quot;securityCheckAdvice&quot; pointcut-ref=&quot;takeSubway&quot;/&gt;</span><br><span class="line">        &lt;aop:after method=&quot;recordAdvice&quot; pointcut-ref=&quot;takeSubway&quot;/&gt;</span><br><span class="line">        &lt;aop:after-throwing method=&quot;expressionAdvice&quot; pointcut-ref=&quot;takeSubway&quot;/&gt;</span><br><span class="line">        &lt;aop:around method=&quot;swipeAdvice&quot; pointcut-ref=&quot;takeSubway&quot;/&gt;</span><br><span class="line">        &lt;aop:after-returning method=&quot;arriveDestination&quot; pointcut-ref=&quot;takeSubway&quot;/&gt;</span><br><span class="line">    &lt;/aop:aspect&gt;</span><br><span class="line"></span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>

<p>编写测试类进行测试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class Application &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext context =</span><br><span class="line">                new ClassPathXmlApplicationContext(&quot;spring-aop.xml&quot;);</span><br><span class="line">        SubwayService subwayService  =</span><br><span class="line">                context.getBean(&quot;subwayService&quot;, SubwayService.class);</span><br><span class="line">        subwayService.takeSubway();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="【总结】不同通知的执行顺序"><a href="#【总结】不同通知的执行顺序" class="headerlink" title="【总结】不同通知的执行顺序"></a>【总结】不同通知的执行顺序</h4><p>在没有发生异常的情况下结果如下，通过结果可以了解不同通知的执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码前置通知：开始安全检查</span><br><span class="line">环绕通知start：开始并刷卡进站</span><br><span class="line">乘坐地铁，行驶中...</span><br><span class="line">返回后通知：到达目的地</span><br><span class="line">环绕通知finish：结束并刷卡出站</span><br><span class="line">后置通知：记录本次行程</span><br></pre></td></tr></table></figure>

<p>由于没有出现异常因此看不到抛异常后的通知</p>
<p>制造一个算数异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码public class SubwayService &#123;</span><br><span class="line"></span><br><span class="line">    public void takeSubway() &#123;</span><br><span class="line">        System.out.println(&quot;乘坐地铁，行驶中.。。&quot;);</span><br><span class="line">        int n = 10/0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发生异常的情况下结果如下，通过结果可以了解不同通知的执行顺序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sql复制代码前置通知：开始安全检查</span><br><span class="line">环绕通知start：开始并刷卡进站</span><br><span class="line">乘坐地铁，行驶中...</span><br><span class="line">异常通知：运行过程出现异常</span><br><span class="line">后置通知：记录本次行程</span><br></pre></td></tr></table></figure>

<p>由于方法执行一半就抛出异常，因此没有返回后的通知以及环绕通知的后半段</p>
<h3 id="3-1-2-注解实现使用Spring-AOP"><a href="#3-1-2-注解实现使用Spring-AOP" class="headerlink" title="3.1.2 注解实现使用Spring AOP"></a>3.1.2 注解实现使用Spring AOP</h3><blockquote>
<p>源码位置<a href="https://gitee.com/gcm0109/classcode_java/tree/master/java-ee/spring/spring-aop_2" target="_blank" rel="noopener">：spring-aop_2</a></p>
</blockquote>
<p>谈到<code>Spring AOP</code>的注解，就不得不谈到Spring AOP和AspectJ的关系：Spring AOP 的注解是基于 AspectJ 注解的一种简化和封装。这意味着你可以使用 AspectJ 注解来定义切面，但实际的织入过程是由 Spring AOP 来完成的。</p>
<p>添加依赖和xml方式是一样的，这里就不赘述了。</p>
<p>注解的方式只需要在xml中添加下面两个标签：上面是组件注解的扫描路径，下面是<code>aspectj</code>注解的声明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;context:component-scan base-package=&quot;com.chenshu.aop_annotation&quot;/&gt;</span><br><span class="line">&lt;aop:aspectj-autoproxy/&gt;</span><br></pre></td></tr></table></figure>

<p>编写Aspect类：</p>
<ol>
<li>在<code>Aspect</code>类上添加<code>@Aspect</code>注解</li>
<li>定义一个方法，并在方法上使用<code>@Pointcut</code>注解将其声明一个切点，并在注解内添加<code>value属性</code>的值（切点表达式）</li>
<li>在通知方法上使用<code>@Before</code>（前置通知）、<code>@After</code>（后置通知）、<code>@AfterThrowing</code>（抛异常后通知）、<code>@Around</code>（环绕通知）、<code>@AfterReturning</code>（返回后的通知）注解声明不同类型的通知，并在注解属性中添加上一步定义的切点<code>&quot;myPointcut()&quot;</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class SubwayAspect &#123;</span><br><span class="line">    @Pointcut(value = &quot;execution(* com.chenshu.aop_annotation.service.SubwayService.takeSubway())&quot;)</span><br><span class="line">    private void myPointcut() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;myPointcut()&quot;)</span><br><span class="line">    public void securityCheckAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;前置通知：开始安全检查&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After(&quot;myPointcut()&quot;)</span><br><span class="line">    public void recordAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;后置通知：记录本次行程&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterThrowing(&quot;myPointcut()&quot;)</span><br><span class="line">    public void expressionAdvice() &#123;</span><br><span class="line">        System.out.println(&quot;异常通知：运行过程出现异常&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Around(&quot;myPointcut()&quot;)</span><br><span class="line">    public void swipeAdvice(ProceedingJoinPoint joinPoint) throws Throwable &#123;</span><br><span class="line">        System.out.println(&quot;环绕通知start：开始并刷卡进站&quot;);</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">        System.out.println(&quot;环绕通知finish：结束并刷卡出站&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning(&quot;myPointcut()&quot;)</span><br><span class="line">    public void arriveDestination() &#123;</span><br><span class="line">        System.out.println(&quot;返回后通知：到达目的地&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-2-Spring-Boot项目中Spring-AOP的使用"><a href="#3-2-Spring-Boot项目中Spring-AOP的使用" class="headerlink" title="3.2 Spring Boot项目中Spring AOP的使用"></a>3.2 Spring Boot项目中Spring AOP的使用</h2><blockquote>
<p>源码位置<a href="https://gitee.com/gcm0109/classcode_java/tree/master/blog-demo/MyBatis_demo" target="_blank" rel="noopener">：MyBatis_demo</a></p>
</blockquote>
<p>这里我直接基于上一篇文章中的代码来演示Spring AOP的使用。</p>
<p><strong>1. 添加依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xml复制代码&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>2. 新建一个<code>aspect</code>包编写切面类<code>LoginAspect</code>：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java复制代码@Component</span><br><span class="line">@Aspect</span><br><span class="line">public class LoginAspect &#123;</span><br><span class="line">    @Pointcut(&quot;execution(* com.chenshu.mybatis_demo.controller.UserController.*(..))&quot;)</span><br><span class="line">    public void myPointcut() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    @Before(&quot;myPointcut()&quot;)</span><br><span class="line">    public void before() &#123;</span><br><span class="line">        System.out.println(&quot;进行登录验证&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3. 测试切面是否生效：</strong></p>
<p>由于我编写的切面中的前置方法对所有<code>UserController</code>类下的方法都生效，这里我直接访问一下<code>UserController</code>中<code>getUsers</code>方法的路由<code>&quot;/getall&quot;</code></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e10c7933d4067bb959314b3ad2b0a4d793a388cf86e5c0ef79ac4402848a3ca6" alt="image.png"></p>
<p>查看日志信息：我们发现在执行<code>getUsers()</code>方法之前成功执行了前置通知</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yaml复制代码进行登录验证</span><br><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@3e84be0f] was not registered for synchronization because synchronization is not active</span><br><span class="line">2024-04-20 17:07:40.813  INFO 40289 --- [nio-8080-exec-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...</span><br><span class="line">2024-04-20 17:07:40.890  INFO 40289 --- [nio-8080-exec-1] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.</span><br><span class="line">JDBC Connection [HikariProxyConnection@212054083 wrapping com.mysql.cj.jdbc.ConnectionImpl@3ef56d86] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: select * from userinfo</span><br><span class="line">==&gt; Parameters: </span><br><span class="line">&lt;==    Columns: id, username, password, photo, createtime, updatetime, state</span><br><span class="line">&lt;==        Row: 1, zhang, 12345, doge.png, 2024-04-19 13:09:45, 2024-04-19 13:09:45, 1</span><br><span class="line">&lt;==        Row: 2, lisi, 123, , 2024-04-19 13:31:01, 2024-04-19 13:31:01, 1</span><br><span class="line">&lt;==        Row: 3, wangwu, 123, , 2024-04-19 14:17:29, 2024-04-19 14:17:29, 1</span><br><span class="line">&lt;==      Total: 3</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359577911990517795" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Spring Boot,Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>golang 的 deadline/timeout（超时）</title>
    <url>/7359510792343584777.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>golang 的 deadline/timeout（超时） 弹性模式。</p>
</blockquote>
<p>创建 deadline 只需一个参数：等待的时间。</p>
<p>💡 前几天发布后，发现末尾的地方，写得不是很清楚，于是删掉了，今天补充后，重新进行发布</p>
<p>仓库给的使用例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码dl := deadline.New(1 * time.Second)</span><br><span class="line"></span><br><span class="line">err := dl.Run(func(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	// do something potentially slow</span><br><span class="line">	// give up when the `stopper` channel is closed (indicating a time-out)</span><br><span class="line">	// 做一些可能很慢的事情</span><br><span class="line">	// 当 `stopper` 通道关闭（表示超时）时放弃</span><br><span class="line">	return nil</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">switch err &#123;</span><br><span class="line">case deadline.ErrTimedOut:</span><br><span class="line">	// execution took too long, oops</span><br><span class="line">	// 执行时间太长了</span><br><span class="line">default:</span><br><span class="line">	// some other error</span><br><span class="line">	// 其他错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 New 函数，新建一个超时器,传入的参数，是所期待的超时时长</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码func New(timeout time.Duration) *Deadline &#123;</span><br><span class="line">	return &amp;Deadline&#123;</span><br><span class="line">		timeout: timeout,</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>然后调用超时器的 Run 方法即可，在运行时间超出所期待的超时时长就会退出，返回 <code>ErrTimedOut</code> 的错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码// ErrTimedOut is the error returned from Run when the deadline expires.</span><br><span class="line">var ErrTimedOut = errors.New(&quot;timed out waiting for function to finish&quot;)</span><br><span class="line"></span><br><span class="line">// Run runs the given function, passing it a stopper channel. If the deadline passes before</span><br><span class="line">// the function finishes executing, Run returns ErrTimeOut to the caller and closes the stopper</span><br><span class="line">// channel so that the work function can attempt to exit gracefully. It does not (and cannot)</span><br><span class="line">// simply kill the running function, so if it doesn&apos;t respect the stopper channel then it may</span><br><span class="line">// keep running after the deadline passes. If the function finishes before the deadline, then</span><br><span class="line">// the return value of the function is returned from Run.</span><br><span class="line">// Run 运行给定函数，并传递给它一个 stopper 通道。如果在 </span><br><span class="line">// 函数执行完毕之前截止时间已过，Run 会向调用者返回 ErrTimeOut，并关闭 stopper </span><br><span class="line">// 通道，以便工作函数可以优雅地退出。它不会（也不能） </span><br><span class="line">// 简单地杀死正在运行的函数，因此如果它不尊重 stopper 通道，那么它可能 </span><br><span class="line">// 在截止日期过后继续运行。如果函数在截止日期前结束，那么 </span><br><span class="line">// 函数的返回值将从 Run 返回。</span><br><span class="line">func (d *Deadline) Run(work func(&lt;-chan struct&#123;&#125;) error) error &#123;</span><br><span class="line">	result := make(chan error)</span><br><span class="line">	stopper := make(chan struct&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	go func() &#123;</span><br><span class="line">		value := work(stopper)</span><br><span class="line">		select &#123;</span><br><span class="line">		case result &lt;- value:</span><br><span class="line">		case &lt;-stopper:</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;()</span><br><span class="line"></span><br><span class="line">	select &#123;</span><br><span class="line">	case ret := &lt;-result:</span><br><span class="line">		return ret</span><br><span class="line">	case &lt;-time.After(d.timeout):</span><br><span class="line">		close(stopper)</span><br><span class="line">		return ErrTimedOut</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试用例所要执行的 work 函数定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码func takesFiveMillis(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	time.Sleep(5 * time.Millisecond)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func takesTwentyMillis(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	time.Sleep(20 * time.Millisecond)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func returnsError(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	return errors.New(&quot;foo&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出我们要执行的函数的参数都必须是 chan 类型，然后定义的字段名是 stopper，其实定义为其他字段名也是一样的</p>
<p>如果只是想简单地将我们执行的函数超时就不执行了，那么直接定义完相应的执行函数和新建超时器进行执行即可，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码func takesFiveMillis(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	time.Sleep(5 * time.Millisecond)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func takesTwentyMillis(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	time.Sleep(20 * time.Millisecond)</span><br><span class="line">	return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func returnsError(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">	return errors.New(&quot;foo&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func TestDeadline(t *testing.T) &#123;</span><br><span class="line">	dl := New(10 * time.Millisecond)</span><br><span class="line"></span><br><span class="line">	if err := dl.Run(takesFiveMillis); err != nil &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	if err := dl.Run(takesTwentyMillis); err != ErrTimedOut &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是如果你想在超时后执行一些操作，那么就可以利用我们执行函数的传入 stopper 参数，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go复制代码dl := New(10 * time.Millisecond)</span><br><span class="line">done := make(chan struct&#123;&#125;)</span><br><span class="line">	err := dl.Run(func(stopper &lt;-chan struct&#123;&#125;) error &#123;</span><br><span class="line">		&lt;-stopper</span><br><span class="line">		// 可以在这里执行在超时后,进行的一些处理</span><br><span class="line">		close(done)</span><br><span class="line">		return nil</span><br><span class="line">	&#125;)·</span><br><span class="line">	if err != ErrTimedOut &#123;</span><br><span class="line">		t.Error(err)</span><br><span class="line">	&#125;</span><br><span class="line">	&lt;-done</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里有一个大家可能会很疑惑的点，就是超时之后，Run 函数不应该是立即退出了吗？其实是的，超时之后就立即退出了，但是我们的 work 函数执行的时候是用协程去执行的，所以我们的 work 还是在执行中，</p>
<p>所以就需要 done 通道，去判断 work 函数是否执行完了，否则这个测试用例就直接退出了， 为了我这里说的是否正常，我们将测试用例注释相应的改动：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c1f281f0319d6343999bb6a14cbc874cd0dc2598cd9d07886d55bd1fa054a8b5" alt="Untitled.png"></p>
<p>查看执行结果后，可以看出我这里所说的是正确的</p>
<p>这里大家可能还有一个疑惑点，就是我们这里的 stopper 阻塞在这里，那么超时之后，不是就进行关闭了吗？</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1971b834a759e7d58f103898e1c0860626bee3fd7849b8e7fcf6fe12569a8651" alt="Untitled 1.png"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6e013fb431e844fffbb337556a76668fe26aed7fb85530b5a6987c4decf5cfd7" alt="Untitled 2.png"></p>
<p>这里就设计到 channel 的知识点了，读已经关闭的 channel 进行读操作的时候，依然是可以读的，我们这里的 stopper 是无缓冲区的 channel，那么读出来的就是相应类型的零值，但是如果是有缓存区的呢？如果关闭前，有缓存区的 channel 里面有数据，我们仍然能读出来，读到没有数据的时候，再读就是相应类型的零值。</p>
<p>这里我们引申一下，如果去写已经关闭的缓存区呢？这种情况就会 <strong>panic:send on closed channel</strong> 的情况，对于有无缓冲区的 channel 都是一样的结果</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359510792343584777" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,源码</tag>
      </tags>
  </entry>
  <entry>
    <title>一次线上 update SQL调优分享</title>
    <url>/7359490238416257062.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>这几周系统访问量也是居高不下，不出意外系统又出现瓶颈了，大量用户反馈判题结果响应太慢；经排查，又是关于SQL的问题</p>
<h3 id="业务背景"><a href="#业务背景" class="headerlink" title="业务背景"></a>业务背景</h3><p>一个类似于<strong>力扣在线做题</strong>的代码评测模块，用户提交判题任务后，后台会进行异步判题，前端会轮询判题结果，如下图</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9d3d570ae6e7053c98125926ed0ab82cad2434c7dd95b9710f48cf73ccb1f7b5" alt="image-20240419232745256"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/49c8089ddadd760f283a60361c937bb1b89f5709b47f64e26fbb81ae422174b1" alt="image-20240419233755841"></p>
<h3 id="线上问题"><a href="#线上问题" class="headerlink" title="线上问题"></a>线上问题</h3><p>大量的用户在前端提交后，一直都轮询不到判题结果。经代码排查，发现问题就出现在<strong>判题结果写库逻辑</strong>，耗时竟然有1s多。</p>
<p>而我们的判题结果写库 分为两个步骤</p>
<ol>
<li>更新 这道题的提交数量，正确率等等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码 可以简单理解为       </span><br><span class="line"> update  xxxx  where  topic_id = xxx</span><br><span class="line"> ​</span><br><span class="line"> //topic_id是索引</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>将用户的判题结果写库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua复制代码 逻辑较多，可以理解为多次insert，和用户维度的update.</span><br></pre></td></tr></table></figure>

<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>查看方法调用日志， 发现 第一个步骤（更新这道题的提交数，正确率）占据了80%的耗时。</p>
<p>当我们 <code>update xxxx where topic_id = xxx</code>时，MySQL会对topic_id 索引加<code>行锁</code>，由于第一个步骤和第二个步骤又在同一个事务。</p>
<p>当高并发时，用户做题是多对一的关系，大量用户可能都在写一道题，造成题目ID的行锁竞争激烈，<strong>更新题目提交数、正确率的行锁在更新玩之后不会释放；还需等待第二步，将结果写库完后（等事务执行完后）。这样行锁的无效持有时间或者叫行锁的持有粒度就增加了。</strong></p>
<h3 id="解决问题"><a href="#解决问题" class="headerlink" title="解决问题"></a>解决问题</h3><p>按问题解决，直接减小行锁的粒度。</p>
<p>将1、2两个步骤交换下顺序。交换后逻辑变为：</p>
<ol>
<li>将用户的判题结果写库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lua复制代码 逻辑较多，可以理解为多次insert，和用户维度的update.</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新 这道题的提交数量，正确率等等</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bash复制代码 可以简单理解为       </span><br><span class="line"> update  xxxx  where  topic_id = xxx</span><br><span class="line"> ​</span><br><span class="line"> //topic_id是索引</span><br></pre></td></tr></table></figure>

<p>你可以简单的理解为 <strong>原先老逻辑是 先update，再insert。现在是先insert再update</strong>；这样行锁的持有粒度就降低了。</p>
<p>经此一役，判题结果写库的逻辑从原来的 400TPS直接拉高到2000多TPS！！！</p>
<h3 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h3><p>再总结一下，本篇通过线上判题结果的业务逻辑 分享SQL读写的调优小技巧，先insert再update，可以降低行锁的粒度，提高TPS。</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359490238416257062" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,MySQL,数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>八股复习Day 4redis 基本知识总结 基本概念 基本</title>
    <url>/7359821247675498531.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>Redis 是我们常用的存储中间件,全称为 <strong>RE</strong>mote <strong>DI</strong>ctionary <strong>S</strong>erver，是一个基于 C 语言开发的开源 NoSQL 数据库（BSD 许可）。</p>
<p>与传统数据库不同的是，Redis 的数据是保存在内存中的（内存数据库，支持持久化），因此读写速度非常快，被广泛应用于分布式缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6c74b286bb7ff1c3f635d28e5ef79b179d52559af5f2a8aef2cb5b1603d54977" alt="image.png"><br>Redis是个单线程模型(Ps.单线程指的是 Redis 键值对读写指令的执行是单线程)，在内存中运算;</p>
<ul>
<li>为什么使用单线程模型呢：CPU 不是 Redis 的瓶颈，Redis 的瓶颈最有可能是机器内存的大小或者网络带宽，所以使用单线程已经完全足够了并且可以减少切换带来的损耗</li>
</ul>
<p>对于上游的客户端请求，Redis 采用了IO多路复用的原理，</p>
<ul>
<li>Redis 会给每一个客户端套接字都关联一个指令队列，客户端的指令队列通过队列排队来进行顺序处理；</li>
<li>同时 Reids 给每一个客户端的套件字关联一个响应队列，Redis 服务器通过响应队列来将指令的接口返回给客户端(基于reactor的事件分发机制，分开独立处理不同的事件)。</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ec2a003d82f78f95c6c5fa0b730787d9d35be6f073738759d4dd05bd4105c398" alt="image.png"></p>
<h1 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h1><p>1、string 即字符串类型，一般用于常规计数、分布式锁、共享 session 信息等</p>
<p>2、list 即链表类型（插入删除效率高，查询效率低），常用于做异步队列，消息队列(lpush,rpop)等</p>
<p>3、set 一个无序map，适合用于去重场景，相比于hash map,set只有key,没有value</p>
<p>4、hash,就是我们理解的哈希表，有key 有value</p>
<p>5、zset 即有序列表，有score字段，可用于做延时队列，排序场景等</p>
<p>每种数据结构的底层实现一般有多种方式，对于旧版本的list,hash,zset，在数据量小的时候会使用压缩表实现，这个数据量怎么衡量呢</p>
<ul>
<li>每个元素的长度小于64字节</li>
<li>一个对象包含的元素小于512个(跳表是128)</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e07fdc36df155008cefb4b6cb6885de04ccd55a648445231731dcd7019862077" alt="image.png"></p>
<h2 id="压缩列表-zipList"><a href="#压缩列表-zipList" class="headerlink" title="压缩列表(zipList)"></a>压缩列表(zipList)</h2><p>压缩列表(zipList) 实际上是利用数组来实现的链表，他的优点是结构紧凑占用内存少，连续内存读写快，但缺点是，频繁增加导致realoc重新分配内存，消耗性能。</p>
<p>而双向链表的特点是需要存储前后指针（浪费一定空间），增加删除、删除结点不用内存重分配，但缺点是存储的内存非连续，读写性能偏低，并且容易造成内存碎片。</p>
<p>先看看zipList的结构</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/25e78fad92bf3c024cd3f3fb8d351752b036e4d8e8e956f0f141cb4b2b14fe13" alt="image.png"></p>
<p>一块连续的内存空间 (像内存连续的数组，但每个元素长度不同)，一个 ziplist 可以包含多个节点（entry）。元素之间紧挨着存储，没有任何冗余空隙。</p>
<ul>
<li><strong>zlbytes：</strong> 记录整个压缩列表占用对内存字节数；</li>
<li><strong><em>zltail：</em></strong> 记录压缩列表「尾部」节点距离起始地址由多少字节，也就是列表尾的偏移量；</li>
<li><strong><em>zllen：</em></strong> 记录压缩列表包含的节点数量；</li>
<li><strong><em>zlend：</em></strong> 标记压缩列表的结束点，固定值 0xFF（十进制255）。</li>
</ul>
<p>有这个头部，让压缩表找头元素和尾元素非常快 O(1)，但其他元素就是 O(N)了，所以不适合存储大量元素。</p>
<p>对于每个entry，其架构如图</p>
<p>PS.因为每一项数据占用的空间不同，而采用了变长编码</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/93364fb7ff4c6ed1809b2252eae08e57b868ed2d8702796133ecc7e3735b11eb" alt="image.png"></p>
<ul>
<li><strong><em>prevlen：</em></strong> 记录了「前一个节点」的长度，目的是为了实现从后向前遍历；</li>
</ul>
<pre><code>+ 如果前结点小于254字节，则entry中prelength占用1个字节来记录，如果大于等于254，prelength占用5个字节，第一字节固定254，后4个字节表示大小</code></pre><ul>
<li><strong><em>data：</em></strong> 记录了当前节点的实际数据，类型和长度都由 <code>encoding</code> 决定；</li>
<li><strong><em>encoding：8位，</em></strong> 记录了当前节点实际数据的「类型和长度」，类型主要有两种：字符串和整数;</li>
</ul>
<pre><code>+ 对于整数类型，encoding 11开头，分别对应不同类型的data类型
+ 最后1111xxxx表示超小数0-12。0000，1110，1111被占掉了，xxxx可以表示1-13，实际表示的值再-1。</code></pre><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5ea3c5870e052c6e5b0855abfdbb70e9b94c8e83c65bc01f4f58edc651144b83" alt="image.png"></p>
<ul>
<li>对于字符类型，图中pppqqqrrrsssttt都是用来表示字符串大小的</li>
</ul>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/93e398ce502f15e8d1606a38e33f527e231faf5848406e08d266ebecf396f057" alt="image.png"></p>
<h2 id="快速链表QuickList"><a href="#快速链表QuickList" class="headerlink" title="快速链表QuickList"></a>快速链表QuickList</h2><p>但就如前面所说，这种结构和链表各有优劣，在新版的redis中通过quickList来实现List</p>
<p>quickList结合了二者的优点，每个节点都是一个双向链表节点，但每个节点又指向一个压缩表，分段压缩，避免单个压缩表太大。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3bb6e140f805fff3a99a5c31a7c1af958ff2b6e54c7c57e8e0a12311d8bb5ddd" alt="image.png"></p>
<h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>Redis 只有 Zset 对象的底层实现用到了跳表，跳表的优势是能支持平均 O(logN) 复杂度的节点查找。</p>
<p>简单理解，跳表就是一个多层的链表</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/522771f8263382d560583143c8f80d3e31fbf9577908322abc3d311f22349dc4" alt="image.png"><br>链表在查询时，需要逐个遍历节点，所以复杂度时O(N);但是我们如果每隔几个元素抽一个元素组成第二层链表，则可以少遍历部分元素(前提，链表是有序的)</p>
<p>至于为什么使用跳表而不是我们熟悉的平衡树等结构呢，网上给的答案是：</p>
<p>1、跳表实现简单，平衡树涉及到插入时树的调整旋转，比较复杂，跳表只需要改变左右指针</p>
<p>2、btree这类结构为了迎合磁盘io的特性设计，内存占用会比跳表大</p>
<p>3、反过来，跳表的层级会比btree深(取决于抽取上一级的比例)—这是为什么mysql用b+树</p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>Redis一般使用场景除了用于缓存，还可以做</p>
<p>1、布隆过滤器</p>
<p>2、分布式锁</p>
<h1 id="持久化方式"><a href="#持久化方式" class="headerlink" title="持久化方式"></a>持久化方式</h1><p>Redis 的读写操作都是在内存中，所以 Redis 性能才会高，但是当 Redis 重启后，内存中的数据就会丢失，那为了保证内存中的数据不会丢失，Redis 实现了数据持久化的机制，这个机制会把数据存储到磁盘，这样在 Redis 重启就能够从磁盘中恢复原有的数据。</p>
<p>Redis 共有三种数据持久化的方式：</p>
<ul>
<li>RDB:RDB 是对当前 Redis 的存储数据进行一次快照</li>
<li>AOF每执行一条写操作命令，就把该命令以追加的方式写入到一个文件里日志只记录</li>
<li>混合持久化</li>
</ul>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9a2980055b0a1d2b23a7d9cd8e4c9bf0a508a3d9e9cdb97d03ab024f08d50196" alt="image.png"><br>Redis客户端在每执行完一条写命令之后，会记录命令到AOF文件中，这样redis宕机重启后就可以基于文件恢复数据。</p>
<ul>
<li>执行完再写的好处:1、不阻塞命令执行，2、避免语法有问题</li>
</ul>
<p>实际上，命令并不是每次都直接sync到磁盘上的，而是先写到缓冲区(aof_buf)，然后写到内核的pageCache内核缓存区中，由内核决定每隔一段时间同步到磁盘上，这个操作叫<strong>写回</strong>。写回有几种策略：</p>
<ul>
<li><strong>Always</strong>，每次写操作命令执行完后，同步将 AOF 日志数据写回硬盘；(可靠性高，开销大)</li>
<li><strong>Everysec</strong>，每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，然后每隔一秒将缓冲区里的内容写回到硬盘；</li>
<li><strong>No</strong>，意味着不由 Redis 控制写回硬盘的时机，转交给操作系统控制写回的时机，也就是每次写操作命令执行完后，先将命令写入到 AOF 文件的内核缓冲区，再由操作系统决定何时将缓冲区内容写回硬盘。（性能开销小，可靠性不高，容易丢数据）</li>
</ul>
<p>因为每个写命令都要追加到文件中，导致AOF文件会越来越大(但其实同一个key只有后面的命令有效，覆盖了前面的值)，为了解决这个问题，redis提供了<strong>重写</strong>的机制。当 AOF 文件的大小超过所设定的阈值后，Redis 就会启用 AOF 重写机制，来压缩 AOF 文件。</p>
<p>简单来说，AOF 重写机制就是读取当前数据库中的所有键值对，然后将每一个键值对用一条命令记录到「新的 AOF 文件」，等到全部记录完后，就将新的 AOF 文件替换掉现有的 AOF 文件。这样一来，一个键值对在重写日志中只用一条命令就行了。</p>
<p>重写的流程：</p>
<p>1、主进程(<strong><em>bgrewriteaof</em></strong>)fork一个子进程进行重写</p>
<p>2、重写过程中，主进程仍然可以提供服务</p>
<p>3、父子进程共享一份数据副本，只有当主进程写缓存时，会触发COW（copy on write）机制，复制一份数据副本（节约资源，高效，也不需要通过加锁来保证数据正确性）</p>
<p>4、主进程的命令会写入到AOF 重写冲区</p>
<p>5、子进程按上面的逻辑去读数据，写新AOF文件</p>
<p>6、子进程完成后，给主进程发一条信号， AOF 重写缓冲区中的所有内容追加到新的 AOF 的文件中，使得新旧两个 AOF 文件所保存的数据库状态一致；</p>
<p>7、 新的 AOF 的文件进行改名，覆盖现有的 AOF 文件。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5f028269d52e4f8d3102798491ebc777de80cabf6c95205dfb0b479a9b8d729a" alt="image.png"><br>缺陷：AOF 日志记录的是操作命令，不是实际的数据，所以用 AOF 方法做故障恢复时，需要全量把日志都执行一遍，一旦 AOF 日志非常多，势必会造成 Redis 的恢复操作缓慢。</p>
<h2 id="RDB-快照"><a href="#RDB-快照" class="headerlink" title="RDB 快照"></a><strong>RDB 快照</strong></h2><p>为了解决AOF的问题，Redis 增加了 RDB 快照。</p>
<p>RDB 快照就是记录某一个瞬间的内存数据，记录的是实际数据，而 AOF 文件记录的是命令操作的日志，而不是实际的数据。</p>
<p>因此在 Redis 恢复数据时， RDB 恢复数据的效率会比 AOF 高些，因为直接将 RDB 文件读入内存就可以，不需要像 AOF 那样还需要额外执行操作命令的步骤才能恢复数据。</p>
<p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave，他们的区别就在于是否在「主线程」里执行：</p>
<ul>
<li>执行了 save 命令，就会在主线程生成 RDB 文件，由于和执行操作命令在同一个线程，所以如果写入 RDB 文件的时间太长，<strong>会阻塞主线程</strong>；</li>
<li>执行了 bgsave 命令，会创建一个子进程来生成 RDB 文件，这样可以<strong>避免主线程的阻塞(同样利用COW机制)</strong> ；</li>
</ul>
<h1 id="过期机制和内存淘汰机制"><a href="#过期机制和内存淘汰机制" class="headerlink" title="过期机制和内存淘汰机制"></a>过期机制和内存淘汰机制</h1><p>redis 有的key是有生命周期的，对于这类key的过期机制有：</p>
<ul>
<li>惰性删除：Redis不会去主动删除，而是在客户端要获取某个key的时候，Redis会先去检测一下这个key是否已经过期，如果没有过期则返回给客户端，如果已经过期了，那么Redis会删除这个key，不会返回给客户端。</li>
<li>定期删除：Redis默认每隔一段时间就<strong>随机抽取</strong>一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。</li>
</ul>
<p>Redis在使用内存达到某个阈值的时候，就会触发内存淘汰机制，选取一些key来删除。内存淘汰有许多策略如</p>
<ul>
<li>random 随机</li>
<li>LRU 最近最少使用</li>
<li>LFU 最少使用</li>
</ul>
<h1 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h1><ul>
<li>主从复制：redis 支持主从复制模式来提供高可用的性能(主写从读)，但是无法实现强一致性保证（主从数据时时刻刻保持一致），数据不一致是难以避免的。</li>
<li>哨兵模式：主从模式下，如果主宕机了，需要手动恢复；哨兵模式时为了解决这问题，</li>
</ul>
<pre><code>+ Sentinel 集群是一个由 3-5 个（可以更多）节点组成的，用来监听整个 Redis 的集群，如果发现 master 不可用的时候，会关闭和断开全部的与 master 相连的旧链接。这个时候 Sentinel 会完成选举和故障转移，新的请求则会转到新到 master 中.
+ 哨兵是 Redis 的一种运行模式，它专注于对 Redis 实例(主节点、从节点)运行状态的监控，并能够在主节点发生故障时通过一系列的机制实现选主及主从切换，实现故障转移，确保整个 Redis 系统的可用性。</code></pre><ul>
<li>集群（cluster）模式：Redis 集群通过槽指派机制来决定写命令应该被分配到那个节点。整个集群对应的槽是由 <strong>16384</strong> 大小的二进制数组组成，集群中每个主节点分配一部分槽，每条写命令落到二进制数组中的某个位置，该位置被分配给了哪个节点，则对应的命令就由该节点去执行。(连接时要指定集群模式)</li>
<li>codis：在redis前面加了一层类似proxy角色的代理</li>
</ul>
<h1 id="缓存更新策略"><a href="#缓存更新策略" class="headerlink" title="缓存更新策略"></a>缓存更新策略</h1><ul>
<li>Cache Aside（旁路缓存）策略：</li>
</ul>
<pre><code>+ 写：先更新数据库，再删缓存（先删再写容易数据不一致）
+ 读：从db读到后更新缓存
+ **适合读多写少的场景，不适合写多的场景**，因为当写入比较频繁时，缓存中的数据会被频繁地清理，这样会对缓存的命中率有一些影响。</code></pre><ul>
<li>Read/Write Through（读穿 / 写穿）策略：先写缓存，然后由缓存写db</li>
<li>Write Back（写回）策略：</li>
</ul>
<pre><code>+ Write Back 是计算机体系结构中的设计，比如 CPU 的缓存、操作系统中文件系统的缓存都采用了 Write Back（写回）策略。
+ **Write Back 策略特别适合写多的场景**，因为发生写操作的时候， 只需要更新缓存，就立马返回了。比如，写文件的时候，实际上是写入到文件系统的缓存就返回了，并不会写磁盘。
+ 容易丢数据</code></pre><h1 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h1><p>大key问题：</p>
<ul>
<li>阻塞导致redis变慢</li>
</ul>
<p>缓存击穿，雪崩，穿透是什么以及如何解决：</p>
<ul>
<li>击穿：热点key过期，导致请求直接打到db，容易将db打挂</li>
</ul>
<pre><code>+ 解决办法：1、分布式锁，只有一个请求可以打到db，2、业务逻辑续期，避免过期</code></pre><ul>
<li>雪崩：大量热点key同时过期，请求直接打到db</li>
</ul>
<pre><code>+ 解决办法：过期时间随机化，避免同时过期</code></pre><ul>
<li>穿透：数据既不在缓存又不在db，缓存无法起到作用</li>
</ul>
<pre><code>+ 解决办法：1、布隆过滤器 2、设置redis空值或致默认值，避免大量请求查db 3、限制非法请求(避免恶意请求一些不合法数据)</code></pre><p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359821247675498531" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Go,Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>python把c扩展模块打包成免编译且可pip instal</title>
    <url>/7359577911990566947.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>python用c语言编写的扩展模块，在setup.py sdist或者bdist打包时，默认是把c源码编译进去，在pip install的时候先编译再安装的，即使我把so加到了MANIFEST.in文件中，查看编出来的包里包含了so，但是仍然不会进行so的安装。搜索查阅了一下，没有找到相关的文章可以解决这个问题。因此只能自己通过debug研究python-prctl的安装流程，把相关的流程走通了。总结记录一下：</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>首先说明一下背景：</p>
<p>我们的业务逻辑有一部分需要使用c语言来写，这部分c语言写的代码只能在特定的编译机上编译成.so，我们使用的python版本统一定为python3.8。因此我编写了一个python的c扩展模块，并对底层c接口进行了相应的python函数包装，在使用的时候，需要放到内网pip源，用pip install的方式安装。所有使用人的os版本、python版本都是一致的，且没有编译需要的相关文件。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h3><p>由于时间比较紧，所以没有详细研究pip install的流程，python-prctl这个模块的项目结构和我们的类似，不同的是它是pip install的时候先编译再安装的，因此用它当作例子来学习。</p>
<p>在pycharm上配置ssh远程解释器，然后配置执行方式：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c63cd5892d3c9a7a19b6fbb6f8eee30ee9c8473db5fa7ff4aad2a3c9414ecd8" alt="image.png"></p>
<h3 id="一些简单观察到的流程（没有实际看完整流程，只是靠debug和猜测推断了下）"><a href="#一些简单观察到的流程（没有实际看完整流程，只是靠debug和猜测推断了下）" class="headerlink" title="一些简单观察到的流程（没有实际看完整流程，只是靠debug和猜测推断了下）"></a>一些简单观察到的流程（没有实际看完整流程，只是靠debug和猜测推断了下）</h3><h4 id="pip-install的流程"><a href="#pip-install的流程" class="headerlink" title="pip install的流程"></a>pip install的流程</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码1. egg_info</span><br><span class="line">2. install</span><br><span class="line">    1) build</span><br><span class="line">        a) build_py</span><br><span class="line">        b) build_clib</span><br><span class="line">        c) build_ext</span><br><span class="line">        d) build_scripts</span><br><span class="line">    2) install_lib</span><br><span class="line">    3) install_egg_info</span><br><span class="line">    3) install_scripts</span><br></pre></td></tr></table></figure>

<p>编译的.so，会拷贝到build/lib.linux-x86_64-3.8目录</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h3><p>经过多次踩坑（一直不安装so，甚至改install命令自己把so拷贝到site-packages，但是uninstall时又不会卸载等等），最终确定一个实现的思路，虽然不编译，但是在build_ext的流程中，把对应的so拷贝到build/lib.linux-x86_64-3.8目录，让后续的安装流程能够正常安装进行，这样后面的流程能够正常的把so拷贝到site-packages目录，且卸载时正常删除。这样对原流程的改动最小，影响也最少。</p>
<h3 id="build-ext命令的定制"><a href="#build-ext命令的定制" class="headerlink" title="build_ext命令的定制"></a>build_ext命令的定制</h3><p>我们的业务工程代码，对于Makefile有整体的封装，怎么搜索头文件，怎么搜索lib库都有封装，我们想要调用这些封装的内容来去找我们的依赖模块，这样我们依赖的模块有修改的话，该模块不用修改。所以不能在setup.py中写死include目录及libraries。因此对build_ext做一些定制。把include目录、链接的.a文件、源码通过Makefile传递进去。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setup.py复制代码class my_build_ext(build_ext):</span><br><span class="line">    user_options = build_ext.user_options</span><br><span class="line">    user_options.extend([</span><br><span class="line">        (&apos;extra-objects=&apos;, None, &quot;list of extra_objects&quot;),</span><br><span class="line">        (&apos;sources=&apos;, None, &quot;list of sources&quot;)</span><br><span class="line">    ])</span><br><span class="line"></span><br><span class="line">    def initialize_options(self):</span><br><span class="line">        super(my_build_ext, self).initialize_options()</span><br><span class="line">        self.extra_objects = None</span><br><span class="line">        self.sources = None</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        include_dirs = []</span><br><span class="line">        for include_dir in self.include_dirs:</span><br><span class="line">            include_dirs.extend(include_dir.split())</span><br><span class="line">        self.include_dirs = include_dirs</span><br><span class="line"></span><br><span class="line">        for extension in self.extensions:</span><br><span class="line">            if self.sources:</span><br><span class="line">                extension.sources = self.sources.split()</span><br><span class="line">                if self.extra_objects:</span><br><span class="line">                    extension.extra_objects = self.extra_objects.split()</span><br><span class="line">        super(my_build_ext, self).run()</span><br></pre></td></tr></table></figure>

<h3 id="setup-py的定制"><a href="#setup-py的定制" class="headerlink" title="setup.py的定制"></a>setup.py的定制</h3><p>根据实现思路的描述，这里主要处理pip install的时候的流程，跳过编译阶段，直接把so拷贝到build目录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ruby复制代码def build_extensions(self):</span><br><span class="line">    if not self.sources:</span><br><span class="line">        # 没有传sources 说明是pip install, 跳过编译阶段, 直接把包里面的so拷贝到build目录</span><br><span class="line">        for extension in self.extensions:</span><br><span class="line">            # 找编译的目标目录</span><br><span class="line">            ext_path = self.get_ext_fullpath(extension.name)</span><br><span class="line">            ext_name = os.path.basename(ext_path)</span><br><span class="line">            ext_dir = os.path.dirname(ext_path)</span><br><span class="line">            mkpath(ext_dir, 0o777, dry_run=0)</span><br><span class="line">            copy_file(ext_name, ext_dir)</span><br><span class="line">        return</span><br><span class="line">    # build</span><br><span class="line">    super(my_build_ext, self).build_extensions()</span><br></pre></td></tr></table></figure>

<h3 id="makefile编写"><a href="#makefile编写" class="headerlink" title="makefile编写"></a>makefile编写</h3><p>在定义make all和make clean</p>
<p>make all时，先调用setup.py build_ext把so编译出来，然后拷贝到当前目录，最后调用setup.py sdist编译为可pip安装的包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">makefile复制代码all:</span><br><span class="line">   python3.8 setup.py build_ext --include-dirs=&quot;include&quot; --sources=&quot;_sample_extension_mod.c&quot;</span><br><span class="line">   \cp build/lib.linux-x86_64-3.8/_sample_extension_mod.cpython-38-x86_64-linux-gnu.so .</span><br><span class="line">   python3.8 setup.py sdist</span><br><span class="line">clean:</span><br><span class="line">   rm -rf build dist *.so</span><br></pre></td></tr></table></figure>

<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/31bd5012bc26225b005ff26a3668886617af4086b0f4fd294d534e3dade80772" alt="image.png"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b859a81ba44f59efeb40ea1a894bc014e0b55f3d6e2c4da424381defac090c09" alt="image.png"></p>
<p>可以看到最终实现了预期, 安装的时候, 自动把so给安装上了. 卸载的时候, 也顺利把so及相关文件卸载了.</p>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359577911990566947" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>Python,后端</tag>
      </tags>
  </entry>
  <entry>
    <title>java-opencv分水岭算法分割硬币复现关键点</title>
    <url>/7359490238416388134.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>java-opencv分水岭算法示例网上我是没找到java版本的教程。另外网上搜关于#基于分水岭算法的图像分割用法的教程基本都是官网基于那个有粘连的硬币分割图的。因为python语法简介灵活很多，移植到java的话稍不注意就会没那个效果的还不好排查，试了很多次才复现出示例的那个效果。教程很多我就不写明细了，说下例子了解的东西吧。<strong>理论我是不懂的想了解的网上找教程</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/225653712ce3a361266c1698e19ad067f4e922f44bb0d966d9a44798d603a0cd" alt="image.png"></p>
<h4 id="关键点在这个步骤上"><a href="#关键点在这个步骤上" class="headerlink" title="关键点在这个步骤上"></a>关键点在这个步骤上</h4><ol>
<li>联通函数返回物体个数和对应的掩码(ret个数，markers的坐标值其实的是个数的序号0，1，2，3最大值是ret；0算是背景）</li>
<li>markers[unknown==255] = 0；这步是个关键只是python语法太简洁，unknown来源就是背景（膨胀）-前景（腐蚀）的到的,把得到的联通域中之前的未知部分变为分水岭的未知区域。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码     #Marker labelling`</span><br><span class="line">     ret, markers = cv.connectedComponents(sure_fg)`</span><br><span class="line">     # Add one to all labels so that sure background is not 0, but 1`</span><br><span class="line">     markers = markers+1`</span><br><span class="line">     # Now, mark the region of unknown with zero`</span><br><span class="line">     markers[unknown==255] = 0`</span><br></pre></td></tr></table></figure>

<h4 id="流程了解的东西也不知道对不对"><a href="#流程了解的东西也不知道对不对" class="headerlink" title="流程了解的东西也不知道对不对"></a>流程了解的东西也不知道对不对</h4><ol>
<li>图像的二值化，就是将图像上的像素点的灰度值设置为0或255，也就是将整个图像呈现出明显的只有黑和白的视觉效果，二值化后的图片是单通道的。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scss复制代码//背景黑色前景白色THRESH_OTSU自动二值化</span><br><span class="line">Imgproc.threshold(gray,gray,0,255,Imgproc.THRESH_BINARY_INV+Imgproc.THRESH_OTSU);</span><br></pre></td></tr></table></figure>

<p>2.形态学处理，二值化后由于图像存在一些噪声（即白色的点）。所以需要形态学的开运算：腐蚀与膨胀平滑边界消除一些白点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码Mat element = Imgproc.getStructuringElement(Imgproc.MORPH_RECT, new Size(3,3));</span><br><span class="line">Imgproc.morphologyEx(gray,gray,Imgproc.MORPH_OPEN,element);</span><br></pre></td></tr></table></figure>

<p>3.得到背景、前景、未知区域。 膨胀是内容变大背景变小，物体边界增加到背景肯定是背景；腐蚀是内容变小，背景变大，这部分内容肯定是内容；然后膨胀后的图像-腐蚀后的=得到未知区域（如果物体不相连的话应该就是所谓的边界）。这个未知区域后面会用到</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码Mat sure_bg=new Mat();</span><br><span class="line">Imgproc.dilate(gray, sure_bg, element, new Point(-1, -1), 3);</span><br><span class="line">Mat sure_fg=new Mat();</span><br><span class="line">Imgproc.erode(gray, sure_fg, element, new Point(-1, -1), 3);</span><br><span class="line">Mat unknown=new Mat();</span><br><span class="line">Core.subtract(sure_bg, sure_fg, unknown);</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>物体有相连接的部分需要用到距离变换，注意这里要使用第二次二值化处理。</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ini复制代码//上次开运算得到的</span><br><span class="line">Imgproc.distanceTransform(gray, dist_transform, Imgproc.CV_DIST_L2, 5);</span><br><span class="line">//归一化</span><br><span class="line">Core.normalize(dist_transform, dist_transform, 0, 1, Core.NORM_MINMAX);</span><br><span class="line">Mat sure_fg2=new Mat();</span><br><span class="line">Core.MinMaxLocResult mmr=Core.minMaxLoc(dist_transform);</span><br><span class="line">//再次二值化</span><br><span class="line">Imgproc.threshold(dist_transform,sure_fg2,0.5*mmr.maxVal,255,Imgproc.THRESH_BINARY);</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用分水岭算法</li>
</ol>
<p>markers = markers+1<code>因为分水岭中0是未知区域</code> makrers在java中里面坐标表示的图像的个数</p>
<p>markers[unknown==255] = 0<code>把上面得到的未知区域，在得到的连通域中表示为未知的地方</code></p>
<p>unknown是第一次得到的背景-第二次二值化的大前景</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">css复制代码int count=Imgproc.connectedComponents(sure_fg2,mask);</span><br><span class="line">for(int i=0;i&lt;mask.rows();i++)&#123;</span><br><span class="line">    for(int j=0;j&lt;mask.cols();j++)&#123;</span><br><span class="line">        mask.put(i,j,new int[]&#123;(int)mask.get(i,j)[0]+1&#125;);</span><br><span class="line">        if(unknown.get(i,j)[0]==255)&#123;</span><br><span class="line">            mask.put(i,j,new int[]&#123;0&#125;);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Imgproc.watershed(source,mask);</span><br></pre></td></tr></table></figure>

<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7359490238416388134" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>OpenCV,Java,机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>全网最硬核 Java 新内存模型解析与实验单篇版（不断更新Q</title>
    <url>/7080869319407566879.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>个人创作公约：本人声明创作的所有文章皆为自己原创，如果有参考任何文章的地方，会标注出来，如果有疏漏，欢迎大家批判。如果大家发现网上有抄袭本文章的，欢迎举报，并且积极向这个 <a href="https://github.com/HashZhang/fxckPlagiarism" target="_blank" rel="noopener">github 仓库</a> 提交 issue，谢谢支持~</p>
</blockquote>
<blockquote>
<p>本篇文章参考了大量文章，文档以及论文，但是这块东西真的很繁杂，我的水平有限，可能理解的也不到位，如有异议欢迎留言提出。<strong>本系列会不断更新，结合大家的问题以及这里的错误和疏漏，欢迎大家留言</strong></p>
</blockquote>
<blockquote>
<p>JMM 相关文档：</p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html" target="_blank" rel="noopener">Java Language Specification Chapter 17</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/jmm/cookbook.html" target="_blank" rel="noopener">The JSR-133 Cookbook for Compiler Writers - Doug Lea’s</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/html/j9mm.html" target="_blank" rel="noopener">Using JDK 9 Memory Order Modes - Doug Lea’s</a></li>
</ul>
</blockquote>
<blockquote>
<p>内存屏障，CPU 与内存模型相关：</p>
<ul>
<li><a href="https://preshing.com/20120930/weak-vs-strong-memory-models/" target="_blank" rel="noopener">Weak vs. Strong Memory Models</a></li>
<li><a href="http://www.puppetmastertrading.com/images/hwViewForSwHackers.pdf" target="_blank" rel="noopener">Memory Barriers: a Hardware View for Software Hackers</a></li>
<li><a href="https://core.ac.uk/download/pdf/10597715.pdf" target="_blank" rel="noopener">A Detailed Analysis of Contemporary ARM and x86 Architectures</a></li>
<li><a href="http://csg.csail.mit.edu/pubs/memos/Memo-493/memo-493.pdf" target="_blank" rel="noopener">Memory Model = Instruction Reordering + Store Atomicity</a></li>
<li><a href="https://iis-people.ee.ethz.ch/~gmichi/asocd/addinfo/Out-of-Order_execution.pdf" target="_blank" rel="noopener">Out-of-Order Execution</a></li>
</ul>
</blockquote>
<blockquote>
<p>x86 CPU 相关资料：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/X86#:~:text=x86%20is%20a%20family%20of,microprocessor%20and%20its%208088%20variant." target="_blank" rel="noopener">x86 wiki</a></li>
<li><a href="https://www.intel.com/products/processor/manuals/" target="_blank" rel="noopener">Intel® 64 and IA-32 Architectures Software Developer Manuals</a></li>
<li><a href="https://core.ac.uk/download/pdf/10697957.pdf" target="_blank" rel="noopener">Formal Specification of the x86 Instruction Set Architecture</a></li>
</ul>
</blockquote>
<blockquote>
<p>ARM CPU 相关资料：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/ARM_architecture_family" target="_blank" rel="noopener">ARM wiki</a></li>
<li><a href="https://developer.arm.com/Processors/Cortex-A710" target="_blank" rel="noopener">aarch64 Cortex-A710 Specification</a></li>
</ul>
</blockquote>
<blockquote>
<p>各种一致性的理解：</p>
<ul>
<li><a href="https://cseweb.ucsd.edu/classes/sp14/cse240A-a/Slides/15_Coherence_and_Consistency.pdf" target="_blank" rel="noopener">Coherence and Consistency</a></li>
</ul>
</blockquote>
<blockquote>
<p>Aleskey 大神的 JMM 讲解：</p>
<ul>
<li><a href="https://www.bilibili.com/video/BV1JT4y1D7CL?spm_id_from=333.999.0.0" target="_blank" rel="noopener">Aleksey Shipilëv - 不要误解Java内存模型（上）</a></li>
<li><a href="https://www.bilibili.com/video/BV1HU4y1o7eA?spm_id_from=333.999.0.0" target="_blank" rel="noopener">Aleksey Shipilëv - 不要误解Java内存模型（下）</a></li>
</ul>
</blockquote>
<p>相信很多 Java 开发，都使用了 Java 的各种并发同步机制，例如 volatile，synchronized 以及 Lock 等等。也有很多人读过 JSR 第十七章 Threads and Locks（地址：<a href="https://docs.oracle.com/javase/specs/jls/se17/html/jls-17.html" target="_blank" rel="noopener">docs.oracle.com/javase/spec…</a>），其中包括同步、Wait/Notify、Sleep &amp; Yield 以及内存模型等等做了很多规范讲解。但是也相信大多数人和我一样，第一次读的时候，感觉就是在看热闹，看完了只是知道他是这么规定的，但是为啥要这么规定，不这么规定会怎么样，并没有很清晰的认识。同时，结合 Hotspot 的实现，以及针对 Hotspot 的源码的解读，我们甚至还会发现，由于 javac 的静态代码编译优化以及 C1、C2 的 JIT 编译优化，导致最后代码的表现与我们的从规范上理解出代码可能的表现是不太一致的。并且，这种不一致，导致我们在学习 Java 内存模型（JMM，Java Memory Model），理解 Java 内存模型设计的时候，如果想通过实际的代码去试，结果是与自己本来可能正确的理解被带偏了，导致误解。<br>我本人也是不断地尝试理解 Java 内存模型，重读 JLS 以及各路大神的分析。这个系列，会梳理我个人在阅读这些规范以及分析还有通过 jcstress 做的一些实验而得出的一些理解，希望对于大家对 Java 9 之后的 Java 内存模型以及 API 抽象的理解有所帮助。但是，还是强调一点，内存模型的设计，出发点是让大家可以不用关心底层而抽象出来的一些设计，涉及的东西很多，我的水平有限，可能理解的也不到位，我会尽量把每一个论点的论据以及参考都摆出来，<strong>请大家不要完全相信这里的所有观点，如果有任何异议欢迎带着具体的实例反驳并留言</strong>。</p>
<ol>
<li><h1 id="理解“规范”与“实现”"><a href="#理解“规范”与“实现”" class="headerlink" title="理解“规范”与“实现”"></a>理解“规范”与“实现”</h1></li>
</ol>
<p>首先，我想先参考 Aleksey Shipilëv 大神的理解思路，即首先分清楚规范（Specification）与实现（Implementation）的区别。前面提到的 JLS（Java Language Specification）其实就是一种规范，它规范了 Java 语言，并且所有能编译运行 Java 语言的 JDK 实现都要实现它里面规定的功能。但是对于实际的实现，例如 Hotspot JVM 的 JDK，就是具体的实现了，<strong>从规范到实际的实现，其实是有一定的差异的</strong>。首先是下面这个代码：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/23129ab2238d3680ac5a3fae2bc52dd6ad63699ea47d68b364e99fa9e625078f" alt="image"></p>
<p>实际 HotSpot 最后编译并且经过 JIT 优化与 CPU 指令优化运行的代码其实是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2d1fa4b8f33f1984d2dccb2d2da381ec5d008ecb40048e8e04c76fbb6986a82b" alt="image"></p>
<p>即将结果 3 放入寄存器并返回，这样与原始代码其实效果是一致的，省略了无用的本地变量操作，也是合理的。那么你可能会有疑问：不会呀，我打断点运行到这里的时候，能看到本地变量 x,y,result 呀。这个其实是 JVM 运行时做的工作，如果你是以 DEBUG 模式运行 JVM，那么其实 JIT 默认就不会启用，只会简单的解释执行，所以你能看到本地变量。但是实际执行中，如果这个方法是热点方法，经过 JIT 的优化，这些本地变量其实就不存在了。</p>
<p>还有一个例子是，Hotspot 会有锁膨胀机制（这个我们后面还会测试），即：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2bf2a8a9a84615537ea4048e8c1003cdf8d416a39f6ad6879d3ed1d956a801de" alt="image"><br>如果按照 JLS 的描述，那么 x = 1 与 y = 1 这两个操作是不能重排序的。但是 Hotspot 实际的实现会将上面的代码优化成：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dcaee1fa3d2f2919a4d24e9143a6977f5e7ec67ac59d199620eb07259f6b6056" alt="image"><br>那么这样，其实 x = 1 与 y = 1 这两个操作就可以重排序了，这个我们后面也会验证。</p>
<p>不同的 JVM 实现，实际的表现都会有些差异。并且就算是同一个 JVM 实现，在不同的操作系统，硬件环境等等，表现也有可能不一样。例如下面这个例子：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/bd49f680cc2772fbf2045e60bb595ded4d686b39956b08b1cce0d53d98c7279c" alt="image"><br>正常情况下，r1 的值应该只有 <code>{-1, 0}</code> 这两个结果之一。但是在某些 32 位的 JVM 上执行会有些问题，例如在 x86_32 的环境下，可能会有 <code>{-1, 0, -4294967296, 4294967295}</code> 这些结果。</p>
<p>所以，如果我们要全面的覆盖底层到 JMM 设计以及 Hotspot 实现和 JIT 优化等等等等，涉及的东西太多太多，一层逻辑套逻辑，面面俱到我真的做不到。并且我也没法保证我理解的百分百准确。如果我们要涉及太多的 HotSpot 实现，那么我们可能就偏离了我们这个系列的主题，<strong>我们其实主要关心的是 Java 本身内存模型的设计规范，然后从中总结出我们在实际使用中，需要知道并且注意的点的最小集合</strong>，这个也是本系列要梳理的，同时，为了保证本系列梳理出的这个最小集合准确，会加上很多实际测试的代码，大家也可以跑一下看看这里给出的结论以及对于 JMM 的理解是否正确。</p>
<ol start="2">
<li><h1 id="什么是内存模型"><a href="#什么是内存模型" class="headerlink" title="什么是内存模型"></a>什么是内存模型</h1></li>
</ol>
<p>任何需要访问内存的语言，都需要有内存模型，描述如何访问内存：<strong>即我可以用哪些方式去写内存，可以用哪些方式去读取内存，不同的写入方式以及读取方式，会有什么不同的表现</strong>。当然，如果你的程序是一个简单的串行程序，你读取到的一定是最新写入的值，这样的情况下，其实你并不需要内存模型这种东西。一般是并发的环境下，才会需要内存模型这个东西。</p>
<p>Java 内存模型其实就是规定了<strong>在 Java 多线程环境下，以不同的特定方式读取或者写入内存的时候，能观察到内存的合理的值</strong>。</p>
<p>也有是这么定义 Java 内存的，即 Java 指令是会重排序的，Java 内存模型规定了哪些指令是禁止重排序的，实际上这也是 JLS 第 17 章中 Java 内存模型中的主要内容。这其实也是实现<strong>观察到内存的合理的值</strong>的方式，即<strong>对于给定的源代码</strong>，可能的结果集是什么。</p>
<p>我们接下来看两个简单的入门例子，作为热身。分别是原子性访问，以及字分裂。</p>
<ol start="3">
<li><h1 id="原子性访问"><a href="#原子性访问" class="headerlink" title="原子性访问"></a>原子性访问</h1></li>
</ol>
<p>原子性访问，对于一个字段的写入与读取，这个操作本身是原子的不可分割的。可能大家不经常关注的一点是根据 JLS 第 17 章中的说明，下面这两个操作，并不是原子性访问的：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4caa65d6fed6a2786e86f1ac1d33d76c802c389ee5d1b4f69f02863f03747dde" alt="image"><br>因为大家当前的系统通常都是 64 位的，得益于此，这两个操作大多是原子性的了。但是其实根据 Java 的规范，这两个并不是原子性的，在 32 位的系统上就保证不了原子性。我这里直接引用 JLS 第 17 章的一段原话：</p>
<blockquote>
<p>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as <strong>two separate writes: one to each 32-bit half</strong>. This can result in a situation where a thread sees the first 32 bits of a 64-bit value from one write, and the second 32 bits from another write.<br>Writes and reads of <strong>volatile long and double values are always atomic</strong>.</p>
</blockquote>
<p>翻译过来，简单来说非 volatile 的 long 或者 double 可能会按照两次单独的 32 位写更新，所以是非原子性的。volatile 的 long 或者 double 读取和写入都是原子性的。</p>
<p>为了说明我们这里的原子性，我引用一个 jcstress 中的一个例子：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/112c88acd876ffc971b74ff5b3aae6dcdd21a44ab1eb3e1d692127c717e5f0a7" alt="image"></p>
<p>我们使用 Java 8 32bit （Java 9 之后就不再支持 32 位的机器了）的 JVM 运行这里的代码，结果是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/dc5fb844f8c14ac4807b10d8508d1a0e385acf324fe3e54cede05e91524c985e" alt="image"></p>
<p>可以看到，结果不止 -1 和 0 这种我们代码中的指定的值，还有一些中间结果。</p>
<ol start="4">
<li><h1 id="字分裂（word-tearing）"><a href="#字分裂（word-tearing）" class="headerlink" title="字分裂（word tearing）"></a>字分裂（word tearing）</h1></li>
</ol>
<p>字分裂（word tearing）即你<strong>更新一个字段，数组中的一个元素，会影响到另一个字段，数组中的另一个元素的值</strong>。例如处理器没有提供写单个 byte 的功能，假设最小维度是 int，在这样的处理器上更新 byte 数组，若只是简单地读取 byte 所在的整个 int，更新对应的 byte，然后将整个 int 再写回，这种做法是有问题的。<strong>Java 中没有字分裂现象</strong>，字段之间以及数组元素之间是独立的，更新一个字段或元素不能影响任何其它字段或元素的读取与更新。</p>
<p>为了说明什么是字分裂，举一个不太恰当的例子，即线程不安全的 BitSet。BitSet 的抽象是比特位集合（一个一个 0，1 这样，可以理解为一个 boolean 集合），底层实现是一个 long 数组，一个 long 保存 64 个比特位，每次更新都是读取这个 long 然后通过位运算更新对应的比特位，再更新回去。<strong>接口层面是一位一位更新，但是底层却是按照 long 的维度更新的</strong>（因为是底层 long 数组），很明显，如果没有同步锁，并发访问就会并发安全问题从而造成字分裂的问题：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ce771eacfe995ab7ec067987194b535f6cbc9fcf842088d6780a44b4aaace78b" alt="image"></p>
<p>结果是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4fdab6ddf0e23d66b9854fc7f2b64f634345ea28a3a66da70168f0c80d6f6a1c" alt="image"></p>
<p>这里用了一个不太恰当的例子来说明什么是字分裂，Java 中是可以保证没有字分裂的，对应上面的 BitSet 的例子就是我们尝试更新一个 boolean 数组，这样结果就只会是 true true：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/39851a97c9406a61478fa4d9b7f017b7cc64d683eeee25ba3502d0b422258b97" alt="image"></p>
<p>这个结果只会是 true true</p>
<p>接下来，我们将进入一个比较痛苦的章节了，<strong>内存屏障</strong>，不过大家也不用太担心，从我个人的经验来看，内存屏障很难理解的原因是因为网上基本上不会从 Java 已经为你屏蔽的底层细节去给你讲，直接理解会很难说服自己，于是就会猜想一些东西然后造成误解，所以本文不会上来丢给你 Doug Lea 抽象的并一直沿用至今的 Java 四种内存屏障（就是 LoadLoad，StoreStore，LoadStore 和 StoreLoad 这四个，其实通过后面的分析也能看出来，这四个内存屏障的设计对于现在的 CPU 来说已经有些过时了，现在用的更多的是 acquire, release 以及 fence）希望能通过笔者看的一些关于底层细节的文章论文中提取出便于大家理解的东西供大家参考，更好地更容易的理解内存屏障。</p>
<ol start="5">
<li><h1 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h1></li>
</ol>
<h2 id="5-1-为何需要内存屏障"><a href="#5-1-为何需要内存屏障" class="headerlink" title="5.1. 为何需要内存屏障"></a>5.1. 为何需要内存屏障</h2><p>内存屏障(Memory Barrier)，也有叫内存栅栏(Memory Fence)，还有的资料直接为了简便，就叫 membar，这些其实意思是一样的。内存屏障主要为了解决指令乱序带来了结果与预期不一致的问题，通过加入内存屏障防止指令乱序（或者称为重排序，reordering）。</p>
<p>那么为什么会有指令乱序呢？主要是因为 <strong>CPU 乱序（CPU乱序还包括 CPU 内存乱序以及 CPU 指令乱序）以及编译器乱序</strong>。内存屏障可以用于防止这些乱序。如果内存屏障对于编译器和 CPU 都生效，那么一般称为硬件内存屏障，如果只对编译器生效，那么一般被称为软件内存屏障。我们这里主要关注 CPU 带来的乱序，对于编译器的重排序我们会在最后简要介绍下。</p>
<h2 id="5-2-CPU-内存乱序相关"><a href="#5-2-CPU-内存乱序相关" class="headerlink" title="5.2. CPU 内存乱序相关"></a>5.2. CPU 内存乱序相关</h2><p>我们从 CPU 高速缓存以及缓存一致性协议出发，开始分析为何 CPU 中会有乱序。我们这里假设<strong>一种简易的 CPU 模型</strong>，<strong>请大家一定记住，实际的 CPU 要比这里列举的简易 CPU 模型复杂的多</strong></p>
<h3 id="5-2-1-简易-CPU-模型-CPU-高速缓存的出发点-减少-CPU-Stall"><a href="#5-2-1-简易-CPU-模型-CPU-高速缓存的出发点-减少-CPU-Stall" class="headerlink" title="5.2.1. 简易 CPU 模型 - CPU 高速缓存的出发点 - 减少 CPU Stall"></a>5.2.1. 简易 CPU 模型 - CPU 高速缓存的出发点 - 减少 CPU Stall</h3><p>我们在这里会看到，现代的 CPU 的很多设计，一切以减少 CPU Stall 出发。什么是 CPU Stall 呢？举一个简单的例子，假设 CPU 需要直接读取内存中的数据（忽略其他的结构，例如 CPU 缓存，总线与总线事件等等）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/38a31f753ce707275c7bf5361f91b7748103008f8149c82ffb6ae6cf28885e38" alt="image"></p>
<p>CPU 发出读取请求，在内存响应之前，CPU 需要一直等待，无法处理其他的事情。这一段 CPU 就是<strong>处于 Stall 状态</strong>。如果 CPU 一直直接从内存中读取，CPU 直接访问内存消耗时间很长，可能需要<strong>几百个指令周期</strong>，也就是每次访问都会有几百个指令周期内 CPU 处于 Stall 状态什么也干不了，这样效率会很低。一般需要引入<strong>若干个高速缓存</strong>（Cache）来减少 Stall：高速缓存即与处理器紧挨着的小型存储器，位于处理器和内存之间。</p>
<p>我们这里<strong>不关心多级高速缓存，以及是否存在多个 CPU 共用某一缓存的情况</strong>，我们就简单认为是下面这个架构：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/75c7dc73fa120659986c950831a5fc889213c6722e427f07116f101a8e03b651" alt="image"><br>当需要读取一个地址的值时，访问高速缓存看是否存在：存在代表<strong>命中</strong>（hit），直接读取。不存在被称为<strong>缺失</strong>（miss）。同样的，如果需要写一个值到一个地址，这个地址在缓存中存在也就不需要访问内存了。大部分程序都表现出较高的<strong>局部性</strong>（locality）：</p>
<ul>
<li><strong>如果处理器读或写一个内存地址，那么它很可能很快还会读或写同一个地址</strong>。</li>
<li><strong>如果处理器读或写一个内存地址，那么它很可能很快还会读或写附近的地址</strong>。</li>
</ul>
<p>针对局部性，高速缓存一般会一次操作不止一个字，而是<strong>一组临近的字</strong>，称为<strong>缓存行</strong>。</p>
<p>但是呢，由于告诉缓存的存在，就给更新内存带来了麻烦：当一个 CPU 需要更新一块缓存行对应内存的时候，它需要将其他 CPU 缓存中这块内存的缓存行也置为失效。为了维持每个 CPU 的缓存数据一致性，引入了缓存一致性协议（Cache Coherence Protocols）</p>
<h3 id="5-2-2-简易-CPU-模型-一种简单的缓存一致性协议-实际的-CPU-用的要比这个复杂-MESI"><a href="#5-2-2-简易-CPU-模型-一种简单的缓存一致性协议-实际的-CPU-用的要比这个复杂-MESI" class="headerlink" title="5.2.2. 简易 CPU 模型 - 一种简单的缓存一致性协议(实际的 CPU 用的要比这个复杂) - MESI"></a>5.2.2. 简易 CPU 模型 - 一种简单的缓存一致性协议(实际的 CPU 用的要比这个复杂) - MESI</h3><p>现代的缓存一致性的协议以及算法非常复杂，缓存行可能会有数十种不同的状态。这里我们并不需要研究这种复杂的算法，我们这里引入一个最经典最简单的缓存一致性协议即 4 状态 MESI 协议（<strong>再次强调，实际的 CPU 用的协议要比这个复杂，MESI 其实本身有些问题解决不了</strong>），MESI 其实指的就是缓存行的四个状态：</p>
<ul>
<li><strong>Modified</strong>：缓存行被修改，最终一定会被写回入主存，在此之前其他处理器不能再缓存这个缓存行。</li>
<li><strong>Exclusive</strong>：缓存行还未被修改，但是其他的处理器不能将这个缓存行载入缓存</li>
<li><strong>Shared</strong>：缓存行未被修改，其他处理器可以加载这个缓存行到缓存</li>
<li><strong>Invalid</strong>：缓存行中没有有意义的数据</li>
</ul>
<p>根据我们前面的 CPU 缓存结构图中所示，假设所有 CPU 都共用在同一个总线上，则会有如下这些信息在总线上发送：</p>
<ol>
<li><strong>Read</strong>：这个事件包含要读取的缓存行的物理地址。</li>
<li><strong>Read Response</strong>：包含前面的读取事件请求的数据，数据来源可能是<strong>内存或者是其他高速缓存</strong>，例如，如果请求的数据在其他缓存处于 modified 状态的话，那么必须从这个缓存读取缓存行数据作为 Read Response</li>
<li><strong>Invalidate</strong>：这个事件包含要过期掉的缓存行的物理地址。其他的高速缓存必须移除这个缓存行并且响应 Invalidate Acknowledge 消息。</li>
<li><strong>Invalidate Acknowledge</strong>：收到 Invalidate 消息移除掉对应的缓存行之后，回复 Invalidate Acknowledge 消息。</li>
<li><strong>Read Invalidate</strong>：是 Read 消息还有 Invalidate 消息的组合，包含要读取的缓存行的物理地址。既读取这个缓存行并且需要 Read Response 消息响应，同时发给其他的高速缓存，移除这个缓存行并且响应 Invalidate Acknowledge 消息。</li>
<li><strong>Writeback</strong>：这个消息包含要更新的内存地址以及数据。同时，这个消息也允许状态为 modified 的缓存行被剔除，以给其他数据腾出空间。</li>
</ol>
<p><strong>缓存行状态转移与事件</strong>的关系：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2851daf02b512a9cff42ecba6b652016a8c3909f3862dc8094eaa165d9ded200" alt="image"></p>
<p>这里只是列出这个图，<strong>我们不会深入去讲的，因为 MESI 是一个非常精简的协议，具体实现的时候会有很多额外的问题 MESI 无法解决</strong>，如果详细的去讲，会把读者绕进去，读者会思考在某个极限情况下这个协议要怎么做才能保证正确，但是 MESI 实际上解决不了这些。在<strong>实际的实现中，CPU 一致性协议要比 MESI 复杂的多得多，但是一般都是基于 MESI 扩展的</strong>。</p>
<p>举一个简单的 MESI 的例子：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f4b0a859a37a3aaaa90487dfb2d9783ad881736619fdad2a208722118b9c79de" alt="image"><br>1.CPU A 发送 <strong>Read</strong> 从地址 a 读取数据，收到 <strong>Read Response</strong> 将数据存入他的高速缓存并将对应的缓存行置为 <strong>Exclusive</strong></p>
<p>2.CPU B 发送 <strong>Read</strong> 从地址 a 读取数据，CPU A 检测到地址冲突，CPU A 响应 <strong>Read Response</strong> 返回缓存中包含 a 地址的缓存行数据，之后，地址 a 的数据对应的缓存行被 A 和 B 以 Shared 状态装入缓存</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eee077306e076a1b78b5c0dd30c26e61f93a7fd3035466532056197ceba0c3b5" alt="image"><br>3.CPU B 对于 a 马上要进行写操作，发送 <strong>Invalidate</strong>，等待 CPU A 的 <strong>Invalidate Acknowledge</strong> 响应之后，状态修改为 <strong>Exclusive</strong>。CPU A 收到 <strong>Invalidate</strong> 之后，将 a 所在的缓存行状态置为 <strong>Invalid</strong> 失效</p>
<p>4.CPU B 修改数据存储到包含地址 a 的缓存行上，缓存行状态置为 <strong>modified</strong></p>
<p>5.这时候 CPU A 又需要 a 数据，发送 <strong>Read</strong> 从地址 a 读取数据，CPU B 检测到地址冲突，CPU B 响应 <strong>Read Response</strong> 返回缓存中包含 a 地址的缓存行数据，之后，地址 a 的数据对应的缓存行被 A 和 B 以 Shared 状态装入缓存</p>
<p>我们这里可以看到，MESI 协议中，发送 <strong>Invalidate</strong> 消息需要当前 CPU 等待其他 CPU 的 <strong>Invalidate Acknowledge</strong>，也就是<strong>这里有 CPU Stall</strong>。为了避免这个 Stall，引入了 Store Buffer</p>
<h3 id="5-2-3-简易-CPU-模型-避免等待-Invalidate-Response-的-Stall-Store-Buffer"><a href="#5-2-3-简易-CPU-模型-避免等待-Invalidate-Response-的-Stall-Store-Buffer" class="headerlink" title="5.2.3. 简易 CPU 模型 - 避免等待 Invalidate Response 的 Stall - Store Buffer"></a>5.2.3. 简易 CPU 模型 - 避免等待 Invalidate Response 的 Stall - Store Buffer</h3><p>为了避免这种 Stall，在 CPU 与 CPU 缓存之间添加 Store Buffer，如下图所示：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/35a1275feb7cbf7ecd506089290d1eb79704db7aa7b40ee81e6b48df99b5cf31" alt="image"></p>
<p>有了 Store Buffer，CPU 在发送 <strong>Invalidate</strong> 消息的时候，不用等待 <strong>Invalidate Acknowledge</strong> 的返回，将修改的数据直接放入 Store Buffer。如果收到了所有的 <strong>Invalidate Acknowledge</strong> 再从 Store Buffer 放入 CPU 的高速缓存的对应缓存行中。但是加入的这个 Store Buffer 又带来了新的问题：</p>
<p>假设有两个变量 a 和 b，不会处于同一个缓存行，初始都是 0，a 现在位于 CPU A 的缓存行中，b 现在位于 CPU B 的缓存行中：</p>
<p>假设 CPU B 要执行下面的代码：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/eaa900e07241ce3c88c1fccfd300a9eec620fcc2eaa76f465f6ff6db7d693b6f" alt="image"><br>我们肯定是期望最后 b 会等于 2 的。但是真的会如我们所愿么？我们来详细看下下面这个运行步骤：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c012ab5a2209fee66a9e646407dda5f5364c6ed0d776e37d42df1a8886cde200" alt="image"></p>
<p>1.CPU B 执行 a = 1：</p>
<p>(1)由于 CPU B 缓存中没有 a，并且要修改，所以发布 <strong>Read Invalidate</strong> 消息（因为是要先把包含 a 的整个缓存行读取后才能更新，所以发的是 <strong>Read Invalidate</strong>，而不只是 Invalidate）。</p>
<p>(2)CPU B 将 a 的修改（a=1）放入 Storage Buffer</p>
<p>(3)CPU A 收到 <strong>Read Invalidate</strong> 消息，将 a 所在的缓存行标记为 Invalid 并清除出缓存，并响应 <strong>Read Response</strong>（a=0） 和 <strong>Invalidate Acknowlegde</strong>。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e5ad16651fc90504ff4349010966e069759bd12a22f37fb38854d44dc35e6606" alt="image"><br>2.CPU B 执行 b = a + 1:</p>
<p>(1)CPU B 收到来自于 CPU A 的 <strong>Read Response</strong>，这时候这里面 a 还是等于 0。</p>
<p>(2)CPU B 将 a + 1 的结果(0+1=1)存入缓存中已经包含的 b。</p>
<p>3.CPU B 执行 assert(b == 2) 失败</p>
<p>这个错误的原因主要是我们在加载到缓存的时候没考虑从 store buffer 最新的值，所以我们可以加上一步，在加载到缓存的时候从 store buffer 读取最新的值。这样，就能保证上面我们看到的结果 b 最后是 2：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3bd8b391a9e2407362adb273c1cf834a8f41d3282b3e1ea0b03402c0c2d506c5" alt="image"></p>
<h3 id="5-2-4-简易-CPU-模型-避免-Store-Buffer-带来的乱序执行-内存屏障"><a href="#5-2-4-简易-CPU-模型-避免-Store-Buffer-带来的乱序执行-内存屏障" class="headerlink" title="5.2.4. 简易 CPU 模型 - 避免 Store Buffer 带来的乱序执行 - 内存屏障"></a>5.2.4. 简易 CPU 模型 - 避免 Store Buffer 带来的乱序执行 - 内存屏障</h3><p>我们下面再来看一个示例：假设有两个变量 a 和 b，不会处于同一个缓存行，初始都是 0。假设 CPU A （缓存行里面包含 b，这个缓存行状态是 Exclusive）执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5fbfe763a26626521cd8f0a1a802d3eaa5abe2b3b467a07b753c1a84d45256d6" alt="image"></p>
<p>假设 CPU B 执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c54aed94d88b5117fae37dbc499fac9dc83b0babc032d4675b846dedd6efe7a" alt="image"></p>
<p>如果一切按照程序顺序预期执行，那么我们期望 CPU B 执行 assert(a == 1) 是成功的，但是我们来看下面这种执行流程：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3eefa4ecd350873c5d8ec9fe9845aa6739dfeac6ed3ab79a2cb21b5103cbd8d8" alt="image"><br>1.CPU A 执行 a = 1：</p>
<p>(1)CPU A 缓存里面没有 a，并且要修改，所以发布 <strong>Read Invalidate</strong> 消息。</p>
<p>(2)CPU A 将 a 的修改（a=1）放入 Storage Buffer</p>
<p>2.CPU B 执行 while (b == 0) continue:</p>
<p>(1)CPU B 缓存里面没有 b，发布 <strong>Read</strong> 消息。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/72a8e29cff5f4804d4ded9e65726d427339e14eb4d4d29957bb200e8e5186d29" alt="image"><br>3.CPU A 执行 b = 1：</p>
<p>(1)CPU A 缓存行里面有 b，并且状态是 Exclusive，直接更新缓存行。</p>
<p>(2)之后，CPU A 收到了来自于 CPU B 的关于 b 的 <strong>Read</strong> 消息。</p>
<p>(3)CPU A 响应缓存中的 b = 1，发送 <strong>Read Response</strong> 消息，并且缓存行状态修改为 Shared</p>
<p>(4)CPU B 收到 <strong>Read Response</strong> 消息，将 b 放入缓存</p>
<p>(5)CPU B 代码可以退出循环了，因为 CPU B 看到 b 此时为 1</p>
<p>4.CPU B 执行 assert(a == 1)，但是由于 a 的更改还没更新，所以失败了。</p>
<p><strong>像这种乱序，CPU 一般是无法自动控制的，但是一般会提供内存屏障指令，告诉 CPU 防止乱序</strong>，例如：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f41a55b3ccab54894ee5d573eb82dc928b84d499effab7e702dc7143809896a7" alt="image"><br>smp_mb() 会让 CPU 将 Store Buffer 中的内容刷入缓存。加入这个内存屏障指令后，执行流程变成：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0ee1ea59b3e51575e02c3e2af9d746508da6cf40c3d93b47d16c0f35f36513cf" alt="image"><br>1.CPU A 执行 a = 1：</p>
<p>(1)CPU A 缓存里面没有 a，并且要修改，所以发布 <strong>Read Invalidate</strong> 消息。</p>
<p>(2)CPU A 将 a 的修改（a=1）放入 Storage Buffer</p>
<p>2.CPU B 执行 while (b == 0) continue:</p>
<p>(1)CPU B 缓存里面没有 b，发布 <strong>Read</strong> 消息。<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9c8e3cb11465298dc99381754adc104ed2eb7a83da02168f50d9a8fc6a0522e8" alt="image"><br>3.CPU A 执行 smp_mb()：</p>
<p>(1)CPU A 将当前 Store Buffer 的所有条目打上标记（目前这里只有 a，就是对 a 打上标记）</p>
<p>4.CPU A 执行 b = 1：</p>
<p>(1)CPU A 缓存行里面有 b，并且状态是 Exclusive，但是由于 Store Buffer 中有标记的条目 a，不直接更新缓存行，而是放入 Store Buffer（与 a 不同，没有标记）。并发出 <strong>Invalidate</strong> 消息。</p>
<p>(2)之后，CPU A 收到了来自于 CPU B 的关于 b 的 <strong>Read</strong> 消息。</p>
<p>(3)CPU A 响应缓存中的 b = 0，发送 <strong>Read Response</strong> 消息，并且缓存行状态修改为 Shared</p>
<p>(4)CPU B 收到 <strong>Read Response</strong> 消息，将 b 放入缓存</p>
<p>(5)CPU B 代码不断循环，因为 CPU B 看到 b 还是 0</p>
<p>(6)CPU A 收到前面对于 a 的 “Read Invalidate” 相关的消息响应，将 Store Buffer 中打好标记的 a 条目刷入缓存，这个缓存行状态为 modified。</p>
<p>(7)CPU B 收到 CPU A 发的 <strong>Invalidate</strong> b 的消息，将 b 的缓存行失效，回复 <strong>Invalidate Acknowledge</strong></p>
<p>(8)CPU A 收到 <strong>Invalidate Acknowledge</strong>，将 b 从 Store Buffer 刷入缓存。</p>
<p>(9)由于 CPU B 不断读取 b，但是 b 已经不在缓存中了，所以发送 <strong>Read</strong> 消息。</p>
<p>(10)CPU A 收到 CPU B 的 <strong>Read</strong> 消息，设置 b 的缓存行状态为 shared，返回缓存中 b = 1 的 <strong>Read Response</strong></p>
<p>(11)CPU B 收到 <strong>Read Response</strong>，得知 b = 1，放入缓存行，状态为 shared</p>
<p>5.CPU B 得知 b = 1，退出 while (b == 0) continue 循环</p>
<p>6.CPU B 执行 assert(a == 1)（这个比较简单，就不画图了）：<br>(1)CPU B 缓存中没有 a，发出 <strong>Read</strong> 消息。<br>(2)CPU A 从缓存中读取 a = 1，响应 <strong>Read Response</strong><br>(3)CPU B 执行 assert(a == 1) 成功</p>
<p>Store Buffer 一般都会比较小，如果 Store Buffer 满了，那么还是会发生 Stall 的问题。我们期望 Store Buffer 能比较快的刷入 CPU 缓存，这是在收到对应的 <strong>Invalidate Acknowledge</strong> 之后进行的。但是，其他的 CPU 可能在忙，没发很快应对收到的 <strong>Invalidate</strong> 消息并响应 <strong>Invalidate Acknowledge</strong>，这样可能造成 Store Buffer 满了导致 CPU Stall 的发生。所以，可以引入每个 CPU 的 Invalidate queue 来缓存要处理的 <strong>Invalidate</strong> 消息。</p>
<h3 id="5-2-5-简易-CPU-模型-解耦-CPU-的-Invalidate-与-Store-Buffer-Invalidate-Queues"><a href="#5-2-5-简易-CPU-模型-解耦-CPU-的-Invalidate-与-Store-Buffer-Invalidate-Queues" class="headerlink" title="5.2.5. 简易 CPU 模型 - 解耦 CPU 的 Invalidate 与 Store Buffer - Invalidate Queues"></a>5.2.5. 简易 CPU 模型 - 解耦 CPU 的 Invalidate 与 Store Buffer - Invalidate Queues</h3><p>加入 Invalidate Queues 之后，CPU 结构如下所示：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0de000185ea17f93a3de11b68356f0b92ecad26d4ddfce728b05f469a74a2aaa" alt="image"></p>
<p>有了 Invalidate Queue，CPU 可以将 <strong>Invalidate</strong> 放入这个队列之后立刻将 Store Buffer 中的对应数据刷入 CPU 缓存。同时，CPU 在想主动发某个缓存行的 <strong>Invalidate</strong> 消息之前，必须检查自己的 Invalidate Queue 中是否有相同的缓存行的 <strong>Invalidate</strong> 消息。如果有，必须等处理完自己的 Invalidate Queue 中的对应消息再发。</p>
<p>同样的，Invalidate Queue 也带来了乱序执行。</p>
<h3 id="5-2-6-简易-CPU-模型-由于-Invalidate-Queues-带来的进一步乱序-需要内存屏障"><a href="#5-2-6-简易-CPU-模型-由于-Invalidate-Queues-带来的进一步乱序-需要内存屏障" class="headerlink" title="5.2.6. 简易 CPU 模型 - 由于 Invalidate Queues 带来的进一步乱序 - 需要内存屏障"></a>5.2.6. 简易 CPU 模型 - 由于 Invalidate Queues 带来的进一步乱序 - 需要内存屏障</h3><p>假设有两个变量 a 和 b，不会处于同一个缓存行，初始都是 0。假设 CPU A （缓存行里面包含 a(shared), b(Exclusive)）执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a1b2c1e4a95d0f088c416c5e9ec9cbd3146ef0bff59e2d189dc4b7134bbeef05" alt="image"><br>CPU B（缓存行里面包含 a(shared)）执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c99193f34e33e7537f375549d9ab364d0d1403868995058b1468cfed97d691ba" alt="image"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/91fbe22dbd3c0c5a2b9ddc719a37ef135d718977930b32ae94fe0219a11dfc6f" alt="image"><br>1.CPU A 执行 a = 1：</p>
<p>(1)CPU A 缓存里面有 a（shared），CPU A 将 a 的修改（a=1）放入 Store Buffer，发送 <strong>Invalidate</strong> 消息。</p>
<p>2.CPU B 执行 while (b == 0) continue:</p>
<p>(1)CPU B 缓存里面没有 b，发布 <strong>Read</strong> 消息。</p>
<p>(2)CPU B 收到 CPU A 的 <strong>Invalidate</strong> 消息，放入 Invalidate Queue 之后立刻返回。</p>
<p>(3)CPU A 收到 <strong>Invalidate</strong> 消息的响应，将 Store Buffer 中的缓存行刷入 CPU 缓存</p>
<p>3.CPU A 执行 smp_mb()：</p>
<p>(1)因为 CPU A 已经把 Store Buffer 中的缓存行刷入 CPU 缓存，所以这里直接通过</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/36d477c0210f7d862f8dd3a9787e8a4328c80bf9c71fb3bdec0568fd0f8a4c0e" alt="image"><br>4.CPU A 执行 b = 1：</p>
<p>(1)因为 CPU A 本身包含 b 的缓存行 (Exclusive)，直接更新缓存行即可。</p>
<p>(2)CPU A 收到 CPU B 之前发的 <strong>Read</strong> 消息，将 b 的缓存行状态更新为 Shared，之后发送 <strong>Read Response</strong> 包含 b 的最新值</p>
<p>(3)CPU B 收到 <strong>Read Response</strong>， b 的值为 1</p>
<p>5.CPU B 退出循环，开始执行 assert(a == 1)</p>
<p>(1)由于目前关于 a 的 <strong>Invalidate</strong> 消息还在 Invalidate queue 中没有处理，所以 CPU B 看到的还是 a = 0，assert 失败</p>
<p>所以，我们针对这种乱序，在 CPU B 执行的代码中也加入内存屏障，这里内存屏障不仅等待 CPU 刷完所有的 Store Buffer，还要等待 CPU 的 Invalidate Queue 全部处理完。加入内存屏障，CPU B 执行的代码是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3dc7b7e4f5f4752291cbc062ce5cf7afc4c5ba2a9c91cf1a6b72e110b6894065" alt="image"></p>
<p>这样，在前面的第 5 步，CPU B 退出循环，执行 assert(a == 1) 之前需要等待 Invalidate queue 处理完：<br>(1)处理 <strong>Invalidate</strong> 消息，将 b 置为 Invalid<br>(2)继续代码，执行 assert(a == 1)，这时候缓存内不存在 b，需要发 <strong>Read</strong> 消息，这样就能看到 b 的最新值 1 了，assert 成功。</p>
<h3 id="5-2-7-简易-CPU-模型-更细粒度的内存屏障"><a href="#5-2-7-简易-CPU-模型-更细粒度的内存屏障" class="headerlink" title="5.2.7. 简易 CPU 模型 - 更细粒度的内存屏障"></a>5.2.7. 简易 CPU 模型 - 更细粒度的内存屏障</h3><p>我们前面提到，在我们前面提到的 CPU 模型中，<code>smp_mb()</code> 这个内存屏障指令，做了两件事：等待 CPU 刷完所有的 Store Buffer，等待 CPU 的 Invalidate Queue 全部处理完。但是，对于我们这里 CPU A 与 CPU B 执行的代码中的内存屏障，并不是每次都要这两个操作同时存在：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e0703e32d8237a4873a79b84d9dd8b307471e70c91937eb7b2ead1f107409c2a" alt="image"></p>
<p>所以，一般 CPU 还会抽象出更细粒度的内存屏障指令，我们这里管等待 CPU 刷完所有的 Store Buffer 的指令叫做<strong>写内存屏障</strong>(Write Memory Buffer)，等待 CPU 的 Invalidate Queue 全部处理完的指令叫做<strong>读内存屏障</strong>(Read Memory Buffer)。</p>
<h3 id="5-2-8-简易-CPU-模型-总结"><a href="#5-2-8-简易-CPU-模型-总结" class="headerlink" title="5.2.8. 简易 CPU 模型 - 总结"></a>5.2.8. 简易 CPU 模型 - 总结</h3><p>我们这里通过一个简单的 CPU 架构出发，层层递进，讲述了一些简易的 CPU 结构以及为何会需要内存屏障，可以总结为下面这个简单思路流程图：</p>
<ol>
<li>CPU 每次直接访问内存太慢，会让 CPU 一直处于 Stall 等待。<strong>为了减少 CPU Stall，加入了 CPU 缓存</strong>。</li>
<li>CPU 缓存带来了多 CPU 间的缓存不一致性，所以<strong>通过 MESI 这种简易的 CPU 缓存一致性协议协调不同 CPU 之间的缓存一致性</strong></li>
<li>对于 MESI 协议中的一些机制进行优化，进一步减少 CPU Stall：</li>
<li>通过将更新放入 Store Buffer，让更新发出的 Invalidate 消息不用 CPU Stall 等待 Invalidate Response。</li>
<li>Store Buffer 带来了指令(代码)乱序，需要内存屏障指令，强制当前 CPU Stall 等待刷完所有 Store Buffer 中的内容。这个内存屏障指令一般称为写屏障。</li>
<li>为了加快 Store Buffer 刷入缓存，增加 Invalidate Queue，</li>
</ol>
<h2 id="5-3-CPU-指令乱序相关"><a href="#5-3-CPU-指令乱序相关" class="headerlink" title="5.3. CPU 指令乱序相关"></a>5.3. CPU 指令乱序相关</h2><p>CPU 指令的执行，也可能会乱序，我们这里只说一种比较常见的 - 指令并行化。</p>
<h3 id="5-3-1-增加-CPU-执行效率-CPU-流水线模式（CPU-Pipeline）"><a href="#5-3-1-增加-CPU-执行效率-CPU-流水线模式（CPU-Pipeline）" class="headerlink" title="5.3.1. 增加 CPU 执行效率 - CPU 流水线模式（CPU Pipeline）"></a>5.3.1. 增加 CPU 执行效率 - CPU 流水线模式（CPU Pipeline）</h3><p>现代 CPU 在执行指令时，是以指令流水线的模式来运行的。因为 CPU 内部也有不同的组件，我们可以将执行一条指令分成不同阶段，不同的阶段涉及的组件不同，这样伪解耦可以让每个组件独立的执行，不用等待一个指令完全执行完再处理下一个指令。</p>
<p>一般分为如下几个阶段：<strong>取指</strong>（Instrcution Fetch，IF）、<strong>译码</strong>（Instruction Decode，ID）、<strong>执行</strong>（Execute，EXE）、<strong>存取</strong>（Memory，MEM）、<strong>写回</strong>（Write-Back， WB）<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0e7947254e4e87716bbe50696317049148363b8a644e55ec43031f91087b9dd3" alt="image"></p>
<h3 id="5-3-2-进一步降低-CPU-Stall-CPU-乱序流水线（Out-of-order-execution-Pipeline）"><a href="#5-3-2-进一步降低-CPU-Stall-CPU-乱序流水线（Out-of-order-execution-Pipeline）" class="headerlink" title="5.3.2. 进一步降低 CPU Stall - CPU 乱序流水线（Out of order execution Pipeline）"></a>5.3.2. 进一步降低 CPU Stall - CPU 乱序流水线（Out of order execution Pipeline）</h3><p>由于指令的数据是否就绪也是不确定的，比如下面这个例子：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8a390ad6b6d5952677f14a23d61cda6f0c8e1d952cd0cb65e1b1ac504324451e" alt="image"></p>
<p>倘若数据 a 没有就绪，还没有载入到寄存器，那么我们其实没必要 Stall 等待加载 a，可以先执行 c = 1; 由此，我们可以将程序中，可以并行的指令提取出来同时安排执行，CPU 乱序流水线（Out of order execution Pipeline）就是基于这种思路：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5c9dd771c1f3d003aa99b40e526b29f713f3289fb943acd3fac3956658d27645" alt="image"></p>
<p>如图所示，CPU 的执行阶段分为：</p>
<ol>
<li>Instructions Fetch：批量拉取一批指令，进行指令分析，分析其中的循环以及依赖，分支预测等等</li>
<li>Instruction Decode：指令译码，与前面的流水线模式大同小异</li>
<li>Reservation stations：需要操作数输入的指令，如果输入就绪，就进入 Functoinal Unit (FU) 处理，如果没有没有就绪就监听 Bypass network，数据就绪发回信号到 Reservation stations，让指令进图 FU 处理。</li>
<li>Functional Unit：处理指令</li>
<li>Reorder Buffer：会将指令按照原有程序的顺序保存，这些指令会在被 dispatched 后添加到列表的一端，而当他们完成执行后，从列表的另一端移除。通过这种方式，指令会按他们 dispatch 的顺序完成。</li>
</ol>
<p>这样的结构设计下，可以保证写入 Store Buffer 的顺序，与原始的指令顺序一样。但是加载数据，以及计算，是并行执行的。前面我们已经知道了在我们的简易 CPU 架构里面，有着多 CPU 缓存 MESI， Store Buffer 以及 Invalidate Queue 导致读取不到最新的值，这里的乱序并行加载以及处理更加剧了这一点。并且，结构设计下，仅能保证检测出同一个线程下的指令之间的互相依赖，保证这样的互相依赖之间的指令执行顺序是对的，但是多线程程序之间的指令依赖，CPU 批量取指令以及分支预测是无法感知的。<strong>所以还是会有乱序。这种乱序，同样可以通过前面的内存屏障避免</strong>。</p>
<h2 id="5-4-实际的-CPU"><a href="#5-4-实际的-CPU" class="headerlink" title="5.4. 实际的 CPU"></a>5.4. 实际的 CPU</h2><p>实际的 CPU 多种多样，有着不同的 CPU 结构设计以及不同的 CPU 缓存一致性协议，就会有<strong>不同种类的乱序</strong>，如果每种单独来看，就太复杂了。所以，大家通过一种标准来抽象描述不同的 CPU 的乱序现象（即第一个操作为 M，第二个操作为 N，这两个操作是否会乱序，是不是很像 Doug Lea 对于 JMM 的描述，其实 Java 内存模型也是参考这个设计的），参考下面这个表格：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/77c59a6be965b3b13901b6e24f90875bcdd607e6c9059868cd1461db2e0cfd31" alt="image"></p>
<p>我们先来说一下每一列的意思：</p>
<ol>
<li>Loads Reordered After Loads：第一个操作是读取，第二个也是读取，是否会乱序。</li>
<li>Loads Reordered After Stores：第一个操作是读取，第二个是写入，是否会乱序。</li>
<li>Stores Reordered After Stores：第一个操作是写入，第二个也是写入，是否会乱序。</li>
<li>Stores Reordered After Loads：第一个操作是写入，第二个是读取，是否会乱序。</li>
<li>Atomic Instructions Reordered With Loads：两个操作是原子操作（一组操作，同时发生，例如同时修改两个字这种指令）与读取，这两个互相是否会乱序。</li>
<li>Atomic Instructions Reordered With Stores：两个操作是原子操作（一组操作，同时发生，例如同时修改两个字这种指令）与写入，这两个互相是否会乱序。</li>
<li>Dependent Loads Reordered：如果一个读取依赖另一个读取的结果，是否会乱序。</li>
<li>Incoherent Instruction Cache/Pipeline：是否会有指令乱序执行。</li>
</ol>
<p>举一个例子来看即我们自己的 PC 上面常用的 x86 结构，在这种结构下，仅仅会发生 Stores Reordered After Loads 以及 Incoherent Instruction Cache/Pipeline。其实后面要提到的 LoadLoad，LoadStore，StoreLoad，StoreStore 这四个 Java 中的内存屏障，为啥在 x86 的环境下其实只需要实现 StoreLoad，其实就是这个原因。</p>
<h2 id="5-5-编译器乱序"><a href="#5-5-编译器乱序" class="headerlink" title="5.5. 编译器乱序"></a>5.5. 编译器乱序</h2><p>除了 CPU 乱序以外，在软件层面还有编译器优化重排序导致的，其实编译器优化的一些思路与上面说的 CPU 的指令流水线优化其实有些类似。比如编译器也会分析你的代码，对相互不依赖的语句进行优化。对于相互没有依赖的语句，就可以随意的进行重排了。但是同样的，编译器也是只能从单线程的角度去考虑以及分析，并不知道你程序在多线程环境下的依赖以及联系。再举一个简单的例子，假设没有任何 CPU 乱序的环境下，有两个变量 x = 0，y = 0，线程 1 执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e4f714944fb86c7f1764b9e938f5f940719dae6532ac73e7edb33a70d5388340" alt="image"></p>
<p>线程 2 执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d839af003d4cf831df323f443da22e51d19255f93453bc72cd338ac5c8b2fe56" alt="image"></p>
<p>那么线程 2 是可能 assert 失败的，因为编译器可能会让 <code>x = 1</code> 与 <code>y = 1</code> 之间乱序。</p>
<p>编译器乱序，可以通过增加不同操作系统上的编译器屏障语句进行避免。例如线程一执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/40a0b16d1572fbc4b6a85bfe6afa5e96e9de0ecc7d4c43d0ec1e339bb49cf97d" alt="image"></p>
<p>这样就不会出现 <code>x = 1</code> 与 <code>y = 1</code> 之间乱序的情况。</p>
<p>同时，我们在实际使用的时候，一般内存屏障指的是硬件内存屏障，即通过硬件 CPU 指令实现的内存屏障，<strong>这种硬件内存屏障一般也会隐式地带上编译器屏障</strong>。编译器屏障一般被称为软件内存屏障，仅仅是控制编译器软件层面的屏障，举一个例子即 C++ 中的 volaile，它与 Java 中的 volatile 不一样， C++ 中的 volatile 仅仅是禁止编译器重排即有编译器屏障，但是无法避免 CPU 乱序。</p>
<p>以上，我们就基本搞清楚了乱序的来源，以及内存屏障的作用。接下来，我们即将步入正题，开始我们的 Java 9+ 内存模型之旅。在这之前，再说一件需要注意的事情：为什么最好不要自己写代码验证 JMM 的一些结论，而是使用专业的框架去测试</p>
<ol start="6">
<li><h1 id="为什么最好不要自己写代码验证-JMM-的一些结论"><a href="#为什么最好不要自己写代码验证-JMM-的一些结论" class="headerlink" title="为什么最好不要自己写代码验证 JMM 的一些结论"></a>为什么最好不要自己写代码验证 JMM 的一些结论</h1></li>
</ol>
<p>通过前面的一系列分析我们知道，程序乱序的问题错综复杂，假设一段代码，没有任何限制所有可能的输出结果是如下图所示这个全集：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4772560410f17d3b26466f88219a0b6ddfb8e970544a4b5468208da852d79ed5" alt="image"></p>
<p>在 Java 内存模型的限制下，可能的结果被限制到了所有乱序结果中的一个子集：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f2bdcb2fc58a78703518f46251fd7ec10dca1a9476708c02d9f52cbec8498133" alt="image"></p>
<p>在 Java 内存模型的限制下，在不同的 CPU 架构上，CPU 乱序情况不同，有的场景有的 CPU 会乱序，有的则不会，但是都在 JMM 的范围内所以是合理的，这样所有可能的结果集又被限制到 JMM 的一个个不同子集：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d6be0945c6231f17ee165fbbdd4ba1e3bdc7715dfa59e6c3934fbfc1d5955912" alt="image"></p>
<p>在 Java 内存模型的限制下，在不同的操作系统的编译器编译出来的 JVM 的代码执行顺序不同，底层系统调用定义不同，在不同操作系统执行的 Java 代码又有可能会有些微小的差异，但是由于都在 JMM 的限制范围内，所以也是合理的：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/700130ec8f1366b7d093f234bb360a2adfb9c51e09374b4b3a16d485b1b152bd" alt="image"></p>
<p>最后呢，在不同的执行方式以及 JIT 编译下，底层执行的代码还是有差异的，进一步导致了结果集的分化：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b25307c6f94ca166f9f0fd312e2526720714debba59a781ce60d3c6218041ab2" alt="image"></p>
<p>所以，如果你自己编写代码在自己的唯一一台电脑唯一一种操作系统上面去试，那么你所能试出来的结果集只是 JMM 的一个子集，<strong>很可能有些乱序结果你是看不到的</strong>。并且，有些乱序执行次数少或者没走到 JIT 优化，还看不到，所以，真的不建议你自己写代码去实验。</p>
<p>那么应该怎么做呢？使用较为官方的用来<strong>测试并发可见性的框架 - jcstress</strong>，这个框架虽然不能模拟不同的 CPU 架构和不同操作系统，但是能让你排除不同执行（解释执行，C1执行，C2执行）以及测试压力不足次数少的原因，后面的所有讲解都会附上对应的 jcstress 代码实例供大家使用。</p>
<ol start="7">
<li><h1 id="层层递进可见性与-Java-9-内存模型的对应-API"><a href="#层层递进可见性与-Java-9-内存模型的对应-API" class="headerlink" title="层层递进可见性与 Java 9+ 内存模型的对应 API"></a>层层递进可见性与 Java 9+ 内存模型的对应 API</h1></li>
</ol>
<p>这里主要参考了 Aleksey 大神的思路，去总结出不同层次，层层递进的 Java 中的一些内存可见性限制性质以及对应的 API。Java 9+ 中，将原来的普通变量（非 volatile，final 变量）的普通访问，<strong>定义为了 Plain</strong>。普通访问，没有对这个访问的地址做任何屏障（不同 GC 的那些屏障，比如分代 GC 需要的指针屏障，不是这里要考虑的，那些屏障只是 GC 层面的，对于这里的可见性没啥影响），会有前面提到的各种乱序。那么 Java 9+ 内存模型中究竟提出了那些限制以及对应这些限制的 API 是啥，我们接下层层递进讲述。</p>
<h2 id="7-1-Coherence（相干性，连贯性）与-Opaque"><a href="#7-1-Coherence（相干性，连贯性）与-Opaque" class="headerlink" title="7.1. Coherence（相干性，连贯性）与 Opaque"></a>7.1. Coherence（相干性，连贯性）与 Opaque</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0787a61e1ddbc426869420f6b2e28b5c3e8bf1230ab2ff9e4753b28a4c52bcde" alt="image"></p>
<p>这里的标题我不太清楚究竟应该翻译成什么，因为我看网上很多地方把 CPU Cache Coherence Protocol 翻译成了 CPU 缓存一致性协议，即 Coherence 在那种语境下代表一致性，但是我们这里的 Coherence 如果翻译成一致性就不太合适。所以，之后的一些名词我也直接沿用 Doug Lea 大神的以及 Aleksey 大神的定义。</p>
<p>那么这里什么是 coherence 呢？举一个简单的例子：假设某个对象字段 int x 初始为 0，一个线程执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0b849607e9efa6b02528fcd7b5def27262dfda5b2748da5c94f480ba547a00a3" alt="image"></p>
<p>另一个线程执行(r1, r2 为本地变量)：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1ec9121cb0e0f984ccbc813e1ead9309344fa70174a2d3ef55686e0671a9799d" alt="image"></p>
<p>那么在 Java 内存模型下，可能的结果是包括：</p>
<ol>
<li><code>r1 = 1, r2 = 1</code></li>
<li><code>r1 = 0, r2 = 1</code></li>
<li><code>r1 = 1, r2 = 0</code></li>
<li><code>r1 = 0, r2 = 0</code></li>
</ol>
<p>其中第三个结果很有意思，从程序上理解即我们先看到了 x = 1，之后又看到了 x 变成了 0.当然，通过前面的分析，我们知道实际上是因为<strong>编译器乱序</strong>。如果我们不想看到这个第三种结果，我们所需要的特性即 coherence。</p>
<p>coherence 的定义，我引用下原文：</p>
<blockquote>
<p>The writes to the single memory location appear to be in a total order consistent with program order.</p>
</blockquote>
<p>即对单个内存位置的写看上去是按照与程序顺序一致的总顺序进行的。看上去有点难以理解，结合上面的例子，可以这样理解：在全局，x 由 0 变成了 1，那么每个线程中看到的 x 只能从 0 变成 1，而不会可能看到从 1 变成 0.</p>
<p>正如前面所说，Java 内存模型定义中的 Plain 读写，是不能保证 coherence 的。但是如果大家跑一下针对上面的测试代码，会发现跑不出来第三种结果。这是因为 Hotspot 虚拟机中的语义分析会认为这两个对于 x 的读取（load）是互相依赖的，进而限制了这种乱序：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/715531de950bf77bcfd3f001077a5a4b196a5dc26e4fd5c9407c3cf83cb5efd1" alt="image"></p>
<p>这就是我在前面一章中提到的，<strong>为什么最好不要自己写代码验证 JMM 的一些结论</strong>。虽然在 Java 内存模型的限制中，是允许第三种结果 1, 0 的，但是这里通过这个例子是试不出来的。</p>
<p><strong>我们这里通过一个别扭的例子来骗过 Java 编译器造成这种乱序</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/2757f64d164e140df8f2321e83fe07b52bbd9f5822aede8c15e2627371439ea6" alt="image"></p>
<p>我们不用太深究其原理，直接看结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0024c680a67a58fd5a582ff476bc444c6683243a5c2a8d16e072dd3990b1f96c" alt="image"></p>
<p>发现出现了乱序的结果，并且，如果你自己跑一下这个例子，会发现这个乱序是发生在执行 JIT C2 编译后的 actor2 方法才会出现。</p>
<p>那么如何避免这种乱序呢？使用 volatile 肯定是可以避免的，但是这里我们并不用劳烦 volatile 这种重操作出马，<strong>就用 Opaque 访问即可</strong>。<strong>Opaque 其实就是禁止 Java 编译器优化，但是没有涉及任何的内存屏障</strong>，和 C++ 中的 volatile 非常类似。测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6eb67e833cb287bc54bb3c54e92f9dd267d94d9db83db89c78c97689d0e00f91" alt="image"></p>
<p>运行下，可以发现，这个就没有乱序了(命令行如果没有 ACCEPTABLE_INTERESTING，FORBIDDEN，UNKNOWN 的 结果就不会输出了，只能最后看输出的 html)：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46ac83bf2d9b7327f39e4a7845f573e3049f917209e5f1105a9d2a8c18c1556d" alt="image"></p>
<h2 id="7-2-Causality（因果性）与-Acquire-Release"><a href="#7-2-Causality（因果性）与-Acquire-Release" class="headerlink" title="7.2. Causality（因果性）与 Acquire/Release"></a>7.2. Causality（因果性）与 Acquire/Release</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8bb5a15c2a4d8b8bc3d7f8da8b0815e02a328937d4bd39b83f8eb080ebff52c5" alt="image"></p>
<p><strong>在 Coherence 的基础上，我们一般在某些场景还会需要 Causality</strong></p>
<p>一般到这里，大家会接触到两个很常见的词，即 happens-before 以及 synchronized-with order，我们这里先不从这两个比较晦涩的概念开始介绍（具体概念介绍不会在这一章节解释），而是通过一个例子，即假设某个对象字段 int x 初始为 0，int y 也初始为 0，<strong>这两个字段不在同一个缓存行中</strong>（<strong>后面的 jcstress 框架会自动帮我们进行缓存行填充</strong>），一个线程执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/40070ecf6038e5dfbc0b3510278a74ecb076f5fd024e8979f03ba0b16685d10a" alt="image"></p>
<p>另一个线程执行(r1, r2 为本地变量)：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e18cde951b02d890ea90e3e0fc2dac11c5918f3034c8fe00fe276e1846e49fd8" alt="image"></p>
<p>这个例子与我们前面的 CPU 缓存那里的乱序分析举得例子很像，在 Java 内存模型中，可能的结果有：</p>
<ol>
<li><code>r1 = 1, r2 = 1</code></li>
<li><code>r1 = 0, r2 = 1</code></li>
<li><code>r1 = 1, r2 = 0</code></li>
<li><code>r1 = 0, r2 = 0</code></li>
</ol>
<p>同样的，第三个结果也是很有趣的，第二个线程先看到 y 更新，但是没有看到 x 的更新。这个在前面的 CPU 缓存乱序那里我们详细分析，在前面的分析中，我们需要像这样加内存屏障才能避免第三种情况的出现，即：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f4c925817e5fa61b9063895c9d71a17afa47b02d071d143b9a70cbb1f5c591df" alt="image"></p>
<p>以及</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b0df7cf9da7caece1f481b9d5bdb6343f4ac135d20cc880642e2fe214481d7e7" alt="image"></p>
<p>简单回顾下，线程 1 执行 x = 1 之后，在 y = 1 之前执行了写屏障，保证 store buffer 的更新都更新到了缓存，y = 1 之前的更新都保证了不会因为存在 store buffer 中导致不可见。线程 2 执行 int r1 = y 之后执行了读屏障，保证 invalidate queue 中的需要失效的数据全部被失效，保证当前缓存中不会有脏数据。这样，如果线程 2 看到了 y 的更新，就一定能看到 x 的更新。</p>
<p>我们进一步更形象的描述一下：我们把写屏障以及后面的一个 Store（即 y = 1）理解为将前面的更新打包，然后将这个包在这点发射出去，读屏障与前面一个 Load（即 int r1 = y）理解成一个接收点，如果接收到发出的包，就在这里将包打开并读取进来。所以，如下图所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d9cf4726e41df7f621667d39e276b06f2010b07d34818198d04e6f4b55a3b550" alt="image"></p>
<p>在发射点，会将发射点之前（包括发射点本身的信息）的所有结果打包，如果<strong>在执行接收点的代码的时候接收到了这个包，那么在这个接收点之后的所有指令就能看到包里面的所有内容，即发射点之前以及发射点的内容</strong>。Causality（因果性），有的地方也叫做 Casual Consistency（因果一致性），它在不同的语境下有不同的含义，我们这里仅特指：可以定义一系列写入操作，如果读取看到了最后一个写入，那么这个读取之后的所有读取操作，都能看到这个写入以及之前的所有写入操作。这是一种 Partial Order（半顺序），而不是 Total Order（全顺序），关于这个定义将在后面的章节详细说明。</p>
<p>在 Java 中，Plain 访问与 Opaque 访问都不能保证 Causality，因为 Plain 没有任何的内存屏障，Opaque 只是有编译器屏障，我们可以通过如下代码测试出来：</p>
<p>首先是 Plain：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/46fc091275f311b1cf72f7c1ee8a7347c0dbcf634ad6d93d9ef0d0a4deedff8c" alt="image"></p>
<p>结果是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8f305a5ffc8c7cc1384cbd42d6758855fc2a2ca91f05178cd684d2b8f6ef10c1" alt="image"></p>
<p>然后是 Opaque：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8d6f414a35a6c45343532b87d612a39984bb488e86b4e5467f3d4ea100755377" alt="image"></p>
<p>这里我们需要注意：<strong>由于前面我们看到， x86 CPU 是天然保证一些指令不乱序的，稍后我们就能看到是哪些不乱序保证了这里的 Causality</strong>，所以 x86 的 CPU 都看不到乱序，Opaque 访问就能看到因果一致性的结果，如下图所示（AMD64 是一种 x86 的实现）：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c0ba2d29d4557f40eed926748f4eead8c00ff7d466fb593856d3974421e4c6e5" alt="image"><br>但是，如果我们换成其他稍微弱一致一些的 CPU，就能看到 Opaque 访问保证不了因果一致性，下面的结果是我在 aarch64 （是一种 arm 的实现）：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/83d566616bb96ae224e0be9424765737914a32ae496cc0815cf69027146f5a67" alt="image"></p>
<p><strong>并且，还有一个比较有意思的点，即乱序都是 C2 编译执行的时候发生的</strong>。</p>
<p>那么，我们如何保证 Causality 呢？同样的，我们同样不必劳烦 volatile 这么重的操作，采用 release/acquire 模式即可。release/acquire 可以保证 Coherence + Causality。release/acquire 必须成对出现（一个 acquire 对应一个 release），可以将 release 视为前面提到的发射点，acquire 视为前面提到的接收点，那么我们就可以像下图这样实现代码：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/73b5f6c4e50936298c7ff956f9a072d55ad12224a48828ab3fbc7dd7bbae3059" alt="image"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/5e4a1a922571e312c5d13e36b3f613d75622f60d66598268583863a8a0407c7f" alt="image"></p>
<p>然后，继续在刚刚的 aarch64 的机器上面执行，结果是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0442f6d473a5f9f912a26432f25ee86de124f2981f8266255f133173b754e242" alt="image"></p>
<p>可以看出，Causuality 由于使用了 Release/Acquire 保证了 Causality。注意，对于发射点和接收点的选取一定要选好，例如这里我们如果换个位置，那么就不对了：</p>
<p>示例一：发射点只会打包之前的所有更新，对于 x = 1 的更新在发射点之后，相当于没有打包进去，所以还是会出现 1,0 的结果。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c625bef9cab0efb85eb311441d1129ad1bcb9347a9781d07ddeaffccaa0cf285" alt="image"></p>
<p>示例二：在接收点会解包，从而让后面的读取看到包里面的结果，对于 x 的读取在接收点之前，相当于没有看到包里面的更新，所以还是会出现 1,0 的结果。</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/91f74f6ee4a171992a738c11042b33a9df566bcbcb7fc1cc30af916e97adab82" alt="image"></p>
<p>由此，我们类比下 Doug Lea 的 Java 内存屏障设计，来看看这里究竟用了哪些 Java 中设计的内存屏障。在 Doug Lea 的很早也是很经典的一篇文章中，介绍了 Java 内存模型以及其中的内存屏障设计，提出了四种屏障：</p>
<p><strong>1.LoadLoad</strong></p>
<p>如果有两个完全不相干的互不依赖（即可以乱序执行的）的读取（Load），可以通过 LoadLoad 屏障避免它们的乱序执行（即在 Load(x) 执行之前不会执行 Load(y)）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c168b1d48e488ffa61aa49ef5b0e271e4bd05fef2468633ac3c6d80e58452a4a" alt="image"></p>
<p><strong>2.LoadStore</strong></p>
<p>如果有一个读取（Load）以及一个完全不相干的（即可以乱序执行的）的写入（Store），可以通过 LoadStore 屏障避免它们的乱序执行（即在 Load(x) 执行之前不会执行 Store(y)）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/4a92d2a862c373c11ebaeb87842bcc77bc017b1777e3fce5d4cfcdf1ade31f43" alt="image"></p>
<p><strong>3.StoreStore</strong></p>
<p>如果有两个完全不相干的互不依赖（即可以乱序执行的）的写入（Store），可以通过 StoreStore 屏障避免它们的乱序执行（即在 Store(x) 执行之前不会执行 Store(y)）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d45789b7d106b02db4034b29232379162c77c32fb0c7c222152a51e97b0e9218" alt="image"></p>
<p><strong>4.StoreLoad</strong></p>
<p>如果有一个写入（Store）以及一个完全不相干的（即可以乱序执行的）的读取（Load），可以通过 LoadStore 屏障避免它们的乱序执行（即在 Store(x) 执行之前不会执行 Load(y)）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f2e8d97d8d75ee3d342d32520de67ecd8e6b64c0e5563e1b5ca9b49ddfdafe89" alt="image"></p>
<p>那么如何通过这些内存屏障实现的 Release/Acquire 呢？我们可以通过前面我们的抽象推出来，首先是发射点。发射点首先是一个 Store，并且保证打包前面的所有，那么不论是 Load 还是 Store 都要打包，都不能跑到后面去，所以<strong>需要在 Release 的前面加上 LoadStore，StoreStore 两种内存屏障来实现</strong>。同理，接收点是一个 Load，并且保证后面的都能看到包里面的值，那么无论 Load 还是 Store 都不能跑到前面去，所以<strong>需要在 Acquire 的后面加上 LoadLoad，LoadStore 两种内存屏障来实现</strong>。</p>
<p>但是呢我们可以在下一章中看到，其实目前来看这<strong>四个内存屏障的设计有些过时了</strong>（由于 CPU 的发展以及 C++ 语言的发展） ，<strong>JVM 内部用的更多的是 acquire，release，fence 这三个</strong>。这里的 acquire 以及 release 其实就是我们这里提到的 Release/Acquire。这三个与传统的四屏障的设计的关系是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ef23b16ce3918963baf4c77b70597dbef7f2b48e741a2da27e79299279e7541f" alt="image"></p>
<p>我们这里知道了 Release/Acquire 的内存屏障，<strong>x86 为何没有设置这个内存屏障就没有这种乱序呢</strong>？参考前面的 CPU 乱序图：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/90b0a864ec813f440924c93acabf2a146c9ada9c4603b89847f6f1302c60f05a" alt="image"></p>
<p>通过这里我们知道，x86 对于 Store 与 Store，Load 与 Load，Load 与 Store 都不会乱序，所以天然就能保证 Casuality</p>
<h2 id="7-3-Consensus（共识性）与-Volatile"><a href="#7-3-Consensus（共识性）与-Volatile" class="headerlink" title="7.3. Consensus（共识性）与 Volatile"></a>7.3. Consensus（共识性）与 Volatile</h2><p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a8a66ff8817c3c0517b7b76625c14434b6c1009d146b0f2e05a80f26962f0c45" alt="image"></p>
<p>最后终于来到我们所熟悉的 Volatile 了，Volatile 其实就是在 Release/Acquire 的基础上，进一步保证了 Consensus；Consensus 即所有线程看到的内存更新顺序是一致的，即所有线程看到的内存顺序全局一致，举个例子：假设某个对象字段 int x 初始为 0，int y 也初始为 0，<strong>这两个字段不在同一个缓存行中</strong>（<strong>后面的 jcstress 框架会自动帮我们进行缓存行填充</strong>），一个线程执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ae657ef4815a58463c718c7f5b8188de9ed9ca8573c8f3bcda27c60f9f379f7" alt="image"></p>
<p>另一个执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/910b4de343e36c54c7f168c679b362c976a79514db4671cd80e97ab52d94635e" alt="image"></p>
<p>在 Java 内存模型下，同样可能有4种结果：</p>
<ol>
<li><code>r1 = 1, r2 = 1</code></li>
<li><code>r1 = 0, r2 = 1</code></li>
<li><code>r1 = 1, r2 = 0</code></li>
<li><code>r1 = 0, r2 = 0</code></li>
</ol>
<p>第四个结果比较有意思，他是不符合 Consensus 的，因为两个线程看到的更新顺序不一样（第一个线程看到 0 代表他认为 x 的更新是在 y 的更新之前执行的，第二个线程看到 0 代表他认为 y 的更新是在 x 的更新之前执行的）。如果没有乱序，那么肯定不会看到 x, y 都是 0，因为线程 1 和线程 2 都是先更新后读取的。但是也正如前面所有的讲述一样，各种乱序造成了我们可以看大第三个这样的结果。那么 Release/Acquire 能否保证不会出现这样的结果呢？我们来简单分析下，如果对于 x，y 的访问都是 Release/Acquire 模式的，那么线程 1 实际执行的就是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c6c0db182e8763b1d031f295d2a7e9ea77feece7c990aad24b71e4986e0c51dd" alt="image"></p>
<p>这里我们就可以看出来，x = 1 与 int r1 = y 之间没有任何内存屏障，所以实际可能执行的是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1c8caee218cec82f6fc617ac0dd863eaa86bed19eeed04e042afec6c0d6d515e" alt="image"></p>
<p>同理，线程 2 可能执行的是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/312d5cde597e8fea3ee14df38330cd98e8095d215e6b7b158d507b87ef979275" alt="image"></p>
<p>或者：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e3dc561397fa6cb552cac292a2bc3e20ceef4e8f81324400f47828f5343aa369" alt="image"></p>
<p>这样，就会造成我们可能看到第四种结果。我们通过代码测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/327e7acbd168b96016fb37befdccf320d3cb7007a67b9737bab4a6b39b63933c" alt="image"></p>
<p>测试结果是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9ebb8c2b4ddbbe74bf6e7632128eabb9c24fb3197b1cf3590df016c40c731dfa" alt="image"></p>
<p>如果要保证 Consensus，我们只要保证线程 1 的代码与线程 2 的代码不乱序即可，即在原本的内存屏障的基础上，添加 StoreLoad 内存屏障，即线程 1 执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/096e7dda121d1ffc1f2a73e7c02080cc29fe5a7cc260bb5d6ba75f8dd7959c96" alt="image"></p>
<p>线程 2 执行：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/83f232d0471f54562daf985c7c7f01acd3bb0e5d45dd3c2e21da13f3eee62341" alt="image"></p>
<p>这样就能保证不会乱序，这其实就是 volatile 访问了。Volatile 访问即在 Release/Acquire 的基础上增加 StoreLoad 屏障，我们来测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c413b6e66bee7920aa680582d891d234d76a1a55c862a89ae0f8b797126738ec" alt="image"></p>
<p>结果是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/754c960855879722712254fa63525e6b1433322f7f3a182e23cf699e931607e0" alt="image"></p>
<p>那么引出另一个问题，这个 StoreLoad 屏障是 Volatile Store 之后添加，还是 Volatile Load 之前添加呢？我们来做下这个实验：</p>
<p>首先保留 Volatile Store，将 Volatile Load 改成 Plain Load，即：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c44cebbe9dba1f881a2d29af5e1fff126a4884ba5f1fcf7a3f67b6b248484956" alt="image"></p>
<p>测试结果：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/349a05c700e4c8628b0ff4f84a396584c891aa4c442d141cfa0730e1d6eafd52" alt="image"><br>从结果中可以看出，仍然保持了 Consensus。再来看保留 Volatile Load，将 Volatile Store 改成 Plain Store：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/3ba533b536364a1f3548f89ac87d83000dbae93ad87b99a3010525c9310fb254" alt="image"></p>
<p>测试结果：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/56c4e1292b1d3998cec48a6c6894b5faabcd2bb0629a063dbda6fc6f717d3d99" alt="image"></p>
<p>发现又乱序了。</p>
<p>所以，可以得出结论，这个 StoreLoad 是加在 Volatile 写之后的，在后面的 JVM 底层源码分析我们也能看出来。</p>
<h2 id="7-4-Final-的作用"><a href="#7-4-Final-的作用" class="headerlink" title="7.4 Final 的作用"></a>7.4 Final 的作用</h2><p>Java 中，创建对象通过调用类的构造函数实现，我们还可能在构造函数中放一些初始化一些字段的值，例如：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fb4ebcb7f12c18bf526ec63e4165b26bd9b2dea741e7f13393fb1e4da7ade414" alt="image"></p>
<p>我们可以这样调用构造器创建一个对象：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b97e5c1fa2e1a24b75529af96a5fc240df86c18dd4d49774b8ede630c756e1b3" alt="image"></p>
<p>我们合并这些步骤，用伪代码表示底层实际执行的是：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/88a18fc7b4db0438cfab7552889cec84a78474127019865b08289c49741c1c69" alt="image"></p>
<p>他们之间，没有任何内存屏障，同时根据语义分析，1 和 5 之间有依赖关系，所以 1 和 5 的前后顺序不能变。1，2，3，4 之间有依赖，所以 1，2，3，4 的前后顺序也不能变。<strong>2，3，4 与 5 之间，没有任何关系，他们之间的执行顺序是可能乱序的</strong>。如果 5 在 2，3，4 中的任一一步之前执行，那么就会造成我们可能看到构造器还未执行完，x,y,z 还是初始值的情况。测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/40a53ead03ca949475838b4842b7f6fc06d08738f01590535fb6841bc5409121" alt="image"></p>
<p>在 x86 平台的测试结果，你只会看到两个结果，即 -1, -1, -1（代表没看到对象初始化）和 1, 2, 3（看到对象初始化，并且没有乱序），结果如下图所示（AMD64 是一种 x86 的实现）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/84f8cacd63cf533d67b4a2f5b072a2c1c9ea71389fb0f21dfb2ffb130cb055e0" alt="image"></p>
<p>这是因为，前文我们也提到过类似的， x86 CPU 是比较强一致性的 CPU，这里不会乱序。至于由于 x86 哪种不乱序性质这里才不乱序，我们后面会看到。</p>
<p>还是和前文一样，我们换到不那么强一致性的 CPU （ARM）上执行，这里看到的结果就比较热闹了，如下图所示（aarch64 是一种 ARM 实现）：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8c640c5560d69cd4061de0f280d61c51ef8b296b1e217b5b7dc1b41ecf1dfb49" alt="image"></p>
<p>那我们如何保证看到构造器执行完的结果呢？<br><strong>用前面的内存屏障设计，我们可以把伪代码的第五步改成 setRelease</strong>，即：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/44d89eecc9eb03568202921179a476d1f9db085223d27073ee0ebc50b8de4526" alt="image"></p>
<p>前面我们提到过 setRelease 会在前面加上 LoadStore 和 StoreStore 屏障，StoreStore 屏障会防止 2，3，4 与 5 乱序，所以可以避免这个问题，我们来试试看：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/30223ca6b38a111da057c5f583ae565a1e97c20c981599388f9979b6550049f2" alt="image"></p>
<p>再到前面的 aarch64 机器上试一下，结果是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/11175cb5e4b1a1361ddfe8a5492630b7fbcfd40a5a3fb5d6c38e41c74836d121" alt="image"></p>
<p>从结果可以看出，只能看到要么没初始化，要么完整的构造器执行后的结果了。</p>
<p><strong>我们再进一步，其实我们这里只需要 StoreStore 屏障就够了</strong>，由此引出了 Java 的 final 关键字：final 其实就是在更新后面紧接着加入 StoreStore 屏障，这样也相当于在构造器结束之前加入 StoreStore 屏障，保证了只要我们能看到对象，对象的构造器一定是执行完了的。测试代码：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/699a56c945862a4463e751370728a8122bf017394cdab80f8e1a6ca835434cff" alt="image"></p>
<p><strong>我们再进一步，由于伪代码中 2，3，4 是互相依赖的，所以这里我们只要保证 4 先于 5 执行，那么2，3，一定先于 5 执行，也就是我们只需要对 z 设置为 final，从而加 StoreStore 内存屏障，而不是每个都声明为 final，从而多加内存屏障</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b555b0616ea5f97c32c8e8c86adf0d106411d0f2e204bdb7365808dbe3f09b76" alt="image"></p>
<p>然后，我们继续用 aarch64 测试，测试结果依然是对的：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f89861d496d49ec534849064972c378f1b1917a3d6d50e64242fb04e3918c9ad" alt="image"></p>
<p>最后我们需要注意，<strong>final 仅仅是在更新后面加上 StoreStore 屏障，如果你在构造器过程中，将 this 暴露了出去，那么还是会看到 final 的值没有初始化</strong>，我们测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f2d256ced6b4e5657b9cce065354e64aae68e6d3c62cb81a5888ece14ba1fcd2" alt="image"></p>
<p>这次我们在 x86 的机器上就能看到 final 没有初始化：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7b9567c0f839b94147d82132ee2ece4bc4dd01b4841c0afb2360613c0398efdd" alt="image"></p>
<p>最后，<strong>为何这里的示例中 x86 不需要内存屏障就能实现</strong>，参考前面的 CPU 图：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/d6a2881169c54dbdb5a8bd35bd01c73ab50b7358f967dd3085e2cd100969040e" alt="image"></p>
<p>x86 本身 Store 与 Store 之间就不会乱序，天然就有保证。</p>
<p>最后给上表格：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/0c5c8e7f9d95d90adb1accf71301818f3a159bcba67d8bfec1983c1b8d799332" alt="image"></p>
<ol start="8">
<li><h1 id="底层-JVM-实现分析"><a href="#底层-JVM-实现分析" class="headerlink" title="底层 JVM 实现分析"></a>底层 JVM 实现分析</h1></li>
</ol>
<h2 id="8-1-JVM-中的-OrderAccess-定义"><a href="#8-1-JVM-中的-OrderAccess-定义" class="headerlink" title="8.1. JVM 中的 OrderAccess 定义"></a>8.1. JVM 中的 OrderAccess 定义</h2><p>JVM 中有各种用到内存屏障的地方：</p>
<ol>
<li>实现 Java 的各种语法元素（volatile，final，synchronized，等等）</li>
<li>实现 JDK 的各种 API（VarHandle，Unsafe，Thread，等等）</li>
<li>GC 需要的内存屏障：因为要考虑 GC 多线程与应用线程（在 GC 算法中叫做 Mutator）的工作方式，究竟是停止世界（Stop-the-world， STW）的方式，还是并发的方式<ol>
<li>对象引用屏障：例如分代 GC，复制算法，年轻代 GC 的时候我们一般是从一个 S 区复制存活对象到另一个 S 区，如果<strong>复制的过程，我们不想停止世界（Stop-the-world， STW），而是和应用线程同时进行，那么我们就需要内存屏障</strong>，例如；</li>
<li>维护屏障：例如分区 GC 算法，我们需要维护每个区的跨区引用表以及使用情况表，例如 Card Table。<strong>这个如果我们想要应用线程与 GC 线程并发修改访问，而不是停止世界，那么也需要内存屏障</strong>。</li>
</ol>
</li>
<li>JIT 也需要内存屏障：同样地，应用线程究竟是解释执行代码还是执行 JIT 优化后的代码，这里也是需要内存屏障的。</li>
</ol>
<p>这些内存屏障，不同的 CPU，不同的操作系统，底层需要不同的代码实现，统一的接口设计是：</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/share/runtime/orderAccess.hpp" target="_blank" rel="noopener">源代码地址：<code>orderAccess.hpp</code></a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ac47e72822662314aca0c57f636652c47551ca8c13e6f059cb159b6d041938d2" alt="image"></p>
<p>不同的 CPU，不同的操作系统实现是不一样的，结合前面 CPU 乱序表格：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b60aefbe19e9b7b4ecd6fedf4647fb04ebea80f3e76164e06451b8d215cd53c9" alt="image"></p>
<p>我们来看下 linux + x86 的实现：</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/os_cpu/linux_x86/orderAccess_linux_x86.hpp" target="_blank" rel="noopener">源代码地址：<code>orderAccess_linux_x86.hpp</code></a><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e6be278892f609113f05c80d9e8cfccb5113112f7c937ccd832b02546fb2762f" alt="image"></p>
<p>对于 x86，由于 Load 与 Load，Load 与 Store，Store 与 Store 本来有一致性保证，<strong>所以只要没有编译器乱序，那么就天生有 StoreStore，LoadLoad，LoadStore 屏障</strong>，所以这里我们看到 StoreStore，LoadLoad，LoadStore 屏障的实现都只是加了编译器屏障。同时，前文中我们分析过，acquire 其实就是相当于在 Load 后面加上 LoadLoad，LoadStore 屏障，对于 x86 还是需要编译器屏障就够了。release 我们前文中也分析过，其实相当于在 Store 前面加上 LoadStore 和 StoreStore，对于 x86 还是需要编译器屏障就够了。于是，我们有如下表格：</p>
<p>我们再看下前面我们经常使用的 Linux aarch64 下的实现：</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/os_cpu/linux_aarch64/orderAccess_linux_aarch64.hpp" target="_blank" rel="noopener">源代码地址：<code>orderAccess_linux_aarch64.hpp</code></a><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/79175797865bb3a90bdecb50c5b34b45568b0374fc58ab4d1b1203eb6959f592" alt="image"></p>
<p>如前面表格里面说，ARM 的 CPU Load 与 Load，Load 与 Store，Store 与 Store，Store 与 Load 都会乱序。JVM 针对 aarch64 没有直接使用 CPU 指令，而是使用了 C++ 封装好的内存屏障实现。C++ 封装好的很像我们前面讲的简易 CPU 模型的内存屏障，即读内存屏障（<code>__atomic_thread_fence(__ATOMIC_ACQUIRE)</code>），写内存屏障（<code>__atomic_thread_fence(__ATOMIC_RELEASE)</code>），读写内存屏障（全内存屏障，<code>__sync_synchronize()</code>）。acquire 的作用是作为接收点解包让后面的都看到包里面的内容，类比简易 CPU 模型，其实就是阻塞等待 invalidate queue 完全处理完保证 CPU 缓存没有脏数据。release 的作用是作为发射点将前面的更新打包发出去，类比简易 CPU 模型，其实就是阻塞等待 store buffer 完全刷入 CPU 缓存。所以，acquire，release 分别使用读内存屏障和写内存屏障实现。</p>
<p>LoadLoad 保证第一个 Load 先于第二个，那么其实就是在第一个 Load 后面加入读内存屏障，阻塞等待 invalidate queue 完全处理完；LoadStore 同理，保证第一个 Load 先于第二个 Store，只要 invalidate queue 处理完，那么当前 CPU 中就没有对应的脏数据了，就不需要等待当前的 CPU 的 store buffer 也清空。</p>
<p>StoreStore 保证第一个 Store 先于第二个，那么其实就是在第一个写入后面放读内存屏障，阻塞等待 store buffer 完全刷入 CPU 缓存；对于 StoreLoad，比较特殊，由于第二个 Load 需要看到 Store 的最新值，也就是更新不能只到 store buffer，同时过期不能存在于 invalidate queue 未处理，所以需要读写内存屏障，即全屏障。</p>
<h2 id="8-2-volatile-与-final-的内存屏障源码"><a href="#8-2-volatile-与-final-的内存屏障源码" class="headerlink" title="8.2. volatile 与 final 的内存屏障源码"></a>8.2. volatile 与 final 的内存屏障源码</h2><p>我们接下来看一下 volatile 的内存屏障插入的相关代码，以 arm 为例子. 我们其实通过跟踪 <a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.10.1.9.iload" target="_blank" rel="noopener">iload 这个字节码</a>就可以看出来如果 load 的是 volatile 关键字或者 final 关键字修饰的字段会怎么样，以及 <a href="https://docs.oracle.com/javase/specs/jvms/se18/html/jvms-4.html#jvms-4.10.1.9.istore" target="_blank" rel="noopener">istore</a>就可以看出来如果 store的是 volatile 关键字或者 final 关键字修饰的字段会怎么样</p>
<p>对于字段访问，JVM 中也有快速路径和慢速路径，我们这里只看快速路径的代码：</p>
<p>对应源码：</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/src/hotspot/cpu/arm/templateTable_arm.cpp" target="_blank" rel="noopener">源代码地址：<code>templateTable_arm.cpp</code></a></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7a6c9de6f0d07dc5b1705582d50cd2ef4b0cbe5cb5e19faff973e4a8e47f5e3f" alt="image"></p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e985771a627e9cf2c403ae702e603d9e06c5ca4fcfc87acfa03614d1105015a7" alt="image"></p>
<ol start="9">
<li><h1 id="一些-QA"><a href="#一些-QA" class="headerlink" title="一些 QA"></a>一些 QA</h1></li>
</ol>
<h2 id="9-1-为什么看到某些地方在方法本地变量使用-final"><a href="#9-1-为什么看到某些地方在方法本地变量使用-final" class="headerlink" title="9.1. 为什么看到某些地方在方法本地变量使用 final"></a>9.1. 为什么看到某些地方在方法本地变量使用 final</h2><p>对于<strong>本地变量中的 final</strong>（和前面提到的修饰字段的 final 不是一回事），这个单纯从语义上讲，其实并没有什么性能方面的考虑，仅仅是作为一种标记。即：你可能在方法本地声明很多变量，但是为了语义清晰，就将肯定不会改的声明为 final。</p>
<p><strong>JDK 的开发者一般用 final 本地变量来做这样一件事</strong>，假设有如下代码：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/20b24eebd07fc7bf22b47f86e5fc077f7d6a65dbb1ae293da376fac4cc9760f3" alt="image"></p>
<p>假设编译器不会做任何优化，那么 1，2，4 我们都各做了一次对于字段的访问。如果有编译器优化参与进来，那么是有可能优化成下面的代码的：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a36afea29246cbd17601039626c293b758fdc4f406295669e074dd6efa2a67db" alt="image"></p>
<p>这样，只会读取 1 次 x 字段。这样造成的问题是，<strong>代码在被解释器执行，不同的 JIT 优化执行的时候，如果 x 有并发的更新，那么看到的可能的结果集是不一样的</strong>。为了避免这种歧义，如果我们确定我们这里的函数只想读取一次 x，那么就直接写成：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/97d14a32deb78ce7ae366e7f45aada57547122b97f39cfb70ea40b0dded9461a" alt="image"></p>
<p>为了标记 lx 是不会变的(同时也为了表达我们只想读一次 x)，加上 final，就变成：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/66180dbb9e4bac0bd2174caf3fe771003f7ede83361cf1261e282a9009fd53a3" alt="image"></p>
<h2 id="9-2-解密-DCL（Double-Check-Locking）"><a href="#9-2-解密-DCL（Double-Check-Locking）" class="headerlink" title="9.2. 解密 DCL（Double Check Locking）"></a>9.2. 解密 DCL（Double Check Locking）</h2><p><strong>我发现多年来对于 Java 内存模型有很多误解，并且我发现很多很多人都存在这样的误解</strong>，所以这次通过不断优化一个经典的 DCL （Double Check Locking）程序实例来帮助大家消除这个误解。</p>
<p>首先有这样一个程序, 我们想实现一个单例值，只有第一次调用的时候初始化，并且有多线程会访问这个单例值，那么我们会有：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fdfe08bf6daaf2ad67c9eeea5334a89f7d8636d84750628fe272832bf21ed4f6" alt="image"></p>
<p>getValue 的实现就是经典的 DCL 写法。</p>
<p>在 Java 内存模型的限制下，这个 ValueHolder 有两个潜在的问题：</p>
<ol>
<li>如果根据 Java 内存模型的定义，不考虑实际 JVM 的实现，那么 getValue 是有可能返回 null 的。</li>
<li>可能读取到没有初始化完成的 Value 的字段值。</li>
</ol>
<p>下面我们就这两个问题进行进一步分析并优化。</p>
<h3 id="9-2-1-根据-Java-内存模型的定义，不考虑实际-JVM-的实现，getValue-有可能返回-null-的原因"><a href="#9-2-1-根据-Java-内存模型的定义，不考虑实际-JVM-的实现，getValue-有可能返回-null-的原因" class="headerlink" title="9.2.1. 根据 Java 内存模型的定义，不考虑实际 JVM 的实现，getValue 有可能返回 null 的原因"></a>9.2.1. 根据 Java 内存模型的定义，不考虑实际 JVM 的实现，getValue 有可能返回 null 的原因</h3><p>在 全网最硬核 Java 新内存模型解析与实验 文章的<strong>7.1. Coherence（相干性，连贯性）与 Opaque</strong>中我们提到过：假设某个对象字段 int x 初始为 0，一个线程执行：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/512ae5a0486975824207e504d6232cdcf79ce4d6ea4b10d337a2ae9e682c105f" alt="image"><br>另一个线程执行(r1, r2 为本地变量)：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9cc61669b446b4405a8588d65dd5195848be343f462b098f8cccee0359cfea5c" alt="image"></p>
<p>那么这个实际上是两次对于字段的读取（对应字节码 getfield），在 Java 内存模型下，可能的结果是包括：</p>
<ol>
<li><code>r1 = 1, r2 = 1</code></li>
<li><code>r1 = 0, r2 = 1</code></li>
<li><code>r1 = 1, r2 = 0</code></li>
<li><code>r1 = 0, r2 = 0</code></li>
</ol>
<p>其中第三个结果很有意思，从程序上理解即我们先看到了 x = 1，之后又看到了 x 变成了 0.实际上这是因为<strong>编译器乱序</strong>。如果我们不想看到这个第三种结果，我们所需要的特性即 coherence。<strong>这里由于<code>private Value value</code>是普通的字段，所以根据 Java 内存模型来看并不保证 coherence</strong>。</p>
<p>回到我们的程序，我们有三次对字段读取（对应字节码 getfield），分别位于:<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/9869e194b42d2563777ae3476e8f47d7dbd18c2f482fb0004d101c24f61e7fdc" alt="image"></p>
<p>由于 1，2 之间有明显的分支关系（2 根据 1 的结果而执行或者不执行），所以无论在什么编译器看来，都要先执行 1 然后执行 2。但是对于 1 和 3，他们之间并没有这种依赖关系，<strong>在一些简单的编译器看来，他们是可以乱序执行的。在 Java 内存模型下，也没有限制 1 与 3 之间是否必须不能乱序。所以，可能你的程序先执行 3 的读取，然后执行 1 的读取以及其他逻辑，最后方法返回 3 读取的结果</strong>。</p>
<p>但是，<strong>在 OpenJDK Hotspot 的相关编译器环境下，这个是被避免了的</strong>。OpenJDK Hotspot 编译器是比较严谨的编译器，它产生的 1 和 3 的两次读取（针对同一个字段的两次读取）也是两次互相依赖的读取，<strong>在编译器维度是不会有乱序的</strong>（注意这里说的是编译器维度哈，不是说这里会有内存屏障连可能的 CPU 乱序也避免了，不过这里针对同一个字段读取，前面已经说了仅和编译器乱序有关，和 CPU 乱序无关）</p>
<p>不过，这个仅仅是针对一般程序的写法，我们可以通过一些奇怪的写法骗过编译器，让他任务两次读取没有关系，例如在全网最硬核 Java 新内存模型解析与实验 文章的<strong>7.1. Coherence（相干性，连贯性）与 Opaque</strong>中的实验环节，<strong>OpenJDK Hotspot 对于下面的程序是没有编译器乱序的</strong>：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/b8d1de89fdb7323abc29b8c21513ccb1465934bcec259cfdf0b9b74a5706ce45" alt="image"><br>但是如果你换成下面这种写法，就骗过了编译器：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/6c19ecbcd550a35c620a9f35f0d94e2e5e97865d1ccf729b28297b58f8427274" alt="image"><br>我们不用太深究其原理，直接看其中一个结果：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a388c6f3ff1ff7964e74577e57becf068ed4114a516969c6660e1b0db7332931" alt="image"><br><strong>对于 DCL 这种写法，我们也是可以骗过编译器的，但是一般我们不会这么写，这里就不赘述了</strong>。</p>
<h3 id="9-2-2-可能读取到没有初始化完成的-Value-的字段值"><a href="#9-2-2-可能读取到没有初始化完成的-Value-的字段值" class="headerlink" title="9.2.2. 可能读取到没有初始化完成的 Value 的字段值"></a>9.2.2. 可能读取到没有初始化完成的 Value 的字段值</h3><p>这个就不只是编译器乱序了，还涉及了 CPU 指令乱序以及 CPU 缓存乱序，需要内存屏障解决可见性问题。</p>
<p>我们从 Value 类的构造器入手：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/78571618218ba4f61decd5b1d861e5366ca061c1a9382f4f05644dcb9f118ae3" alt="image"><br>对于 <code>value = new Value(10);</code> 这一步，将代码分解为更详细易于理解的伪代码则是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/991ff7e5f94403289045982d5cedec3c6189a20404db9e8ec0d0b214b9b061e0" alt="image"><br>这中间没有任何内存屏障，根据语义分析，1 与 5 之间有依赖关系，因为 5 依赖于 1 的结果，必须先执行 1 再执行 5。 2 与 3 之间也是有依赖关系的，因为 3 依赖 2 的结果。但是，2和3，与 4，以及 5 这三个之间没有依赖关系，是可以乱序的。我们使用使用代码测试下这个乱序：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/05df60bc039fe9153537e82eeb4e2cd641180a7dea499d91b73d55f5e6725390" alt="image"></p>
<p>虽然在注释中写出了这么编写代码的原因，但是这里还是想强调下这么写的原因：</p>
<ol>
<li>jcstress 的 @Actor 是使用一个线程执行这个方法中的代码，在测试中，每次会用不同的 JVM 启动参数让这段代码解释执行，C1编译执行，C2编译执行，同时对于 JIT 编译还会修改编译参数让它的编译代码效果不一样。<strong>这样我们就可以看到在不同的执行方式下是否会有不同的编译器乱序效果</strong>。</li>
<li>jcstress 的 @Actor 是使用一个线程执行这个方法中的代码，在每次使用不同的 JVM 测试启动时，会将这个 @Actor 绑定到一个 CPU 执行，这样保证在测试的过程中，<strong>这个方法只会在这个 CPU 上执行， CPU 缓存由这个方法的代码独占，这样才能更容易的测试出 CPU 缓存不一致导致的乱序</strong>。<strong>所以，我们的 @Actor 注解方法的数量需要小于 CPU 个数</strong>。</li>
<li>我们测试机这里只有两个 CPU，那么只能有两个线程，如果都执行原始代码的话，那么很可能都执行到 synchronized 同步块等待，synchronized 本身有内存屏障的作用（后面会提到）。为了更容易测试出没有走 synchronized 同步块的情况，我们第二个 @Actor 注解的方法直接去掉同步块逻辑，并且如果 value 为 null，我们就设置结果都是 -1 用来区分</li>
</ol>
<p>我分别在 <strong>x86</strong> 和 <strong>arm</strong> CPU 上测试了这个程序，结果分别是：</p>
<p><strong>x86 - AMD64</strong>：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ac0fad7540089c0d134889ad7bf1fb5c63b2e6e226b72469020acccbb89e9c3e" alt="image"></p>
<p><strong>arm - aarch64</strong>:</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/187ef578c0102fceb8658136c734a7470d44010a8d86ddcc0f7c2c8d3aa9bafe" alt="image"></p>
<p>我们可以看到，<strong>在比较强一致性的 CPU 如 x86 中，是没有看到未初始化的字段值的，但是在 arm 这种弱一致性的 CPU 上面，我们就看到了未初始化的值</strong>。在我的另一个系列 - 全网最硬核 Java 新内存模型解析与实验中，我们也多次提到了这个 CPU 乱序表格：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/1e6d1a6a4e96be3f0a277f77e24efaf29c4c3ad560164e5a70cf072155008ffe" alt="image"></p>
<p>在这里，<strong>我们需要的内存屏障是 StoreStore</strong>（同时我们也从上面的表格看出，x86 天生不需要 StoreStore，只要没有编译器乱序的话，CPU 层面是不会乱序的，而 arm 需要内存屏障保证 Store 与 Store 不会乱序），<strong>只要这个内存屏障</strong>保证我们前面伪代码中第 2,3 步在第 5 步前，第 4 步在第 5 步之前即可，那么我们可以怎么做呢？参考我的那篇全网最硬核 Java 新内存模型解析与实验中各种内存屏障对应关系，我们可以有如下做法，每种做法我们都会对比其内存屏障消耗：</p>
<h4 id="9-2-2-1-使用-final"><a href="#9-2-2-1-使用-final" class="headerlink" title="9.2.2.1. 使用 final"></a>9.2.2.1. 使用 final</h4><p>final 是在赋值语句末尾添加 StoreStore 内存屏障，所以我们只需要在第 2,3 步以及第 4 步末尾添加 StoreStore 内存屏障<strong>即把 a2 和 b 设置成 final 即可</strong>，如下所示：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/8f5a62a3934b13514db3d22b6eb075674b1a0d858543e27117be837399149685" alt="image"></p>
<p>对应伪代码：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/a77f08ab6874824c42c5d6ee2c950ce4ab34f1f0a40c2c2ac634212f2b4b40af" alt="image"></p>
<p>我们测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/c79aac4268bba27e5652e5f6dabb53c4f1dc322a2e47c5155ddca69987761694" alt="image"></p>
<p>这次在 arm 上的结果是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/212339a805acbcf54329f88c79d9f775e84ee91e67865d882bc154b3d5f32083" alt="image"></p>
<p>如你所见，这次 arm CPU 上也没有看到未初始化的值了。</p>
<p><strong>这里 a1 不需要设置成 final</strong>，因为前面我们说过，2 与 3 之间是有依赖的，可以把他们看成一个整体，只需要整体后面添加好内存屏障即可。但是<strong>这个并不可靠</strong>！！！！因为在某些 JDK 中可能会把这个代码：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/52127caafc2c8d2cf99a7c965c3ca52fcc7fbcedba799e18d7cf343b9129556e" alt="image"></p>
<p>优化成这样：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/54879d305998ed1232576774a6ad20b87bac47242da7eb19542aecb117fd1905" alt="image"></p>
<p>这样 a1, a2 之间就没有依赖了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！<strong>所以最好还是所有的变量都设置为 final</strong></p>
<p>但是，这在我们不能将字段设置为 final 的时候，就不好使了。</p>
<h4 id="9-2-2-2-使用-volatile，这是大家常用以及官方推荐的做法"><a href="#9-2-2-2-使用-volatile，这是大家常用以及官方推荐的做法" class="headerlink" title="9.2.2.2. 使用 volatile，这是大家常用以及官方推荐的做法"></a>9.2.2.2. 使用 volatile，这是大家常用以及官方推荐的做法</h4><p>将 value 设置为 volatile 的，在我的另一系列文章 全网最硬核 Java 新内存模型解析与实验中，我们知道对于 volatile 写入，我们通过在写入之前加入 LoadStore + StoreStore 内存屏障，在写入之后加入 StoreLoad 内存屏障实现的，如果把 value 设置为 volatile 的，那么前面的伪代码就变成了：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/fc2a7b688e366909f0c36d47ddcfee31c0703530d3e4c91587a19c383a78431b" alt="image"></p>
<p>我们通过下面的代码测试下：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e198111399bba5f37870dbb12058ed8b656bddfdda73e260a71760940bba9e2e" alt="image"></p>
<p>依旧在 arm 机器上面测试，结果是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/f9f3cd8e2f909efff89b775db598791b8054759d722161fcc36fa675dc2b601f" alt="image"></p>
<p>没有看到未初始化值了</p>
<h4 id="9-2-2-3-对于-Java-9-可以使用-Varhandle-的-acquire-release"><a href="#9-2-2-3-对于-Java-9-可以使用-Varhandle-的-acquire-release" class="headerlink" title="9.2.2.3. 对于 Java 9+ 可以使用 Varhandle 的 acquire/release"></a>9.2.2.3. 对于 Java 9+ 可以使用 Varhandle 的 acquire/release</h4><p>前面分析，我们其实只需要保证在伪代码第五步之前保证有 StoreStore 内存屏障即可，所以 volatile 其实有点重，我们可以通过使用 Varhandle 的 acquire/release 这一级别的可见性 api 实现，这样伪代码就变成了：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/7637ee18dbe1faa851819b1c378c5ab077b8294d0a75dd56f3cd38ca303f6158" alt="image"></p>
<p>我们的测试代码变成了：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/e488deeab2bba5357e1e0349c5ed4e6c9852ccc00b0982fd1495f831047cefbd" alt="image"></p>
<p>测试结果是：<br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/54554c325c96dccaf6fd9789848832b5293746b12d85aeb77fb531610edf3033" alt="image"></p>
<p>也是没有看到未初始化值了。这种方式是用内存屏障最少，同时不用限制目标类型里面不必使用 final 字段的方式。</p>
<h4 id="9-2-2-4-一种有趣但是没啥用的思路-如果是静态方法，可以通过类加载器机制实现很简便的写法"><a href="#9-2-2-4-一种有趣但是没啥用的思路-如果是静态方法，可以通过类加载器机制实现很简便的写法" class="headerlink" title="9.2.2.4. 一种有趣但是没啥用的思路 - 如果是静态方法，可以通过类加载器机制实现很简便的写法"></a>9.2.2.4. 一种有趣但是没啥用的思路 - 如果是静态方法，可以通过类加载器机制实现很简便的写法</h4><p>如果我们，ValueHolder 里面的方法以及字段可以是 static 的，例如：</p>
<p><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/ba3077edd2c978327734e8065959215e71ba653f198fac7c290089ffc39ac500" alt="image"><br>将 ValueHolder 作为一个单独的类，或者一个内部类，这样也是能保证 Value 里面字段的可见性的，这是通过类加载器机制实现的，在加载同一个类的时候(类加载的过程中会初始化 static 字段并且运行 static 块代码)，是通过 synchronized 关键字同步块保护的，参考其中类加载器(ClassLoader.java)的源码：</p>
<p><a href="https://github.com/openjdk/jdk/blob/master/src/java.base/share/classes/java/lang/ClassLoader.java" target="_blank" rel="noopener"><code>ClassLoader.java</code></a><br><img src="https://gitee.com/songjianzaina/juejin_p1/raw/master/img/cdd90865fb647008f10df39d17cbf455cf8985820dc62edf7696229d8a347cd0" alt="image"></p>
<p>对于 syncrhonized 底层对应的 monitorenter 和 monitorexit，monitorenter 与 volatile 读有一样的内存屏障，即在操作之后加入 LoadLoad 和 LoadStore，monitorexit 与 volatile 写有一样的内存屏障，在操作之前加入 LoadStore + StoreStore 内存屏障，在操作之后加入 StoreLoad 内存屏障。所以，也是能保证可见性的。但是这样虽然写起来貌似很简便，效率上更加低（低了很多，类加载需要更多事情）并且不够灵活，只是作为一种扩展知识知道就好。</p>
<blockquote>
<p><strong>微信搜索“干货满满张哈希”关注公众号，加作者微信，每日一刷，轻松提升技术，斩获各种offer</strong>：</p>
</blockquote>
<p><strong>本文转载自:</strong> <a href="https://juejin.cn/post/7080869319407566879" target="_blank" rel="noopener">掘金</a></p>
<p><em><a href="https://dev.newban.cn/">开发者博客 – 和开发相关的 这里全都有</a></em></p>
]]></content>
      <tags>
        <tag>后端,Java,JVM</tag>
      </tags>
  </entry>
</search>
